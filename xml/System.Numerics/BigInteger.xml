<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="0fa7e-101">Reprezentuje dowolnie dużą liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-101">Represents an arbitrarily large signed integer.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-102"><xref:System.Numerics.BigInteger> Typ jest niezmiennego typu, który reprezentuje dowolnie dużą liczbą całkowitą, którego wartość teoretycznie nie ma żadnych granic górnej i dolnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-102">The <xref:System.Numerics.BigInteger> type is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds.</span></span> <span data-ttu-id="0fa7e-103">Elementy członkowskie <xref:System.Numerics.BigInteger> typu ściśle równoległe tych innych typów całkowitych ( <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, i <xref:System.UInt64> typy).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-103">The members of the <xref:System.Numerics.BigInteger> type closely parallel those of other integral types (the <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64> types).</span></span> <span data-ttu-id="0fa7e-104">Ten typ różni się od innych typów całkowitych w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], które mają zakres wskazywany przez ich `MinValue` i `MaxValue` właściwości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-104">This type differs from the other integral types in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], which have a range indicated by their `MinValue` and `MaxValue` properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-105">Ponieważ <xref:System.Numerics.BigInteger> typu nie można modyfikować (zobacz [zmienność i struktura BigInteger](#mutability)) i dlatego nie ma ona żadnych granic górnego i dolnego <xref:System.OutOfMemoryException> może zostać zgłoszony do żadnej operacji, która powoduje występowanie <xref:System.Numerics.BigInteger> wartość do zwiększenia zbyt duża.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-105">Because the <xref:System.Numerics.BigInteger> type is immutable (see [Mutability and the BigInteger Structure](#mutability)) and because it has no upper or lower bounds, an <xref:System.OutOfMemoryException> can be thrown for any operation that causes a <xref:System.Numerics.BigInteger> value to grow too large.</span></span>  
  
## <a name="instantiating-a-biginteger-object"></a><span data-ttu-id="0fa7e-106">Utworzenie wystąpienia obiektu BigInteger</span><span class="sxs-lookup"><span data-stu-id="0fa7e-106">Instantiating a BigInteger Object</span></span>  
 <span data-ttu-id="0fa7e-107">Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> obiekt na kilka sposobów:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-107">You can instantiate a <xref:System.Numerics.BigInteger> object in several ways:</span></span>  
  
-   <span data-ttu-id="0fa7e-108">Można użyć `new` — słowo kluczowe i podaj wartości całkowitych i zmiennoprzecinkowych jako parametr <xref:System.Numerics.BigInteger> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-108">You can use the `new` keyword and provide any integral or floating-point value as a parameter to the <xref:System.Numerics.BigInteger> constructor.</span></span> <span data-ttu-id="0fa7e-109">(Wartości zmiennoprzecinkowe są obcinane przed są przypisane do <xref:System.Numerics.BigInteger>.) Poniższy przykład przedstawia sposób użycia `new` — słowo kluczowe można utworzyć wystąpienia <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-109">(Floating-point values are truncated before they are assigned to the <xref:System.Numerics.BigInteger>.) The following example illustrates how to use the `new` keyword to instantiate <xref:System.Numerics.BigInteger> values.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   <span data-ttu-id="0fa7e-110">Można zadeklarować <xref:System.Numerics.BigInteger> zmienną i przypisz wartości podobnie jak miałoby to dowolnego typu liczbowego, dopóki ta wartość jest typem całkowitym.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-110">You can declare a <xref:System.Numerics.BigInteger> variable and assign it a value just as you would any numeric type, as long as that value is an integral type.</span></span> <span data-ttu-id="0fa7e-111">W poniższym przykładzie użyto przypisania, aby utworzyć <xref:System.Numerics.BigInteger> wartość z <xref:System.Int64>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-111">The following example uses assignment to create a <xref:System.Numerics.BigInteger> value from an <xref:System.Int64>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   <span data-ttu-id="0fa7e-112">Można przypisać wartość dziesiętną lub zmiennoprzecinkowe <xref:System.Numerics.BigInteger> obiekt można rzutować wartości lub przekonwertować ją najpierw.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-112">You can assign a decimal or floating-point value to a <xref:System.Numerics.BigInteger> object if you cast the value or convert it first.</span></span> <span data-ttu-id="0fa7e-113">Poniższy przykład jawnie rzutuje (w języku C#) lub konwertuje (w języku Visual Basic) <xref:System.Double> i <xref:System.Decimal> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-113">The following example explicitly casts (in C#) or converts (in Visual Basic) a <xref:System.Double> and a <xref:System.Decimal> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 <span data-ttu-id="0fa7e-114">Te metody umożliwiają utworzenie wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość jest w zakresie istniejących liczbowe tylko typy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-114">These methods enable you to instantiate a <xref:System.Numerics.BigInteger> object whose value is in the range of one of the existing numeric types only.</span></span> <span data-ttu-id="0fa7e-115">Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość może przekroczyć istniejących typów numerycznych w jeden z trzech sposobów:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-115">You can instantiate a <xref:System.Numerics.BigInteger> object whose value can exceed the range of the existing numeric types in one of three ways:</span></span>  
  
-   <span data-ttu-id="0fa7e-116">Można użyć `new` — słowo kluczowe i podaj tablica bajtów o dowolnym rozmiarze <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-116">You can use the `new` keyword and provide a byte array of any size to the <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="0fa7e-117">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-117">For example:</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   <span data-ttu-id="0fa7e-118">Możesz wywołać <xref:System.Numerics.BigInteger.Parse%2A> lub <xref:System.Numerics.BigInteger.TryParse%2A> metod do konwertowania reprezentację liczby <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-118">You can call the <xref:System.Numerics.BigInteger.Parse%2A> or <xref:System.Numerics.BigInteger.TryParse%2A> methods to convert the string representation of a number to a <xref:System.Numerics.BigInteger>.</span></span> <span data-ttu-id="0fa7e-119">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-119">For example:</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   <span data-ttu-id="0fa7e-120">Możesz wywołać `static` (`Shared` w języku Visual Basic) <xref:System.Numerics.BigInteger> metodę, która wykonuje pewne operacje na wyrażenia liczbowego i zwraca obliczeniowego <xref:System.Numerics.BigInteger> wynik.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-120">You can call a `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> method that performs some operation on a numeric expression and returns a calculated <xref:System.Numerics.BigInteger> result.</span></span> <span data-ttu-id="0fa7e-121">Poniższy przykład robi to przez cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> i przypisywanie wynik, który ma <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-121">The following example does this by cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> and assigning the result to a <xref:System.Numerics.BigInteger>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 <span data-ttu-id="0fa7e-122">Wartość niezainicjowanej <xref:System.Numerics.BigInteger> jest <xref:System.Numerics.BigInteger.Zero%2A>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-122">The uninitialized value of a <xref:System.Numerics.BigInteger> is <xref:System.Numerics.BigInteger.Zero%2A>.</span></span>  
  
## <a name="performing-operations-on-biginteger-values"></a><span data-ttu-id="0fa7e-123">Wykonywanie operacji na wartościach typu BigInteger</span><span class="sxs-lookup"><span data-stu-id="0fa7e-123">Performing Operations on BigInteger Values</span></span>  
 <span data-ttu-id="0fa7e-124">Można użyć <xref:System.Numerics.BigInteger> wystąpienie, jak w przypadku innych typ całkowity.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-124">You can use a <xref:System.Numerics.BigInteger> instance as you would use any other integral type.</span></span> <span data-ttu-id="0fa7e-125"><xref:System.Numerics.BigInteger> Overloads standardowych operatorów liczbowych i umożliwiają wykonywanie podstawowych operacji matematycznych, takich jak dodawanie, odejmowania, dzielenia, mnożenia, odejmowania, negacji i negacji jednoargumentowy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-125"><xref:System.Numerics.BigInteger> overloads the standard numeric operators to enable you to perform basic mathematical operations such as addition, subtraction, division, multiplication, subtraction, negation, and unary negation.</span></span> <span data-ttu-id="0fa7e-126">Umożliwia także standardowych operatorów liczbowe do porównania dwóch <xref:System.Numerics.BigInteger> wartości ze sobą.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-126">You can also use the standard numeric operators to compare two <xref:System.Numerics.BigInteger> values with each other.</span></span> <span data-ttu-id="0fa7e-127">Inne typy całkowite, takich jak <xref:System.Numerics.BigInteger> obsługuje również operatora testu koniunkcji `And`, `Or`, `XOr`, lewego shift i operatory przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-127">Like the other integral types, <xref:System.Numerics.BigInteger> also supports the bitwise `And`, `Or`, `XOr`, left shift, and right shift operators.</span></span> <span data-ttu-id="0fa7e-128">Dla języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.BigInteger> struktury udostępnia również równoważne metody służące do wykonywania operacji matematycznych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-128">For languages that do not support custom operators, the <xref:System.Numerics.BigInteger> structure also provides equivalent methods for performing mathematical operations.</span></span> <span data-ttu-id="0fa7e-129">Obejmują one <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>i kilka innych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-129">These include <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, and several others.</span></span>  
  
 <span data-ttu-id="0fa7e-130">Wiele elementów członkowskich z <xref:System.Numerics.BigInteger> struktury odpowiada bezpośrednio do elementów członkowskich innych typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-130">Many members of the <xref:System.Numerics.BigInteger> structure correspond directly to members of the other integral types.</span></span> <span data-ttu-id="0fa7e-131">Ponadto <xref:System.Numerics.BigInteger> dodaje elementy członkowskie, takie jak następujące:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-131">In addition, <xref:System.Numerics.BigInteger> adds members such as the following:</span></span>  
  
-   <span data-ttu-id="0fa7e-132"><xref:System.Numerics.BigInteger.Sign%2A>, która zwraca wartość wskazującą znak <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-132"><xref:System.Numerics.BigInteger.Sign%2A>, which returns a value that indicates the sign of a <xref:System.Numerics.BigInteger> value.</span></span>  
  
-   <span data-ttu-id="0fa7e-133"><xref:System.Numerics.BigInteger.Abs%2A>, która zwraca wartość bezwzględną liczby <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-133"><xref:System.Numerics.BigInteger.Abs%2A>, which returns the absolute value of a <xref:System.Numerics.BigInteger> value.</span></span>  
  
-   <span data-ttu-id="0fa7e-134"><xref:System.Numerics.BigInteger.DivRem%2A>, która zwraca iloraz i pozostałej części operacji dzielenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-134"><xref:System.Numerics.BigInteger.DivRem%2A>, which returns both the quotient and remainder of a division operation.</span></span>  
  
-   <span data-ttu-id="0fa7e-135"><xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, która zwraca największy wspólny dzielnik dwóch <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-135"><xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, which returns the greatest common divisor of two <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="0fa7e-136">Wiele z tych dodatkowych elementów członkowskich odpowiadają członków <xref:System.Math> klasy, która udostępnia funkcje do pracy z liczbowych typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-136">Many of these additional members correspond to the members of the <xref:System.Math> class, which provides the functionality to work with the primitive numeric types.</span></span>  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a><span data-ttu-id="0fa7e-137">Zmienność i struktura BigInteger</span><span class="sxs-lookup"><span data-stu-id="0fa7e-137">Mutability and the BigInteger Structure</span></span>  
 <span data-ttu-id="0fa7e-138">Poniższy przykład tworzy <xref:System.Numerics.BigInteger> obiektu i następnie zwiększa jedną wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-138">The following example instantiates a <xref:System.Numerics.BigInteger> object and then increments its value by one.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 <span data-ttu-id="0fa7e-139">Aby zmodyfikować wartość istniejący obiekt jest wyświetlany w tym przykładzie, ale nie jest to to.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-139">Although this example appears to modify the value of the existing object, this is not the case.</span></span> <span data-ttu-id="0fa7e-140"><xref:System.Numerics.BigInteger> obiekty są niezmienne, co oznacza, że wewnętrznie, środowisko uruchomieniowe języka wspólnego faktycznie tworzy nową <xref:System.Numerics.BigInteger> obiektów i przypisuje jej wartość jeden większa niż poprzednia wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-140"><xref:System.Numerics.BigInteger> objects are immutable, which means that internally, the common language runtime actually creates a new <xref:System.Numerics.BigInteger> object and assigns it a value one greater than its previous value.</span></span> <span data-ttu-id="0fa7e-141">Ten nowy obiekt jest następnie zwracany do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-141">This new object is then returned to the caller.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-142">Inne typy liczbowe w programie .NET Framework również są niezmienne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-142">The other numeric types in the .NET Framework are also immutable.</span></span> <span data-ttu-id="0fa7e-143">Jednak ponieważ <xref:System.Numerics.BigInteger> typ nie ma żadnych granic górny lub niższy, jego wartości można zwiększyć bardzo duże lub ma zauważalnego wpływu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-143">However, because the <xref:System.Numerics.BigInteger> type has no upper or lower bounds, its values can grow extremely large and have a measurable impact on performance.</span></span>  
  
 <span data-ttu-id="0fa7e-144">Mimo że ten proces jest niewidoczny dla obiekt wywołujący, jego pociągnąć za sobą zmniejszenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-144">Although this process is transparent to the caller, it does incur a performance penalty.</span></span> <span data-ttu-id="0fa7e-145">W niektórych przypadkach, szczególnie gdy powtarzane operacje są wykonywane w pętli na bardzo dużych <xref:System.Numerics.BigInteger> wartości, może być znaczny wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-145">In some cases, especially when repeated operations are performed in a loop on very large <xref:System.Numerics.BigInteger> values, that performance penalty can be significant.</span></span> <span data-ttu-id="0fa7e-146">Na przykład w poniższym przykładzie jest wykonywane kilkukrotnie do milionów razy, a <xref:System.Numerics.BigInteger> wartość jest zwiększany o jeden za każdym razem operacja się powiodła.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-146">For example, in the following example, an operation is performed repetitively up to a million times, and a <xref:System.Numerics.BigInteger> value is incremented by one every time the operation succeeds.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 <span data-ttu-id="0fa7e-147">W takim przypadku można poprawić wydajność, wykonując wszystkie pośrednie przypisania do <xref:System.Int32> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-147">In such a case, you can improve performance by performing all intermediate assignments to an <xref:System.Int32> variable.</span></span> <span data-ttu-id="0fa7e-148">Następnie można przypisać końcowa wartość zmiennej do <xref:System.Numerics.BigInteger> obiektu, gdy kończy pętli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-148">The final value of the variable can then be assigned to the <xref:System.Numerics.BigInteger> object when the loop exits.</span></span> <span data-ttu-id="0fa7e-149">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-149">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a><span data-ttu-id="0fa7e-150">Praca z tablicami bajtowymi i ciągami znaków szesnastkowych</span><span class="sxs-lookup"><span data-stu-id="0fa7e-150">Working with Byte Arrays and Hexadecimal Strings</span></span>  
 <span data-ttu-id="0fa7e-151">W przypadku przekonwertowania <xref:System.Numerics.BigInteger> wartości tablice typu byte, lub jeśli Konwertuj tablice typu byte do <xref:System.Numerics.BigInteger> wartości, należy rozważyć kolejności bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-151">If you convert <xref:System.Numerics.BigInteger> values to byte arrays, or if you convert byte arrays to <xref:System.Numerics.BigInteger> values, you must consider the order of bytes.</span></span> <span data-ttu-id="0fa7e-152"><xref:System.Numerics.BigInteger> Struktury oczekuje poszczególnych bajtów w tablicy bajtowej pojawią się w kolejności little endian (czyli kolejność małą liczbę bajtów wartość poprzedzać bajtów wyższego rzędu).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-152">The <xref:System.Numerics.BigInteger> structure expects the individual bytes in a byte array to appear in little-endian order (that is, the lower-order bytes of the value precede the higher-order bytes).</span></span> <span data-ttu-id="0fa7e-153">Można wyrównana <xref:System.Numerics.BigInteger> wartość wywołując <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przekazywanie wynikowy bajtów tablicy do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-153">You can round-trip a <xref:System.Numerics.BigInteger> value by calling the <xref:System.Numerics.BigInteger.ToByteArray%2A> method and then passing the resulting byte array to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 <span data-ttu-id="0fa7e-154">Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy bajtów reprezentujący wartość całkowitą typu, można przekazać wartości całkowite <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody, a następnie przekaż tablica wynikowa bajtów do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-154">To instantiate a <xref:System.Numerics.BigInteger> value from a byte array that represents a value of some other integral type, you can pass the integral value to the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method, and then pass the resulting byte array to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span> <span data-ttu-id="0fa7e-155">Poniższy przykład tworzy <xref:System.Numerics.BigInteger> wartości z tablicy bajtów reprezentujący <xref:System.Int16> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-155">The following example instantiates a <xref:System.Numerics.BigInteger> value from a byte array that represents an <xref:System.Int16> value.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <span data-ttu-id="0fa7e-156"><xref:System.Numerics.BigInteger> Struktury przyjęto założenie, że wartości ujemne są przechowywane przy użyciu dwóch jego reprezentacja dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-156">The <xref:System.Numerics.BigInteger> structure assumes that negative values are stored by using two's complement representation.</span></span> <span data-ttu-id="0fa7e-157">Ponieważ <xref:System.Numerics.BigInteger> struktury reprezentuje wartość numeryczną z brak stałej długości <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor zawsze interpretuje najbardziej znaczącego bitu ostatniego bajtu w tablicy jako bitem znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-157">Because the <xref:System.Numerics.BigInteger> structure represents a numeric value with no fixed length, the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor always interprets the most significant bit of the last byte in the array as a sign bit.</span></span> <span data-ttu-id="0fa7e-158">Aby zapobiec <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora z skomplikowana dwie firmy dopełnienia reprezentacja wartości ujemnej z logowania i wielkości reprezentację dodatnią wartość dodatnią wartości w którym najbardziej znaczącego bitu ostatniego bajtu w tablicy bajtów normalnie jest zestaw powinny zawierać dodatkowe bajt, którego wartość jest równa 0.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-158">To prevent the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor from confusing the two's complement representation of a negative value with the sign and magnitude representation of a positive value, positive values in which the most significant bit of the last byte in the byte array would ordinarily be set should include an additional byte whose value is 0.</span></span> <span data-ttu-id="0fa7e-159">Na przykład 0xC0 0xBD 0xF0 0xFF jest szesnastkową reprezentację little endian-1,000,000 lub 4,293,967,296.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-159">For example, 0xC0 0xBD 0xF0 0xFF is the little-endian hexadecimal representation of either -1,000,000 or 4,293,967,296.</span></span> <span data-ttu-id="0fa7e-160">Ponieważ najbardziej znaczącego bitu w tej macierzy ostatniego bajtu na wartość tablicy bajtów może zostać zinterpretowany przez <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor jako-1,000,000.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-160">Because the most significant bit of the last byte in this array is on, the value of the byte array would be interpreted by the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor as -1,000,000.</span></span> <span data-ttu-id="0fa7e-161">Można utworzyć wystąpienia <xref:System.Numerics.BigInteger> którego wartość jest dodatnia, której elementy są 0xC0 tablicy bajtów 0xBD 0xF0 0xFF 0x00 musi zostać przekazany do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-161">To instantiate a <xref:System.Numerics.BigInteger> whose value is positive, a byte array whose elements are 0xC0 0xBD 0xF0 0xFF 0x00 must be passed to the constructor.</span></span> <span data-ttu-id="0fa7e-162">Ilustruje to poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-162">The following example illustrates this.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 <span data-ttu-id="0fa7e-163">Tablice typu byte utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> metody z wartości dodatnie obejmują bajt bardzo wartość zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-163">Byte arrays created by the <xref:System.Numerics.BigInteger.ToByteArray%2A> method from positive values include this extra zero-value byte.</span></span> <span data-ttu-id="0fa7e-164">W związku z tym <xref:System.Numerics.BigInteger> struktury może pomyślnie obustronne wartości przez przypisywanie ich do i przywracania ich z tablice typu byte, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-164">Therefore, the <xref:System.Numerics.BigInteger> structure can successfully round-trip values by assigning them to, and then restoring them from, byte arrays, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 <span data-ttu-id="0fa7e-165">Może jednak może być konieczne dodanie dodatkowych bajt wartość zero do tablice typu byte, które są tworzone dynamicznie przez dewelopera lub który są zwracane przez metody, które przekonwertować tablic bajtowych liczb całkowitych bez znaku (takie jak <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, i <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-165">However, you may need to add this additional zero-value byte to byte arrays that are created dynamically by the developer or that are returned by methods that convert unsigned integers to byte arrays (such as <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, and <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="0fa7e-166">Podczas analizowania ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> i <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metod przyjęto założenie, że jeśli ustawiono najbardziej znaczącego bitu pierwszego bajtu w ciągu lub jeśli cyfry szesnastkowe ciąg reprezentuje niższe cztery bity wartość bajtu, wartość to przedstawić przy użyciu dwóch jego reprezentacja dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-166">When parsing a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> and <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> methods assume that if the most significant bit of the first byte in the string is set, or if the first hexadecimal digit of the string represents the lower four bits of a byte value, the value is represented by using two's complement representation.</span></span> <span data-ttu-id="0fa7e-167">Na przykład zarówno "FF01" i "F01" reprezentują-255 wartości dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-167">For example, both "FF01" and "F01" represent the decimal value -255.</span></span> <span data-ttu-id="0fa7e-168">Rozróżnianie dodatnią z wartości ujemnych, liczbę wartości dodatnich powinna zawierać zerem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-168">To differentiate positive from negative values, positive values should include a leading zero.</span></span> <span data-ttu-id="0fa7e-169">Odpowiednie przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody, gdy są one przekazywane ciąg formatu "X", dodać zera do zwracany ciąg szesnastkowy dla wartości dodatnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-169">The relevant overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, when they are passed the "X" format string, add a leading zero to the returned hexadecimal string for positive values.</span></span> <span data-ttu-id="0fa7e-170">Dzięki temu przesyłania danych <xref:System.Numerics.BigInteger> wartości przy użyciu <xref:System.Numerics.BigInteger.ToString%2A> i <xref:System.Numerics.BigInteger.Parse%2A> metody, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-170">This makes it possible to round-trip <xref:System.Numerics.BigInteger> values by using the <xref:System.Numerics.BigInteger.ToString%2A> and <xref:System.Numerics.BigInteger.Parse%2A> methods, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 <span data-ttu-id="0fa7e-171">Jednak ciągów szesnastkowych utworzona przez wywołanie metody `ToString` metod innych typów całkowitych lub przeciążeń <xref:System.Convert.ToString%2A> — metoda, która zawiera `toBase` parametr wskazuje znak wartość lub źródłowego typu danych, z którego ciąg szesnastkowy został uzyskany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-171">However, the hexadecimal strings created by calling the `ToString` methods of the other integral types or the overloads of the <xref:System.Convert.ToString%2A> method that include a `toBase` parameter do not indicate the sign of the value or the source data type from which the hexadecimal string was derived.</span></span> <span data-ttu-id="0fa7e-172">Pomyślnie tworzenia wystąpienia <xref:System.Numerics.BigInteger> dodatkowe logikę wymaga wartości z tych parametrów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-172">Successfully instantiating a <xref:System.Numerics.BigInteger> value from such a string requires some additional logic.</span></span> <span data-ttu-id="0fa7e-173">W poniższym przykładzie przedstawiono jeden wdrażanych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-173">The following example provides one possible implementation.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-174">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-174">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-175">Tablica wartości bajtu w kolejności little endian.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-175">An array of byte values in little-endian order.</span></span></param>
        <summary><span data-ttu-id="0fa7e-176">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury, używając wartości z tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-176">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using the values in a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-177">Poszczególne bajty `value` tablicy powinna być w kolejności little endian z najniższą kolejności bajtów do najwyższej kolejności bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-177">The individual bytes in the `value` array should be in little-endian order, from lowest-order byte to highest-order byte.</span></span> <span data-ttu-id="0fa7e-178">Na przykład wartość liczbowa 1,000,000,000,000 odpowiada, jak pokazano w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-178">For example, the numeric value 1,000,000,000,000 is represented as shown in the following table:</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="0fa7e-179">Ciąg szesnastkowy</span><span class="sxs-lookup"><span data-stu-id="0fa7e-179">Hexadecimal string</span></span>|<span data-ttu-id="0fa7e-180">E8D4A51000</span><span class="sxs-lookup"><span data-stu-id="0fa7e-180">E8D4A51000</span></span>|  
|<span data-ttu-id="0fa7e-181">Tablica bajtów (najniższy indeksu najpierw)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-181">Byte array (lowest index first)</span></span>|<span data-ttu-id="0fa7e-182">00 10 A5 D4 E8 00</span><span class="sxs-lookup"><span data-stu-id="0fa7e-182">00 10 A5 D4 E8 00</span></span>|  
  
 <span data-ttu-id="0fa7e-183">Większości metod, które Konwertuj wartości liczbowych na tablice typu byte, takich jak <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> i <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, zwraca tablice typu byte w kolejności little endian.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-183">Most methods that convert numeric values to byte arrays, such as <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> and <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, return byte arrays in little-endian order.</span></span>  
  
 <span data-ttu-id="0fa7e-184">Konstruktor oczekuje wartości dodatnie w tablicy bajtów na potrzeby użyj dwóch jego reprezentacja dopełnienia reprezentacja logowania i wielkości i wartości ujemnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-184">The constructor expects positive values in the byte array to use sign-and-magnitude representation, and negative values to use two's complement representation.</span></span> <span data-ttu-id="0fa7e-185">Innymi słowy Jeśli najwyższej kolejności bit bajtu najwyższej kolejności w `value` ustawiono powstałe w ten sposób <xref:System.Numerics.BigInteger> wartość jest liczbą ujemną.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-185">In other words, if the highest-order bit of the highest-order byte in `value` is set, the resulting <xref:System.Numerics.BigInteger> value is negative.</span></span> <span data-ttu-id="0fa7e-186">W zależności od źródła tablicy bajtów może to spowodować wartość dodatnią zostać błędnie zinterpretowane jako wartość ujemną.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-186">Depending on the source of the byte array, this may cause a positive value to be misinterpreted as a negative value.</span></span> <span data-ttu-id="0fa7e-187">Tablice typu byte są zwykle generowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-187">Byte arrays are typically generated in the following ways:</span></span>  
  
-   <span data-ttu-id="0fa7e-188">Wywołując <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-188">By calling the <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0fa7e-189">Ta metoda zwraca tablicę bajtów z bitowego najwyższej kolejności o najwyższej kolejności bajtów w zestawie tablicy równą zero dla wartości dodatnie, nie istnieje wystąpienia misinterpreting dodatnią jako ujemne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-189">Because this method returns a byte array with the highest-order bit of the highest-order byte in the array set to zero for positive values, there is no chance of misinterpreting a positive value as negative.</span></span> <span data-ttu-id="0fa7e-190">Niezmodyfikowane tablice typu byte utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> zawsze pomyślnie wykonywać Rundy, gdy są one przekazywane do metody <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-190">Unmodified byte arrays created by the <xref:System.Numerics.BigInteger.ToByteArray%2A> method always successfully round-trip when they are passed to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span>  
  
-   <span data-ttu-id="0fa7e-191">Wywołując <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> — metoda i przekazaniem go całkowita jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-191">By calling the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method and passing it a signed integer as a parameter.</span></span> <span data-ttu-id="0fa7e-192">Liczb całkowitych ze znakiem obsługiwać reprezentacja logowania i wielkości i dwa jego reprezentacja dopełnienia, nie istnieje wystąpienia misinterpreting dodatnią jako ujemne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-192">Because signed integers handle both sign-and-magnitude representation and two's complement representation, there is no chance of misinterpreting a positive value as negative.</span></span>  
  
-   <span data-ttu-id="0fa7e-193">Wywołując <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> — metoda i przekazaniem go całkowitą bez znaku jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-193">By calling the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method and passing it an unsigned integer as a parameter.</span></span> <span data-ttu-id="0fa7e-194">Ponieważ liczb całkowitych bez znaku są reprezentowane przez ich znaczenie tylko, liczbę wartości dodatnich może być błędnie zinterpretowana jako wartości ujemnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-194">Because unsigned integers are represented by their magnitude only, positive values can be misinterpreted as negative values.</span></span> <span data-ttu-id="0fa7e-195">Aby uniknąć tego błędnej interpretacji, można dodać zera bajtową wartość do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-195">To prevent this misinterpretation, you can add a zero-byte value to the end of the array.</span></span> <span data-ttu-id="0fa7e-196">W przykładzie w następnej sekcji przedstawiono ilustracji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-196">The example in the next section provides an illustration.</span></span>  
  
-   <span data-ttu-id="0fa7e-197">Tworząc tablicę bajtów albo dynamicznie lub statycznie bez niekoniecznie wywoływanie jednego z poprzednich metod lub przez zmodyfikowanie istniejącej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-197">By creating a byte array either dynamically or statically without necessarily calling any of the previous methods, or by modifying an existing byte array.</span></span> <span data-ttu-id="0fa7e-198">Aby zapobiec jest nieprawidłowo interpretowane jako wartości ujemnych wartości dodatnie, można dodać zera bajtową wartość do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-198">To prevent positive values from being misinterpreted as negative values, you can add a zero-byte value to the end of the array.</span></span>  
  
 <span data-ttu-id="0fa7e-199">Jeśli `value` jest pusta <xref:System.Byte> tablicy, nowa <xref:System.Numerics.BigInteger> obiektu jest ustawiana na wartość <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-199">If `value` is an empty <xref:System.Byte> array, the new <xref:System.Numerics.BigInteger> object is initialized to a value of <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-200">Jeśli `value` jest `null`, zgłasza konstruktora <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-200">If `value` is `null`, the constructor throws an <xref:System.ArgumentNullException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-201">Poniższy przykład tworzy <xref:System.Numerics.BigInteger> obiektu z tablicą bajtów elementu 5, którego wartość wynosi {5, 4, 3, 2, 1}.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-201">The following example instantiates a <xref:System.Numerics.BigInteger> object from a 5-element byte array whose value is {5, 4, 3, 2, 1}.</span></span> <span data-ttu-id="0fa7e-202">Następnie wyświetla <xref:System.Numerics.BigInteger> reprezentowaną jako zarówno dziesiętną, a szesnastkową liczby, w konsoli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-202">It then displays the <xref:System.Numerics.BigInteger> value, represented as both decimal and hexadecimal numbers, to the console.</span></span> <span data-ttu-id="0fa7e-203">Porównanie wartości tablicy wejściowej z tekst wyjściowy ułatwia wyczyść dlaczego tego przeciążenia <xref:System.Numerics.BigInteger> tworzy konstruktora klasy <xref:System.Numerics.BigInteger> obiektu, którego wartość jest 4328719365 (lub 0x102030405).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-203">A comparison of the input array with the text output makes it clear why this overload of the <xref:System.Numerics.BigInteger> class constructor creates a <xref:System.Numerics.BigInteger> object whose value is 4328719365 (or 0x102030405).</span></span> <span data-ttu-id="0fa7e-204">Pierwszy element tablicy bajtów, którego wartość to 5, definiuje wartość bajtu najniższy kolejności <xref:System.Numerics.BigInteger> obiektu, który jest 0x05.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-204">The first element of the byte array, whose value is 5, defines the value of the lowest-order byte of the <xref:System.Numerics.BigInteger> object, which is 0x05.</span></span> <span data-ttu-id="0fa7e-205">Drugi element tablicy bajtów, którego wartość wynosi 4, definiuje wartość bajtu drugi <xref:System.Numerics.BigInteger> obiektu, który jest 0x04 i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-205">The second element of the byte array, whose value is 4, defines the value of the second byte of the <xref:System.Numerics.BigInteger> object, which is 0x04, and so on.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 <span data-ttu-id="0fa7e-206">Poniższy przykład tworzy dodatnie i ujemne <xref:System.Numerics.BigInteger> wartość, przekazuje je do <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przywrócenie oryginalnej <xref:System.Numerics.BigInteger> wartości wynikowej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-206">The following example instantiates a positive and a negative <xref:System.Numerics.BigInteger> value, passes them to the <xref:System.Numerics.BigInteger.ToByteArray%2A> method, and then restores the original <xref:System.Numerics.BigInteger> values from the resulting byte array.</span></span> <span data-ttu-id="0fa7e-207">Należy pamiętać, że te dwie wartości są reprezentowane przez tablice typu byte identyczne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-207">Note that the two values are represented by identical byte arrays.</span></span> <span data-ttu-id="0fa7e-208">Jedyną różnicą między nimi jest najbardziej znaczącego bitu ostatniego elementu w tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-208">The only difference between them is in the most significant bit of the last element in the byte array.</span></span> <span data-ttu-id="0fa7e-209">Ten bit jest ustawiony (wartość bajtu to 0xFF), jeśli tablicy jest tworzona na podstawie ujemny <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-209">This bit is set (the value of the byte is 0xFF) if the array is created from a negative <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="0fa7e-210">Bit nie zdefiniowano (wartość bajtu wynosi zero), jeśli tablica jest tworzona na podstawie dodatnią <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-210">The bit is not set (the value of the byte is zero), if the array is created from a positive <xref:System.Numerics.BigInteger> value.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 <span data-ttu-id="0fa7e-211">Poniższy przykład przedstawia sposób upewnić się, że wartość dodatnią jest nie niepoprawnie wystąpienia jako wartość ujemną, dodając którego wartość wynosi zero do końca tablicy typu byte.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-211">The following example illustrates how to make sure that a positive value is not incorrectly instantiated as a negative value by adding a byte whose value is zero to the end of the array.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0fa7e-212"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-212"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-213">Liczba dziesiętna.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-213">A decimal number.</span></span></param>
        <summary><span data-ttu-id="0fa7e-214">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury, za pomocą <see cref="T:System.Decimal" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-214">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a <see cref="T:System.Decimal" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-215">Wynikiem wywołania tego konstruktora jest taki sam jak przypisywanie jawnie <xref:System.Decimal> do wartości <xref:System.Numerics.BigInteger> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-215">The result of calling this constructor is identical to explicitly assigning a <xref:System.Decimal> value to a <xref:System.Numerics.BigInteger> variable.</span></span>  
  
 <span data-ttu-id="0fa7e-216">Wywołanie konstruktora może spowodować utratę danych; wszystkie części ułamkowej `value` zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-216">Calling this constructor can cause data loss; any fractional part of `value` is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-217">Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-217">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="0fa7e-218">Definiuje tablicę <xref:System.Decimal> wartości, a następnie przekazuje każdej wartości <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-218">It defines an array of <xref:System.Decimal> values, and then passes each value to the <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor.</span></span> <span data-ttu-id="0fa7e-219">Należy pamiętać, że <xref:System.Decimal> wartość zostanie obcięta zamiast zaokrąglona, gdy jest przypisany do <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-219">Note that the <xref:System.Decimal> value is truncated instead of rounded when it is assigned to the <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-220">Wartość zmiennoprzecinkową podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-220">A double-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-221">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowej podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-221">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a double-precision floating-point value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-222">Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-222">Any fractional part of the `value` parameter is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="0fa7e-223">Ze względu na brak dokładności <xref:System.Double> typu danych, wywoływania ten konstruktor może spowodować utratę danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-223">Because of the lack of precision of the <xref:System.Double> data type, calling this constructor can cause data loss.</span></span>  
  
 <span data-ttu-id="0fa7e-224"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem jawnie przypisywanie <xref:System.Double> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-224">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from explicitly assigning a <xref:System.Double> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-225">Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-225">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="0fa7e-226">Również dwie utratę dokładności, który może wystąpić, gdy używasz <xref:System.Double> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-226">It also illustrates the loss of precision that may occur when you use the <xref:System.Double> data type.</span></span> <span data-ttu-id="0fa7e-227">A <xref:System.Double> przypisano duża wartość, która jest następnie przypisana do <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-227">A <xref:System.Double> is assigned a large value, which is then assigned to a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="0fa7e-228">Jak pokazano na dane wyjściowe, to przypisanie pociąga za sobą zmniejszenie precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-228">As the output shows, this assignment involves a loss of precision.</span></span> <span data-ttu-id="0fa7e-229">Obie wartości są następnie zwiększany o jeden.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-229">Both values are then incremented by one.</span></span> <span data-ttu-id="0fa7e-230">Dane wyjściowe wskazuje, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, podczas gdy <xref:System.Double> obiektu nie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-230">The output shows that the <xref:System.Numerics.BigInteger> object reflects the changed value, whereas the <xref:System.Double> object does not.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-231">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-231">The value of <paramref name="value" /> is <see cref="F:System.Double.NaN" />.</span></span>  
  
 <span data-ttu-id="0fa7e-232">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-232">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-233">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-233">The value of <paramref name="value" /> is <see cref="F:System.Double.NegativeInfinity" />.</span></span>  
  
 <span data-ttu-id="0fa7e-234">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-234">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-235">Wartość <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-235">The value of <paramref name="value" /> is <see cref="F:System.Double.PositiveInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-236">Całkowita 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-236">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-237">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-237">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 32-bit signed integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-238">Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-238">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> object by using this constructor.</span></span>  
  
 <span data-ttu-id="0fa7e-239"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.Int32> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-239">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning an <xref:System.Int32> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
 <span data-ttu-id="0fa7e-240"><xref:System.Numerics.BigInteger> Struktury nie ma konstruktorów z parametrem typu <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, lub <xref:System.UInt16>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-240">The <xref:System.Numerics.BigInteger> structure does not include constructors with a parameter of type <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, or <xref:System.UInt16>.</span></span> <span data-ttu-id="0fa7e-241">Jednak <xref:System.Int32> typu obsługuje niejawnej konwersji wartości 8-bitowych i 16-bitowych znakiem i bez znaku liczb całkowitych liczb całkowitych ze znakiem 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-241">However, the <xref:System.Int32> type supports the implicit conversion of 8-bit and 16-bit signed and unsigned integers to signed 32-bit integers.</span></span> <span data-ttu-id="0fa7e-242">W związku z tym ten konstruktor jest wywoływana, gdy `value` jest jednym z tych czterech typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-242">As a result, this constructor is called if `value` is any one of these four integral types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-243">Następujące przykładowe wywołania <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy 32-bitowych liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-243">The following example calls the <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> constructor to instantiate <xref:System.Numerics.BigInteger> values from an array of 32-bit integers.</span></span> <span data-ttu-id="0fa7e-244">Niejawna konwersja go używa również przypisać każdej wartości 32-bitową liczbę całkowitą <xref:System.Numerics.BigInteger> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-244">It also uses implicit conversion to assign each 32-bit integer value to a <xref:System.Numerics.BigInteger> variable.</span></span> <span data-ttu-id="0fa7e-245">Następnie porównuje dwie wartości ustalenie, czy powstałe w ten sposób <xref:System.Numerics.BigInteger> wartości są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-245">It then compares the two values to establish that the resulting <xref:System.Numerics.BigInteger> values are the same.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-246">Całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-246">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-247">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości 64-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-247">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 64-bit signed integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-248">Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-248">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> object by using this constructor.</span></span>  
  
 <span data-ttu-id="0fa7e-249"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.Int64> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-249">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning an <xref:System.Int64> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-250">Następujące przykładowe wywołania <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy 64-bitowych liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-250">The following example calls the <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> constructor to instantiate <xref:System.Numerics.BigInteger> values from an array of 64-bit integers.</span></span> <span data-ttu-id="0fa7e-251">Niejawna konwersja go używa również przypisać każdej wartości 64-bitową liczbę całkowitą <xref:System.Numerics.BigInteger> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-251">It also uses implicit conversion to assign each 64-bit integer value to a <xref:System.Numerics.BigInteger> variable.</span></span> <span data-ttu-id="0fa7e-252">Następnie porównuje dwie wartości ustalenie, czy powstałe w ten sposób <xref:System.Numerics.BigInteger> wartości są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-252">It then compares the two values to establish that the resulting <xref:System.Numerics.BigInteger> values are the same.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-253">Wartość zmiennoprzecinkową o pojedynczej dokładności.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-253">A single-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-254">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowej pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-254">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a single-precision floating-point value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-255">Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-255">Any fractional part of the `value` parameter is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="0fa7e-256">Ze względu na brak dokładności <xref:System.Single> typu danych, wywoływania ten konstruktor może spowodować utratę danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-256">Because of the lack of precision of the <xref:System.Single> data type, calling this constructor can result in data loss.</span></span>  
  
 <span data-ttu-id="0fa7e-257"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem jawnie przypisywanie <xref:System.Single> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-257">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from explicitly assigning a <xref:System.Single> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-258">Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-258">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="0fa7e-259">Również dwie utratę dokładności, który może wystąpić, gdy używasz <xref:System.Single> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-259">It also illustrates the loss of precision that may occur when you use the <xref:System.Single> data type.</span></span> <span data-ttu-id="0fa7e-260">A <xref:System.Single> przypisano duża wartość ujemną, która jest następnie przypisana do <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-260">A <xref:System.Single> is assigned a large negative value, which is then assigned to a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="0fa7e-261">Jak pokazano na dane wyjściowe, to przypisanie pociąga za sobą zmniejszenie precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-261">As the output shows, this assignment involves a loss of precision.</span></span> <span data-ttu-id="0fa7e-262">Obie wartości są następnie zwiększany o jeden.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-262">Both values are then incremented by one.</span></span> <span data-ttu-id="0fa7e-263">Dane wyjściowe wskazuje, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, podczas gdy <xref:System.Single> obiektu nie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-263">The output shows that the <xref:System.Numerics.BigInteger> object reflects the changed value, whereas the <xref:System.Single> object does not.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-264">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-264">The value of <paramref name="value" /> is <see cref="F:System.Single.NaN" />.</span></span>  
  
 <span data-ttu-id="0fa7e-265">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-265">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-266">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-266">The value of <paramref name="value" /> is <see cref="F:System.Single.NegativeInfinity" />.</span></span>  
  
 <span data-ttu-id="0fa7e-267">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-267">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-268">Wartość <paramref name="value" /> jest <see cref="F:System.Single.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-268">The value of <paramref name="value" /> is <see cref="F:System.Single.PositiveInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-269">Wartość liczby całkowitej bez znaku 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-269">An unsigned 32-bit integer value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-270">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości bez znaku 32-bitowej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-270">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using an unsigned 32-bit integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-271">Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-271">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> using this constructor.</span></span>  
  
 <span data-ttu-id="0fa7e-272"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.UInt32> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-272">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning a <xref:System.UInt32> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-273">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> Konstruktor i instrukcji przypisania, aby zainicjować <xref:System.Numerics.BigInteger> wartości z tablicy liczb całkowitych bez znaku 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-273">The following example uses the <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> constructor and an assignment statement to initialize <xref:System.Numerics.BigInteger> values from an array of unsigned 32-bit integers.</span></span> <span data-ttu-id="0fa7e-274">Następnie porównuje dwie wartości i Wykaż, że te dwie metody inicjowania <xref:System.Numerics.BigInteger> wartość tworzy identycznych wyników.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-274">It then compares the two values to demonstrate that the two methods of initializing a <xref:System.Numerics.BigInteger> value produce identical results.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-275">64-bitowa liczba całkowita bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-275">An unsigned 64-bit integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-276">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury z wartością całkowitą 64-bitowych unsigned.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-276">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure with an unsigned 64-bit integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-277">Nie są tracone dokładności podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-277">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> using this constructor.</span></span>  
  
 <span data-ttu-id="0fa7e-278"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość będącą wynikiem przypisywanie <xref:System.UInt64> do wartości <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-278">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning a <xref:System.UInt64> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-279">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość jest równa <xref:System.UInt64.MaxValue>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-279">The following example uses the <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object whose value is equal to <xref:System.UInt64.MaxValue>.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-280">Liczba.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-280">A number.</span></span></param>
        <summary><span data-ttu-id="0fa7e-281">Pobiera wartość bezwzględną liczby <see cref="T:System.Numerics.BigInteger" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-281">Gets the absolute value of a <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-282">Wartość bezwzględna <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-282">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-283">Wartość bezwzględna liczby jest ten numer bez znaku, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-283">The absolute value of a number is that number without its sign, as shown in the following table.</span></span>  
  
|<span data-ttu-id="0fa7e-284">`value` Parametr</span><span class="sxs-lookup"><span data-stu-id="0fa7e-284">`value` parameter</span></span>|<span data-ttu-id="0fa7e-285">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-285">Return value</span></span>|  
|-----------------------|------------------|  
|<span data-ttu-id="0fa7e-286">`value` >= 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-286">`value` >= 0</span></span>|`value`|  
|<span data-ttu-id="0fa7e-287">`value` < 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-287">`value` < 0</span></span>|<span data-ttu-id="0fa7e-288">`value` \* -1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-288">`value` \* -1</span></span>|  
  
 <span data-ttu-id="0fa7e-289"><xref:System.Numerics.BigInteger.Abs%2A> Metoda jest odpowiednikiem <xref:System.Math.Abs%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-289">The <xref:System.Numerics.BigInteger.Abs%2A> method is equivalent to the <xref:System.Math.Abs%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-290">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Abs%2A> metodę, aby przekonwertować <xref:System.Numerics.BigInteger> wartość z reprezentacji dopełnienia dwóch w reprezentacji logowania i wielkości przed szeregując go do pliku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-290">The following example uses the <xref:System.Numerics.BigInteger.Abs%2A> method to convert a <xref:System.Numerics.BigInteger> value from two's complement representation to sign-and-magnitude representation before serializing it to a file.</span></span> <span data-ttu-id="0fa7e-291">Dane w pliku jest następnie zdeserializować i przypisana do nowej <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-291">Data in the file is then deserialized and assigned to a new <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-292">Pierwsza wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-292">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-293">Druga wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-293">The second value to add.</span></span></param>
        <summary><span data-ttu-id="0fa7e-294">Dodaje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-294">Adds two <see cref="T:System.Numerics.BigInteger" /> values and returns the result.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-295">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-295">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-296">Języki, które nie obsługują przeładowania operatora lub operatory niestandardowych można używać <xref:System.Numerics.BigInteger.Add%2A> metodę w celu dodania przy użyciu <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-296">Languages that do not support operator overloading or custom operators can use the <xref:System.Numerics.BigInteger.Add%2A> method to perform addition using <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="0fa7e-297"><xref:System.Numerics.BigInteger.Add%2A> Metoda jest przydatna zamiast operatora dodawania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przypisać sum, będące wynikiem dodania, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-297">The <xref:System.Numerics.BigInteger.Add%2A> method is a useful substitute for the addition operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it a sum that results from addition, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-298">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-298">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-299">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-299">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-300">Porównuje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy pierwsza wartość jest mniejsza niż równa lub większa od drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-300">Compares two <see cref="T:System.Numerics.BigInteger" /> values and returns an integer that indicates whether the first value is less than, equal to, or greater than the second value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-301">Całkowita wskazująca wartości <paramref name="left" /> i <paramref name="right" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-301">A signed integer that indicates the relative values of <paramref name="left" /> and <paramref name="right" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="0fa7e-302"><list type="table"><listheader><term> Wartość</span><span class="sxs-lookup"><span data-stu-id="0fa7e-302"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="0fa7e-303"></term><description> Warunek</span><span class="sxs-lookup"><span data-stu-id="0fa7e-303"></term><description> Condition</span></span>  
  
 <span data-ttu-id="0fa7e-304"></description></listheader><item><term> Mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-304"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="0fa7e-305"></term><description><paramref name="left" /> jest mniejsza niż <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-305"></term><description><paramref name="left" /> is less than <paramref name="right" />.</span></span>  
  
 <span data-ttu-id="0fa7e-306"></description></item><item><term> Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-306"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="0fa7e-307"></term><description><paramref name="left" /> Equals <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-307"></term><description><paramref name="left" /> equals <paramref name="right" />.</span></span>  
  
 <span data-ttu-id="0fa7e-308"></description></item><item><term> Większa niż zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-308"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="0fa7e-309"></term><description><paramref name="left" /> jest większa niż <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-309"></term><description><paramref name="left" /> is greater than <paramref name="right" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-310">Mimo że <xref:System.Numerics.BigInteger> typ ma zakres stałej nie porównania <xref:System.Numerics.BigInteger> wartości nie charakteryzują się brak dokładności, która charakteryzuje porównanie liczb zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-310">Although the <xref:System.Numerics.BigInteger> type has no fixed range, comparisons of <xref:System.Numerics.BigInteger> values are not characterized by the lack of precision that characterizes the comparison of floating-point numbers.</span></span> <span data-ttu-id="0fa7e-311">Poniższy przykład porównuje dwa <xref:System.Numerics.BigInteger> wartości, które różnią się jeden i że każdy ma 1,896 cyfr.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-311">The following example compares two <xref:System.Numerics.BigInteger> values that differ by one and that each have 1,896 digits.</span></span> <span data-ttu-id="0fa7e-312"><xref:System.Numerics.BigInteger.Compare%2A> — Metoda prawidłowo informuje, czy dwie wartości nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-312">The <xref:System.Numerics.BigInteger.Compare%2A> method correctly reports that the two values are not equal.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-313">Porównuje wartość tego wystąpienia z inną wartość i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równy lub większy niż inne wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-313">Compares the value of this instance with another value and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the other value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0fa7e-314">Całkowita 64-bitowa do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-314">The signed 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-315">Porównuje tego wystąpienia całkowita 64-bitowa i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość całkowita 64-bitowa.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-315">Compares this instance to a signed 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the signed 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-316">Wartość całkowita, która wskazuje relacji tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-316">A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="0fa7e-317"><list type="table"><listheader><term> Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-317"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="0fa7e-318"></term><description> Opis elementu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-318"></term><description> Description</span></span>  
  
 <span data-ttu-id="0fa7e-319"></description></listheader><item><term> Mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-319"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="0fa7e-320"></term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-320"></term><description> The current instance is less than <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="0fa7e-321"></description></item><item><term> Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-321"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="0fa7e-322"></term><description> Bieżące wystąpienie jest równe <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-322"></term><description> The current instance equals <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="0fa7e-323"></description></item><item><term> Większa niż zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-323"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="0fa7e-324"></term><description> Bieżące wystąpienie jest większa niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-324"></term><description> The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-325">Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartość przy <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-325">If `other` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-326">Poniższy przykład przedstawia wyniku wywołania metody <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metody o wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-326">The following example illustrates the result of calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> method with integral values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0fa7e-327">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-327">The object to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-328">Porównuje to wystąpienie do drugiej <see cref="T:System.Numerics.BigInteger" /> i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równa lub większa niż wartość określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-328">Compares this instance to a second <see cref="T:System.Numerics.BigInteger" /> and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-329">Wartość całkowita, która wskazuje relacji tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-329">A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="0fa7e-330"><list type="table"><listheader><term> Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-330"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="0fa7e-331"></term><description> Opis elementu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-331"></term><description> Description</span></span>  
  
 <span data-ttu-id="0fa7e-332"></description></listheader><item><term> Mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-332"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="0fa7e-333"></term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-333"></term><description> The current instance is less than <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="0fa7e-334"></description></item><item><term> Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-334"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="0fa7e-335"></term><description> Bieżące wystąpienie jest równe <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-335"></term><description> The current instance equals <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="0fa7e-336"></description></item><item><term> Większa niż zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-336"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="0fa7e-337"></term><description> Bieżące wystąpienie jest większa niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-337"></term><description> The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-338">To przeciążenie metody <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metody <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-338">This overload of the <xref:System.Numerics.BigInteger.CompareTo%2A> method implements the <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0fa7e-339">Jest używany przez obiekty kolekcji ogólnej porządkowania elementów w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-339">It is used by generic collection objects to order the items in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-340">Poniższy przykład przedstawia użycie <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metody, aby uporządkować listę `StarInfo` obiektów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-340">The following example illustrates the use of the <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> method to order a list of `StarInfo` objects.</span></span> <span data-ttu-id="0fa7e-341">Każdy `StarInfo` obiektu zawiera informacje o nazwie gwiazdy i jego odległości od Earth w milach.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-341">Each `StarInfo` object provides information about a star's name and its distance from the Earth in miles.</span></span> <span data-ttu-id="0fa7e-342">`StarInfo` implementuje <xref:System.IComparable%601> interfejsu, które umożliwia `StarInfo` obiektów, które mają być sortowane według klasy rodzajowej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-342">`StarInfo` implements the <xref:System.IComparable%601> interface, which enables `StarInfo` objects to be sorted by generic collection classes.</span></span> <span data-ttu-id="0fa7e-343">Jego <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementacji opakowuje tylko wywołania <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-343">Its <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementation just wraps a call to <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 <span data-ttu-id="0fa7e-344">Poniższy kod tworzy następnie cztery `StarInfo` obiekty i przechowuje je w ogólnej metodzie <xref:System.Collections.Generic.List%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-344">The following code then instantiates four `StarInfo` objects and stores them in a generic <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="0fa7e-345">Po <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> metoda jest wywoływana, `StarInfo` obiekty są wyświetlane w kolejności ich odległość od ziemi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-345">After the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method is called, `StarInfo` objects are displayed in order of their distance from the Earth.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="0fa7e-346">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-346">The object to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-347">Porównuje tego wystąpienia określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równa lub większa niż wartość określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-347">Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-348">Całkowita wskazująca relacji do bieżącego wystąpienia <paramref name="obj" /> parametru, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-348">A signed integer that indicates the relationship of the current instance to the <paramref name="obj" /> parameter, as shown in the following table.</span></span>  
  
 <span data-ttu-id="0fa7e-349"><list type="table"><listheader><term> Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-349"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="0fa7e-350"></term><description> Opis elementu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-350"></term><description> Description</span></span>  
  
 <span data-ttu-id="0fa7e-351"></description></listheader><item><term> Mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-351"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="0fa7e-352"></term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-352"></term><description> The current instance is less than <paramref name="obj" />.</span></span>  
  
 <span data-ttu-id="0fa7e-353"></description></item><item><term> Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-353"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="0fa7e-354"></term><description> Bieżące wystąpienie jest równe <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-354"></term><description> The current instance equals <paramref name="obj" />.</span></span>  
  
 <span data-ttu-id="0fa7e-355"></description></item><item><term> Większa niż zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-355"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="0fa7e-356"></term><description> Bieżące wystąpienie jest większa niż <paramref name="obj" />, lub <paramref name="obj" /> parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-356"></term><description> The current instance is greater than <paramref name="obj" />, or the <paramref name="obj" /> parameter is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-357">To przeciążenie metody <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metody <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-357">This overload of the <xref:System.Numerics.BigInteger.CompareTo%2A> method implements the <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0fa7e-358">Jest używany przez obiekty kolekcja nierodzajową porządkowania elementów w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-358">It is used by non-generic collection objects to order the items in the collection.</span></span>  
  
 <span data-ttu-id="0fa7e-359">`obj` Parametr musi mieć jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-359">The `obj` parameter must be one of the following:</span></span>  
  
-   <span data-ttu-id="0fa7e-360">Obiekt o typie środowiska wykonawczego <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-360">An object whose run-time type is <xref:System.Numerics.BigInteger>.</span></span>  
  
-   <span data-ttu-id="0fa7e-361"><xref:System.Object> Zmiennej, którego wartość jest `null`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-361">An <xref:System.Object> variable whose value is `null`.</span></span> <span data-ttu-id="0fa7e-362">Jeśli wartość `obj` parametr jest `null`, metoda zwraca wartość 1, która wskazuje, czy bieżące wystąpienie jest większa niż `obj`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-362">If the value of the `obj` parameter is `null`, the method returns 1, which indicates that that the current instance is greater than `obj`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-363">Następujące przykładowe wywołania <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metody do porównania <xref:System.Numerics.BigInteger> wartości z każdego elementu w tablicy obiektów</span><span class="sxs-lookup"><span data-stu-id="0fa7e-363">The following example calls the <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> method to compare a <xref:System.Numerics.BigInteger> value with each element in an object array</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0fa7e-364"><paramref name="obj" /> nie jest <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-364"><paramref name="obj" /> is not a <see cref="T:System.Numerics.BigInteger" />.</span></span></exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0fa7e-365">64-bitowa liczba całkowita bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-365">The unsigned 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-366">Porównuje tego wystąpienia na liczbę całkowitą bez znaku 64-bitowe i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejszy, równa lub większa niż wartość liczby całkowitej bez znaku 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-366">Compares this instance to an unsigned 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the unsigned 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-367">Całkowita wskazująca względna wartość tego wystąpienia i <paramref name="other" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-367">A signed integer that indicates the relative value of this instance and <paramref name="other" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="0fa7e-368"><list type="table"><listheader><term> Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-368"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="0fa7e-369"></term><description> Opis elementu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-369"></term><description> Description</span></span>  
  
 <span data-ttu-id="0fa7e-370"></description></listheader><item><term> Mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-370"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="0fa7e-371"></term><description> Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-371"></term><description> The current instance is less than <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="0fa7e-372"></description></item><item><term> Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-372"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="0fa7e-373"></term><description> Bieżące wystąpienie jest równe <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-373"></term><description> The current instance equals <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="0fa7e-374"></description></item><item><term> Większa niż zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-374"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="0fa7e-375"></term><description> Bieżące wystąpienie jest większa niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-375"></term><description> The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="0fa7e-376">Wartość podział.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-376">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="0fa7e-377">Wartość do dzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-377">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="0fa7e-378">Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> przez inną wartość i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-378">Divides one <see cref="T:System.Numerics.BigInteger" /> value by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-379">Iloraz z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-379">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-380"><xref:System.Numerics.BigInteger.Divide%2A> Metoda przeprowadza dzielenie liczby całkowitej; reszta będącą wynikiem podziału zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-380">The <xref:System.Numerics.BigInteger.Divide%2A> method performs integer division; any remainder that results from the division is discarded.</span></span> <span data-ttu-id="0fa7e-381">Aby wykonać dzielenie liczby całkowitej przy zachowaniu pozostałą, należy wywołać <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-381">To perform integer division while preserving the remainder, call the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span> <span data-ttu-id="0fa7e-382">Aby pobrać tylko resztę, należy wywołać <xref:System.Numerics.BigInteger.Remainder%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-382">To retrieve only the remainder, call the <xref:System.Numerics.BigInteger.Remainder%2A> method.</span></span>  
  
 <span data-ttu-id="0fa7e-383"><xref:System.Numerics.BigInteger.Divide%2A> Metody mogą być używane przez języki, które nie obsługują przeładowania operatora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-383">The <xref:System.Numerics.BigInteger.Divide%2A> method can be used by languages that do not support operator overloading.</span></span> <span data-ttu-id="0fa7e-384">Jego zachowanie jest identyczne dzielenia przy użyciu operatora dzielenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-384">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-385">Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-385">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-386">Następnie używa każdy element jako iloraz w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> — metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-386">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="0fa7e-387"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-387"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="0fa7e-388">Wartość podział.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-388">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="0fa7e-389">Wartość do dzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-389">The value to divide by.</span></span></param>
        <param name="remainder"><span data-ttu-id="0fa7e-390">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> wartość, która reprezentuje resztę z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-390">When this method returns, contains a <see cref="T:System.Numerics.BigInteger" /> value that represents the remainder from the division.</span></span> <span data-ttu-id="0fa7e-391">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-391">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="0fa7e-392">Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik i zwraca resztę do parametru output.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-392">Divides one <see cref="T:System.Numerics.BigInteger" /> value by another, returns the result, and returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-393">Iloraz z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-393">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-394">Ta metoda umożliwia zachowanie zarówno iloraz i pozostałej, będącą wynikiem dzielenie liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-394">This method preserves both the quotient and the remainder that results from integer division.</span></span> <span data-ttu-id="0fa7e-395">Jeśli nie jest konieczne w pozostałej, użyj <xref:System.Numerics.BigInteger.Divide%2A> metody lub operator dzielenia; w przypadku jedynie zainteresowani pozostałą, użyć <xref:System.Numerics.BigInteger.Remainder%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-395">If you are not interested in the remainder, use the <xref:System.Numerics.BigInteger.Divide%2A> method or the division operator; if you are only interested in the remainder, use the <xref:System.Numerics.BigInteger.Remainder%2A> method.</span></span>  
  
 <span data-ttu-id="0fa7e-396">Znak zwracana `remainder` wartość jest taka sama jak znak `dividend` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-396">The sign of the returned `remainder` value is the same as the sign of the `dividend` parameter.</span></span>  
  
 <span data-ttu-id="0fa7e-397">Zachowanie <xref:System.Numerics.BigInteger.DivRem%2A> metoda jest identyczna ze <xref:System.Math.DivRem%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-397">The behavior of the <xref:System.Numerics.BigInteger.DivRem%2A> method is identical to that of the <xref:System.Math.DivRem%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-398">Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-398">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-399">Następnie używa każdy element jako iloraz w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> — metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-399">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="0fa7e-400"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-400"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-401">Zwraca wartość wskazującą, czy dwie wartości liczbowe są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-401">Returns a value that indicates whether two numeric values are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0fa7e-402">Całkowita 64-bitowa wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-402">The signed 64-bit integer value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-403">Zwraca wartość wskazującą, czy bieżące wystąpienie i całkowita 64-bitowa mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-403">Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-404"><see langword="true" /> Jeśli całkowita 64-bitowa i bieżącego wystąpienia mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-404"><see langword="true" /> if the signed 64-bit integer and the current instance have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-405">Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-405">If `other` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the method is called.</span></span>  
  
 <span data-ttu-id="0fa7e-406">Aby określić relacji między tymi dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-406">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-407">Poniższy przykład tworzy <xref:System.Numerics.BigInteger> obiektu z każdego typu całkowitego, z wyjątkiem <xref:System.UInt64>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-407">The following example instantiates a <xref:System.Numerics.BigInteger> object from each integral type except <xref:System.UInt64>.</span></span> <span data-ttu-id="0fa7e-408">Następnie wywołuje <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metody do porównania <xref:System.Numerics.BigInteger> wartości z oryginalnej wartości całkowitej, który został przekazany do <xref:System.Numerics.BigInteger> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-408">It then calls the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> method to compare the <xref:System.Numerics.BigInteger> value with the original integer value that was passed to the <xref:System.Numerics.BigInteger> constructor.</span></span> <span data-ttu-id="0fa7e-409">Jak pokazano na dane wyjściowe, wartości są równe, w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-409">As the output shows, the values are equal in each case.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0fa7e-410">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-410">The object to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-411">Zwraca wartość wskazującą, czy bieżące wystąpienie i określonej <see cref="T:System.Numerics.BigInteger" /> obiektu mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-411">Returns a value that indicates whether the current instance and a specified <see cref="T:System.Numerics.BigInteger" /> object have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-412"><see langword="true" /> Jeśli <see cref="T:System.Numerics.BigInteger" /> obiektu i <paramref name="other" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-412"><see langword="true" /> if this <see cref="T:System.Numerics.BigInteger" /> object and <paramref name="other" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-413">Ta metoda implementuje <xref:System.IEquatable%601> interfejsu i wykonuje nieco większą niż <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , ponieważ nie muszą być konwertowane `other` parametr <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-413">This method implements the <xref:System.IEquatable%601> interface and performs slightly better than <xref:System.Numerics.BigInteger.Equals%28System.Object%29> because it does not have to convert the `other` parameter to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="0fa7e-414">Można określić relacji między tymi dwoma <xref:System.Numerics.BigInteger> obiektów, a nie tylko testowanie pod kątem równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-414">To determine the relationship between the two <xref:System.Numerics.BigInteger> objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-415">Poniższy przykład porównuje przybliżonej odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby sprawdzić, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-415">The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</span></span> <span data-ttu-id="0fa7e-416">W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-416">The example uses each overload of the <xref:System.Numerics.BigInteger.Equals%2A> method to test for equality.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="0fa7e-417">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-417">The object to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-418">Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-418">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-419"><see langword="true" /> Jeśli <paramref name="obj" /> argument jest <see cref="T:System.Numerics.BigInteger" /> obiekt i jego wartość jest równa wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> wystąpienia; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-419"><see langword="true" /> if the <paramref name="obj" /> argument is a <see cref="T:System.Numerics.BigInteger" /> object, and its value is equal to the value of the current <see cref="T:System.Numerics.BigInteger" /> instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-420">Jeśli `obj` argument nie jest <xref:System.Numerics.BigInteger> wartości, metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-420">If the `obj` argument is not a <xref:System.Numerics.BigInteger> value, the method returns `false`.</span></span> <span data-ttu-id="0fa7e-421">Metoda zwraca `true` tylko wtedy, gdy `obj` jest <xref:System.Numerics.BigInteger> wystąpienie, którego wartość jest równa bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-421">The method returns `true` only if `obj` is a <xref:System.Numerics.BigInteger> instance whose value is equal to the current instance.</span></span>  
  
 <span data-ttu-id="0fa7e-422">Aby określić relacji między tymi dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-422">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-423">W poniższym przykładzie zdefiniowano równoległe <xref:System.Object> i <xref:System.Numerics.BigInteger> tablic.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-423">The following example defines parallel <xref:System.Object> and <xref:System.Numerics.BigInteger> arrays.</span></span> <span data-ttu-id="0fa7e-424">Każdy element tablicy ma taką samą wartość jak odpowiadający mu element w tablicy drugiego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-424">Each element of one array has the same value as the corresponding element of the second array.</span></span> <span data-ttu-id="0fa7e-425">Jako dane wyjściowe w przykładzie pokazano, wystąpienie w <xref:System.Numerics.BigInteger> tablicy jest uznawany za taki sam jak wystąpienie w <xref:System.Object> tablicy tylko wtedy, gdy jest on <xref:System.Numerics.BigInteger> i ich wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-425">As the output from the example shows, the instance in the <xref:System.Numerics.BigInteger> array is considered to be equal to the instance in the <xref:System.Object> array only if the latter is a <xref:System.Numerics.BigInteger> and their values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0fa7e-426">64-bitowa liczba całkowita bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-426">The unsigned 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-427">Zwraca wartość wskazującą, czy bieżące wystąpienie i całkowitą bez znaku 64-bitowych mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-427">Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-428"><see langword="true" /> Jeśli bieżące wystąpienie i liczbę całkowitą bez znaku 64-bitowych mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-428"><see langword="true" /> if the current instance and the unsigned 64-bit integer have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-429">Aby określić relacji między tymi dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-429">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-430">Poniższy przykład porównuje przybliżonej odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby sprawdzić, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-430">The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</span></span> <span data-ttu-id="0fa7e-431">W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-431">The example uses each overload of the <xref:System.Numerics.BigInteger.Equals%2A> method to test for equality.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0fa7e-432">Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-432">Returns the hash code for the current <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-433">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-433">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-434">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-434">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-435">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-435">The second value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-436">Wyszukuje największy wspólny dzielnik dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-436">Finds the greatest common divisor of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-437">Największy wspólny dzielnik <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-437">The greatest common divisor of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-438">Największy wspólny dzielnik jest największą liczbę, do którego dwa <xref:System.Numerics.BigInteger> wartości można podzielić bez reszty powrotu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-438">The greatest common divisor is the largest number into which the two <xref:System.Numerics.BigInteger> values can be divided without returning a remainder.</span></span>  
  
 <span data-ttu-id="0fa7e-439">Jeśli `left` i `right` parametry są liczbami zera, metoda zawsze zwraca co najmniej wartość 1, ponieważ wszystkie numery można podzielić się o 1.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-439">If the `left` and `right` parameters are non-zero numbers, the method always returns at least a value of 1 because all numbers can be divided by 1.</span></span> <span data-ttu-id="0fa7e-440">Jeśli albo parametr ma wartość zero, metoda zwraca wartość bezwzględną liczby parametrów inną niż zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-440">If either parameter is zero, the method returns the absolute value of the non-zero parameter.</span></span> <span data-ttu-id="0fa7e-441">Jeśli obie wartości zero, metoda zwraca wartość zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-441">If both values are zero, the method returns zero.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-442">Obliczanie największy wspólny dzielnik bardzo dużej wartości `left` i `right` może być bardzo czasochłonna operacja.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-442">Computing the greatest common divisor of very large values of `left` and `right` can be a very time-consuming operation.</span></span>  
  
 <span data-ttu-id="0fa7e-443">Wartość zwrócona przez <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody zawsze jest dodatnia, niezależnie od jej znaku `left` i `right` parametrów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-443">The value returned by the <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> method is always positive regardless of the sign of the `left` and `right` parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-444">Poniższy przykład przedstawia wywołanie <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody i obsługi konieczne dostarczające przydatnych informacji na temat wyjątków <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-444">The following example illustrates a call to the <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> method and the exception handling necessary to provide useful information about an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="0fa7e-445">Wynik wskazuje, że te dwie liczb największy wspólny dzielnik jest 1.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-445">The result indicates that the greatest common divisor of these two numbers is 1.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-446">Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-446">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is an even number.</span></span></summary>
        <value>
          <span data-ttu-id="0fa7e-447"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-447"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is an even number; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-448">Ta właściwość jest wygody, która wskazuje, czy <xref:System.Numerics.BigInteger> wartość jest podzielna przez dwa.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-448">This property is a convenience feature that indicates whether a <xref:System.Numerics.BigInteger> value is evenly divisible by two.</span></span> <span data-ttu-id="0fa7e-449">Jest odpowiednikiem następującego wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-449">It is equivalent to the following expression:</span></span>  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 <span data-ttu-id="0fa7e-450">Jeśli wartość bieżącej klasy <xref:System.Numerics.BigInteger> obiekt jest <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, zwraca właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-450">If the value of the current <xref:System.Numerics.BigInteger> object is <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, the property returns `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-451">Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-451">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />.</span></span></summary>
        <value>
          <span data-ttu-id="0fa7e-452"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-452"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-453">Ta właściwość oferuje znacznie większą wydajność niż pozostałych porównań z jednym, takich jak `thisBigInteger.Equals(BigInteger.One)`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-453">This property offers significantly better performance than other comparisons with one, such as `thisBigInteger.Equals(BigInteger.One)`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-454">Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-454">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is a power of two.</span></span></summary>
        <value>
          <span data-ttu-id="0fa7e-455"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-455"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is a power of two; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-456">Ta właściwość określa, czy <xref:System.Numerics.BigInteger> wartość ma jeden bit niezerową wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-456">This property determines whether a <xref:System.Numerics.BigInteger> value has a single non-zero bit set.</span></span> <span data-ttu-id="0fa7e-457">Oznacza to, że zwraca `true` Jeśli wartość bieżącej klasy <xref:System.Numerics.BigInteger> obiekt jest 1 (czyli 2<sup>0</sup>) lub dowolnego większa potęgą liczby dwa.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-457">This means that it returns `true` if the value of the current <xref:System.Numerics.BigInteger> object is 1 (that is, 2<sup>0</sup>) or any greater power of two.</span></span> <span data-ttu-id="0fa7e-458">Zwraca `false` Jeśli wartość bieżącej klasy <xref:System.Numerics.BigInteger> obiektu wynosi 0.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-458">It returns `false` if the value of the current <xref:System.Numerics.BigInteger> object is 0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-459">Wskazuje, czy wartość bieżącej klasy <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-459">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />.</span></span></summary>
        <value>
          <span data-ttu-id="0fa7e-460"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-460"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-461">Ta właściwość zapewnia znacznie większą wydajność niż `BigInteger.Equals(BigInteger.Zero)`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-461">This property offers significantly better performance than `BigInteger.Equals(BigInteger.Zero)`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-462">Zwraca wartość logarytmu określonej liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-462">Returns the logarithm of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-463">Liczba, której logarytm ma zostać znaleziona.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-463">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="0fa7e-464">Zwraca fizyczna (podstawowy <see langword="e" />) logarytm o podstawie określonej liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-464">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-465">Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-465">The natural (base <see langword="e" />) logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-466">`value` Parametr jest określony jako podstawowy numer 10.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-466">The `value` parameter is specified as a base 10 number.</span></span>  
  
 <span data-ttu-id="0fa7e-467">Dokładne zwrócić wartość ta metoda zależy od jej znaku `value`, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-467">The precise return value of this method depends on the sign of `value`, as the following table shows.</span></span>  
  
|<span data-ttu-id="0fa7e-468">Zaloguj się z `value` parametru</span><span class="sxs-lookup"><span data-stu-id="0fa7e-468">Sign of `value` parameter</span></span>|<span data-ttu-id="0fa7e-469">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-469">Return value</span></span>|  
|-------------------------------|------------------|  
|<span data-ttu-id="0fa7e-470">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="0fa7e-470">Positive</span></span>|<span data-ttu-id="0fa7e-471">Logarytm naturalny `value`; oznacza to, ln `value`, lub dziennika e`value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-471">The natural logarithm of `value`; that is, ln `value`, or log e`value`.</span></span>|  
|<span data-ttu-id="0fa7e-472">Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-472">Zero</span></span>|<span data-ttu-id="0fa7e-473"><xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-473"><xref:System.Double.NegativeInfinity>.</span></span>|  
|<span data-ttu-id="0fa7e-474">Ujemne</span><span class="sxs-lookup"><span data-stu-id="0fa7e-474">Negative</span></span>|<span data-ttu-id="0fa7e-475"><xref:System.Double.NaN>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-475"><xref:System.Double.NaN>.</span></span>|  
  
 <span data-ttu-id="0fa7e-476">Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartości, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-476">To calculate the base 10 logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log10%2A> method.</span></span> <span data-ttu-id="0fa7e-477">Aby obliczyć logarytm liczby w innej bazie, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-477">To calculate the logarithm of a number in another base, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> method.</span></span>  
  
 <span data-ttu-id="0fa7e-478">Pierwiastek kwadratowy liczby można znaleźć wywołując <xref:System.Numerics.BigInteger.Log%2A> metody wraz z programem <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-478">You can find the square root of a number by calling the <xref:System.Numerics.BigInteger.Log%2A> method along with the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0fa7e-479">Należy zauważyć, że wynik <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Jeśli wynik jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-479">Note that the result is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> if the result is greater than <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-480">W poniższym przykładzie oblicza pierwiastek kwadratowy każdego elementu w tablicy <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-480">The following example calculates the square root of each element in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 <span data-ttu-id="0fa7e-481">Ta metoda odpowiada <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-481">This method corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0fa7e-482">Logarytm naturalny z <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-482">The natural log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-483">Liczba, której logarytm ma zostać znaleziona.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-483">A number whose logarithm is to be found.</span></span></param>
        <param name="baseValue"><span data-ttu-id="0fa7e-484">Podstawa logarytmu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-484">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="0fa7e-485">Zwraca logarytm o określonej liczby w określonej podstawy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-485">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-486">Podstawowym <paramref name="baseValue" /> logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-486">The base <paramref name="baseValue" /> logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-487">`value` i `baseValue` parametry są określane jako podstawowa 10 cyfr.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-487">The `value` and `baseValue` parameters are specified as base 10 numbers.</span></span>  
  
 <span data-ttu-id="0fa7e-488">Dokładne zwrócić wartość metody zależy od jej znaku `value` logowania i wartość `baseValue`, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-488">The precise return value of the method depends on the sign of `value` and on the sign and value of `baseValue`, as the following table shows.</span></span>  
  
|<span data-ttu-id="0fa7e-489">`value` Parametr</span><span class="sxs-lookup"><span data-stu-id="0fa7e-489">`value` parameter</span></span>|<span data-ttu-id="0fa7e-490">`baseValue` Parametr</span><span class="sxs-lookup"><span data-stu-id="0fa7e-490">`baseValue` parameter</span></span>|<span data-ttu-id="0fa7e-491">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-491">Return value</span></span>|  
|-----------------------|---------------------------|------------------|  
|<span data-ttu-id="0fa7e-492">`value` > 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-492">`value` > 0</span></span>|<span data-ttu-id="0fa7e-493">(0 < `baseValue` < 1) - lub -(`baseValue` > 1)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-493">(0 < `baseValue` < 1) -or-(`baseValue` > 1)</span></span>|<span data-ttu-id="0fa7e-494">logbaseValue (`value`)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-494">logbaseValue(`value`)</span></span>|  
|<span data-ttu-id="0fa7e-495">`value` < 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-495">`value` < 0</span></span>|<span data-ttu-id="0fa7e-496">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-496">(any value)</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-497">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-497">(any value)</span></span>|<span data-ttu-id="0fa7e-498">`baseValue` < 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-498">`baseValue` < 0</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-499">`value` != 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-499">`value` != 1</span></span>|<span data-ttu-id="0fa7e-500">`baseValue` = 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-500">`baseValue` = 0</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-501">`value` != 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-501">`value` != 1</span></span>|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-502">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-502">(any value)</span></span>|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-503">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-503">(any value)</span></span>|<span data-ttu-id="0fa7e-504">`baseValue` = 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-504">`baseValue` = 1</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-505">`value` = 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-505">`value` = 0</span></span>|<span data-ttu-id="0fa7e-506">0 < `baseValue` < 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-506">0 < `baseValue` < 1</span></span>|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-507">`value` = 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-507">`value` = 0</span></span>|<span data-ttu-id="0fa7e-508">`baseValue` > 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-508">`baseValue` > 1</span></span>|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|<span data-ttu-id="0fa7e-509">`value` = 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-509">`value` = 1</span></span>|<span data-ttu-id="0fa7e-510">`baseValue` = 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-510">`baseValue` = 0</span></span>|<span data-ttu-id="0fa7e-511">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-511">0</span></span>|  
|<span data-ttu-id="0fa7e-512">`value` = 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-512">`value` = 1</span></span>|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<span data-ttu-id="0fa7e-513">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-513">0</span></span>|  
  
 <span data-ttu-id="0fa7e-514">Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartości, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-514">To calculate the base 10 logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log10%2A> method.</span></span> <span data-ttu-id="0fa7e-515">Aby obliczyć logarytm naturalny liczby, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-515">To calculate the natural logarithm of a number, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> method.</span></span>  
  
 <span data-ttu-id="0fa7e-516">Ta metoda odpowiada <xref:System.Math.Log%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-516">This method corresponds to the <xref:System.Math.Log%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0fa7e-517">Dziennik <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-517">The log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-518">Liczba, której logarytm ma zostać znaleziona.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-518">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="0fa7e-519">Zwraca logarytm 10 podanej liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-519">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-520">Logarytm 10 z <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-520">The base 10 logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-521">`value` Parametr jest określony jako podstawowy numer 10.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-521">The `value` parameter is specified as a base 10 number.</span></span>  
  
 <span data-ttu-id="0fa7e-522">Dokładne zwrócić wartość metody zależy od jej znaku `value`, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-522">The precise return value of the method depends on the sign of `value`, as the following table shows.</span></span>  
  
|<span data-ttu-id="0fa7e-523">Znak, wartość parametru</span><span class="sxs-lookup"><span data-stu-id="0fa7e-523">Sign of value parameter</span></span>|<span data-ttu-id="0fa7e-524">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-524">Return value</span></span>|  
|-----------------------------|------------------|  
|<span data-ttu-id="0fa7e-525">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="0fa7e-525">Positive</span></span>|<span data-ttu-id="0fa7e-526">Dziennik podstawowej 10 `value`; oznacza to, że log10`value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-526">The base 10 log of `value`; that is, log10`value`.</span></span>|  
|<span data-ttu-id="0fa7e-527">Zero</span><span class="sxs-lookup"><span data-stu-id="0fa7e-527">Zero</span></span>|<span data-ttu-id="0fa7e-528"><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-528"><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="0fa7e-529">Ujemne</span><span class="sxs-lookup"><span data-stu-id="0fa7e-529">Negative</span></span>|<span data-ttu-id="0fa7e-530"><xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-530"><xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="0fa7e-531">Aby obliczyć logarytm naturalny <xref:System.Numerics.BigInteger> wartości, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-531">To calculate the natural logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0fa7e-532">Aby obliczyć logarytm liczby w innej bazie, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-532">To calculate the logarithm of a number in another base, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0fa7e-533">Ta metoda odpowiada <xref:System.Math.Log10%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-533">This method corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0fa7e-534">Dziennik podstawowej 10 <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-534">The base 10 log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-535">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-535">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-536">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-536">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-537">Zwraca większej liczby dwa <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-537">Returns the larger of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-538"><paramref name="left" /> Lub <paramref name="right" /> parametru, w zależności od jest większy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-538">The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-539">Ta metoda odpowiada <xref:System.Math.Max%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-539">This method corresponds to the <xref:System.Math.Max%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-540">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Max%2A> metoda, aby wybrać największa liczba w tablicy <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-540">The following example uses the <xref:System.Numerics.BigInteger.Max%2A> method to select the largest number in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-541">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-541">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-542">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-542">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-543">Zwraca mniejszy z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-543">Returns the smaller of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-544"><paramref name="left" /> Lub <paramref name="right" /> parametru, w zależności od jest mniejsza.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-544">The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-545">Ta metoda odpowiada <xref:System.Math.Min%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-545">This method corresponds to the <xref:System.Math.Min%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-546">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Min%2A> metoda, aby wybrać najmniejszą wartość w tablicy <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-546">The following example uses the <xref:System.Numerics.BigInteger.Min%2A> method to select the smallest number in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-547">Pobiera wartość reprezentującą liczbę minus (-1).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-547">Gets a value that represents the number negative one (-1).</span></span></summary>
        <value><span data-ttu-id="0fa7e-548">Liczba całkowita, którego wartość jest ujemna (-1).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-548">An integer whose value is negative one (-1).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-549"><xref:System.Numerics.BigInteger.MinusOne%2A> Właściwość jest używana do porównania <xref:System.Numerics.BigInteger> wartość -1 lub -1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-549">The <xref:System.Numerics.BigInteger.MinusOne%2A> property is used to compare a <xref:System.Numerics.BigInteger> value to -1 or to assign -1 to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-550">Numer, do której zostaną podniesione <c>wykładnik</c> zasilania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-550">The number to raise to the <c>exponent</c> power.</span></span></param>
        <param name="exponent"><span data-ttu-id="0fa7e-551">Wykładnik, aby podnieść <c>wartość</c> przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-551">The exponent to raise <c>value</c> by.</span></span></param>
        <param name="modulus"><span data-ttu-id="0fa7e-552">Liczbę, przez którą chcesz podzielić <c>wartość</c> do <c>wykładnik</c> zasilania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-552">The number by which to divide <c>value</c> raised to the <c>exponent</c> power.</span></span></param>
        <summary><span data-ttu-id="0fa7e-553">Wykonuje dzielenie modulo na liczbę podniesioną do potęgi równej innej liczbie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-553">Performs modulus division on a number raised to the power of another number.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-554">Resztę po podzieleniu <paramref name="value" /> <sup>wykładnik</sup> przez <paramref name="modulus" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-554">The remainder after dividing <paramref name="value" /><sup>exponent</sup> by <paramref name="modulus" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-555"><xref:System.Numerics.BigInteger.ModPow%2A> Metody oblicza wyrażenie następujące:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-555">The <xref:System.Numerics.BigInteger.ModPow%2A> method evaluates the following expression:</span></span>  
  
 <span data-ttu-id="0fa7e-556">(baseValue ^ wykładnik) Mod modulo</span><span class="sxs-lookup"><span data-stu-id="0fa7e-556">(baseValue ^ exponent) Mod modulus</span></span>  
  
 <span data-ttu-id="0fa7e-557">Do przeprowadzenia potęgowania na <xref:System.Numerics.BigInteger> Użyj wartości bez dzielenie modulo <xref:System.Numerics.BigInteger.Pow%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-557">To perform exponentiation on <xref:System.Numerics.BigInteger> values without modulus division, use the <xref:System.Numerics.BigInteger.Pow%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-558">W poniższym przykładzie przedstawiono prosty ilustracji wywołania metody <xref:System.Numerics.BigInteger.ModPow%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-558">The following example provides a simple illustration of calling the <xref:System.Numerics.BigInteger.ModPow%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="0fa7e-559"><paramref name="modulus" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-559"><paramref name="modulus" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0fa7e-560"><paramref name="exponent" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-560"><paramref name="exponent" /> is negative.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-561">Pierwszy liczbę Aby pomnożyć.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-561">The first number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-562">Druga liczba do wielokrotnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-562">The second number to multiply.</span></span></param>
        <summary><span data-ttu-id="0fa7e-563">Zwraca iloczyn dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-563">Returns the product of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-564">Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-564">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-565"><xref:System.Numerics.BigInteger.Multiply%2A> Metoda została zaimplementowana dla języków, które nie obsługują przeładowania operatora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-565">The <xref:System.Numerics.BigInteger.Multiply%2A> method is implemented for languages that do not support operator overloading.</span></span> <span data-ttu-id="0fa7e-566">Jego zachowanie jest identyczne mnożenia przy użyciu operatora mnożenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-566">Its behavior is identical to multiplication using the multiplication operator.</span></span> <span data-ttu-id="0fa7e-567">Ponadto <xref:System.Numerics.BigInteger.Multiply%2A> metoda jest przydatna zastępuje operator mnożenia podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przypisać produkt, który jest wynikiem mnożenia, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-567">In addition, the <xref:System.Numerics.BigInteger.Multiply%2A> method is a useful substitute for the multiplication operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it a product that results from multiplication, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 <span data-ttu-id="0fa7e-568">Jeśli to konieczne, ta metoda automatycznie wykonuje niejawna konwersja z innych typów całkowitych do <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-568">If necessary, this method automatically performs implicit conversion of other integral types to <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="0fa7e-569">Jest to zilustrowane w przykładzie w następnej sekcji, gdzie <xref:System.Numerics.BigInteger.Multiply%2A> metody jest przekazywany dwa <xref:System.Int64> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-569">This is illustrated in the example in the next section, where the <xref:System.Numerics.BigInteger.Multiply%2A> method is passed two <xref:System.Int64> values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-570">Poniższy przykład próbuje wykonać mnożenia z dwóch długich liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-570">The following example tries to perform multiplication with two long integers.</span></span> <span data-ttu-id="0fa7e-571">Ponieważ wynik przekracza zakres długich liczb całkowitych <xref:System.OverflowException> jest zgłaszany i <xref:System.Numerics.BigInteger.Multiply%2A> wywoływana jest metoda obsługi mnożenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-571">Because the result exceeds the range of a long integer, an <xref:System.OverflowException> is thrown, and the <xref:System.Numerics.BigInteger.Multiply%2A> method is called to handle the multiplication.</span></span> <span data-ttu-id="0fa7e-572">Należy pamiętać, że C# wymaga użycia albo `checked` — słowo kluczowe (jak w poniższym przykładzie) lub `/checked+` opcję kompilatora, aby upewnić się na przepełnienie liczbowe jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-572">Note that C# requires that you use either the `checked` keyword (as in this example) or the `/checked+` compiler option to make sure an exception is thrown on a numeric overflow.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-573">Wartość do wskazania ujemnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-573">The value to negate.</span></span></param>
        <summary><span data-ttu-id="0fa7e-574">Negacja określonej <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-574">Negates a specified <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-575">Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-575">The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-576">Negacja uzyskuje odwrotność dodatku dla danej liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-576">Negation obtains the additive inverse of a number.</span></span> <span data-ttu-id="0fa7e-577">Odwrotność dodatku liczby jest liczba, która tworzy wartość zero, gdy jest ona dodawana do liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-577">The additive inverse of a number is a number that produces a value of zero when it is added to the original number.</span></span>  
  
 <span data-ttu-id="0fa7e-578"><xref:System.Numerics.BigInteger.Negate%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-578">The <xref:System.Numerics.BigInteger.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="0fa7e-579">Jego zachowanie jest identyczne negacji przy użyciu Jednoargumentowy operator negacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-579">Its behavior is identical to negation using the unary negation operator.</span></span> <span data-ttu-id="0fa7e-580">Ponadto <xref:System.Numerics.BigInteger.Negate%2A> metoda jest przydatna zastępuje operator negacji podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-580">In addition, the <xref:System.Numerics.BigInteger.Negate%2A> method is a useful substitute for the negation operator when instantiating a <xref:System.Numerics.BigInteger> variable, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-581">Poniższy przykład przedstawia trzy sposoby negate — wartość <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-581">The following example illustrates three ways to negate the value of a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-582">Pobiera wartość, która reprezentuje liczby jeden (1).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-582">Gets a value that represents the number one (1).</span></span></summary>
        <value><span data-ttu-id="0fa7e-583">Obiekt, którego wartość jest jeden (1).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-583">An object whose value is one (1).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-584"><xref:System.Numerics.BigInteger.One%2A> Jest zwykle używana do porównania <xref:System.Numerics.BigInteger> wartość 1 lub 1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-584">The <xref:System.Numerics.BigInteger.One%2A> property is usually used to compare a <xref:System.Numerics.BigInteger> value to 1 or to assign 1 to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-585">Pierwsza wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-585">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-586">Druga wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-586">The second value to add.</span></span></param>
        <summary><span data-ttu-id="0fa7e-587">Dodaje dwa określone wartości <see cref="T:System.Numerics.BigInteger" /> obiektów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-587">Adds the values of two specified <see cref="T:System.Numerics.BigInteger" /> objects.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-588">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-588">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-589"><xref:System.Numerics.BigInteger.op_Addition%2A> Metoda definiuje operacji dodawania dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-589">The <xref:System.Numerics.BigInteger.op_Addition%2A> method defines the addition operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-590">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-590">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 <span data-ttu-id="0fa7e-591">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Add%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-591">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Add%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-592">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-592">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-593">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-593">The second value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-594">Wykonuje bitowej <see langword="And" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-594">Performs a bitwise <see langword="And" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-595">Wynik operatora testu koniunkcji <see langword="And" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-595">The result of the bitwise <see langword="And" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-596"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda definiuje operatora testu koniunkcji `And` operacji <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-596">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method defines the bitwise `And` operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-597">Bitowe `And` operacji Ustawia wynik bit tylko wtedy, gdy odpowiednich bitów w `left` i `right` również są ustawione, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-597">The bitwise `And` operation sets a result bit only if the corresponding bits in `left` and `right` are also set, as shown in the following table.</span></span>  
  
|<span data-ttu-id="0fa7e-598">Bit w `left`</span><span class="sxs-lookup"><span data-stu-id="0fa7e-598">Bit in `left`</span></span>|<span data-ttu-id="0fa7e-599">Bit w `right`</span><span class="sxs-lookup"><span data-stu-id="0fa7e-599">Bit in `right`</span></span>|<span data-ttu-id="0fa7e-600">Bit w wyniku</span><span class="sxs-lookup"><span data-stu-id="0fa7e-600">Bit in result</span></span>|  
|-------------------|--------------------|-------------------|  
|<span data-ttu-id="0fa7e-601">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-601">0</span></span>|<span data-ttu-id="0fa7e-602">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-602">0</span></span>|<span data-ttu-id="0fa7e-603">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-603">0</span></span>|  
|<span data-ttu-id="0fa7e-604">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-604">1</span></span>|<span data-ttu-id="0fa7e-605">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-605">0</span></span>|<span data-ttu-id="0fa7e-606">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-606">0</span></span>|  
|<span data-ttu-id="0fa7e-607">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-607">1</span></span>|<span data-ttu-id="0fa7e-608">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-608">1</span></span>|<span data-ttu-id="0fa7e-609">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-609">1</span></span>|  
|<span data-ttu-id="0fa7e-610">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-610">0</span></span>|<span data-ttu-id="0fa7e-611">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-611">1</span></span>|<span data-ttu-id="0fa7e-612">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-612">0</span></span>|  
  
 <span data-ttu-id="0fa7e-613"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-613">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <span data-ttu-id="0fa7e-614"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda wykonuje logiczną `And` operacji na dwóch <xref:System.Numerics.BigInteger> wartości, tak jakby były to zarówno w dwóch jego dopełnienia reprezentacji z rozszerzeniem wirtualnego logowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-614">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method performs the bitwise `And` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-615">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-615">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-616">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-616">The second value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-617">Wykonuje bitowej <see langword="Or" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-617">Performs a bitwise <see langword="Or" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-618">Wynik operatora testu koniunkcji <see langword="Or" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-618">The result of the bitwise <see langword="Or" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-619"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda definiuje operatora testu koniunkcji `Or` operacji <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-619">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method defines the bitwise `Or` operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-620">Bitowe `Or` operacji Ustawia wynik bit tylko wtedy, gdy jednego lub obu odpowiednich bitów w `left` i `right` są ustawione, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-620">The bitwise `Or` operation sets a result bit only if either or both of the corresponding bits in `left` and `right` are set, as shown in the following table.</span></span>  
  
|<span data-ttu-id="0fa7e-621">Bit w `left`</span><span class="sxs-lookup"><span data-stu-id="0fa7e-621">Bit in `left`</span></span>|<span data-ttu-id="0fa7e-622">Bit w `right`</span><span class="sxs-lookup"><span data-stu-id="0fa7e-622">Bit in `right`</span></span>|<span data-ttu-id="0fa7e-623">Bit w wyniku</span><span class="sxs-lookup"><span data-stu-id="0fa7e-623">Bit in result</span></span>|  
|-------------------|--------------------|-------------------|  
|<span data-ttu-id="0fa7e-624">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-624">0</span></span>|<span data-ttu-id="0fa7e-625">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-625">0</span></span>|<span data-ttu-id="0fa7e-626">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-626">0</span></span>|  
|<span data-ttu-id="0fa7e-627">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-627">1</span></span>|<span data-ttu-id="0fa7e-628">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-628">0</span></span>|<span data-ttu-id="0fa7e-629">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-629">1</span></span>|  
|<span data-ttu-id="0fa7e-630">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-630">1</span></span>|<span data-ttu-id="0fa7e-631">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-631">1</span></span>|<span data-ttu-id="0fa7e-632">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-632">1</span></span>|  
|<span data-ttu-id="0fa7e-633">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-633">0</span></span>|<span data-ttu-id="0fa7e-634">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-634">1</span></span>|<span data-ttu-id="0fa7e-635">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-635">1</span></span>|  
  
 <span data-ttu-id="0fa7e-636"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-636">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <span data-ttu-id="0fa7e-637"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda wykonuje logiczną `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości, tak jakby były to zarówno w dwóch jego dopełnienia reprezentacji z rozszerzeniem wirtualnego logowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-637">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method performs the bitwise `Or` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-638">Wartość, aby zmniejszyć.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-638">The value to decrement.</span></span></param>
        <summary><span data-ttu-id="0fa7e-639">Zmniejsza <see cref="T:System.Numerics.BigInteger" /> wartość 1.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-639">Decrements a <see cref="T:System.Numerics.BigInteger" /> value by 1.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-640">Wartość <paramref name="value" /> parametru zmniejszana o 1.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-640">The value of the <paramref name="value" /> parameter decremented by 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-641"><xref:System.Numerics.BigInteger.op_Decrement%2A> Metoda definiuje operacji dekrementacji dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-641">The <xref:System.Numerics.BigInteger.op_Decrement%2A> method defines the decrement operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-642">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-642">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 <span data-ttu-id="0fa7e-643">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Subtract%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-643">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Subtract%2A> method instead.</span></span> <span data-ttu-id="0fa7e-644">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-644">For example:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 <span data-ttu-id="0fa7e-645">Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Decrement%2A> tworzy nowy operator <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden mniejszej niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-645">Because <xref:System.Numerics.BigInteger> objects are immutable, the <xref:System.Numerics.BigInteger.op_Decrement%2A> operator creates a new <xref:System.Numerics.BigInteger> object whose value is one less than the <xref:System.Numerics.BigInteger> object represented by `value`.</span></span> <span data-ttu-id="0fa7e-646">Oznacza to, że powtarzane wywołania <xref:System.Numerics.BigInteger.op_Decrement%2A> może być kosztowne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-646">This means that repeated calls to <xref:System.Numerics.BigInteger.op_Decrement%2A> may be expensive.</span></span>  
  
 <span data-ttu-id="0fa7e-647">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-647">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="0fa7e-648">Wartość podział.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-648">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="0fa7e-649">Wartość do dzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-649">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="0fa7e-650">Dzieli określonej <see cref="T:System.Numerics.BigInteger" /> wartości przez inny określony <see cref="T:System.Numerics.BigInteger" /> wartość przy użyciu dzielenie liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-650">Divides a specified <see cref="T:System.Numerics.BigInteger" /> value by another specified <see cref="T:System.Numerics.BigInteger" /> value by using integer division.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-651">Całkowite wyniku podziału.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-651">The integral result of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-652"><xref:System.Numerics.BigInteger.op_Division%2A> Metoda definiuje operacji dzielenia dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-652">The <xref:System.Numerics.BigInteger.op_Division%2A> method defines the division operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-653">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-653">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 <span data-ttu-id="0fa7e-654">Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.Numerics.BigInteger.Divide%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-654">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.BigInteger.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-655">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0fa7e-655">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="0fa7e-656">Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-656">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-657">Następnie używa każdy element jako iloraz w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> — metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-657">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="0fa7e-658"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-658"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-659">Zwraca wartość wskazującą, czy dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-659">Returns a value that indicates whether two values are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-660">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-660">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-661">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-661">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-662">Zwraca wartość wskazującą, czy wartość całkowita długie i a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-662">Returns a value that indicates whether a signed long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-663"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-663"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-664"><xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-664">The <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-665">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-665">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 <span data-ttu-id="0fa7e-666">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-666">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-667">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-667">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-668">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-668">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-669">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-669">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-670">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-670">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-671">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i podpisem długich liczb całkowitych są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-671">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a signed long integer value are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-672"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-672"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-673"><xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-673">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-674">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-674">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 <span data-ttu-id="0fa7e-675">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-675">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-676">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-676">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-677">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-677">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-678">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-678">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-679">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-679">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-680">Zwraca wartość wskazującą, czy wartości dwu <see cref="T:System.Numerics.BigInteger" /> obiekty są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-680">Returns a value that indicates whether the values of two <see cref="T:System.Numerics.BigInteger" /> objects are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-681"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-681"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-682"><xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-682">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method defines the operation of the equality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-683">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-683">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 <span data-ttu-id="0fa7e-684">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-684">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-685">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-685">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-686">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-686">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-687">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-687">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-688">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i wartości bez znaku długich liczb całkowitych są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-688">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and an unsigned long integer value are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-689"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-689"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-690"><xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-690">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-691">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-691">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 <span data-ttu-id="0fa7e-692">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-692">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-693">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-693">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-694">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-694">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-695">Zwraca wartość wskazującą, czy wartość bez znaku długich liczb całkowitych i a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-695">Returns a value that indicates whether an unsigned long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-696"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-696"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-697"><xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-697">The <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-698">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-698">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 <span data-ttu-id="0fa7e-699">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-699">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-700">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-700">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-701">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-701">The second value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-702">Operator wyłączny wykonuje <see langword="Or" /> (<see langword="XOr" />) operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-702">Performs a bitwise exclusive <see langword="Or" /> (<see langword="XOr" />) operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-703">Wynik operatora testu koniunkcji <see langword="Or" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-703">The result of the bitwise <see langword="Or" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-704">Wynik operator wyłączny `Or` operacji `true` w przypadku różnych; w przeciwnym razie wartości dwa bity jest `false`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-704">The result of a bitwise exclusive `Or` operation is `true` if the values of the two bits are different; otherwise, it is `false`.</span></span> <span data-ttu-id="0fa7e-705">W poniższej tabeli przedstawiono wyłączne `Or` operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-705">The following table illustrates the exclusive `Or` operation.</span></span>  
  
|<span data-ttu-id="0fa7e-706">Bit x `left`</span><span class="sxs-lookup"><span data-stu-id="0fa7e-706">Bit x in `left`</span></span>|<span data-ttu-id="0fa7e-707">Bit x `right`</span><span class="sxs-lookup"><span data-stu-id="0fa7e-707">Bit x in `right`</span></span>|<span data-ttu-id="0fa7e-708">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0fa7e-708">Return value</span></span>|  
|---------------------|----------------------|------------------|  
|<span data-ttu-id="0fa7e-709">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-709">0</span></span>|<span data-ttu-id="0fa7e-710">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-710">0</span></span>|<span data-ttu-id="0fa7e-711">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-711">0</span></span>|  
|<span data-ttu-id="0fa7e-712">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-712">0</span></span>|<span data-ttu-id="0fa7e-713">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-713">1</span></span>|<span data-ttu-id="0fa7e-714">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-714">1</span></span>|  
|<span data-ttu-id="0fa7e-715">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-715">1</span></span>|<span data-ttu-id="0fa7e-716">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-716">0</span></span>|<span data-ttu-id="0fa7e-717">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-717">1</span></span>|  
|<span data-ttu-id="0fa7e-718">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-718">1</span></span>|<span data-ttu-id="0fa7e-719">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-719">1</span></span>|<span data-ttu-id="0fa7e-720">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-720">0</span></span>|  
  
 <span data-ttu-id="0fa7e-721"><xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-721">The <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <span data-ttu-id="0fa7e-722"><xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda przeprowadza operator wyłączny `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości, tak jakby były to zarówno w dwóch jego dopełnienia reprezentacji z rozszerzeniem wirtualnego logowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-722">The <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> method performs the bitwise exclusive `Or` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-723">Definiuje jawnej konwersji między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-723">Defines an explicit conversion between a <see cref="T:System.Numerics.BigInteger" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-724">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-724">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-725">Definiuje jawna konwersja <see cref="T:System.Decimal" /> do obiektu <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-725">Defines an explicit conversion of a <see cref="T:System.Decimal" /> object to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-726">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-726">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-727">Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-727">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="0fa7e-728">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-728">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-729">Ponieważ konwersja z <xref:System.Decimal> do <xref:System.Numerics.BigInteger> może pociągać za sobą żadnych części ułamkowej obcinanie `value`, Kompilatory języka nie wykonaj tę konwersję automatycznie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-729">Because the conversion from <xref:System.Decimal> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="0fa7e-730">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-730">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-731">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-731">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="0fa7e-732">Dla języków, które nie obsługują niestandardowych operatory alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-732">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="0fa7e-733">Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Decimal> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-733">The following example converts the individual elements in an array of <xref:System.Decimal> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="0fa7e-734">Należy pamiętać, że jakaś ułamkową część <xref:System.Decimal> wartość zostanie obcięta podczas konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-734">Note that any fractional part of a <xref:System.Decimal> value is truncated during the conversion.</span></span>   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-735">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-735">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-736">Definiuje jawna konwersja <see cref="T:System.Double" /> do wartości <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-736">Defines an explicit conversion of a <see cref="T:System.Double" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-737">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-737">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-738">Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-738">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="0fa7e-739">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-739">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-740">Ponieważ konwersja z <xref:System.Double> do <xref:System.Numerics.BigInteger> może pociągać za sobą żadnych części ułamkowej obcinanie `value`, Kompilatory języka nie wykonaj tę konwersję automatycznie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-740">Because the conversion from <xref:System.Double> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="0fa7e-741">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-741">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-742">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-742">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="0fa7e-743">Dla języków, które nie obsługują niestandardowych operatory alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-743">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="0fa7e-744">Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Double> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-744">The following example converts the individual elements in an array of <xref:System.Double> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="0fa7e-745">Należy pamiętać, że jakaś ułamkową część <xref:System.Double> wartość zostanie obcięta podczas konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-745">Note that any fractional part of a <xref:System.Double> value is truncated during the conversion.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-746">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-746">The value of <paramref name="value" /> is <see cref="F:System.Double.NaN" />.</span></span>  
  
 <span data-ttu-id="0fa7e-747">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-747">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-748">Wartość <paramref name="value" /> jest <see cref="F:System.Double.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-748">The value of <paramref name="value" /> is <see cref="F:System.Double.PositiveInfinity" />.</span></span>
  
 <span data-ttu-id="0fa7e-749">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-749">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-750">Wartość <paramref name="value" /> jest <see cref="F:System.Double.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-750">The value of <paramref name="value" /> is <see cref="F:System.Double.NegativeInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-751">Wartość do przekonwertowania na <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-751">The value to convert to a <see cref="T:System.Byte" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-752">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości bajtu bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-752">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned byte value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-753">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-753">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-754">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-754">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-755">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-755">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-756">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CByte` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-756">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CByte` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-757">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-757">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="0fa7e-758">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-758">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Byte> data type.</span></span> <span data-ttu-id="0fa7e-759">Nie są tracone dokładności powstałe w ten sposób <xref:System.Byte> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-759">There is no loss of precision in the resulting <xref:System.Byte> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-760">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Byte> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-760">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Byte> values.</span></span> <span data-ttu-id="0fa7e-761">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-761">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Byte> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-762">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Byte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-762">The value of <paramref name="value" /> is less than <see cref="F:System.Byte.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-763">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-763">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-764">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Byte.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-764">The value of <paramref name="value" /> is greater than <see cref="F:System.Byte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-765">Wartość do przekonwertowania na <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-765">The value to convert to a <see cref="T:System.Decimal" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-766">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> do obiektu <see cref="T:System.Decimal" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-766">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Decimal" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-767">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-767">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-768">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-768">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-769">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-769">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-770">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDec` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-770">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CDec` in Visual Basic) is used.</span></span>   

 <span data-ttu-id="0fa7e-771">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-771">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Decimal> data type.</span></span> 

## Examples
 <span data-ttu-id="0fa7e-772">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Decimal> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-772">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Decimal> values.</span></span> <span data-ttu-id="0fa7e-773">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-773">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Decimal> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-774">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Decimal.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-774">The value of <paramref name="value" /> is less than <see cref="F:System.Decimal.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-775">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-775">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-776">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Decimal.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-776">The value of <paramref name="value" /> is greater than <see cref="F:System.Decimal.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-777">Wartość do przekonwertowania na <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-777">The value to convert to a <see cref="T:System.Double" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-778">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> do obiektu <see cref="T:System.Double" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-778">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Double" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-779">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-779">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-780">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-780">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-781">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-781">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-782">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDbl` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-782">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CDbl` in Visual Basic) is used.</span></span>   

 <span data-ttu-id="0fa7e-783">Ponieważ <xref:System.Numerics.BigInteger> możliwe wartości spoza zakresu <xref:System.Double> typ danych, ta operacja jest konwersji zawężającej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-783">Because the <xref:System.Numerics.BigInteger> value can be outside the range of the <xref:System.Double> data type, this operation is a narrowing conversion.</span></span> <span data-ttu-id="0fa7e-784">Jeśli konwersja zakończy się niepowodzeniem, nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-784">If the conversion is unsuccessful, it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-785">Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Double.MinValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Double> wartość jest <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-785">Instead, if the <xref:System.Numerics.BigInteger> value is less than <xref:System.Double.MinValue?displayProperty=nameWithType>, the resulting <xref:System.Double> value is <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-786">Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Double> wartość jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-786">If the <xref:System.Numerics.BigInteger> value is greater than <xref:System.Double.MaxValue?displayProperty=nameWithType>, the resulting <xref:System.Double> value is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>
 
 <span data-ttu-id="0fa7e-787">Konwersja typu <xref:System.Numerics.BigInteger> do <xref:System.Double> może pociągać za sobą zmniejszenie precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-787">The conversion of a <xref:System.Numerics.BigInteger> to a <xref:System.Double> may involve a loss of precision.</span></span> <span data-ttu-id="0fa7e-788">W niektórych przypadkach utratę dokładności może spowodować powodzenie operacji rzutowania lub konwersji nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-788">In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Double> data type.</span></span> <span data-ttu-id="0fa7e-789">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-789">The following example provides an illustration.</span></span> <span data-ttu-id="0fa7e-790">Przypisuje wartość maksymalna <xref:System.Double> do dwóch <xref:System.Numerics.BigInteger> zmiennych, co zwiększa <xref:System.Numerics.BigInteger> zmiennej 9.999e291, a testy dwie zmienne pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-790">It assigns the maximum value of a <xref:System.Double> to two <xref:System.Numerics.BigInteger> variables, increments one <xref:System.Numerics.BigInteger> variable by 9.999e291, and tests the two variables for equality.</span></span> <span data-ttu-id="0fa7e-791">Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody pokazuje, czy są one nierówne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-791">As expected, the call to the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method shows that they are unequal.</span></span> <span data-ttu-id="0fa7e-792">Jednak konwersji większy <xref:System.Numerics.BigInteger> wartości z powrotem do <xref:System.Double> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-792">However, the conversion of the larger <xref:System.Numerics.BigInteger> value back to a <xref:System.Double> succeeds, although the <xref:System.Numerics.BigInteger> value now exceeds <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 <span data-ttu-id="0fa7e-793">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Double> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-793">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Double> values.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-794">Wartość do przekonwertowania na 16-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-794">The value to convert to a 16-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-795">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 16-bitową liczbę całkowitą ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-795">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 16-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-796">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-796">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-797">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-797">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-798">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-798">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-799">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CShort` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-799">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CShort` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-800">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-800">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="0fa7e-801">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-801">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int16> data type.</span></span> <span data-ttu-id="0fa7e-802">Nie są tracone dokładności powstałe w ten sposób <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-802">There is no loss of precision in the resulting <xref:System.Int16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-803">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int16> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-803">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int16> values.</span></span> <span data-ttu-id="0fa7e-804">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-804">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int16> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-805">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-805">The value of <paramref name="value" /> is less than <see cref="F:System.Int16.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-806">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-806">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-807">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int16.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-807">The value of <paramref name="value" /> is greater than <see cref="F:System.Int16.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-808">Wartość do przekonwertowania na 32-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-808">The value to convert to a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-809">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu wartości 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-809">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 32-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-810">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-810">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-811">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-811">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-812">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-812">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-813">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CInt` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-813">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CInt` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-814">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-814">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="0fa7e-815">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-815">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int32> data type.</span></span> <span data-ttu-id="0fa7e-816">Nie są tracone dokładności powstałe w ten sposób <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-816">There is no loss of precision in the resulting <xref:System.Int16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-817">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int32> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-817">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int32> values.</span></span> <span data-ttu-id="0fa7e-818">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-818">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int32> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-819">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int32.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-819">The value of <paramref name="value" /> is less than <see cref="F:System.Int32.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-820">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-820">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-821">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-821">The value of <paramref name="value" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-822">Wartość do przekonwertowania na 64-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-822">The value to convert to a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-823">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 64-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-823">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-824">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-824">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-825">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-825">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-826">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-826">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-827">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CLng` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-827">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CLng` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-828">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-828">Otherwise, they display a compiler error.</span></span>  

 <span data-ttu-id="0fa7e-829">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-829">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int64> data type.</span></span> 

## Examples
 <span data-ttu-id="0fa7e-830">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int64> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-830">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int64> values.</span></span> <span data-ttu-id="0fa7e-831">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-831">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int64> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-832">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.Int64.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-832">The value of <paramref name="value" /> is less than <see cref="F:System.Int64.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-833">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-833">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-834">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-834">The value of <paramref name="value" /> is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-835">Wartość do przekonwertowania na podpisem 8-bitową wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-835">The value to convert to a signed 8-bit value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-836">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu podpisem wartości 8-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-836">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a signed 8-bit value.</span></span>  
  
 <span data-ttu-id="0fa7e-837">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-837">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-838">Alternatywa zgodna ze standardem jest <see cref="T:System.Int16" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-838">The compliant alternative is <see cref="T:System.Int16" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-839">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-839">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-840">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-840">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-841">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-841">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-842">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSByte` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-842">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CSByte` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-843">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-843">Otherwise, they display a compiler error.</span></span>  

 <span data-ttu-id="0fa7e-844">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-844">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.SByte> data type.</span></span> <span data-ttu-id="0fa7e-845">Nie są tracone dokładności powstałe w ten sposób <xref:System.SByte> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-845">There is no loss of precision in the resulting <xref:System.SByte> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-846">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.SByte> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-846">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.SByte> values.</span></span> <span data-ttu-id="0fa7e-847">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-847">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.SByte> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-848">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.SByte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-848">The value of <paramref name="value" /> is less than <see cref="F:System.SByte.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-849">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-849">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-850">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.SByte.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-850">The value of <paramref name="value" /> is greater than <see cref="F:System.SByte.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-851">Wartość do przekonwertowania na wartość zmiennoprzecinkową o pojedynczej dokładności.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-851">The value to convert to a single-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-852">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości zmiennoprzecinkowych pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-852">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a single-precision floating-point value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-853">Obiekt zawierający najbliższego reprezentacja możliwe <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-853">An object that contains the closest possible representation of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-854">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-854">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-855">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować, utrata danych lub utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-855">Language compilers do not perform this conversion automatically because it can involve data loss or a loss of precision.</span></span> <span data-ttu-id="0fa7e-856">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSng` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-856">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CSng` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-857">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-857">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="0fa7e-858">Ponieważ <xref:System.Numerics.BigInteger> możliwe wartości spoza zakresu <xref:System.Single> typ danych, ta operacja jest konwersji zawężającej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-858">Because the <xref:System.Numerics.BigInteger> value can be outside the range of the <xref:System.Single> data type, this operation is a narrowing conversion.</span></span> <span data-ttu-id="0fa7e-859">Jeśli konwersja zakończy się niepowodzeniem, nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-859">If the conversion is unsuccessful, it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-860">Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Single.MinValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Single> wartość jest <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-860">Instead, if the <xref:System.Numerics.BigInteger> value is less than <xref:System.Single.MinValue?displayProperty=nameWithType>, the resulting <xref:System.Single> value is <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-861">Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType>, powstałe w ten sposób <xref:System.Single> wartość jest <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-861">If the <xref:System.Numerics.BigInteger> value is greater than <xref:System.Single.MaxValue?displayProperty=nameWithType>, the resulting <xref:System.Single> value is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="0fa7e-862">Konwersja typu <xref:System.Numerics.BigInteger> do <xref:System.Single> może pociągać za sobą zmniejszenie precyzji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-862">The conversion of a <xref:System.Numerics.BigInteger> to a <xref:System.Single> may involve a loss of precision.</span></span> <span data-ttu-id="0fa7e-863">W niektórych przypadkach utratę dokładności może spowodować powodzenie operacji rzutowania lub konwersji nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Single> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-863">In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Single> data type.</span></span> <span data-ttu-id="0fa7e-864">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-864">The following example provides an illustration.</span></span> <span data-ttu-id="0fa7e-865">Przypisuje wartość maksymalna <xref:System.Single> do dwóch <xref:System.Numerics.BigInteger> zmiennych, co zwiększa <xref:System.Numerics.BigInteger> zmiennej 9.999e291, a testy dwie zmienne pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-865">It assigns the maximum value of a <xref:System.Single> to two <xref:System.Numerics.BigInteger> variables, increments one <xref:System.Numerics.BigInteger> variable by 9.999e291, and tests the two variables for equality.</span></span> <span data-ttu-id="0fa7e-866">Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody pokazuje, czy są one nierówne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-866">As expected, the call to the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method shows that they are unequal.</span></span> <span data-ttu-id="0fa7e-867">Jednak konwersji większy <xref:System.Numerics.BigInteger> wartości z powrotem do <xref:System.Single> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Single.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-867">However, the conversion of the larger <xref:System.Numerics.BigInteger> value back to a <xref:System.Single> succeeds, although the <xref:System.Numerics.BigInteger> value now exceeds <xref:System.Single.MaxValue?displayProperty=nameWithType>.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 <span data-ttu-id="0fa7e-868">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.Single> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-868">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Single> values.</span></span>   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-869">Wartość do przekonwertowania na liczbę całkowitą bez znaku 16-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-869">The value to convert to an unsigned 16-bit integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-870">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu niepodpisane 16-bitową liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-870">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 16-bit integer value.</span></span>  
  
 <span data-ttu-id="0fa7e-871">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-871">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-872">Alternatywa zgodna ze standardem jest <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-872">The compliant alternative is <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-873">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-873">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-874">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-874">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-875">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-875">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-876">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUShort` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-876">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CUShort` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-877">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-877">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="0fa7e-878">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-878">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt16> data type.</span></span> <span data-ttu-id="0fa7e-879">Nie są tracone dokładności powstałe w ten sposób <xref:System.UInt16> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-879">There is no loss of precision in the resulting <xref:System.UInt16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-880">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt16> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-880">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt16> values.</span></span> <span data-ttu-id="0fa7e-881">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-881">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt16> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-882">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-882">The value of <paramref name="value" /> is less than <see cref="F:System.UInt16.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-883">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-883">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-884">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt16.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-884">The value of <paramref name="value" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-885">Wartość do przekonwertowania na liczbę całkowitą bez znaku 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-885">The value to convert to an unsigned 32-bit integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-886">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu wartości bez znaku 32-bitowej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-886">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 32-bit integer value.</span></span>  
  
 <span data-ttu-id="0fa7e-887">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-887">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-888">Alternatywa zgodna ze standardem jest <see cref="T:System.Int64" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-888">The compliant alternative is <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-889">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-889">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-890">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-890">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-891">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-891">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-892">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUInt` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-892">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CUInt` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-893">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-893">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="0fa7e-894">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-894">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt32> data type.</span></span> <span data-ttu-id="0fa7e-895">Nie są tracone dokładności powstałe w ten sposób <xref:System.UInt32> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-895">There is no loss of precision in the resulting <xref:System.UInt32> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-896">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt32> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-896">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt32> values.</span></span> <span data-ttu-id="0fa7e-897">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-897">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt32> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-898">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt32.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-898">The value of <paramref name="value" /> is less than <see cref="F:System.UInt32.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-899">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-899">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-900">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-900">The value of <paramref name="value" /> is greater than <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-901">Wartość do przekonwertowania na liczbę całkowitą bez znaku 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-901">The value to convert to an unsigned 64-bit integer.</span></span></param>
        <summary><span data-ttu-id="0fa7e-902">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość całkowitą 64-bitowych unsigned.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-902">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 64-bit integer value.</span></span>  
  
 <span data-ttu-id="0fa7e-903">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-903">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-904">Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-904">The compliant alternative is <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-905">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-905">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-906">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-906">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-907">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-907">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="0fa7e-908">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CULng` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-908">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CULng` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-909">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-909">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="0fa7e-910">Ponieważ ta operacja definiuje konwersji zawężającej, może zgłosić <xref:System.OverflowException> na czas wykonywania Jeśli <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-910">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt64> data type.</span></span> <span data-ttu-id="0fa7e-911">Nie są tracone dokładności powstałe w ten sposób <xref:System.UInt64> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-911">There is no loss of precision in the resulting <xref:System.UInt64> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="0fa7e-912">Poniższy przykład przedstawia konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt64> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-912">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt64> values.</span></span> <span data-ttu-id="0fa7e-913">Umożliwia on również obsługę <xref:System.OverflowException> który jest generowany, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> — typ danych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-913">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt64> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-914">Wartość <paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt64.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-914">The value of <paramref name="value" /> is less than <see cref="F:System.UInt64.MinValue" />.</span></span>  
  
 <span data-ttu-id="0fa7e-915">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-915">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-916">Wartość <paramref name="value" /> jest większa niż <see cref="F:System.UInt64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-916">The value of <paramref name="value" /> is greater than <see cref="F:System.UInt64.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-917">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-917">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-918">Definiuje jawna konwersja <see cref="T:System.Single" /> do wartości <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-918">Defines an explicit conversion of a <see cref="T:System.Single" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-919">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-919">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-920">Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-920">Any fractional part of the `value` parameter is truncated before conversion.</span></span>
 
 <span data-ttu-id="0fa7e-921">Przeciążeń <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego <xref:System.Numerics.BigInteger> można przekonwertować obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-921">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="0fa7e-922">Ponieważ konwersja z <xref:System.Single> do <xref:System.Numerics.BigInteger> może pociągać za sobą żadnych części ułamkowej obcinanie `value`, Kompilatory języka nie wykonaj tę konwersję automatycznie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-922">Because the conversion from <xref:System.Single> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="0fa7e-923">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-923">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="0fa7e-924">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-924">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="0fa7e-925">Dla języków, które nie obsługują niestandardowych operatory alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-925">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="0fa7e-926">Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Single> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-926">The following example converts the individual elements in an array of <xref:System.Single> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="0fa7e-927">Należy pamiętać, że jakaś ułamkową część <xref:System.Single> wartość zostanie obcięta podczas konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-927">Note that any fractional part of a <xref:System.Single> value is truncated during the conversion.</span></span>
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="0fa7e-928">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-928">The value of <paramref name="value" /> is <see cref="F:System.Single.NaN" />.</span></span>  
  
 <span data-ttu-id="0fa7e-929">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-929">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-930">Wartość <paramref name="value" /> jest <see cref="F:System.Single.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-930">The value of <paramref name="value" /> is <see cref="F:System.Single.PositiveInfinity" />.</span></span>
  
 <span data-ttu-id="0fa7e-931">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-931">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-932">Wartość <paramref name="value" /> jest <see cref="F:System.Single.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-932">The value of <paramref name="value" /> is <see cref="F:System.Single.NegativeInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-933">Zwraca wartość wskazującą, czy określona wartość jest większa niż innego określona wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-933">Returns a value that indicates whether a specified value is greater than another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-934">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-934">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-935">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-935">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-936">Zwraca wartość wskazującą, czy całkowita 64-bitowego jest większy niż <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-936">Returns a value that indicates whether a 64-bit signed integer is greater than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-937"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-937"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-938"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-938">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-939">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-939">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 <span data-ttu-id="0fa7e-940">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> zamiast tego wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-940">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span> <span data-ttu-id="0fa7e-941">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-941">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 <span data-ttu-id="0fa7e-942">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-942">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-943">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-943">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-944">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-944">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-945">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-945">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-946">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> jest większa niż wartość 64-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-946">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> is greater than a 64-bit signed integer value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-947"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-947"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-948"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-948">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-949">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-949">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 <span data-ttu-id="0fa7e-950">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-950">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-951">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-951">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 <span data-ttu-id="0fa7e-952">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-952">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-953">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-953">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-954">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-954">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-955">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-955">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-956">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż innego <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-956">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-957"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-957"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-958"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-958">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-959">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-959">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 <span data-ttu-id="0fa7e-960">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-960">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-961">Można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-961">They can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 <span data-ttu-id="0fa7e-962">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-962">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-963">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-963">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-964">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-964">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-965">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej liczby całkowitej bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-965">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-966"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-966"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-967"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-967">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-968">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-968">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 <span data-ttu-id="0fa7e-969">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-969">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-970">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-970">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-971">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-971">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-972">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-972">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-973">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej liczby całkowitej bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-973">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-974"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-974"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-975"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-975">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-976">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-976">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 <span data-ttu-id="0fa7e-977">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-977">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-978">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-978">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-979">Zwraca wartość wskazującą, czy określona wartość jest większa niż lub równe innego określona wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-979">Returns a value that indicates whether a specified value is greater than or equal to another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-980">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-980">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-981">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-981">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-982">Zwraca wartość wskazującą, czy 64-bitowych całkowita jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-982">Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-983"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-983"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-984"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-984">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-985">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-985">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 <span data-ttu-id="0fa7e-986">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-986">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-987">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-987">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 <span data-ttu-id="0fa7e-988">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-988">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-989">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-989">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-990">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-990">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-991">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-991">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-992">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa wartości 64-bitowej podpisanej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-992">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit signed integer value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-993"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-993"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-994"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-994">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-995">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-995">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 <span data-ttu-id="0fa7e-996">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-996">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-997">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-997">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 <span data-ttu-id="0fa7e-998">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-998">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-999">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-999">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1000">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1000">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1001">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1001">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1002">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równa innej <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1002">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1003"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1003"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1004"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1004">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1005">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1005">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 <span data-ttu-id="0fa7e-1006">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1006">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1007">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1007">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 <span data-ttu-id="0fa7e-1008">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1008">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1009">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1009">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1010">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1010">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1011">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa wartości 64-bitowej liczby całkowitej bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1011">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit unsigned integer value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1012"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1012"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1013"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1013">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1014">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1014">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 <span data-ttu-id="0fa7e-1015">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1015">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1016">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1016">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 <span data-ttu-id="0fa7e-1017">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1017">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1018">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1018">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1019">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1019">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1020">Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1020">Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1021"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1021"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1022"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1022">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1023">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1023">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 <span data-ttu-id="0fa7e-1024">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1024">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1025">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1025">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 <span data-ttu-id="0fa7e-1026">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1026">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1027">Definiuje niejawna konwersja między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1027">Defines an implicit conversion between a <see cref="T:System.Numerics.BigInteger" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1028">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1028">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1029">Definiuje niejawnej konwersji wartości bajtu bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1029">Defines an implicit conversion of an unsigned byte to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1030">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1030">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1031">Wszystkie części ułamkowej `value` parametr został obcięty przed konwersją.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1031">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="0fa7e-1032">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1032">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="0fa7e-1033">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1033">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1034">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1034">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1035">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Byte> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1035">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1036">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1036">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1037">Definiuje niejawnej konwersji wartości 16-bitową liczbę całkowitą ze znakiem do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1037">Defines an implicit conversion of a signed 16-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1038">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1038">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1039">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1039">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="0fa7e-1040">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1040">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1041">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1041">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1042">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Int16> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1042">This overload lets the compiler handle conversions from a <xref:System.Int16> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1043">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1043">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1044">Definiuje niejawna konwersja całkowita 32-bitowa do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1044">Defines an implicit conversion of a signed 32-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1045">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1045">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1046">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1046">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="0fa7e-1047">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1047">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1048">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1048">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1049">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Int32> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1049">This overload lets the compiler handle conversions from a <xref:System.Int32> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1050">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1050">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1051">Definiuje niejawna konwersja całkowita 64-bitowa do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1051">Defines an implicit conversion of a signed 64-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1052">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1052">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1053">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1053">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.</span></span>   
 
 <span data-ttu-id="0fa7e-1054">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1054">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1055">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1055">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1056">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Int64> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1056">This overload lets the compiler handle conversions from a <xref:System.Int64> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1057">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1057">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1058">Definiuje niejawnej konwersji wartości 8-bitową liczbę całkowitą ze znakiem do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1058">Defines an implicit conversion of an 8-bit signed integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1059">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1059">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-1060">Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1060">The compliant alternative is <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1061">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1061">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1062">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1062">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="0fa7e-1063">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1063">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1064">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1064">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1065">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.SByte> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1065">This overload lets the compiler handle conversions from a <xref:System.SByte> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1066">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1066">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1067">Definiuje niejawnej konwersji wartości 16-bitową liczbę całkowitą bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1067">Defines an implicit conversion of a 16-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1068">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1068">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-1069">Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1069">The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1070">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1070">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1071">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1071">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="0fa7e-1072">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1072">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1073">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1073">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1074">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.UInt16> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1074">This overload lets the compiler handle conversions from a <xref:System.UInt16> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1075">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1075">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1076">Definiuje niejawna konwersja z 32-bitowa liczba całkowita bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1076">Defines an implicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1077">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1077">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-1078">Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1078">The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1079">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1079">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1080">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1080">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="0fa7e-1081">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1081">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1082">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1082">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1083">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.UInt32> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1083">This overload lets the compiler handle conversions from a <xref:System.UInt32> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1084">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1084">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1085">Definiuje niejawna konwersja 64-bitową nieznakowaną liczbą całkowitą do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1085">Defines an implicit conversion of a 64-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1086">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1086">This API is not CLS-compliant.</span></span> <span data-ttu-id="0fa7e-1087">Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1087">The compliant alternative is <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1088">Obiekt zawierający wartości <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1088">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1089">W przypadku języków, które nie obsługują operatory niejawnej alternatywną metodą jest <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1089">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="0fa7e-1090">Przeciążeń <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody Definiowanie typów, do którego lub z którego kompilatora może automatycznie przekonwertować <xref:System.Numerics.BigInteger> wartość bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1090">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="0fa7e-1091">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1091">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="0fa7e-1092">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.UInt64> do wartości <xref:System.Numerics.BigInteger> wartość, jak przedstawiono w następującym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1092">This overload lets the compiler handle conversions from a <xref:System.UInt64> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1093">Wartość do zwiększenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1093">The value to increment.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1094">Zwiększa <see cref="T:System.Numerics.BigInteger" /> wartość 1.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1094">Increments a <see cref="T:System.Numerics.BigInteger" /> value by 1.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1095">Wartość <paramref name="value" /> parametru zwiększana o 1.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1095">The value of the <paramref name="value" /> parameter incremented by 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1096"><xref:System.Numerics.BigInteger.op_Increment%2A> Metoda definiuje operacji przyrostu <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1096">The <xref:System.Numerics.BigInteger.op_Increment%2A> method defines the increment operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1097">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1097">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 <span data-ttu-id="0fa7e-1098">Niektóre języki (na przykład w języku Visual Basic), które mają operatora inkrementacji lub nie obsługują przeładowanie operatora można wywołać <xref:System.Numerics.BigInteger.op_Increment%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1098">Some languages (such as Visual Basic) that lack an increment operator or do not support operator overloading can call the <xref:System.Numerics.BigInteger.op_Increment%2A> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 <span data-ttu-id="0fa7e-1099">Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Increment%2A> tworzy nowy operator <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden więcej niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1099">Because <xref:System.Numerics.BigInteger> objects are immutable, the <xref:System.Numerics.BigInteger.op_Increment%2A> operator creates a new <xref:System.Numerics.BigInteger> object whose value is one more than the <xref:System.Numerics.BigInteger> object represented by `value`.</span></span> <span data-ttu-id="0fa7e-1100">W związku z tym powtarzane wywołania <xref:System.Numerics.BigInteger.op_Increment%2A> może być kosztowne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1100">Therefore, repeated calls to <xref:System.Numerics.BigInteger.op_Increment%2A> may be expensive.</span></span>  
  
 <span data-ttu-id="0fa7e-1101">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1101">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1102">Zwraca wartość wskazującą, czy dwie wartości liczbowe nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1102">Returns a value that indicates whether two numeric values are not equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1103">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1103">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1104">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1104">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1105">Zwraca wartość wskazującą, czy 64-bitowej podpisanej liczby całkowitej i a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1105">Returns a value that indicates whether a 64-bit signed integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1106"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1106"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1107"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1107">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1108">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1108">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 <span data-ttu-id="0fa7e-1109">Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1109">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="0fa7e-1110">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartość podpisem długich liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1110">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instance method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and a signed long integer value.</span></span>  
  
-   <span data-ttu-id="0fa7e-1111">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody i cofania jej wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1111">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method and reversing its value.</span></span>  
  
 <span data-ttu-id="0fa7e-1112">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1112">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1113">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1113">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1114">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1114">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1115">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i całkowita 64-bitowe nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1115">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit signed integer are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1116"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1116"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1117"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1117">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1118">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1118">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 <span data-ttu-id="0fa7e-1119">Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1119">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="0fa7e-1120">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartość podpisem długich liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1120">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and a signed long integer value.</span></span>  
  
-   <span data-ttu-id="0fa7e-1121">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> — metoda i jego wartość cofania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1121">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 <span data-ttu-id="0fa7e-1122">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1122">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-1123">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1123">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1124">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1124">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1125">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1125">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1126">Zwraca wartość wskazującą, czy dwa <see cref="T:System.Numerics.BigInteger" /> obiekty mają różne wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1126">Returns a value that indicates whether two <see cref="T:System.Numerics.BigInteger" /> objects have different values.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1127"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1127"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1128"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1128">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1129">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1129">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 <span data-ttu-id="0fa7e-1130">Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1130">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="0fa7e-1131">Wywoływanie <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodę, która wskazuje relację między dwiema <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1131">Calling the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method, which indicates the relationship between two <xref:System.Numerics.BigInteger> objects.</span></span>  
  
-   <span data-ttu-id="0fa7e-1132">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> — metoda i jego wartość cofania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1132">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 <span data-ttu-id="0fa7e-1133">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1133">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1134">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1134">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1135">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1135">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1136">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> nie są takie same wartości i 64-bitowej liczby całkowitej bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1136">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit unsigned integer are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1137"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1137"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1138"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1138">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1139">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1139">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 <span data-ttu-id="0fa7e-1140">Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1140">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="0fa7e-1141">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartości bez znaku długich liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1141">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and an unsigned long integer value.</span></span>  
  
-   <span data-ttu-id="0fa7e-1142">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> — metoda i jego wartość cofania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1142">Calling the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1143">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1143">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1144">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1144">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1145">Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku i a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1145">Returns a value that indicates whether a 64-bit unsigned integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1146"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1146"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1147"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1147">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1148">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1148">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 <span data-ttu-id="0fa7e-1149">Języki, które nie obsługują niestandardowych operatory można sprawdzić pod kątem nierówności przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1149">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="0fa7e-1150">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę, która wskazuje relację między <xref:System.Numerics.BigInteger> i wartości bez znaku długich liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1150">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and an unsigned long integer value.</span></span>  
  
-   <span data-ttu-id="0fa7e-1151">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> — metoda i jego wartość cofania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1151">Calling the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1152">Wartość, której bity są lekkie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1152">The value whose bits are to be shifted.</span></span></param>
        <param name="shift"><span data-ttu-id="0fa7e-1153">Liczba bitów, które mają zostać przesunięte <c>wartość</c> po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1153">The number of bits to shift <c>value</c> to the left.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1154">Zmiany <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w lewo.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1154">Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the left.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1155">Wartość, która ma zostać przesunięty w lewo przez określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1155">A value that has been shifted to the left by the specified number of bits.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1156"><xref:System.Numerics.BigInteger.op_LeftShift%2A> Metoda definiuje operację z bitowego operator przesunięcia w lewo <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1156">The <xref:System.Numerics.BigInteger.op_LeftShift%2A> method defines the operation of the bitwise left-shift operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1157">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1157">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1158">W przeciwieństwie do operacji przesunięcia w lewo z podstawowych całkowitą <xref:System.Numerics.BigInteger.op_LeftShift%2A> metody zachowuje znak oryginalnej <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1158">Unlike the bitwise left-shift operation with integer primitives, the <xref:System.Numerics.BigInteger.op_LeftShift%2A> method preserves the sign of the original <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1159">Języki, które nie obsługują niestandardowych operatory można wykonać operacji przesunięcia w lewo przez pomnożenie `value` przez `BigInteger.Pow(2, shift)`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1159">Languages that do not support custom operators can perform a bitwise left-shift operation by multiplying `value` by `BigInteger.Pow(2, shift)`.</span></span> <span data-ttu-id="0fa7e-1160">W poniższym przykładzie pokazano, że wyniki są takie same jak wyniki za pomocą tego operatora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1160">The following example shows that the results are identical to the results of using this operator.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1161">Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż drugi określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1161">Returns a value that indicates whether a specified value is less than a second specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1162">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1162">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1163">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1163">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1164">Zwraca wartość wskazującą, czy 64-bitowych całkowita jest mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1164">Returns a value that indicates whether a 64-bit signed integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1165"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1165"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1166"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1166">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1167">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1167">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 <span data-ttu-id="0fa7e-1168">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1168">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1169">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1169">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 <span data-ttu-id="0fa7e-1170">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1170">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-1171">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1171">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1172">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1172">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1173">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1173">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1174">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1174">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit signed integer.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1175"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1175"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1176"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1176">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1177">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1177">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 <span data-ttu-id="0fa7e-1178">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1178">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1179">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1179">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 <span data-ttu-id="0fa7e-1180">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1180">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-1181">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1181">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1182">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1182">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1183">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1183">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1184">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż innego <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1184">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1185"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1185"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1186"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1186">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1187">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1187">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 <span data-ttu-id="0fa7e-1188">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1188">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1189">W przypadku niektórych języków może także wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1189">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 <span data-ttu-id="0fa7e-1190">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1190">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1191">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1191">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1192">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1192">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1193">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowej liczby całkowitej bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1193">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit unsigned integer.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1194"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1194"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1195"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1195">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1196">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1196">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 <span data-ttu-id="0fa7e-1197">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1197">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1198">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1198">They can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 <span data-ttu-id="0fa7e-1199">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1199">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1200">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1200">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1201">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1201">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1202">Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku jest mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1202">Returns a value that indicates whether a 64-bit unsigned integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1203"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1203"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1204"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1204">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1205">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1205">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 <span data-ttu-id="0fa7e-1206">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1206">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1207">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1207">They can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 <span data-ttu-id="0fa7e-1208">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1208">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1209">Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż lub równe inną określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1209">Returns a value that indicates whether a specified value is less than or equal to another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1210">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1210">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1211">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1211">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1212">Zwraca wartość wskazującą, czy całkowita 64-bitowych jest mniejsza niż lub równe <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1212">Returns a value that indicates whether a 64-bit signed integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1213"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1213"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1214"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1214">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1215">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1215">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 <span data-ttu-id="0fa7e-1216">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1216">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1217">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1217">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 <span data-ttu-id="0fa7e-1218">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1218">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-1219">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1219">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1220">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1220">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1221">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1221">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1222">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1222">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit signed integer.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1223"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1223"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1224"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1224">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1225">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1225">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 <span data-ttu-id="0fa7e-1226">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1226">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1227">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1227">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 <span data-ttu-id="0fa7e-1228">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości on jest niejawnie przekonwertowana na <xref:System.Int64> wartości podczas wykonywania operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1228">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="0fa7e-1229">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1229">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1230">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1230">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1231">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1231">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1232">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równa do innego <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1232">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1233"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1233"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1234"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1234">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1235">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1235">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 <span data-ttu-id="0fa7e-1236">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Compare%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1236">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A> method instead.</span></span> <span data-ttu-id="0fa7e-1237">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1237">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 <span data-ttu-id="0fa7e-1238">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1238">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1239">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1239">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1240">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1240">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1241">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowej liczby całkowitej bez znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1241">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit unsigned integer.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1242"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1242"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1243"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1243">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1244">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1244">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 <span data-ttu-id="0fa7e-1245">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1245">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1246">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1246">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 <span data-ttu-id="0fa7e-1247">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1247">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1248">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1248">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1249">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1249">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1250">Zwraca wartość wskazującą, czy 64-bitowej liczby całkowitej bez znaku jest mniejsza lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1250">Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1251"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1251"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1252"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1252">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1253">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1253">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 <span data-ttu-id="0fa7e-1254">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1254">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="0fa7e-1255">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1255">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 <span data-ttu-id="0fa7e-1256">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1256">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="0fa7e-1257">Wartość podział.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1257">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="0fa7e-1258">Wartość do dzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1258">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1259">Zwraca resztę, będącą wynikiem dzielenia przy użyciu dwóch określony <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1259">Returns the remainder that results from division with two specified <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1260">Pozostałe będącą wynikiem podziału.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1260">The remainder that results from the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1261"><xref:System.Numerics.BigInteger.op_Modulus%2A> Metoda definiuje operacji operator modulo <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1261">The <xref:System.Numerics.BigInteger.op_Modulus%2A> method defines the operation of the modulus operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1262">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1262">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 <span data-ttu-id="0fa7e-1263">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1263">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-1264">Znak wartości zwróconej przez operację modulo zależy od jej znaku `dividend`: Jeśli `dividend` jest dodatnia, Operacja modulo zwraca wyników pozytywnych; Jeśli jest ujemna, Operacja modulo zwraca wynik ujemny.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1264">The sign of the value returned by the modulus operation depends on the sign of `dividend`: If `dividend` is positive, the modulus operation returns a positive result; if it is negative, the modulus operation returns a negative result.</span></span> <span data-ttu-id="0fa7e-1265">Zachowanie działania modulo z <xref:System.Numerics.BigInteger> wartości jest taka sama jak operację modulo z innych typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1265">The behavior of the modulus operation with <xref:System.Numerics.BigInteger> values is identical to the modulus operation with other integral types.</span></span>  
  
 <span data-ttu-id="0fa7e-1266">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1266">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="0fa7e-1267"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1267"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1268">Pierwsza wartość wielokrotnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1268">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1269">Druga wartość używana w wielokrotnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1269">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1270">Mnoży dwie określone <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1270">Multiplies two specified <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1271">Iloczyn <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1271">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1272"><xref:System.Numerics.BigInteger.op_Multiply%2A> Metoda definiuje operacji operator mnożenia <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1272">The <xref:System.Numerics.BigInteger.op_Multiply%2A> method defines the operation of the multiplication operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1273">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1273">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 <span data-ttu-id="0fa7e-1274">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1274">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1275">Wartość całkowita.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1275">An integer value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1276">Zwraca operatora testu koniunkcji, jeden dla uzupełnienia z <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1276">Returns the bitwise one's complement of a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1277">Bitowe co do uzupełnienia z <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1277">The bitwise one's complement of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1278"><xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda definiuje operację z bitowego przez jeden operator dopełnienia jednostkowego dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1278">The <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method defines the operation of the bitwise one's complement operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1279">Bitowe odwraca operatorem dopełnienia osoby, każdy bit w wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1279">The bitwise one's complement operator reverses each bit in a numeric value.</span></span> <span data-ttu-id="0fa7e-1280">Oznacza to, że usługa bits w `value` , które są 0 są ustawione na 1, w wyniku i bitów, które są 1 są ustawione na 0 w wyniku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1280">That is, bits in `value` that are 0 are set to 1 in the result, and bits that are 1 are set to 0 in the result.</span></span> <span data-ttu-id="0fa7e-1281"><xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1281">The <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 <span data-ttu-id="0fa7e-1282">Języki, które nie obsługują niestandardowych operatory może być możliwe do wywołania <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metody bezpośrednio do wykonania bitowej, osoby uzupełniają operacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1282">Languages that do not support custom operators may be able to call the <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method directly to perform a bitwise one's complement operation.</span></span> <span data-ttu-id="0fa7e-1283">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1283">For example:</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1284">Wartość, której bity są lekkie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1284">The value whose bits are to be shifted.</span></span></param>
        <param name="shift"><span data-ttu-id="0fa7e-1285">Liczba bitów, które mają zostać przesunięte <c>wartość</c> z prawej strony.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1285">The number of bits to shift <c>value</c> to the right.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1286">Zmiany <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w prawo.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1286">Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the right.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1287">Wartość przesunięcia w prawo o określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1287">A value that has been shifted to the right by the specified number of bits.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1288"><xref:System.Numerics.BigInteger.op_RightShift%2A> Metoda definiuje operację z bitowego operator przesunięcia w prawo <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1288">The <xref:System.Numerics.BigInteger.op_RightShift%2A> method defines the operation of the bitwise right-shift operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1289">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1289">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 <span data-ttu-id="0fa7e-1290">Języki, które nie obsługują niestandardowych operatory można wykonać operacji przesunięcia w prawo, dzieląc `value` przez `BigInteger.Pow(2, shift)` i odejmowanie 1 godziny `shift` dla wartości ujemnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1290">Languages that do not support custom operators can perform a bitwise right-shift operation by dividing `value` by `BigInteger.Pow(2, shift)` and subtracting 1 times `shift` for negative values.</span></span> <span data-ttu-id="0fa7e-1291">W poniższym przykładzie pokazano, że wyniki są takie same jak wyniki za pomocą tego operatora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1291">The following example shows that the results are identical to the results of using this operator.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 <span data-ttu-id="0fa7e-1292">Jeśli `shift` jest większa lub równa liczbie bitów dodatnią <xref:System.Numerics.BigInteger> wartość, wynik operacji przesunięcia w prawo jest <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1292">If `shift` is greater than or equal to the number of bits in a positive <xref:System.Numerics.BigInteger> value, the result of the right-shift operation is <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-1293">Jeśli `shift` jest większa niż liczba bitów ujemny <xref:System.Numerics.BigInteger> wartość, wynik operacji przesunięcia w prawo jest <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1293">If `shift` is greater than the number of bits in a negative <xref:System.Numerics.BigInteger> value, the result of the right-shift operation is <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1294">Wartość, którą chcesz odjąć od (minuend).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1294">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1295">Wartość do odejmowania (subtrahend).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1295">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="0fa7e-1296">Odejmuje <see cref="T:System.Numerics.BigInteger" /> wartości z innej <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1296">Subtracts a <see cref="T:System.Numerics.BigInteger" /> value from another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1297">Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1297">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1298"><xref:System.Numerics.BigInteger.op_Subtraction%2A> Metoda definiuje operacji operator odejmowania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1298">The <xref:System.Numerics.BigInteger.op_Subtraction%2A> method defines the operation of the subtraction operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1299">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1299">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 <span data-ttu-id="0fa7e-1300">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1300">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-1301">Metoda równoważne tego operatora jest <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1301">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1302">Wartość do wskazania ujemnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1302">The value to negate.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1303">Negacja określoną wartość BigInteger.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1303">Negates a specified BigInteger value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1304">Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1304">The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1305"><xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Metoda definiuje operację Jednoargumentowy operator negacji (lub operator odwrotność dodatku) <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1305">The <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> method defines the operation of the unary negation operator (or the additive inverse operator) for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1306">Operacja daje wartość, która powoduje 0 (zero), gdy jest ona dodawana do liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1306">The operation produces a value that results in 0 (zero) when it is added to the original number.</span></span> <span data-ttu-id="0fa7e-1307">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.BigInteger.Negate%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1307">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="0fa7e-1308">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0fa7e-1308">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="0fa7e-1309">Poniższy przykład przedstawia trzy różne sposoby, aby odwrócić wartość <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1309">The following example illustrates three different ways to negate the value of a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1310">Wartość całkowita.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1310">An integer value.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1311">Zwraca wartość <see cref="T:System.Numerics.BigInteger" /> argument.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1311">Returns the value of the <see cref="T:System.Numerics.BigInteger" /> operand.</span></span> <span data-ttu-id="0fa7e-1312">(Znak operand jest bez zmian).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1312">(The sign of the operand is unchanged.)</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1313">Wartość <paramref name="value" /> argument.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1313">The value of the <paramref name="value" /> operand.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1314"><xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Metoda definiuje operacji jednoargumentowej dodatnią dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1314">The <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> method defines the operation of the unary positive operator for <xref:System.Numerics.BigInteger> values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1315">Konwertuje liczbę reprezentację ciągu jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1315">Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1316">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1316">A string that contains the number to convert.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1317">Konwertuje liczbę reprezentację ciągu jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1317">Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1318">Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1318">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1319">`value` Parametr powinien być reprezentację liczby w następującym formacie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1319">The `value` parameter should be the string representation of a number in the following form.</span></span>  
  
 <span data-ttu-id="0fa7e-1320">[*ws*] [*znak*]*cyfr*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1320">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1321">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1321">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="0fa7e-1322">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1322">The following table describes each element.</span></span>  
  
|<span data-ttu-id="0fa7e-1323">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1323">Element</span></span>|<span data-ttu-id="0fa7e-1324">Opis</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1324">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="0fa7e-1325">*ws*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1325">*ws*</span></span>|<span data-ttu-id="0fa7e-1326">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1326">Optional white space.</span></span>|  
|<span data-ttu-id="0fa7e-1327">*sign*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1327">*sign*</span></span>|<span data-ttu-id="0fa7e-1328">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1328">An optional sign.</span></span> <span data-ttu-id="0fa7e-1329">Nieprawidłowy znak znaki są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1329">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the current culture.</span></span>|  
|<span data-ttu-id="0fa7e-1330">*cyfr*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1330">*digits*</span></span>|<span data-ttu-id="0fa7e-1331">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1331">A sequence of digits ranging from 0 to 9.</span></span> <span data-ttu-id="0fa7e-1332">Wszystkie zera wiodące są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1332">Any leading zeros are ignored.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1333">Ciąg określony przez `value` parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1333">The string specified by the `value` parameter is interpreted by using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="0fa7e-1334">Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1334">It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
 <span data-ttu-id="0fa7e-1335">`value` Parametru jest analizowana, korzystając z informacji formatowania w <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> obiekt, który został zainicjowany dla bieżącego ustawienia kulturowego systemu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1335">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> object that is initialized for the current system culture.</span></span> <span data-ttu-id="0fa7e-1336">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1336">For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-1337">Aby przeanalizować ciągu przy użyciu formatowania informacji określoną kulturę, użyj <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1337">To parse a string by using the formatting information of a specific culture, use the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0fa7e-1338">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1338">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="0fa7e-1339">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1339">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1340">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1340">The following example uses the <xref:System.Numerics.BigInteger.Parse%28System.String%29> method to instantiate two <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="0fa7e-1341">Mnoży każdego obiektu przez inny numer, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę, aby określić relacji między dwiema wartościami.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1341">It multiplies each object by another number and then calls the <xref:System.Numerics.BigInteger.Compare%2A> method to determine the relationship between the two values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0fa7e-1342"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1342"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0fa7e-1343"><paramref name="value" /> nie jest w nieprawidłowym formacie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1343"><paramref name="value" /> is not in the correct format.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1344">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1344">A string that contains a number to convert.</span></span></param>
        <param name="style"><span data-ttu-id="0fa7e-1345">Bitowe połączenie wartości wyliczenia, które określają format dozwolonych <c>wartość</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1345">A bitwise combination of the enumeration values that specify the permitted format of <c>value</c>.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1346">Konwertuje reprezentacja ciągu liczb w stylu określony do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1346">Converts the string representation of a number in a specified style to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1347">Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1347">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1348">`style` Parametru definiuje elementy stylu (na przykład biały znak, symbol znaku dodatnie lub ujemne, symbol separatora grupy lub symbol punktu dziesiętnego), które są dozwolone w `value` parametr powodzenie operacji analizy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1348">The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="0fa7e-1349">`styles` musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1349">`styles` must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="0fa7e-1350">`style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera wartość szesnastkową reprezentację ciągu, gdy system numer (dziesiętną lub szesnastkową) reprezentowany przez `value` jest znany tylko w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub znak symbolu w `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1350">The `style` parameter makes this method overload useful when `value` contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by `value` is known only at run time, or when you want to disallow white space or a sign symbol in `value`.</span></span>  
  
 <span data-ttu-id="0fa7e-1351">W zależności od wartości `style`, `value` parametr może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1351">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="0fa7e-1352">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1352">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1353">Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametr może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1353">If `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, the `value` parameter may contain the following elements:</span></span>  
  
 <span data-ttu-id="0fa7e-1354">[*ws*]*hexdigits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1354">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1355">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1355">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="0fa7e-1356">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1356">The following table describes each element.</span></span>  
  
|<span data-ttu-id="0fa7e-1357">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1357">Element</span></span>|<span data-ttu-id="0fa7e-1358">Opis</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1358">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="0fa7e-1359">*ws*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1359">*ws*</span></span>|<span data-ttu-id="0fa7e-1360">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1360">Optional white space.</span></span> <span data-ttu-id="0fa7e-1361">Biały znak, może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1361">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="0fa7e-1362">Symbol waluty specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1362">A culture-specific currency symbol.</span></span> <span data-ttu-id="0fa7e-1363">Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1363">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the current culture.</span></span> <span data-ttu-id="0fa7e-1364">Symbol waluty bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1364">The current culture's currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1365">*sign*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1365">*sign*</span></span>|<span data-ttu-id="0fa7e-1366">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1366">An optional sign.</span></span> <span data-ttu-id="0fa7e-1367">Logowania może wystąpić na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1367">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="0fa7e-1368">Użycie nawiasów w `value` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1368">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1369">*cyfr*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1369">*digits*</span></span><br /><br /> <span data-ttu-id="0fa7e-1370">*fractional_digits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1370">*fractional_digits*</span></span><br /><br /> <span data-ttu-id="0fa7e-1371">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1371">*exponential_digits*</span></span>|<span data-ttu-id="0fa7e-1372">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1372">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="0fa7e-1373">Aby uzyskać *fractional_digits*tylko cyfry 0 jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1373">For *fractional_digits*, only the digit 0 is valid.</span></span>|  
|<span data-ttu-id="0fa7e-1374">*,*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1374">*,*</span></span>|<span data-ttu-id="0fa7e-1375">Symbol separatora grupy specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1375">A culture-specific group separator symbol.</span></span> <span data-ttu-id="0fa7e-1376">Separator grupy bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1376">The current culture's group separator can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1377">*.*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1377">*.*</span></span>|<span data-ttu-id="0fa7e-1378">Symbol dziesiętny specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1378">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="0fa7e-1379">Symbol punktu dziesiętnego bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1379">The current culture's decimal point symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="0fa7e-1380">Tylko cyfry 0 może występować jako cyfrę ułamkowych analizy operacja powiodła się; Jeśli *fractional_digits* zawiera dowolną cyfrę <xref:System.FormatException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1380">Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, a <xref:System.FormatException> is thrown.</span></span>|  
|<span data-ttu-id="0fa7e-1381">E</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1381">E</span></span>|<span data-ttu-id="0fa7e-1382">Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1382">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="0fa7e-1383">`value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1383">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1384">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1384">*hexdigits*</span></span>|<span data-ttu-id="0fa7e-1385">Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1385">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
 <span data-ttu-id="0fa7e-1386">Ciąg zawierający tylko cyfry (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1386">A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully.</span></span> <span data-ttu-id="0fa7e-1387">Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementy, które mogą być obecne, ale nie muszą znajdować się w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1387">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in the input string.</span></span> <span data-ttu-id="0fa7e-1388">W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1388">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="0fa7e-1389">`NumberStyles` Wartość</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1389">`NumberStyles` value</span></span>|<span data-ttu-id="0fa7e-1390">Elementy dozwolone w `value` oprócz cyfr</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1390">Elements permitted in `value` in addition to digits</span></span>|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="0fa7e-1391">*Cyfr* tylko element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1391">The *digits* element only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="0fa7e-1392">Decimal (.) i *cyfr ułamkowych* elementów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1392">The decimal point (.) and *fractional-digits* elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="0fa7e-1393">"E" lub litery "E", która wskazuje notacji wykładniczej, wraz z *exponential_digits*.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1393">The "e" or "E" character, which indicates exponential notation, along with *exponential_digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="0fa7e-1394">*Ws* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1394">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="0fa7e-1395">*Ws* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1395">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="0fa7e-1396">*Znak* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1396">The *sign* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="0fa7e-1397">*Znak* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1397">The *sign* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="0fa7e-1398">*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1398">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="0fa7e-1399">Element separatora grupy (,).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1399">The group separator (,) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="0fa7e-1400">Element określający walutę ($).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1400">The currency ($) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="0fa7e-1401">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1401">All elements.</span></span> <span data-ttu-id="0fa7e-1402">Jednak `value` nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1402">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="0fa7e-1403">*Ws* elementu na początek lub koniec `value`, *znak* na początku `value`i dziesiętnego (*.*) symbolu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1403">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (*.*) symbol.</span></span> <span data-ttu-id="0fa7e-1404">`value` Parametr można również użyć notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1404">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="0fa7e-1405">`ws`, `sign`, Grupy separatora (*,*), a separatorem dziesiętnym (*.*) elementów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1405">The `ws`, `sign`, group separator (*,*), and decimal point (*.*) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="0fa7e-1406">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1406">All elements.</span></span> <span data-ttu-id="0fa7e-1407">Jednak `value` nie może reprezentować liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1407">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="0fa7e-1408">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1408">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="0fa7e-1409">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1409">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1410">W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności określonego stylu elementów w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> styl wartość oznacza, że poszczególne znaki numeryczne w `value` zawsze będą interpretowane jako znaki szesnastkowe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1410">Unlike the other <xref:System.Globalization.NumberStyles> values, which allow for, but do not require, the presence of particular style elements in `value`, the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> style value means that the individual numeric characters in `value` are always interpreted as hexadecimal characters.</span></span> <span data-ttu-id="0fa7e-1411">Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1411">Valid hexadecimal characters are 0-9, A-F, and a-f.</span></span> <span data-ttu-id="0fa7e-1412">Tylko innych flagi, które można łączyć z `style` są parametru <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1412">The only other flags that can be combined with the `style` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-1413">( <xref:System.Globalization.NumberStyles> Wyliczenie zawiera styl numer złożone, <xref:System.Globalization.NumberStyles.HexNumber>, zawierająca zarówno flagi biały znak.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1413">(The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1414">Jeśli `value` reprezentacja ciągu z liczbą szesnastkową nie może być poprzedzone żadnych decoration (takich jak `0x` lub `&h`) który odróżnia go jako liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1414">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="0fa7e-1415">To powoduje niepowodzenie konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1415">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="0fa7e-1416">Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metody `value` jako wartość ujemną przechowywane za pomocą dwóch jego reprezentacja dopełnienia, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równe `0x80`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1416">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="0fa7e-1417">Innymi słowy, metoda interpretuje bit najwyższej kolejności pierwszego bajtu w `value` jako bitem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1417">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="0fa7e-1418">Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako wartość dodatnią, cyfry, w `value` musi mieć wartość zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1418">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="0fa7e-1419">Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartość dodatnią.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1419">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="0fa7e-1420">Poniższy przykład przedstawia różnice między ciągów szesnastkowych, które reprezentują wartości ujemnych i dodatnich.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1420">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 <span data-ttu-id="0fa7e-1421">`value` Parametru jest analizowana, korzystając z informacji formatowania w <xref:System.Globalization.NumberFormatInfo> obiekt, który został zainicjowany dla bieżącego ustawienia kulturowego systemu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1421">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture.</span></span> <span data-ttu-id="0fa7e-1422">Aby określić kulturę, którego formatowania informacje są używane dla operacji analizy, należy wywołać <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1422">To specify the culture whose formatting information is used for the parse operation, call the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1423">Poniższy przykład przedstawia wywołań <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metody z kilku wartości dla `style` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1423">The following example illustrates calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method with several possible values for the `style` parameter.</span></span> <span data-ttu-id="0fa7e-1424">Przedstawia go zinterpretować ciąg jako wartość szesnastkowa oraz sposobu nie zezwalaj na spacje i podpisz symboli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1424">It illustrates how to interpret a string as a hexadecimal value, and how to disallow spaces and sign symbols.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0fa7e-1425"><paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1425"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1426">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1426">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-1427"><paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1427"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0fa7e-1428"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1428"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0fa7e-1429"><paramref name="value" /> nie jest zgodne z wejściowych wzorca określonego przez <see cref="T:System.Globalization.NumberStyles" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1429"><paramref name="value" /> does not comply with the input pattern specified by <see cref="T:System.Globalization.NumberStyles" />.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1430">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1430">A string that contains a number to convert.</span></span></param>
        <param name="provider"><span data-ttu-id="0fa7e-1431">Obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury o <c>wartość</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1431">An object that provides culture-specific formatting information about <c>value</c>.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1432">Konwertuje reprezentację liczby w określonym formacie specyficzne dla kultury do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1432">Converts the string representation of a number in a specified culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1433">Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1433">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1434">`value` Parametr powinien być reprezentację liczby w następującym formacie:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1434">The `value` parameter should be the string representation of a number in the following form:</span></span>  
  
 <span data-ttu-id="0fa7e-1435">[*ws*] [*znak*]*cyfr*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1435">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1436">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1436">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="0fa7e-1437">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1437">The following table describes each element.</span></span>  
  
|<span data-ttu-id="0fa7e-1438">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1438">Element</span></span>|<span data-ttu-id="0fa7e-1439">Opis</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1439">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="0fa7e-1440">*ws*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1440">*ws*</span></span>|<span data-ttu-id="0fa7e-1441">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1441">Optional white space.</span></span>|  
|<span data-ttu-id="0fa7e-1442">*sign*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1442">*sign*</span></span>|<span data-ttu-id="0fa7e-1443">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1443">An optional sign.</span></span> <span data-ttu-id="0fa7e-1444">Nieprawidłowy znak znaki są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu, który jest zwracany przez `provider` obiektu <xref:System.IFormatProvider.GetFormat%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1444">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the <xref:System.Globalization.NumberFormatInfo> object that is returned by the `provider` object's <xref:System.IFormatProvider.GetFormat%2A> method.</span></span>|  
|<span data-ttu-id="0fa7e-1445">*cyfr*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1445">*digits*</span></span>|<span data-ttu-id="0fa7e-1446">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1446">A sequence of digits ranging from 0 to 9.</span></span> <span data-ttu-id="0fa7e-1447">Wszystkie zera wiodące są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1447">Any leading zeros are ignored.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1448">Ciąg określony przez `value` parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1448">The string specified by the `value` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="0fa7e-1449">Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1449">It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0fa7e-1450">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1450">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="0fa7e-1451">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1451">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1452">`provider` Parametr jest <xref:System.IFormatProvider> implementacji których <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1452">The `provider` parameter is an <xref:System.IFormatProvider> implementation whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information.</span></span> <span data-ttu-id="0fa7e-1453">Gdy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> wywołania metody, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> — metoda i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1453">When the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> method is invoked, it calls the `provider` parameter's <xref:System.IFormatProvider.GetFormat%2A> method and passes it a <xref:System.Type> object that represents the <xref:System.Globalization.NumberFormatInfo> type.</span></span> <span data-ttu-id="0fa7e-1454"><xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje o formacie `value` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1454">The <xref:System.IFormatProvider.GetFormat%2A> method then returns the <xref:System.Globalization.NumberFormatInfo> object that provides information about the format of the `value` parameter.</span></span> <span data-ttu-id="0fa7e-1455">Istnieją trzy sposoby używania `provider` parametr, aby podać informacje dotyczące formatowania niestandardowych operacji analizy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1455">There are three ways to use the `provider` parameter to supply custom formatting information to the parse operation:</span></span>  
  
-   <span data-ttu-id="0fa7e-1456">Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1456">You can pass a <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="0fa7e-1457">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania dla tej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1457">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="0fa7e-1458">Można przekazać rzeczywiste <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1458">You can pass the actual <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="0fa7e-1459">(Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1459">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="0fa7e-1460">Można przekazać niestandardowego obiektu, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1460">You can pass a custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="0fa7e-1461">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1461">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="0fa7e-1462">Jeśli `provider` jest `null`, formatowanie `value` jest interpretowana w oparciu o <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1462">If `provider` is `null`, the formatting of `value` is interpreted based on the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1463">W poniższych przykładach pokazano dwa sposoby definiowania tyldy (~) jako znaku minus formatowania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1463">The following examples show two ways to define the tilde (~) as a negative sign for formatting <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="0fa7e-1464">Należy pamiętać, że do wyświetlenia <xref:System.Numerics.BigInteger> wartości w tym samym formacie co oryginalna ciągów, kod musi wywoływać <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> — metoda i przekaż go <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1464">Note that to display the <xref:System.Numerics.BigInteger> values in the same format as the original strings, your code must call the <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method and pass it the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="0fa7e-1465">Pierwszym przykładzie zdefiniowano klasę implementującą <xref:System.IFormatProvider> i używa <xref:System.IFormatProvider.GetFormat%2A> metodę, aby zwrócić <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1465">The first example defines a class that implements <xref:System.IFormatProvider> and uses the <xref:System.IFormatProvider.GetFormat%2A> method to return the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 <span data-ttu-id="0fa7e-1466">A <xref:System.Numerics.BigInteger> następnie wystąpienie obiektu z następującym kodem:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1466">A <xref:System.Numerics.BigInteger> object can then be instantiated with the following code:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 <span data-ttu-id="0fa7e-1467">Drugi przykład jest więcej prosta.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1467">The second example is more straightforward.</span></span> <span data-ttu-id="0fa7e-1468">Przekazuje ono <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania do `provider` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1468">It passes the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information to the `provider` parameter.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0fa7e-1469"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1469"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0fa7e-1470"><paramref name="value" /> nie jest w nieprawidłowym formacie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1470"><paramref name="value" /> is not in the correct format.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1471">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1471">A string that contains a number to convert.</span></span></param>
        <param name="style"><span data-ttu-id="0fa7e-1472">Bitowe połączenie wartości wyliczenia, które określają format dozwolonych <c>wartość</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1472">A bitwise combination of the enumeration values that specify the permitted format of <c>value</c>.</span></span></param>
        <param name="provider"><span data-ttu-id="0fa7e-1473">Obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury o <c>wartość</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1473">An object that provides culture-specific formatting information about <c>value</c>.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1474">Konwertuje reprezentację ciągu liczbą określony styl i specyficzne dla kultury formatu w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1474">Converts the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1475">Wartość odpowiadającą liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1475">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1476">`style` Parametru definiuje elementy stylu (na przykład biały znak, symbol znaku dodatnie lub ujemne, symbol separatora grupy lub symbol punktu dziesiętnego), które są dozwolone w `value` parametr powodzenie operacji analizy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1476">The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="0fa7e-1477">`styles` musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1477">`styles` must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="0fa7e-1478">`style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera wartość szesnastkową reprezentację ciągu, gdy system numer (dziesiętną lub szesnastkową) reprezentowany przez `value` jest znany tylko w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub znak symbolu w `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1478">The `style` parameter makes this method overload useful when `value` contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by `value` is known only at run time, or when you want to disallow white space or a sign symbol in `value`.</span></span>  
  
 <span data-ttu-id="0fa7e-1479">W zależności od wartości `style`, `value` parametr może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1479">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="0fa7e-1480">[*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1480">[*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1481">Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametr może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1481">If `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="0fa7e-1482">[*ws*]*hexdigits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1482">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1483">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1483">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="0fa7e-1484">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1484">The following table describes each element.</span></span>  
  
|<span data-ttu-id="0fa7e-1485">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1485">Element</span></span>|<span data-ttu-id="0fa7e-1486">Opis</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1486">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="0fa7e-1487">*ws*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1487">*ws*</span></span>|<span data-ttu-id="0fa7e-1488">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1488">Optional white space.</span></span> <span data-ttu-id="0fa7e-1489">Biały znak, może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1489">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="0fa7e-1490">Symbol waluty specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1490">A culture-specific currency symbol.</span></span> <span data-ttu-id="0fa7e-1491">Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości kultury wskazywanym przez `provider` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1491">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the culture indicated by the `provider` parameter.</span></span> <span data-ttu-id="0fa7e-1492">Symbol waluty bieżącej kultury może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1492">The current culture's currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1493">*sign*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1493">*sign*</span></span>|<span data-ttu-id="0fa7e-1494">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1494">An optional sign.</span></span> <span data-ttu-id="0fa7e-1495">Logowania może wystąpić na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1495">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="0fa7e-1496">Użycie nawiasów w `value` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1496">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1497">*cyfr*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1497">*digits*</span></span><br /><br /> <span data-ttu-id="0fa7e-1498">*fractional_digits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1498">*fractional_digits*</span></span><br /><br /> <span data-ttu-id="0fa7e-1499">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1499">*exponential_digits*</span></span>|<span data-ttu-id="0fa7e-1500">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1500">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="0fa7e-1501">Aby uzyskać *fractional_digits*tylko cyfry 0 jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1501">For *fractional_digits*, only the digit 0 is valid.</span></span>|  
|<span data-ttu-id="0fa7e-1502">*,*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1502">*,*</span></span>|<span data-ttu-id="0fa7e-1503">Symbol separatora grupy specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1503">A culture-specific group separator symbol.</span></span> <span data-ttu-id="0fa7e-1504">Symbol separatora grupy kultury określonej przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1504">The group separator symbol of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1505">*.*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1505">*.*</span></span>|<span data-ttu-id="0fa7e-1506">Symbol dziesiętny specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1506">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="0fa7e-1507">Symbol punktu dziesiętnego kultury wskazywany przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1507">The decimal point symbol of the culture designated by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="0fa7e-1508">Tylko cyfry 0 może występować jako cyfrę ułamkowych analizy operacja powiodła się; Jeśli *fractional_digits* zawiera dowolną cyfrę <xref:System.FormatException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1508">Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, a <xref:System.FormatException> is thrown.</span></span>|  
|<span data-ttu-id="0fa7e-1509">E</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1509">E</span></span>|<span data-ttu-id="0fa7e-1510">Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1510">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="0fa7e-1511">`value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1511">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1512">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1512">*hexdigits*</span></span>|<span data-ttu-id="0fa7e-1513">Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1513">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
 <span data-ttu-id="0fa7e-1514">Ciąg zawierający tylko cyfry (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1514">A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully.</span></span> <span data-ttu-id="0fa7e-1515">Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementy, które mogą być obecne, ale nie muszą znajdować się w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1515">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in the input string.</span></span> <span data-ttu-id="0fa7e-1516">W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1516">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="0fa7e-1517">Wartość wyliczenia NumberStyles</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1517">NumberStyles value</span></span>|<span data-ttu-id="0fa7e-1518">Dodatkowe (poza cyframi) elementy dozwolone w wartości</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1518">Elements permitted in value in addition to digits</span></span>|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="0fa7e-1519">*Cyfr* tylko element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1519">The *digits* element only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="0fa7e-1520">Decimal (.) i *cyfr ułamkowych* elementów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1520">The decimal point (.) and *fractional-digits* elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="0fa7e-1521">Znak „e” lub znak „E”, co oznacza zapis wykładniczy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1521">The "e" or "E" character, which indicates exponential notation.</span></span> <span data-ttu-id="0fa7e-1522">wraz z programem *exponential_digits*.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1522">along with *exponential_digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="0fa7e-1523">*Ws* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1523">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="0fa7e-1524">*Ws* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1524">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="0fa7e-1525">*Znak* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1525">The *sign* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="0fa7e-1526">*Znak* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1526">The *sign* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="0fa7e-1527">*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1527">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="0fa7e-1528">Element separatora grupy (,).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1528">The group separator (,) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="0fa7e-1529">Element określający walutę ($).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1529">The currency ($) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="0fa7e-1530">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1530">All elements.</span></span> <span data-ttu-id="0fa7e-1531">Jednak `value` nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1531">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="0fa7e-1532">*Ws* elementu na początek lub koniec `value`, *znak* na początku `value`oraz symbol punktu dziesiętnego (.).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1532">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (.) symbol.</span></span> <span data-ttu-id="0fa7e-1533">`value` Parametr można również użyć notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1533">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="0fa7e-1534">`ws`, `sign`, Grupy separatora (,), a elementy dziesiętnym (.).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1534">The `ws`, `sign`, group separator (,), and decimal point (.) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="0fa7e-1535">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1535">All elements.</span></span> <span data-ttu-id="0fa7e-1536">Jednak `value` nie może reprezentować liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1536">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="0fa7e-1537">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1537">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="0fa7e-1538">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1538">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1539">W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności określonego stylu elementów w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> styl wartość oznacza, że poszczególne znaki numeryczne w `value` zawsze będą interpretowane jako znaki szesnastkowe.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1539">Unlike the other <xref:System.Globalization.NumberStyles> values, which allow for but do not require the presence of particular style elements in `value`, the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> style value means that the individual numeric characters in `value` are always interpreted as hexadecimal characters.</span></span> <span data-ttu-id="0fa7e-1540">Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1540">Valid hexadecimal characters are 0-9, A-F, and a-f.</span></span> <span data-ttu-id="0fa7e-1541">Tylko innych flagi, które można łączyć z `style` są parametru <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1541">The only other flags that can be combined with the `style` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-1542">( <xref:System.Globalization.NumberStyles> Wyliczenie zawiera styl numer złożone, <xref:System.Globalization.NumberStyles.HexNumber>, zawierająca zarówno flagi biały znak.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1542">(The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1543">Jeśli `value` reprezentacja ciągu z liczbą szesnastkową nie może być poprzedzone żadnych decoration (takich jak `0x` lub `&h`) który odróżnia go jako liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1543">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="0fa7e-1544">To powoduje niepowodzenie konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1544">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="0fa7e-1545">Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metody `value` jako wartość ujemną przechowywane za pomocą dwóch jego reprezentacja dopełnienia, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równe `0x80`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1545">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="0fa7e-1546">Innymi słowy, metoda interpretuje bit najwyższej kolejności pierwszego bajtu w `value` jako bitem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1546">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="0fa7e-1547">Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako wartość dodatnią, cyfry, w `value` musi mieć wartość zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1547">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="0fa7e-1548">Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartość dodatnią.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1548">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="0fa7e-1549">Poniższy przykład przedstawia różnice między ciągów szesnastkowych, które reprezentują wartości ujemnych i dodatnich.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1549">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 <span data-ttu-id="0fa7e-1550">`provider` Parametr jest <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1550">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="0fa7e-1551">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje specyficzne dla kultury o format `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1551">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of `value`.</span></span> <span data-ttu-id="0fa7e-1552">Zazwyczaj `provider` może być jednym z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1552">Typically, `provider` can be any one of the following:</span></span>  
  
-   <span data-ttu-id="0fa7e-1553">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultura, która zawiera dane liczbowe formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1553">A <xref:System.Globalization.CultureInfo> object that represents the culture that provides numeric formatting information.</span></span> <span data-ttu-id="0fa7e-1554">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1554">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span>  
  
-   <span data-ttu-id="0fa7e-1555">A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1555">A <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span> <span data-ttu-id="0fa7e-1556">(Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1556">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="0fa7e-1557">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> i używa <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> metody w celu utworzenia wystąpienia i zwracać <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1557">A custom object that implements <xref:System.IFormatProvider> and uses the <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> method to instantiate and return the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="0fa7e-1558">Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1558">If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1559">Poniższy przykład powoduje, że wiele wywołań <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodę przy użyciu różnych kombinacji wartości `style` i `provider` parametrów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1559">The following example makes several calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method using various combinations of values for the `style` and `provider` parameters.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 <span data-ttu-id="0fa7e-1560">Liczba wywołań poszczególnych <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku minus.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1560">A number of the individual calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method pass an instance of the following `BigIntegerFormatProvider` class, which defines a tilde (~) as the negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0fa7e-1561"><paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1561"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1562">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1562">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-1563"><paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1563"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0fa7e-1564"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1564"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0fa7e-1565"><paramref name="value" /> nie jest zgodne z wejściowych wzorca określonego przez <paramref name="style" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1565"><paramref name="value" /> does not comply with the input pattern specified by <paramref name="style" />.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1566">Numer, do której zostaną podniesione <c>wykładnik</c> zasilania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1566">The number to raise to the <c>exponent</c> power.</span></span></param>
        <param name="exponent"><span data-ttu-id="0fa7e-1567">Wykładnik, aby podnieść <c>wartość</c> przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1567">The exponent to raise <c>value</c> by.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1568">Zgłasza <see cref="T:System.Numerics.BigInteger" /> wartości do potęgi określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1568">Raises a <see cref="T:System.Numerics.BigInteger" /> value to the power of a specified value.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1569">Wynik podniesienia liczby <paramref name="value" /> do <paramref name="exponent" /> zasilania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1569">The result of raising <paramref name="value" /> to the <paramref name="exponent" /> power.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1570"><xref:System.Numerics.BigInteger.Pow%2A> Metoda zwraca wartość 1, jeśli wartość parametru wykładnika to 0 lub wartości obu `value` i `exponent` parametry są równe 0.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1570">The <xref:System.Numerics.BigInteger.Pow%2A> method returns 1 if the value of the exponent parameter is 0, or if the values of both the `value` and `exponent` parameters are 0.</span></span> <span data-ttu-id="0fa7e-1571">Jeśli `exponent` 1, <xref:System.Numerics.BigInteger.Pow%2A> metoda zwraca `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1571">If `exponent` is 1, the <xref:System.Numerics.BigInteger.Pow%2A> method returns `value`.</span></span> <span data-ttu-id="0fa7e-1572">Jeśli `value` jest ujemna, metoda zwraca wynik ujemny.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1572">If `value` is negative, the method returns a negative result.</span></span>  
  
 <span data-ttu-id="0fa7e-1573">Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1573">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1574">Poniższy przykład przedstawia potęgowania przy użyciu <xref:System.Numerics.BigInteger> wartość i wykładnik, którego wartość należy do zakresu od 0 do 10.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1574">The following example illustrates exponentiation using a <xref:System.Numerics.BigInteger> value and an exponent whose value ranges from 0 to 10.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0fa7e-1575">Wartość <paramref name="exponent" /> parametru jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1575">The value of the <paramref name="exponent" /> parameter is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="0fa7e-1576">Wartość podział.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1576">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="0fa7e-1577">Wartość do dzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1577">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1578">Wykonuje dzielenie liczby całkowitej na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca resztę.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1578">Performs integer division on two <see cref="T:System.Numerics.BigInteger" /> values and returns the remainder.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1579">Resztę po podzieleniu <paramref name="dividend" /> przez <paramref name="divisor" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1579">The remainder after dividing <paramref name="dividend" /> by <paramref name="divisor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1580">Znak pozostałej jest znak `dividend` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1580">The sign of the remainder is the sign of the `dividend` parameter.</span></span>  
  
 <span data-ttu-id="0fa7e-1581"><xref:System.Numerics.BigInteger.Remainder%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1581">The <xref:System.Numerics.BigInteger.Remainder%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="0fa7e-1582">Jego zachowanie jest identyczne dzielenia przy użyciu operatora modulo.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1582">Its behavior is identical to division using the modulus operator.</span></span>  
  
 <span data-ttu-id="0fa7e-1583">Jeśli to konieczne, metoda automatycznie wykonuje niejawna konwersja z innych typów całkowitych do <xref:System.Numerics.BigInteger> obiekty przed przesłaniem operacji modułu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1583">If necessary, the method automatically performs implicit conversion of other integral types to <xref:System.Numerics.BigInteger> objects before it performs the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1584">Poniższy przykład porównuje pozostała z <xref:System.Numerics.BigInteger.DivRem%2A> metody pozostałych zwrócony przez <xref:System.Numerics.BigInteger.Remainder%2A> metodę określenia, że te dwie metody obliczanie reszt identyczne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1584">The following example compares the remainder from the <xref:System.Numerics.BigInteger.DivRem%2A> method with the remainder returned by the <xref:System.Numerics.BigInteger.Remainder%2A> method to establish that the two methods calculate identical remainders.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="0fa7e-1585"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1585"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1586">Pobiera numer, który wskazuje znak (negatywną dodatnie, lub zero) bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1586">Gets a number that indicates the sign (negative, positive, or zero) of the current <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <value><span data-ttu-id="0fa7e-1587">Liczba, która określa znak <see cref="T:System.Numerics.BigInteger" /> obiektów, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1587">A number that indicates the sign of the <see cref="T:System.Numerics.BigInteger" /> object, as shown in the following table.</span></span>  
  
 <span data-ttu-id="0fa7e-1588"><list type="table"><listheader><term> Numer</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1588"><list type="table"><listheader><term> Number</span></span>  
  
 <span data-ttu-id="0fa7e-1589"></term><description> Opis elementu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1589"></term><description> Description</span></span>  
  
 <span data-ttu-id="0fa7e-1590"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1590"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="0fa7e-1591"></term><description> Wartość tego obiektu jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1591"></term><description> The value of this object is negative.</span></span>  
  
 <span data-ttu-id="0fa7e-1592"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1592"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="0fa7e-1593"></term><description> Wartość tego obiektu jest 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1593"></term><description> The value of this object is 0 (zero).</span></span>  
  
 <span data-ttu-id="0fa7e-1594"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1594"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="0fa7e-1595"></term><description> Wartość tego obiektu jest dodatnia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1595"></term><description> The value of this object is positive.</span></span>  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1596"><xref:System.Numerics.BigInteger.Sign%2A> Właściwości jest odpowiednikiem <xref:System.Math.Sign%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1596">The <xref:System.Numerics.BigInteger.Sign%2A> property is equivalent to the <xref:System.Math.Sign%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="0fa7e-1597">Wartość, którą chcesz odjąć od (minuend).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1597">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="0fa7e-1598">Wartość do odejmowania (subtrahend).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1598">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="0fa7e-1599">Odejmuje jedną <see cref="T:System.Numerics.BigInteger" /> wartość z innej i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1599">Subtracts one <see cref="T:System.Numerics.BigInteger" /> value from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1600">Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1600">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1601">Można używać języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.BigInteger.Subtract%2A> metodę w celu za pomocą odejmowania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1601">Languages that do not support custom operators can use the <xref:System.Numerics.BigInteger.Subtract%2A> method to perform subtraction using <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="0fa7e-1602"><xref:System.Numerics.BigInteger.Subtract%2A> Metoda jest przydatna zastępuje operator odejmowania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przypisać tą różnicą, że wyniki z odejmowania, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1602">The <xref:System.Numerics.BigInteger.Subtract%2A> method is a useful substitute for the subtraction operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it the difference that results from subtraction, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0fa7e-1603">Konwertuje <see cref="T:System.Numerics.BigInteger" /> wartość na tablicę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1603">Converts a <see cref="T:System.Numerics.BigInteger" /> value to a byte array.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1604">Wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> przekonwertować obiektu na tablicę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1604">The value of the current <see cref="T:System.Numerics.BigInteger" /> object converted to an array of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1605">Poszczególne bajty w tablicy zwracanej przez tę metodę są wyświetlane w kolejności little endian.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1605">The individual bytes in the array returned by this method appear in little-endian order.</span></span> <span data-ttu-id="0fa7e-1606">Oznacza to, że kolejność małą liczbę bajtów wartość poprzedzać bajtów wyższego rzędu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1606">That is, the lower-order bytes of the value precede the higher-order bytes.</span></span> <span data-ttu-id="0fa7e-1607">Pierwszy bajt tablicy odzwierciedla pierwszych 8 bitów <xref:System.Numerics.BigInteger> wartość, drugie bajtów odzwierciedla dalej osiem bitów i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1607">The first byte of the array reflects the first eight bits of the <xref:System.Numerics.BigInteger> value, the second byte reflects the next eight bits, and so on.</span></span> <span data-ttu-id="0fa7e-1608">Na przykład wartość 1024 lub 0x0400, są przechowywane jako tablica następujące dwa bajty:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1608">For example, the value 1024, or 0x0400, is stored as the following array of two bytes:</span></span>  
  
|<span data-ttu-id="0fa7e-1609">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1609">Element</span></span>|<span data-ttu-id="0fa7e-1610">Wartość bajtu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1610">Byte value</span></span>|  
|-------------|----------------|  
|<span data-ttu-id="0fa7e-1611">0</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1611">0</span></span>|<span data-ttu-id="0fa7e-1612">0x00</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1612">0x00</span></span>|  
|<span data-ttu-id="0fa7e-1613">1</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1613">1</span></span>|<span data-ttu-id="0fa7e-1614">0x04</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1614">0x04</span></span>|  
  
 <span data-ttu-id="0fa7e-1615">Wartości ujemne są zapisywane do tablicy przy użyciu dwóch jego reprezentacja dopełnienia w najbardziej kompaktową możliwe formularza.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1615">Negative values are written to the array using two's complement representation in the most compact form possible.</span></span> <span data-ttu-id="0fa7e-1616">Na przykład wartość -1 jest reprezentowany jako pojedynczy bajt, którego wartość jest `0xFF` zamiast jako tablicy zawierającej wiele elementów, takich jak `0xFF`, `0xFF` lub `0xFF`, `0xFF`, `0xFF`, `0xFF`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1616">For example, -1 is represented as a single byte whose value is `0xFF` instead of as an array with multiple elements, such as `0xFF`, `0xFF` or `0xFF`, `0xFF`, `0xFF`, `0xFF`.</span></span>  
  
 <span data-ttu-id="0fa7e-1617">Ponieważ w dwóch uzupełniają reprezentacja zawsze interpretuje bit najwyższej kolejności ostatniego bajtu w tablicy (bajtów w pozycji <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) jako bitem, metoda zwraca tablicę bajtów z dodatkowy element, którego wartość wynosi zero do odróżniania wartości dodatnie, które w przeciwnym razie można zinterpretować jako o ich bitów logowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1617">Because two's complement representation always interprets the highest-order bit of the last byte in the array (the byte at position <xref:System.Array.Length%2A?displayProperty=nameWithType>`- 1`) as the sign bit, the method returns a byte array with an extra element whose value is zero to disambiguate positive values that could otherwise be interpreted as having their sign bits set.</span></span> <span data-ttu-id="0fa7e-1618">Na przykład wartość 120 lub `0x78` jest reprezentowany jako tablica jednobajtowe: `0x78`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1618">For example, the value 120 or `0x78` is represented as a single-byte array: `0x78`.</span></span> <span data-ttu-id="0fa7e-1619">Jednakże, 128, lub `0x80`, jest reprezentowany jako tablicę bajtów dwa: `0x80`, `0x00`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1619">However, 128, or `0x80`, is represented as a two-byte array: `0x80`, `0x00`.</span></span>  
  
 <span data-ttu-id="0fa7e-1620">Można wyrównana <xref:System.Numerics.BigInteger> wartości przez zapisanie jej na tablicę bajtów, a następnie przywróceniu go za pomocą <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1620">You can round-trip a <xref:System.Numerics.BigInteger> value by storing it to a byte array and then restoring it using the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0fa7e-1621">Kod zmienia wartość poszczególnych bajtów w tablicy zwracanej przez tę metodę, przed jego przywraca wartość, należy się upewnić, że nie przypadkowo zmienisz bitu znaku.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1621">If your code modifies the value of individual bytes in the array returned by this method before it restores the value, you must make sure that you do not unintentionally change the sign bit.</span></span> <span data-ttu-id="0fa7e-1622">Na przykład jeśli modyfikacje zwiększyć wartość dodatnią, dzięki czemu najwyższej kolejności bitu w ostatnim elemencie tablicy bajtów staje się ustawić, można dodać nowego typu byte, którego wartość wynosi zero do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1622">For example, if your modifications increase a positive value so that the highest-order bit in the last element of the byte array becomes set, you can add a new byte whose value is zero to the end of the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1623">Poniższy przykład przedstawia sposób niektóre <xref:System.Numerics.BigInteger> wartości są reprezentowane w tablice typu byte.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1623">The following example illustrates how some <xref:System.Numerics.BigInteger> values are represented in byte arrays.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1624">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1624">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0fa7e-1625">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1625">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1626">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1626">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1627"><xref:System.Numerics.BigInteger.ToString> Formatów metody <xref:System.Numerics.BigInteger> wartość "R" lub przesyłania danych, w formacie bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1627">The <xref:System.Numerics.BigInteger.ToString> method formats a <xref:System.Numerics.BigInteger> value in the "R", or round-trip, format of the current culture.</span></span> <span data-ttu-id="0fa7e-1628">Jeśli chcesz określić inny format lub kultury, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1628">If you want to specify a different format or culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="0fa7e-1629">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1629">To use format</span></span>|<span data-ttu-id="0fa7e-1630">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1630">For culture</span></span>|<span data-ttu-id="0fa7e-1631">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1631">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="0fa7e-1632">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1632">Round-trip ("R") format</span></span>|<span data-ttu-id="0fa7e-1633">Określoną kulturę</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1633">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%2A>|  
|<span data-ttu-id="0fa7e-1634">Określony format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1634">A specific format</span></span>|<span data-ttu-id="0fa7e-1635">Domyślną kulturę (bieżącego)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1635">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|<span data-ttu-id="0fa7e-1636">Określony format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1636">A specific format</span></span>|<span data-ttu-id="0fa7e-1637">Określoną kulturę</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1637">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="0fa7e-1638">Reprezentacja ciągu <xref:System.Numerics.BigInteger> wartość obejmuje znaku minus, jeśli jego wartość jest ujemna i sekwencję cyfr od 0 do 9 bez zerami.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1638">The string representation of the <xref:System.Numerics.BigInteger> value includes a negative sign if its value is negative, and a sequence of digits ranging from 0 to 9 without leading zeros.</span></span> <span data-ttu-id="0fa7e-1639">Znakiem minus jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1639">The negative sign is defined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1640">W poniższym przykładzie przedstawiono <xref:System.Numerics.BigInteger> wartość przy użyciu domyślnej <xref:System.Numerics.BigInteger.ToString> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1640">The following example displays a <xref:System.Numerics.BigInteger> value by using the default <xref:System.Numerics.BigInteger.ToString> method.</span></span> <span data-ttu-id="0fa7e-1641">Wyświetla również reprezentacji ciągu <xref:System.Numerics.BigInteger> wartość będącą wynikiem używanie niektórych specyfikatorów formatu standardowych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1641">It also displays the string representations of the <xref:System.Numerics.BigInteger> value that results from using some standard format specifiers.</span></span> <span data-ttu-id="0fa7e-1642">W przykładach jest używana konwencja formatowania kultury en-US.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1642">The examples are displayed using the formatting conventions of the en-US culture.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="0fa7e-1643">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1643">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1644">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne przy użyciu określonego formatowania informacje specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1644">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1645">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="provider" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1645">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="provider" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1646"><xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Formatów metody <xref:System.Numerics.BigInteger> wartość "R" lub przesłanie sformatować przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1646">The <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> method formats a <xref:System.Numerics.BigInteger> value in the "R", or round-trip, format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture.</span></span> <span data-ttu-id="0fa7e-1647">Jeśli chcesz określić inny format lub bieżącej kultury, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1647">If you want to specify a different format or the current culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="0fa7e-1648">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1648">To use format</span></span>|<span data-ttu-id="0fa7e-1649">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1649">For culture</span></span>|<span data-ttu-id="0fa7e-1650">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1650">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="0fa7e-1651">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1651">Round-trip ("R") format</span></span>|<span data-ttu-id="0fa7e-1652">Domyślną kulturę (bieżącego)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1652">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="0fa7e-1653">Określony format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1653">A specific format</span></span>|<span data-ttu-id="0fa7e-1654">Domyślną kulturę (bieżącego)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1654">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|<span data-ttu-id="0fa7e-1655">Określony format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1655">A specific format</span></span>|<span data-ttu-id="0fa7e-1656">Określoną kulturę</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1656">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="0fa7e-1657">`provider` Parametr jest <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1657">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="0fa7e-1658">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie ciągu zwracane przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1658">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string returned by this method.</span></span> <span data-ttu-id="0fa7e-1659">Jeśli `provider` jest `null`, <xref:System.Numerics.BigInteger> wartość jest sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1659">If `provider` is `null`, the <xref:System.Numerics.BigInteger> value is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span> <span data-ttu-id="0fa7e-1660">Tylko właściwości <xref:System.Globalization.NumberFormatInfo> obiekt, który kontroluje reprezentację ciągu <xref:System.Numerics.BigInteger> jest wartość przy użyciu specyfikatora formatu Ogólne <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, który definiuje znak, który reprezentuje znakiem minus.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1660">The only property of the <xref:System.Globalization.NumberFormatInfo> object that controls the string representation of the <xref:System.Numerics.BigInteger> value using the general format specifier is <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, which defines the character that represents the negative sign.</span></span>  
  
 <span data-ttu-id="0fa7e-1661">`provider` Parametr może być jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1661">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="0fa7e-1662">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1662">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="0fa7e-1663"><xref:System.Globalization.NumberFormatInfo> Obiektu, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1663">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="0fa7e-1664">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1664">A custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="0fa7e-1665">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1665">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1666">Poniższy przykład tworzy niestandardowy <xref:System.Globalization.NumberFormatInfo> obiektu, który definiuje tyldy (~) jako symbolu wartości ujemnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1666">The following example instantiates a custom <xref:System.Globalization.NumberFormatInfo> object that defines the tilde (~) as a negative sign.</span></span> <span data-ttu-id="0fa7e-1667"><xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Metoda używa niestandardowego <xref:System.Globalization.NumberFormatInfo> obiektu do wyświetlenia ujemny <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1667">The <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> method then uses the custom <xref:System.Globalization.NumberFormatInfo> object to display a negative <xref:System.Numerics.BigInteger> value.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="0fa7e-1668">Standardowy lub niestandardowy ciąg formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1668">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1669">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne przy użyciu określonego formatu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1669">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1670">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="format" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1670">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="format" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1671"><xref:System.Numerics.BigInteger.ToString%28System.String%29> Formatów metody <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiekt, który reprezentuje konwencje bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1671">The <xref:System.Numerics.BigInteger.ToString%28System.String%29> method formats a <xref:System.Numerics.BigInteger> value in a specified format by using a <xref:System.Globalization.NumberFormatInfo> object that represents the conventions of the current culture.</span></span> <span data-ttu-id="0fa7e-1672">Jeśli chcesz użyć "R" lub przesyłania danych, formatu lub określić inną kulturę, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1672">If you want to use the "R", or round-trip, format or specify a different culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="0fa7e-1673">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1673">To use format</span></span>|<span data-ttu-id="0fa7e-1674">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1674">For culture</span></span>|<span data-ttu-id="0fa7e-1675">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1675">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="0fa7e-1676">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1676">Round-trip ("R") format</span></span>|<span data-ttu-id="0fa7e-1677">Domyślną kulturę (bieżącego)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1677">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="0fa7e-1678">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1678">Round-trip ("R") format</span></span>|<span data-ttu-id="0fa7e-1679">Określoną kulturę</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1679">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|<span data-ttu-id="0fa7e-1680">Określony format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1680">A specific format</span></span>|<span data-ttu-id="0fa7e-1681">Określoną kulturę</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1681">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="0fa7e-1682">`format` Parametr może być dowolny prawidłowy [standardowy ciąg numeryczny](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolną kombinację [niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1682">The `format` parameter can be any valid [standard numeric string](~/docs/standard/base-types/standard-numeric-format-strings.md), or any combination of [custom numeric format strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="0fa7e-1683">Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest sformatowany w systemie specyfikator formatu obustronne ("R").</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1683">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the return value of the current <xref:System.Numerics.BigInteger> object is formatted with the round-trip format specifier ("R").</span></span> <span data-ttu-id="0fa7e-1684">Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1684">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="0fa7e-1685">Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1685">The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</span></span>  
  
-   <span data-ttu-id="0fa7e-1686">Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1686">For more information about numeric format specifiers, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="0fa7e-1687">Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1687">For more information about support for formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="0fa7e-1688">Format zwrócony ciąg jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1688">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="0fa7e-1689">W zależności od `format` parametr, ten obiekt określa symbole, takie jak znaku minus, separatora grupy i symbol punktu dziesiętnego w ciągu wyjściowego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1689">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="0fa7e-1690">Aby podać informacje dotyczące formatowania dla kultury niż bieżącej kultury, wywołaj <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1690">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1691">W poniższym przykładzie inicjowane <xref:System.Numerics.BigInteger> wartości i wyświetla je przy użyciu każdego ciągu standardowym formacie i niektórych niestandardowych ciągów formatu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1691">The following example initializes a <xref:System.Numerics.BigInteger> value and displays it by using each standard format string and some custom format strings.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0fa7e-1692"><paramref name="format" /> nie jest prawidłowym ciągiem formatu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1692"><paramref name="format" /> is not a valid format string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="0fa7e-1693">Standardowy lub niestandardowy ciąg formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1693">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="0fa7e-1694">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1694">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1695">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt do reprezentacji ciągu równoważne przy użyciu określonego formatu i informacji o formacie specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1695">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format and culture-specific format information.</span></span></summary>
        <returns><span data-ttu-id="0fa7e-1696">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość określoną przez <paramref name="format" /> i <paramref name="provider" /> parametrów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1696">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value as specified by the <paramref name="format" /> and <paramref name="provider" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1697"><xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Formatów metody <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1697">The <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method formats a <xref:System.Numerics.BigInteger> value in a specified format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture.</span></span> <span data-ttu-id="0fa7e-1698">Jeśli chcesz użyć formatu obustronne lub domyślne ustawienia kultury, użyj innego przeciążenia metody <xref:System.Numerics.BigInteger.ToString%2A> metody, w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1698">If you want to use the round-trip format or default culture settings, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="0fa7e-1699">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1699">To use format</span></span>|<span data-ttu-id="0fa7e-1700">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1700">For culture</span></span>|<span data-ttu-id="0fa7e-1701">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1701">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="0fa7e-1702">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1702">Round-trip ("R") format</span></span>|<span data-ttu-id="0fa7e-1703">Domyślną kulturę (bieżącego)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1703">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="0fa7e-1704">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1704">Round-trip ("R") format</span></span>|<span data-ttu-id="0fa7e-1705">Określoną kulturę</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1705">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|<span data-ttu-id="0fa7e-1706">Określony format</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1706">A specific format</span></span>|<span data-ttu-id="0fa7e-1707">Domyślną kulturę (bieżącego)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1707">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 <span data-ttu-id="0fa7e-1708">`format` Parametr może być dowolny prawidłowy [standardowy ciąg numeryczny](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolną kombinację [niestandardowe ciągi formatujące liczby](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1708">The `format` parameter can be any valid  [standard numeric string](~/docs/standard/base-types/standard-numeric-format-strings.md), or any combination of [custom numeric format strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="0fa7e-1709">Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest sformatowany w systemie specyfikator formatu obustronne ("R").</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1709">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the return value of the current <xref:System.Numerics.BigInteger> object is formatted with the round-trip format specifier ("R").</span></span> <span data-ttu-id="0fa7e-1710">Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1710">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="0fa7e-1711">Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1711">The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</span></span>  
  
-   <span data-ttu-id="0fa7e-1712">Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1712">For more information about numeric format specifiers, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="0fa7e-1713">Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1713">For more information about support for formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="0fa7e-1714">`provider` Parametr jest <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1714">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="0fa7e-1715">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie ciągu zwracane przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1715">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string returned by this method.</span></span> <span data-ttu-id="0fa7e-1716">Gdy <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> wywołania metody, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> — metoda i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1716">When the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method is invoked, it calls the `provider` parameter's <xref:System.IFormatProvider.GetFormat%2A> method and passes it a <xref:System.Type> object that represents the <xref:System.Globalization.NumberFormatInfo> type.</span></span> <span data-ttu-id="0fa7e-1717"><xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania `value` parametrów, takich jak symbolu wartości ujemnej, symbol separatora grupy lub symbol punktu dziesiętnego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1717">The <xref:System.IFormatProvider.GetFormat%2A> method then returns the <xref:System.Globalization.NumberFormatInfo> object that provides information for formatting the `value` parameter, such as the negative sign symbol, the group separator symbol, or the decimal point symbol.</span></span> <span data-ttu-id="0fa7e-1718">Istnieją trzy sposoby używania `provider` parametr, aby podać informacje dotyczące formatowania do <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metody:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1718">There are three ways to use the `provider` parameter to supply formatting information to the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method:</span></span>  
  
-   <span data-ttu-id="0fa7e-1719">Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1719">You can pass a <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="0fa7e-1720">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania dla tej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1720">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="0fa7e-1721">Można przekazać rzeczywiste <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1721">You can pass the actual <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="0fa7e-1722">(Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1722">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="0fa7e-1723">Można przekazać niestandardowego obiektu, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1723">You can pass a custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="0fa7e-1724">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1724">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="0fa7e-1725">Jeśli `provider` jest `null`, formatowanie zwrócony ciąg jest oparta na <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1725">If `provider` is `null`, the formatting of the returned string is based on the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1726">W poniższym przykładzie inicjowane <xref:System.Numerics.BigInteger> wartości i wyświetla je w konsoli przy użyciu ciągu standardowym formacie i <xref:System.Globalization.NumberFormatInfo> obiektu, który definiuje tyldy (~) jako symbolu wartości ujemnej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1726">The following example initializes a <xref:System.Numerics.BigInteger> value, and displays it to the console using a standard format string and a <xref:System.Globalization.NumberFormatInfo> object that defines the tilde (~) as a negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0fa7e-1727"><paramref name="format" /> nie jest prawidłowym ciągiem formatu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1727"><paramref name="format" /> is not a valid format string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1728">Podejmuje próbę przekonwertowania reprezentację ciągu numer w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1728">Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1729">Reprezentacja ciągu dla danej liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1729">The string representation of a number.</span></span></param>
        <param name="result"><span data-ttu-id="0fa7e-1730">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> odpowiednikiem liczba, która jest zawarta w <c>wartość</c>, lub zero (0), jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1730">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <c>value</c>, or zero (0) if the conversion fails.</span></span> <span data-ttu-id="0fa7e-1731">Konwersja nie powiedzie się, jeśli <c>wartość</c> parametr jest <see langword="null" /> lub nie ma poprawnego formatu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1731">The conversion fails if the <c>value</c> parameter is <see langword="null" /> or is not of the correct format.</span></span> <span data-ttu-id="0fa7e-1732">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1732">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1733">Podejmuje próbę przekonwertowania reprezentację ciągu numer w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1733">Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1734"><see langword="true" /> Jeśli <paramref name="value" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1734"><see langword="true" /> if <paramref name="value" /> was converted successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1735"><xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Przypomina metody <xref:System.Numerics.BigInteger.Parse%28System.String%29> metody, z wyjątkiem, że nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1735">The <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> method is like the <xref:System.Numerics.BigInteger.Parse%28System.String%29> method, except that it does not throw an exception if the conversion fails.</span></span> <span data-ttu-id="0fa7e-1736">Ta metoda eliminuje potrzebę Użyj obsługi wyjątków w celu zbadania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1736">This method eliminates the need to use exception handling to test for a <xref:System.FormatException> if `value` is invalid and cannot be successfully parsed.</span></span>  
  
 <span data-ttu-id="0fa7e-1737">`value` Parametr powinien być reprezentację liczby dziesiętnej w następującym formacie:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1737">The `value` parameter should be the string representation of a decimal number in the following form:</span></span>  
  
 <span data-ttu-id="0fa7e-1738">[*ws*] [*znak*]*cyfr*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1738">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1739">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1739">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="0fa7e-1740">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1740">The following table describes each element.</span></span>  
  
|<span data-ttu-id="0fa7e-1741">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1741">Element</span></span>|<span data-ttu-id="0fa7e-1742">Opis</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1742">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="0fa7e-1743">*ws*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1743">*ws*</span></span>|<span data-ttu-id="0fa7e-1744">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1744">Optional white space.</span></span>|  
|<span data-ttu-id="0fa7e-1745">*sign*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1745">*sign*</span></span>|<span data-ttu-id="0fa7e-1746">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1746">An optional sign.</span></span> <span data-ttu-id="0fa7e-1747">Nieprawidłowy znak znaki są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1747">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the current culture.</span></span>|  
|<span data-ttu-id="0fa7e-1748">*cyfr*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1748">*digits*</span></span>|<span data-ttu-id="0fa7e-1749">Sekwencja cyfr dziesiętnych od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1749">A sequence of decimal digits ranging from 0 to 9.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1750">Ciąg określony przez `value` parametr nie może zawierać żadnych separatorów grup lub separatora dziesiętnego i nie może mieć części dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1750">The string specified by the `value` parameter cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
 <span data-ttu-id="0fa7e-1751">`value` Parametr jest interpretowany za pomocą <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1751">The `value` parameter is interpreted by using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="0fa7e-1752">Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe z wiodącym znakiem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1752">In addition to the decimal digits, only leading and trailing spaces with a leading sign are allowed.</span></span> <span data-ttu-id="0fa7e-1753">Aby oznaczyć elementy style formatowania informacje specyficzne dla kultury, które mogą być obecne w `value`, wywołaj <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1753">To explicitly define the style elements with the culture-specific formatting information that can be present in `value`, call the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method.</span></span>  
  
 <span data-ttu-id="0fa7e-1754">`value` Parametru jest analizowana, korzystając z informacji formatowania w <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1754">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="0fa7e-1755">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1755">For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0fa7e-1756">Cyfr wszystkich zinterpretuje tego przeciążenia `value` parametr jako cyfr dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1756">This overload interprets all digits in the `value` parameter as decimal digits.</span></span> <span data-ttu-id="0fa7e-1757">Aby przeanalizować liczbę szesnastkową reprezentację ciągu, należy wywołać <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> zamiast tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1757">To parse the string representation of a hexadecimal number, call the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> overload instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1758">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1758">The following example uses the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> method to instantiate two <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="0fa7e-1759">W przypadku konwersji, mnoży każdego obiektu przez inny numer, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę, aby określić relacji między tymi dwoma obiektami.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1759">If the conversions succeed, it multiplies each object by another number and then calls the <xref:System.Numerics.BigInteger.Compare%2A> method to determine the relationship between the two objects.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0fa7e-1760"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1760"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0fa7e-1761">Reprezentacja ciągu dla danej liczby.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1761">The string representation of a number.</span></span> <span data-ttu-id="0fa7e-1762">Ten ciąg jest interpretowany przy użyciu stylu określony przez <c>styl</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1762">The string is interpreted using the style specified by <c>style</c>.</span></span></param>
        <param name="style"><span data-ttu-id="0fa7e-1763">Bitowe połączenie wartości wyliczenia wskazująca elementy style, które mogą być obecne w <c>wartość</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1763">A bitwise combination of enumeration values that indicates the style elements that can be present in <c>value</c>.</span></span> <span data-ttu-id="0fa7e-1764">Jest Typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1764">A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</span></span></param>
        <param name="provider"><span data-ttu-id="0fa7e-1765">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wartość</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1765">An object that supplies culture-specific formatting information about <c>value</c>.</span></span></param>
        <param name="result"><span data-ttu-id="0fa7e-1766">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> odpowiednikiem liczba, która jest zawarta w <c>wartość</c>, lub <see cref="P:System.Numerics.BigInteger.Zero" /> Jeśli konwersja nie powiodła się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1766">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <c>value</c>, or <see cref="P:System.Numerics.BigInteger.Zero" /> if the conversion failed.</span></span> <span data-ttu-id="0fa7e-1767">Konwersja nie powiedzie się, jeśli <c>wartość</c> parametr jest <see langword="null" /> lub nie jest w formacie, który jest zgodny ze <c>styl</c>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1767">The conversion fails if the <c>value</c> parameter is <see langword="null" /> or is not in a format that is compliant with <c>style</c>.</span></span> <span data-ttu-id="0fa7e-1768">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1768">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="0fa7e-1769">Podejmuje próbę przekonwertowania reprezentację ciągu liczbą określony styl i specyficzne dla kultury formatu w celu jego <see cref="T:System.Numerics.BigInteger" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1769">Tries to convert the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
        <returns>
          <span data-ttu-id="0fa7e-1770"><see langword="true" /> Jeśli <paramref name="value" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1770"><see langword="true" /> if the <paramref name="value" /> parameter was converted successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1771"><xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Przypomina metody <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody, z wyjątkiem, że nie zgłosić wyjątek, jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1771">The <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method is like the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method, except that it does not throw an exception if the conversion fails.</span></span> <span data-ttu-id="0fa7e-1772">Ta metoda eliminuje potrzebę Użyj obsługi wyjątków w celu zbadania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1772">This method eliminates the need to use exception handling to test for a <xref:System.FormatException> if `value` is invalid and cannot be parsed successfully.</span></span>  
  
 <span data-ttu-id="0fa7e-1773">`style` Parametru definiuje elementy stylu (na przykład biały znak lub znak dodatnie lub ujemne), które są dozwolone w `value` parametr powodzenie operacji analizy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1773">The `style` parameter defines the style elements (such as white space or a positive or negative sign) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="0fa7e-1774">Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1774">It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="0fa7e-1775">W zależności od wartości `style`, `value` parametr może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1775">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="0fa7e-1776">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1776">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1777">Jeśli `style` zawiera parametr <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` parametr może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1777">If the `style` parameter includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="0fa7e-1778">[*ws*]*hexdigits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1778">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="0fa7e-1779">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1779">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="0fa7e-1780">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1780">The following table describes each element.</span></span>  
  
|<span data-ttu-id="0fa7e-1781">Element</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1781">Element</span></span>|<span data-ttu-id="0fa7e-1782">Opis</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1782">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="0fa7e-1783">*ws*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1783">*ws*</span></span>|<span data-ttu-id="0fa7e-1784">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1784">Optional white space.</span></span> <span data-ttu-id="0fa7e-1785">Biały znak, może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagi, lub na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1785">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="0fa7e-1786">Symbol waluty specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1786">A culture-specific currency symbol.</span></span> <span data-ttu-id="0fa7e-1787">Jej położenie w ciągu jest definiowana za pomocą <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A> metody `provider` parametru.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1787">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter.</span></span> <span data-ttu-id="0fa7e-1788">Symbol waluty może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1788">The currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1789">*sign*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1789">*sign*</span></span>|<span data-ttu-id="0fa7e-1790">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1790">An optional sign.</span></span> <span data-ttu-id="0fa7e-1791">Logowania może wystąpić na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może występować na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1791">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="0fa7e-1792">Użycie nawiasów w `value` wskaż wartość ujemną, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1792">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1793">*cyfr*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1793">*digits*</span></span>|<span data-ttu-id="0fa7e-1794">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1794">A sequence of digits from 0 through 9.</span></span>|  
|<span data-ttu-id="0fa7e-1795">*,*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1795">*,*</span></span>|<span data-ttu-id="0fa7e-1796">Separator grupy specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1796">A culture-specific group separator.</span></span> <span data-ttu-id="0fa7e-1797">Separator grupy kultury określonej przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1797">The group separator of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1798">*.*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1798">*.*</span></span>|<span data-ttu-id="0fa7e-1799">Symbol dziesiętny specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1799">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="0fa7e-1800">Symbol punktu dziesiętnego kultury określonej przez `provider` może występować w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1800">The decimal point symbol of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1801">*fractional_digits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1801">*fractional_digits*</span></span>|<span data-ttu-id="0fa7e-1802">Jedno lub więcej wystąpień cyfry 0.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1802">One or more occurrences of the digit 0.</span></span> <span data-ttu-id="0fa7e-1803">Cyfr ułamkowych może występować w `value` tylko wtedy, gdy `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1803">Fractional digits can appear in `value` only if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1804">E</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1804">E</span></span>|<span data-ttu-id="0fa7e-1805">Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1805">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="0fa7e-1806">`value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1806">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1807">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1807">*exponential_digits*</span></span>|<span data-ttu-id="0fa7e-1808">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1808">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="0fa7e-1809">`value` Parametr może reprezentować liczbę w notacji wykładniczej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1809">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="0fa7e-1810">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1810">*hexdigits*</span></span>|<span data-ttu-id="0fa7e-1811">Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1811">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
 <span data-ttu-id="0fa7e-1812">Ciąg zawierający tylko cyfry dziesiętne (które odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flagi) zawsze przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1812">A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flag) always parses successfully.</span></span> <span data-ttu-id="0fa7e-1813">Większość pozostałych <xref:System.Globalization.NumberStyles> członkowie sterować elementy, które mogą być obecne, ale nie muszą znajdować się w tym ciągu wejściowego.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1813">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in this input string.</span></span> <span data-ttu-id="0fa7e-1814">W poniższej tabeli przedstawiono poszczególne <xref:System.Globalization.NumberStyles> elementów członkowskich mają wpływ na elementy, które mogą być obecne w `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1814">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="0fa7e-1815">Inne niż złożone `NumberStyles` wartości</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1815">Non-composite `NumberStyles` values</span></span>|<span data-ttu-id="0fa7e-1816">Dodatkowe (poza cyframi) elementy dozwolone w wartości</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1816">Elements permitted in value in addition to digits</span></span>|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="0fa7e-1817">Tylko cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1817">Decimal digits only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="0fa7e-1818">Dziesiętnego (*.*) i *fractional_digits* elementów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1818">The decimal point (*.*) and *fractional_digits* elements.</span></span> <span data-ttu-id="0fa7e-1819">Jednak *fractional_digits* musi składać się z jednego lub więcej cyfry 0 lub metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1819">However, *fractional_digits* must consist of only one or more 0 digits, or the method returns `false`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="0fa7e-1820">"E" lub litery "E", która wskazuje notacji wykładniczej, wraz z *exponential_digits*.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1820">The "e" or "E" character, which indicates exponential notation, along with *exponential_digits*.</span></span> <span data-ttu-id="0fa7e-1821">Jeśli `value` reprezentuje liczbę w notacji wykładniczej, nie może mieć inną niż zero, ułamkowych składnika.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1821">If `value` represents a number in exponential notation, it cannot have a non-zero, fractional component.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="0fa7e-1822">*Ws* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1822">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="0fa7e-1823">*Ws* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1823">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="0fa7e-1824">*Znak* element przed *cyfr*.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1824">The *sign* element before *digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="0fa7e-1825">*Znak* elementu po *cyfr*.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1825">The *sign* element after *digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="0fa7e-1826">*Znak* elementu w postaci nawiasów otaczającej wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1826">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="0fa7e-1827">Separator grupy (*,*) elementu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1827">The group separator (*,*) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="0fa7e-1828">Waluta (*$*) elementu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1828">The currency (*$*) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="0fa7e-1829">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1829">All elements.</span></span> <span data-ttu-id="0fa7e-1830">Jednak `value` nie może reprezentować liczbę szesnastkową lub numer w notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1830">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="0fa7e-1831">*Ws* elementu na początek lub koniec `value`, *znak* na początku `value`i dziesiętnego (*.*) symbolu.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1831">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (*.*) symbol.</span></span> <span data-ttu-id="0fa7e-1832">`value` Parametr można również użyć notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1832">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="0fa7e-1833">*Ws*, *znak*, grupy separatora (*,*), a separatorem dziesiętnym (*.*) elementów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1833">The *ws*, *sign*, group separator (*,*), and decimal point (*.*) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="0fa7e-1834">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1834">All elements.</span></span> <span data-ttu-id="0fa7e-1835">Jednak `value` nie może reprezentować liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1835">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="0fa7e-1836">Jeśli używasz <xref:System.Numerics.BigInteger.TryParse%2A> metody przesyłania danych reprezentację ciągu z <xref:System.Numerics.BigInteger> wartość, która została danych wyjściowych przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody z specyfikator formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1836">If you use the <xref:System.Numerics.BigInteger.TryParse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="0fa7e-1837">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 cyfr znaczących większość oryginalnej wartości i dane mogą zostać utracone, korzystając z <xref:System.Numerics.BigInteger.TryParse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1837">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.TryParse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1838">Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest wykorzystywana, `value` musi mieć wartość szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1838">If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `value` must be a hexadecimal value.</span></span> <span data-ttu-id="0fa7e-1839">Tylko innych flagi, które mogą być obecne w `style` są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1839">The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0fa7e-1840">( <xref:System.Globalization.NumberStyles> Wyliczenie ma stylu złożonego <xref:System.Globalization.NumberStyles.HexNumber>, zawierająca zarówno flagi biały znak.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1840">(The <xref:System.Globalization.NumberStyles> enumeration has a composite style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0fa7e-1841">Jeśli `value` reprezentacja ciągu z liczbą szesnastkową nie może być poprzedzone żadnych decoration (takich jak `0x` lub `&h`) który odróżnia go jako liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1841">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="0fa7e-1842">To powoduje niepowodzenie konwersji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1842">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="0fa7e-1843">Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> interpretuje metody `value` jako wartość ujemną przechowywane za pomocą dwóch jego reprezentacja dopełnienia, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równe `0x80`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1843">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="0fa7e-1844">Innymi słowy, metoda interpretuje bit najwyższej kolejności pierwszego bajtu w `value` jako bitem.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1844">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="0fa7e-1845">Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako wartość dodatnią, cyfry, w `value` musi mieć wartość zero.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1845">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="0fa7e-1846">Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartość dodatnią.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1846">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="0fa7e-1847">Poniższy przykład przedstawia różnice między ciągów szesnastkowych, które reprezentują wartości ujemnych i dodatnich.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1847">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 <span data-ttu-id="0fa7e-1848">`provider` Parametr jest <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1848">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="0fa7e-1849">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje specyficzne dla kultury o format `value`.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1849">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of `value`.</span></span> <span data-ttu-id="0fa7e-1850">`provider` Parametru może być jednym z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1850">The `provider` parameter can be any one of the following:</span></span>  
  
-   <span data-ttu-id="0fa7e-1851">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1851">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="0fa7e-1852">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania dla tej kultury.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1852">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="0fa7e-1853">A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje numeryczne formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1853">A <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="0fa7e-1854">(Jej implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca siebie, po prostu.)</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1854">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="0fa7e-1855">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1855">A custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="0fa7e-1856">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1856">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="0fa7e-1857">Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury jest używany.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1857">If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0fa7e-1858">Poniższy przykład powoduje, że niektóre wywołania <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodę przy użyciu różnych kombinacji wartości `style` i `provider` parametrów.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1858">The following example makes some calls to the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method using various combinations of values for the `style` and `provider` parameters.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 <span data-ttu-id="0fa7e-1859">Liczba wywołań poszczególnych <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku minus.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1859">A number of the individual calls to the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method pass an instance of the following `BigIntegerFormatProvider` class, which defines a tilde (~) as the negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0fa7e-1860"><paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1860"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
 <span data-ttu-id="0fa7e-1861">—lub—</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1861">-or-</span></span>  
  
 <span data-ttu-id="0fa7e-1862"><paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartość.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1862"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0fa7e-1863">Pobiera wartość reprezentującą liczbę 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1863">Gets a value that represents the number 0 (zero).</span></span></summary>
        <value><span data-ttu-id="0fa7e-1864">Liczba całkowita, którego wartość wynosi 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1864">An integer whose value is 0 (zero).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0fa7e-1865"><xref:System.Numerics.BigInteger> Obiektu zwróconego przez tę właściwość stanowi wygodny źródło wartość zerową dla przypisania i porównania.</span><span class="sxs-lookup"><span data-stu-id="0fa7e-1865">The <xref:System.Numerics.BigInteger> object returned by this property provides a convenient source of a zero value for use in assignments and comparisons.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>
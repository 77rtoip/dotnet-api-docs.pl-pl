<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="85a4380915d6023fb6b118226ee2acaef322ca38" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58710157" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8d479-101">Reprezentuje liczbę całkowitą dowolnie dużą podpisem.</span><span class="sxs-lookup"><span data-stu-id="8d479-101">Represents an arbitrarily large signed integer.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-102"><xref:System.Numerics.BigInteger> Typ jest typem niezmienne, który reprezentuje liczbę całkowitą dowolnie dużą, którego wartość teoretycznie nie ma żadnych granic górny lub niższą.</span><span class="sxs-lookup"><span data-stu-id="8d479-102">The <xref:System.Numerics.BigInteger> type is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds.</span></span> <span data-ttu-id="8d479-103">Elementy członkowskie <xref:System.Numerics.BigInteger> typu ściśle równoległe udostępnianych przez inne typy całkowitoliczbowe ( <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, i <xref:System.UInt64> typy).</span><span class="sxs-lookup"><span data-stu-id="8d479-103">The members of the <xref:System.Numerics.BigInteger> type closely parallel those of other integral types (the <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64> types).</span></span> <span data-ttu-id="8d479-104">Ten typ, który różni się od innych typów całkowitych w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], które mają zakres wskazywany przez ich `MinValue` i `MaxValue` właściwości.</span><span class="sxs-lookup"><span data-stu-id="8d479-104">This type differs from the other integral types in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], which have a range indicated by their `MinValue` and `MaxValue` properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d479-105">Ponieważ <xref:System.Numerics.BigInteger> typ jest niezmienny (zobacz [zmienność i struktura BigInteger](#mutability)) i ma on żadnych granic górnej i dolnej <xref:System.OutOfMemoryException> może zostać wygenerowany dla każdej operacji, która powoduje, że <xref:System.Numerics.BigInteger> wartość zbyt rozwijania duże.</span><span class="sxs-lookup"><span data-stu-id="8d479-105">Because the <xref:System.Numerics.BigInteger> type is immutable (see [Mutability and the BigInteger Structure](#mutability)) and because it has no upper or lower bounds, an <xref:System.OutOfMemoryException> can be thrown for any operation that causes a <xref:System.Numerics.BigInteger> value to grow too large.</span></span>  
  
## <a name="instantiating-a-biginteger-object"></a><span data-ttu-id="8d479-106">Utworzenie wystąpienia obiektu BigInteger</span><span class="sxs-lookup"><span data-stu-id="8d479-106">Instantiating a BigInteger Object</span></span>  
 <span data-ttu-id="8d479-107">Można utworzyć wystąpienie <xref:System.Numerics.BigInteger> obiekt na kilka sposobów:</span><span class="sxs-lookup"><span data-stu-id="8d479-107">You can instantiate a <xref:System.Numerics.BigInteger> object in several ways:</span></span>  
  
-   <span data-ttu-id="8d479-108">Możesz użyć `new` — słowo kluczowe i podaj wartości całkowitych lub zmiennoprzecinkowych jako parametr do <xref:System.Numerics.BigInteger> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-108">You can use the `new` keyword and provide any integral or floating-point value as a parameter to the <xref:System.Numerics.BigInteger> constructor.</span></span> <span data-ttu-id="8d479-109">(Różne wartości zmiennoprzecinkowe są obcinane przed przypisaniem do <xref:System.Numerics.BigInteger>.) Poniższy przykład ilustruje sposób używania `new` — słowo kluczowe do utworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-109">(Floating-point values are truncated before they are assigned to the <xref:System.Numerics.BigInteger>.) The following example illustrates how to use the `new` keyword to instantiate <xref:System.Numerics.BigInteger> values.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   <span data-ttu-id="8d479-110">Można zadeklarować <xref:System.Numerics.BigInteger> zmienną i przypisz wartości, tak jak miałoby to dowolnego typu liczbowego, tak długo, jak ta wartość jest typu całkowitego.</span><span class="sxs-lookup"><span data-stu-id="8d479-110">You can declare a <xref:System.Numerics.BigInteger> variable and assign it a value just as you would any numeric type, as long as that value is an integral type.</span></span> <span data-ttu-id="8d479-111">W poniższym przykładzie użyto przypisania, aby utworzyć <xref:System.Numerics.BigInteger> wartość z <xref:System.Int64>.</span><span class="sxs-lookup"><span data-stu-id="8d479-111">The following example uses assignment to create a <xref:System.Numerics.BigInteger> value from an <xref:System.Int64>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   <span data-ttu-id="8d479-112">Można przypisać wartość dziesiętną lub zmiennoprzecinkową do <xref:System.Numerics.BigInteger> obiekt można rzutować wartości lub przekonwertować go najpierw.</span><span class="sxs-lookup"><span data-stu-id="8d479-112">You can assign a decimal or floating-point value to a <xref:System.Numerics.BigInteger> object if you cast the value or convert it first.</span></span> <span data-ttu-id="8d479-113">Poniższy przykład jawnie rzutuje (w języku C#) lub konwertuje (w języku Visual Basic) <xref:System.Double> i <xref:System.Decimal> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-113">The following example explicitly casts (in C#) or converts (in Visual Basic) a <xref:System.Double> and a <xref:System.Decimal> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 <span data-ttu-id="8d479-114">Te metody umożliwiają utworzenia wystąpienia <xref:System.Numerics.BigInteger> tylko typy obiektów, których wartość znajduje się w zakresie jednej z istniejących numeryczne.</span><span class="sxs-lookup"><span data-stu-id="8d479-114">These methods enable you to instantiate a <xref:System.Numerics.BigInteger> object whose value is in the range of one of the existing numeric types only.</span></span> <span data-ttu-id="8d479-115">Można utworzyć wystąpienie <xref:System.Numerics.BigInteger> obiektu, którego wartość może przekroczyć zakres istniejące typy liczbowe w jeden z trzech sposobów:</span><span class="sxs-lookup"><span data-stu-id="8d479-115">You can instantiate a <xref:System.Numerics.BigInteger> object whose value can exceed the range of the existing numeric types in one of three ways:</span></span>  
  
-   <span data-ttu-id="8d479-116">Możesz użyć `new` — słowo kluczowe i podaj tablica bajtów o dowolnym rozmiarze <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-116">You can use the `new` keyword and provide a byte array of any size to the <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="8d479-117">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="8d479-117">For example:</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   <span data-ttu-id="8d479-118">Możesz wywołać <xref:System.Numerics.BigInteger.Parse%2A> lub <xref:System.Numerics.BigInteger.TryParse%2A> metody konwersji ciąg reprezentujący liczbę na <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-118">You can call the <xref:System.Numerics.BigInteger.Parse%2A> or <xref:System.Numerics.BigInteger.TryParse%2A> methods to convert the string representation of a number to a <xref:System.Numerics.BigInteger>.</span></span> <span data-ttu-id="8d479-119">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="8d479-119">For example:</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   <span data-ttu-id="8d479-120">Możesz wywołać `static` (`Shared` w języku Visual Basic) <xref:System.Numerics.BigInteger> metodę, która wykonuje niektóre operacje na wyrażenie liczbowe i zwraca obliczeniowego <xref:System.Numerics.BigInteger> wynik.</span><span class="sxs-lookup"><span data-stu-id="8d479-120">You can call a `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> method that performs some operation on a numeric expression and returns a calculated <xref:System.Numerics.BigInteger> result.</span></span> <span data-ttu-id="8d479-121">Poniższy przykład robi to przez cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> i przypisz wynik do <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-121">The following example does this by cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> and assigning the result to a <xref:System.Numerics.BigInteger>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 <span data-ttu-id="8d479-122">Wartość niezainicjowanej <xref:System.Numerics.BigInteger> jest <xref:System.Numerics.BigInteger.Zero%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d479-122">The uninitialized value of a <xref:System.Numerics.BigInteger> is <xref:System.Numerics.BigInteger.Zero%2A>.</span></span>  
  
## <a name="performing-operations-on-biginteger-values"></a><span data-ttu-id="8d479-123">Wykonywanie operacji na wartościach typu BigInteger</span><span class="sxs-lookup"><span data-stu-id="8d479-123">Performing Operations on BigInteger Values</span></span>  
 <span data-ttu-id="8d479-124">Możesz użyć <xref:System.Numerics.BigInteger> wystąpienia tak, jak możesz użyć dowolnego typu całkowitoliczbowego.</span><span class="sxs-lookup"><span data-stu-id="8d479-124">You can use a <xref:System.Numerics.BigInteger> instance as you would use any other integral type.</span></span> <span data-ttu-id="8d479-125"><xref:System.Numerics.BigInteger> Overloads standardowe operatory numeryczne umożliwiające wykonywanie podstawowych operacji matematycznych, takich jak dodawanie, odejmowanie, dzielenie, mnożenie, odejmowanie, negacji i Negacja Jednoargumentowa.</span><span class="sxs-lookup"><span data-stu-id="8d479-125"><xref:System.Numerics.BigInteger> overloads the standard numeric operators to enable you to perform basic mathematical operations such as addition, subtraction, division, multiplication, subtraction, negation, and unary negation.</span></span> <span data-ttu-id="8d479-126">Standardowe operatory numeryczne również służy do porównywania dwóch <xref:System.Numerics.BigInteger> wartości ze sobą.</span><span class="sxs-lookup"><span data-stu-id="8d479-126">You can also use the standard numeric operators to compare two <xref:System.Numerics.BigInteger> values with each other.</span></span> <span data-ttu-id="8d479-127">Inne typy całkowitoliczbowe, takich jak <xref:System.Numerics.BigInteger> obsługuje również operatora testu koniunkcji `And`, `Or`, `XOr`, pozostanie shift i operatory przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="8d479-127">Like the other integral types, <xref:System.Numerics.BigInteger> also supports the bitwise `And`, `Or`, `XOr`, left shift, and right shift operators.</span></span> <span data-ttu-id="8d479-128">W przypadku języków, które nie obsługują operatorów niestandardowych <xref:System.Numerics.BigInteger> struktura zapewnia również równoważne metody służące do wykonywania operacji matematycznych.</span><span class="sxs-lookup"><span data-stu-id="8d479-128">For languages that do not support custom operators, the <xref:System.Numerics.BigInteger> structure also provides equivalent methods for performing mathematical operations.</span></span> <span data-ttu-id="8d479-129">Obejmują one <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>oraz kilka innych.</span><span class="sxs-lookup"><span data-stu-id="8d479-129">These include <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, and several others.</span></span>  
  
 <span data-ttu-id="8d479-130">Wiele elementów członkowskich z <xref:System.Numerics.BigInteger> struktury odpowiadają bezpośrednio do elementów członkowskich inne typy całkowitoliczbowe.</span><span class="sxs-lookup"><span data-stu-id="8d479-130">Many members of the <xref:System.Numerics.BigInteger> structure correspond directly to members of the other integral types.</span></span> <span data-ttu-id="8d479-131">Ponadto <xref:System.Numerics.BigInteger> dodaje elementy członkowskie podobny do następującego:</span><span class="sxs-lookup"><span data-stu-id="8d479-131">In addition, <xref:System.Numerics.BigInteger> adds members such as the following:</span></span>  
  
-   <span data-ttu-id="8d479-132"><xref:System.Numerics.BigInteger.Sign%2A>, która zwraca wartość, która określa znak <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-132"><xref:System.Numerics.BigInteger.Sign%2A>, which returns a value that indicates the sign of a <xref:System.Numerics.BigInteger> value.</span></span>  
  
-   <span data-ttu-id="8d479-133"><xref:System.Numerics.BigInteger.Abs%2A>, która zwraca wartość bezwzględną liczby <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-133"><xref:System.Numerics.BigInteger.Abs%2A>, which returns the absolute value of a <xref:System.Numerics.BigInteger> value.</span></span>  
  
-   <span data-ttu-id="8d479-134"><xref:System.Numerics.BigInteger.DivRem%2A>, która zwraca iloraz i resztę z operacji dzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-134"><xref:System.Numerics.BigInteger.DivRem%2A>, which returns both the quotient and remainder of a division operation.</span></span>  
  
-   <span data-ttu-id="8d479-135"><xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, która zwraca największy wspólny dzielnik dwóch <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-135"><xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, which returns the greatest common divisor of two <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="8d479-136">Wiele z tych dodatkowych członków odnoszą się do elementów członkowskich <xref:System.Math> klasy, która oferuje funkcje do pracy z pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-136">Many of these additional members correspond to the members of the <xref:System.Math> class, which provides the functionality to work with the primitive numeric types.</span></span>  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a><span data-ttu-id="8d479-137">Zmienność i struktura BigInteger</span><span class="sxs-lookup"><span data-stu-id="8d479-137">Mutability and the BigInteger Structure</span></span>  
 <span data-ttu-id="8d479-138">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu, a następnie zwiększa jego wartości przez jeden.</span><span class="sxs-lookup"><span data-stu-id="8d479-138">The following example instantiates a <xref:System.Numerics.BigInteger> object and then increments its value by one.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 <span data-ttu-id="8d479-139">Do modyfikowania wartości istniejący obiekt jest wyświetlana w tym przykładzie, ale nie jest to przypadek.</span><span class="sxs-lookup"><span data-stu-id="8d479-139">Although this example appears to modify the value of the existing object, this is not the case.</span></span> <span data-ttu-id="8d479-140"><xref:System.Numerics.BigInteger> obiekty są niezmienne, co oznacza, że wewnętrznie, środowisko uruchomieniowe języka wspólnego tworzy nową <xref:System.Numerics.BigInteger> obiektu i przypisuje jej wartość większa o jeden od poprzedniej wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-140"><xref:System.Numerics.BigInteger> objects are immutable, which means that internally, the common language runtime actually creates a new <xref:System.Numerics.BigInteger> object and assigns it a value one greater than its previous value.</span></span> <span data-ttu-id="8d479-141">Ten nowy obiekt jest następnie zwracany do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="8d479-141">This new object is then returned to the caller.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d479-142">Inne typy liczbowe w programie .NET Framework, również są niezmienne.</span><span class="sxs-lookup"><span data-stu-id="8d479-142">The other numeric types in the .NET Framework are also immutable.</span></span> <span data-ttu-id="8d479-143">Jednak ponieważ <xref:System.Numerics.BigInteger> typ nie ma żadnych granic górnej i dolnej, jego wartości można powiększać bardzo dużych i ma zauważalnego wpływu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="8d479-143">However, because the <xref:System.Numerics.BigInteger> type has no upper or lower bounds, its values can grow extremely large and have a measurable impact on performance.</span></span>  
  
 <span data-ttu-id="8d479-144">Mimo że ten proces jest niewidoczny dla obiektu wywołującego, ona spowodować zmniejszenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="8d479-144">Although this process is transparent to the caller, it does incur a performance penalty.</span></span> <span data-ttu-id="8d479-145">W niektórych przypadkach, szczególnie gdy powtarzanych operacje są wykonywane w pętli na bardzo dużych <xref:System.Numerics.BigInteger> wartości, że spadek wydajności mogą być znaczące.</span><span class="sxs-lookup"><span data-stu-id="8d479-145">In some cases, especially when repeated operations are performed in a loop on very large <xref:System.Numerics.BigInteger> values, that performance penalty can be significant.</span></span> <span data-ttu-id="8d479-146">Na przykład w poniższym przykładzie jest wykonywane kilkukrotnie do milionów razy, a <xref:System.Numerics.BigInteger> wartość jest zwiększany o jeden, za każdym razem, gdy operacja powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8d479-146">For example, in the following example, an operation is performed repetitively up to a million times, and a <xref:System.Numerics.BigInteger> value is incremented by one every time the operation succeeds.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 <span data-ttu-id="8d479-147">W takim przypadku może poprawić wydajność, wykonując wszystkie pośrednie przypisania do <xref:System.Int32> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="8d479-147">In such a case, you can improve performance by performing all intermediate assignments to an <xref:System.Int32> variable.</span></span> <span data-ttu-id="8d479-148">Końcowa wartość zmiennej można przypisać do <xref:System.Numerics.BigInteger> obiektu, kiedy kończy pętli.</span><span class="sxs-lookup"><span data-stu-id="8d479-148">The final value of the variable can then be assigned to the <xref:System.Numerics.BigInteger> object when the loop exits.</span></span> <span data-ttu-id="8d479-149">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="8d479-149">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a><span data-ttu-id="8d479-150">Praca z tablicami bajtowymi i ciągami znaków szesnastkowych</span><span class="sxs-lookup"><span data-stu-id="8d479-150">Working with Byte Arrays and Hexadecimal Strings</span></span>  
 <span data-ttu-id="8d479-151">Po skonwertowaniu <xref:System.Numerics.BigInteger> wartości, które mają tablice typu byte, lub jeśli skonwertujesz tablice typu byte do <xref:System.Numerics.BigInteger> wartości, należy rozważyć kolejności bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-151">If you convert <xref:System.Numerics.BigInteger> values to byte arrays, or if you convert byte arrays to <xref:System.Numerics.BigInteger> values, you must consider the order of bytes.</span></span> <span data-ttu-id="8d479-152"><xref:System.Numerics.BigInteger> Struktury oczekuje pojedynczych bajtów w tablicy typu byte do są wyświetlane w kolejności little-endian (oznacza to, że wartość w bajtach niższego rzędu poprzedzać wyższego rzędu w bajtach).</span><span class="sxs-lookup"><span data-stu-id="8d479-152">The <xref:System.Numerics.BigInteger> structure expects the individual bytes in a byte array to appear in little-endian order (that is, the lower-order bytes of the value precede the higher-order bytes).</span></span> <span data-ttu-id="8d479-153">Możesz Rundy <xref:System.Numerics.BigInteger> wartość przez wywołanie metody <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przekazywanie wynikowy byte array do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="8d479-153">You can round-trip a <xref:System.Numerics.BigInteger> value by calling the <xref:System.Numerics.BigInteger.ToByteArray%2A> method and then passing the resulting byte array to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 <span data-ttu-id="8d479-154">Aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy bajtowej, która reprezentuje wartość całkowitą typu, można przekazać traktowanie wartości całkowitej <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody, a następnie przekaż wynikowy byte array do <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-154">To instantiate a <xref:System.Numerics.BigInteger> value from a byte array that represents a value of some other integral type, you can pass the integral value to the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method, and then pass the resulting byte array to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span> <span data-ttu-id="8d479-155">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy bajtowej, który reprezentuje <xref:System.Int16> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-155">The following example instantiates a <xref:System.Numerics.BigInteger> value from a byte array that represents an <xref:System.Int16> value.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <span data-ttu-id="8d479-156"><xref:System.Numerics.BigInteger> Struktury przyjęto założenie, że wartości ujemne są przechowywane przy użyciu reprezentacji uzupełnieniem do dwóch.</span><span class="sxs-lookup"><span data-stu-id="8d479-156">The <xref:System.Numerics.BigInteger> structure assumes that negative values are stored by using two's complement representation.</span></span> <span data-ttu-id="8d479-157">Ponieważ <xref:System.Numerics.BigInteger> struktury reprezentuje wartość numeryczną z brak stałej długości <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor interpretuje parametry zawsze najbardziej znaczący bit ostatniego bajtu w tablicy, jako bitu znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-157">Because the <xref:System.Numerics.BigInteger> structure represents a numeric value with no fixed length, the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor always interprets the most significant bit of the last byte in the array as a sign bit.</span></span> <span data-ttu-id="8d479-158">Aby zapobiec <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora z mylące dwójki uzupełnienie reprezentacja wartości ujemnej ze znakiem i wartość reprezentacja wartości dodatniej dodatnią wartości w którym najbardziej znaczący bit ostatniego bajtu w tablicy bajtowej normalnie jest zestaw powinny zawierać dodatkowe bajtów, którego wartość jest równa 0.</span><span class="sxs-lookup"><span data-stu-id="8d479-158">To prevent the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor from confusing the two's complement representation of a negative value with the sign and magnitude representation of a positive value, positive values in which the most significant bit of the last byte in the byte array would ordinarily be set should include an additional byte whose value is 0.</span></span> <span data-ttu-id="8d479-159">Na przykład 0xC0 0xBD 0xF0 0xFF jest reprezentacji szesnastkowej little-endian-1,000,000 lub 4,293,967,296.</span><span class="sxs-lookup"><span data-stu-id="8d479-159">For example, 0xC0 0xBD 0xF0 0xFF is the little-endian hexadecimal representation of either -1,000,000 or 4,293,967,296.</span></span> <span data-ttu-id="8d479-160">Ponieważ najbardziej znaczący bit ostatniego bajtu w tej tablicy na wartość tablica bajtów może być interpretowany przez <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor jako-1,000,000.</span><span class="sxs-lookup"><span data-stu-id="8d479-160">Because the most significant bit of the last byte in this array is on, the value of the byte array would be interpreted by the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor as -1,000,000.</span></span> <span data-ttu-id="8d479-161">Aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> którego wartość jest dodatnia, tablica bajtów, której elementy są 0xC0 0xBD 0xF0 0xFF 0x00 muszą być przekazywane do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-161">To instantiate a <xref:System.Numerics.BigInteger> whose value is positive, a byte array whose elements are 0xC0 0xBD 0xF0 0xFF 0x00 must be passed to the constructor.</span></span> <span data-ttu-id="8d479-162">Ilustruje to poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="8d479-162">The following example illustrates this.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 <span data-ttu-id="8d479-163">Tablice typu byte utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> metody z wartości dodatnich obejmują bajt dodatkowych wartości zero.</span><span class="sxs-lookup"><span data-stu-id="8d479-163">Byte arrays created by the <xref:System.Numerics.BigInteger.ToByteArray%2A> method from positive values include this extra zero-value byte.</span></span> <span data-ttu-id="8d479-164">W związku z tym <xref:System.Numerics.BigInteger> struktura może pomyślnie obustronne wartości przez przypisywanie ich do i przywracania ich z tablic bajtowych, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="8d479-164">Therefore, the <xref:System.Numerics.BigInteger> structure can successfully round-trip values by assigning them to, and then restoring them from, byte arrays, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 <span data-ttu-id="8d479-165">Może jednak może być konieczne dodanie dodatkowych bajt wartości zero do tablic bajtowych, które są tworzone dynamicznie przez dewelopera lub które są zwracane przez metody, które konwertują liczb całkowitych bez znaku do tablic bajtów (takie jak <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, i <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="8d479-165">However, you may need to add this additional zero-value byte to byte arrays that are created dynamically by the developer or that are returned by methods that convert unsigned integers to byte arrays (such as <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, and <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="8d479-166">Podczas analizowania ciąg szesnastkowy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> i <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metod przyjęto założenie, że jeśli ustawiono najbardziej znaczący bit pierwszego bajtu w ciągu lub jeżeli pierwsza cyfra szesnastkowa ciągu reprezentuje niższe cztery bity w wartości typu bajtowego, wartość to reprezentowane przy użyciu reprezentacji uzupełnieniem do dwóch.</span><span class="sxs-lookup"><span data-stu-id="8d479-166">When parsing a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> and <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> methods assume that if the most significant bit of the first byte in the string is set, or if the first hexadecimal digit of the string represents the lower four bits of a byte value, the value is represented by using two's complement representation.</span></span> <span data-ttu-id="8d479-167">Na przykład "FF01" i "F01" reprezentuje wartość dziesiętną-255.</span><span class="sxs-lookup"><span data-stu-id="8d479-167">For example, both "FF01" and "F01" represent the decimal value -255.</span></span> <span data-ttu-id="8d479-168">Do odróżnienia dodatnie, ujemne wartości, wartości dodatnich powinno obejmować zerem wiodącym.</span><span class="sxs-lookup"><span data-stu-id="8d479-168">To differentiate positive from negative values, positive values should include a leading zero.</span></span> <span data-ttu-id="8d479-169">Odpowiednie przeciążenia <xref:System.Numerics.BigInteger.ToString%2A> metody, gdy są przekazywane na ciąg formatu "X", Dodaj zera do zwracanego ciągu szesnastkowego dla wartości dodatnich.</span><span class="sxs-lookup"><span data-stu-id="8d479-169">The relevant overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, when they are passed the "X" format string, add a leading zero to the returned hexadecimal string for positive values.</span></span> <span data-ttu-id="8d479-170">Dzięki temu przesyłania danych <xref:System.Numerics.BigInteger> wartości przy użyciu <xref:System.Numerics.BigInteger.ToString%2A> i <xref:System.Numerics.BigInteger.Parse%2A> metod, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="8d479-170">This makes it possible to round-trip <xref:System.Numerics.BigInteger> values by using the <xref:System.Numerics.BigInteger.ToString%2A> and <xref:System.Numerics.BigInteger.Parse%2A> methods, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 <span data-ttu-id="8d479-171">Jednak ciągów szesnastkowych utworzonych przez wywoływanie `ToString` metod inne typy całkowitoliczbowe lub przeciążeń <xref:System.Convert.ToString%2A> metody, które obejmują `toBase` parametr wskazuje znak wartość lub typ źródła danych, z którego ciąg szesnastkowy został uzyskany.</span><span class="sxs-lookup"><span data-stu-id="8d479-171">However, the hexadecimal strings created by calling the `ToString` methods of the other integral types or the overloads of the <xref:System.Convert.ToString%2A> method that include a `toBase` parameter do not indicate the sign of the value or the source data type from which the hexadecimal string was derived.</span></span> <span data-ttu-id="8d479-172">Pomyślnie wystąpienia <xref:System.Numerics.BigInteger> wartości z ciągu znaków wymaga pewnych dodatkowej logiki.</span><span class="sxs-lookup"><span data-stu-id="8d479-172">Successfully instantiating a <xref:System.Numerics.BigInteger> value from such a string requires some additional logic.</span></span> <span data-ttu-id="8d479-173">W poniższym przykładzie przedstawiono jedną możliwą implementację.</span><span class="sxs-lookup"><span data-stu-id="8d479-173">The following example provides one possible implementation.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-174">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury.</span><span class="sxs-lookup"><span data-stu-id="8d479-174">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-175">Tablica wartości bajtów w kolejności little-endian.</span><span class="sxs-lookup"><span data-stu-id="8d479-175">An array of byte values in little-endian order.</span></span></param>
        <summary><span data-ttu-id="8d479-176">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury, używając wartości z tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-176">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using the values in a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-177">Poszczególne bajty `value` tablicy powinien znajdować się w kolejności little-endian, od najniższej kolejności bajtów do najwyższej kolejności bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-177">The individual bytes in the `value` array should be in little-endian order, from lowest-order byte to highest-order byte.</span></span> <span data-ttu-id="8d479-178">Na przykład wartość liczbowa 1,000,000,000,000 jest reprezentowane, jak pokazano w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="8d479-178">For example, the numeric value 1,000,000,000,000 is represented as shown in the following table:</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="8d479-179">Ciąg szesnastkowy</span><span class="sxs-lookup"><span data-stu-id="8d479-179">Hexadecimal string</span></span>|<span data-ttu-id="8d479-180">E8D4A51000</span><span class="sxs-lookup"><span data-stu-id="8d479-180">E8D4A51000</span></span>|  
|<span data-ttu-id="8d479-181">Tablica bajtów (najniższy indeks najpierw)</span><span class="sxs-lookup"><span data-stu-id="8d479-181">Byte array (lowest index first)</span></span>|<span data-ttu-id="8d479-182">00 10 A5 D4 E8 00</span><span class="sxs-lookup"><span data-stu-id="8d479-182">00 10 A5 D4 E8 00</span></span>|  
  
 <span data-ttu-id="8d479-183">Większość metod, które konwertują wartości liczbowych na tablice bajtów, takich jak <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> i <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, zwracają tablice bajtów w kolejności little-endian.</span><span class="sxs-lookup"><span data-stu-id="8d479-183">Most methods that convert numeric values to byte arrays, such as <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> and <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, return byte arrays in little-endian order.</span></span>  
  
 <span data-ttu-id="8d479-184">Konstruktor oczekuje wartości dodatnich w tablicy bajtów na potrzeby użycia reprezentacji uzupełnieniem do dwóch reprezentacja logowania i wielkości i wartości ujemnych.</span><span class="sxs-lookup"><span data-stu-id="8d479-184">The constructor expects positive values in the byte array to use sign-and-magnitude representation, and negative values to use two's complement representation.</span></span> <span data-ttu-id="8d479-185">Innymi słowy Jeśli najwyższego rzędu trochę bajt najwyższego rzędu w `value` ustawiono wartość wynikowa <xref:System.Numerics.BigInteger> wartość jest liczbą ujemną.</span><span class="sxs-lookup"><span data-stu-id="8d479-185">In other words, if the highest-order bit of the highest-order byte in `value` is set, the resulting <xref:System.Numerics.BigInteger> value is negative.</span></span> <span data-ttu-id="8d479-186">W zależności od źródła tablicy bajtowej może to spowodować wartość dodatnią zostać błędnie zinterpretowane jako wartość ujemną.</span><span class="sxs-lookup"><span data-stu-id="8d479-186">Depending on the source of the byte array, this may cause a positive value to be misinterpreted as a negative value.</span></span> <span data-ttu-id="8d479-187">Tablice typu byte zwykle są generowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8d479-187">Byte arrays are typically generated in the following ways:</span></span>  
  
-   <span data-ttu-id="8d479-188">Przez wywołanie metody <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-188">By calling the <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8d479-189">Ponieważ metoda ta zwraca tablicę bajtów od bitu najwyższego rzędu bajtu najwyższego rzędu w zestawie tablicy od zera dla wartości dodatnich, istnieje prawdopodobieństwo rozdzielnie wartości dodatniej jako ujemny.</span><span class="sxs-lookup"><span data-stu-id="8d479-189">Because this method returns a byte array with the highest-order bit of the highest-order byte in the array set to zero for positive values, there is no chance of misinterpreting a positive value as negative.</span></span> <span data-ttu-id="8d479-190">Tablice typu byte utworzone przez w niezmienionej postaci <xref:System.Numerics.BigInteger.ToByteArray%2A> zawsze pomyślnie Rundy, gdy są przekazywane do metody <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-190">Unmodified byte arrays created by the <xref:System.Numerics.BigInteger.ToByteArray%2A> method always successfully round-trip when they are passed to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span>  
  
-   <span data-ttu-id="8d479-191">Przez wywołanie metody <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody i przekazanie do niej oznaczoną liczbę całkowitą jako parametr.</span><span class="sxs-lookup"><span data-stu-id="8d479-191">By calling the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method and passing it a signed integer as a parameter.</span></span> <span data-ttu-id="8d479-192">Liczby całkowite ze znakiem obsługiwać reprezentacji logowania i wielkości i reprezentacji uzupełnieniem do dwóch, nie istnieje prawdopodobieństwo rozdzielnie wartości dodatniej jako ujemny.</span><span class="sxs-lookup"><span data-stu-id="8d479-192">Because signed integers handle both sign-and-magnitude representation and two's complement representation, there is no chance of misinterpreting a positive value as negative.</span></span>  
  
-   <span data-ttu-id="8d479-193">Przez wywołanie metody <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody i przekazanie do niej liczbę całkowitą bez znaku jako parametr.</span><span class="sxs-lookup"><span data-stu-id="8d479-193">By calling the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method and passing it an unsigned integer as a parameter.</span></span> <span data-ttu-id="8d479-194">Ponieważ liczb całkowitych bez znaku są reprezentowane przez ich znaczenie tylko, wartości dodatnich może być błędnie zinterpretowana jako wartości ujemnych.</span><span class="sxs-lookup"><span data-stu-id="8d479-194">Because unsigned integers are represented by their magnitude only, positive values can be misinterpreted as negative values.</span></span> <span data-ttu-id="8d479-195">Aby uniknąć tego błędnej interpretacji, można dodać wartość zero bajtów do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="8d479-195">To prevent this misinterpretation, you can add a zero-byte value to the end of the array.</span></span> <span data-ttu-id="8d479-196">W przykładzie w następnej sekcji stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="8d479-196">The example in the next section provides an illustration.</span></span>  
  
-   <span data-ttu-id="8d479-197">Tworząc tablicę bajtów albo dynamicznie lub statycznie bez niekoniecznie wywoływanie jednego z poprzednich metod lub przez zmodyfikowanie istniejącej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-197">By creating a byte array either dynamically or statically without necessarily calling any of the previous methods, or by modifying an existing byte array.</span></span> <span data-ttu-id="8d479-198">Aby zapobiec jest błędnie zinterpretowana jako wartości ujemnych wartości dodatnich, można dodać wartość zero bajtów do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="8d479-198">To prevent positive values from being misinterpreted as negative values, you can add a zero-byte value to the end of the array.</span></span>  
  
 <span data-ttu-id="8d479-199">Jeśli `value` jest pustym <xref:System.Byte> tablicy, nowa <xref:System.Numerics.BigInteger> obiekt jest inicjowany do wartości <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-199">If `value` is an empty <xref:System.Byte> array, the new <xref:System.Numerics.BigInteger> object is initialized to a value of <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-200">Jeśli `value` jest `null`, Konstruktor wyrzuca <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-200">If `value` is `null`, the constructor throws an <xref:System.ArgumentNullException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-201">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu z tablicy bajtowej 5-elementowej, w których wartość jest {5, 4, 3, 2, 1}.</span><span class="sxs-lookup"><span data-stu-id="8d479-201">The following example instantiates a <xref:System.Numerics.BigInteger> object from a 5-element byte array whose value is {5, 4, 3, 2, 1}.</span></span> <span data-ttu-id="8d479-202">Następnie wyświetla <xref:System.Numerics.BigInteger> reprezentowaną jako liczby dziesiętnej i szesnastkowa, w konsoli.</span><span class="sxs-lookup"><span data-stu-id="8d479-202">It then displays the <xref:System.Numerics.BigInteger> value, represented as both decimal and hexadecimal numbers, to the console.</span></span> <span data-ttu-id="8d479-203">Porównanie wartości tablicy wejściowej z tekstu wyjściowego sprawia, że jasne, dlaczego to przeciążenie <xref:System.Numerics.BigInteger> tworzy konstruktora klasy <xref:System.Numerics.BigInteger> obiektu, którego wartość jest 4328719365 (lub 0x102030405).</span><span class="sxs-lookup"><span data-stu-id="8d479-203">A comparison of the input array with the text output makes it clear why this overload of the <xref:System.Numerics.BigInteger> class constructor creates a <xref:System.Numerics.BigInteger> object whose value is 4328719365 (or 0x102030405).</span></span> <span data-ttu-id="8d479-204">Pierwszy element tablicy bajtowej, którego wartość to 5, określa wartość bajtu najniższego rzędu <xref:System.Numerics.BigInteger> obiektu, który jest 0x05.</span><span class="sxs-lookup"><span data-stu-id="8d479-204">The first element of the byte array, whose value is 5, defines the value of the lowest-order byte of the <xref:System.Numerics.BigInteger> object, which is 0x05.</span></span> <span data-ttu-id="8d479-205">Drugi element tablicy bajtowej, którego wartość to 4, określa wartość drugi bajt <xref:System.Numerics.BigInteger> obiektu, który jest 0x04 i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="8d479-205">The second element of the byte array, whose value is 4, defines the value of the second byte of the <xref:System.Numerics.BigInteger> object, which is 0x04, and so on.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 <span data-ttu-id="8d479-206">Poniższy przykład tworzy pozytywnych i negatywnych <xref:System.Numerics.BigInteger> wartość, przekazuje je do <xref:System.Numerics.BigInteger.ToByteArray%2A> metody, a następnie przywraca oryginalną <xref:System.Numerics.BigInteger> wartości z tablicą wynikową bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-206">The following example instantiates a positive and a negative <xref:System.Numerics.BigInteger> value, passes them to the <xref:System.Numerics.BigInteger.ToByteArray%2A> method, and then restores the original <xref:System.Numerics.BigInteger> values from the resulting byte array.</span></span> <span data-ttu-id="8d479-207">Należy pamiętać, że te dwie wartości są reprezentowane przez tablice bajtowe identyczne.</span><span class="sxs-lookup"><span data-stu-id="8d479-207">Note that the two values are represented by identical byte arrays.</span></span> <span data-ttu-id="8d479-208">Jedyną różnicą między nimi jest najbardziej znaczącego bitu po ostatnim elemencie w tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-208">The only difference between them is in the most significant bit of the last element in the byte array.</span></span> <span data-ttu-id="8d479-209">Ten bit jest ustawiona, (wartość bajtu to 0xFF), jeśli tablica jest tworzona z ujemnych <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-209">This bit is set (the value of the byte is 0xFF) if the array is created from a negative <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="8d479-210">Bit nie jest ustawiona, (wartość bajtu wynosi zero,), jeśli tablica jest tworzona z dodatnią <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-210">The bit is not set (the value of the byte is zero), if the array is created from a positive <xref:System.Numerics.BigInteger> value.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 <span data-ttu-id="8d479-211">Poniższy przykład ilustruje jak upewnić się, że wartość dodatnią nie niepoprawnie konkretyzacji jako wartość ujemną, dodając bajtów, którego wartość jest równa zero do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="8d479-211">The following example illustrates how to make sure that a positive value is not incorrectly instantiated as a negative value by adding a byte whose value is zero to the end of the array.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d479-212"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-212"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-213">Liczba dziesiętna.</span><span class="sxs-lookup"><span data-stu-id="8d479-213">A decimal number.</span></span></param>
        <summary><span data-ttu-id="8d479-214">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury za pomocą <see cref="T:System.Decimal" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-214">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a <see cref="T:System.Decimal" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-215">Wynik wywołania tego konstruktora jest taka sama jak przypisywanie jawnie <xref:System.Decimal> wartość <xref:System.Numerics.BigInteger> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="8d479-215">The result of calling this constructor is identical to explicitly assigning a <xref:System.Decimal> value to a <xref:System.Numerics.BigInteger> variable.</span></span>  
  
 <span data-ttu-id="8d479-216">Podczas wywoływania tego konstruktora może spowodować utratę danych; wszystkie części ułamkowej `value` zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-216">Calling this constructor can cause data loss; any fractional part of `value` is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-217">Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-217">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="8d479-218">Definiuje on tablicę <xref:System.Decimal> wartości, a następnie przekazuje każdą wartość w celu <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-218">It defines an array of <xref:System.Decimal> values, and then passes each value to the <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor.</span></span> <span data-ttu-id="8d479-219">Należy pamiętać, że <xref:System.Decimal> wartość zostanie obcięta zamiast zaokrąglane, gdy jest przypisany do <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-219">Note that the <xref:System.Decimal> value is truncated instead of rounded when it is assigned to the <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-220">Wartość zmiennoprzecinkowa podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="8d479-220">A double-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="8d479-221">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowe podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="8d479-221">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a double-precision floating-point value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-222">Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-222">Any fractional part of the `value` parameter is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="8d479-223">Ze względu na brak dokładność <xref:System.Double> typu danych, wywoływania tego konstruktora może spowodować utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-223">Because of the lack of precision of the <xref:System.Double> data type, calling this constructor can cause data loss.</span></span>  
  
 <span data-ttu-id="8d479-224"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z jawnie przypisywanie <xref:System.Double> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-224">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from explicitly assigning a <xref:System.Double> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-225">Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-225">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="8d479-226">Ilustruje także utratę dokładności, który może wystąpić, gdy używasz <xref:System.Double> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-226">It also illustrates the loss of precision that may occur when you use the <xref:System.Double> data type.</span></span> <span data-ttu-id="8d479-227">A <xref:System.Double> przypisano dużą wartość, która jest przypisywany do <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-227">A <xref:System.Double> is assigned a large value, which is then assigned to a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="8d479-228">Dane wyjściowe pokazują, to przypisanie pociąga za sobą utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="8d479-228">As the output shows, this assignment involves a loss of precision.</span></span> <span data-ttu-id="8d479-229">Obie wartości są następnie zwiększany o jeden.</span><span class="sxs-lookup"><span data-stu-id="8d479-229">Both values are then incremented by one.</span></span> <span data-ttu-id="8d479-230">Dane wyjściowe pokazują, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, natomiast <xref:System.Double> nie obsługuje obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-230">The output shows that the <xref:System.Numerics.BigInteger> object reflects the changed value, whereas the <xref:System.Double> object does not.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-231"><paramref name="value" /> jest <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-231"><paramref name="value" /> is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-232">Całkowita 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-232">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8d479-233">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości 32-bitową.</span><span class="sxs-lookup"><span data-stu-id="8d479-233">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 32-bit signed integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-234">Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-234">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> object by using this constructor.</span></span>  
  
 <span data-ttu-id="8d479-235"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.Int32> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-235">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning an <xref:System.Int32> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
 <span data-ttu-id="8d479-236"><xref:System.Numerics.BigInteger> Struktury nie ma konstruktorów z parametrem typu <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, lub <xref:System.UInt16>.</span><span class="sxs-lookup"><span data-stu-id="8d479-236">The <xref:System.Numerics.BigInteger> structure does not include constructors with a parameter of type <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, or <xref:System.UInt16>.</span></span> <span data-ttu-id="8d479-237">Jednak <xref:System.Int32> typ obsługuje niejawną konwersję 8-bitowych i 16-bitowe podpisane lub niepodpisane liczby całkowite na liczby całkowite ze znakiem 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-237">However, the <xref:System.Int32> type supports the implicit conversion of 8-bit and 16-bit signed and unsigned integers to signed 32-bit integers.</span></span> <span data-ttu-id="8d479-238">W wyniku tego konstruktora jest wywoływana, gdy `value` jest jednym z tych czterech typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8d479-238">As a result, this constructor is called if `value` is any one of these four integral types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-239">Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy 32-bitowych liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8d479-239">The following example calls the <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> constructor to instantiate <xref:System.Numerics.BigInteger> values from an array of 32-bit integers.</span></span> <span data-ttu-id="8d479-240">Korzysta również niejawna konwersja można przypisać każdą wartość 32-bitowej liczby całkowitej w celu <xref:System.Numerics.BigInteger> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="8d479-240">It also uses implicit conversion to assign each 32-bit integer value to a <xref:System.Numerics.BigInteger> variable.</span></span> <span data-ttu-id="8d479-241">Następnie porównuje dwie wartości ustalenie, czy wynikowy <xref:System.Numerics.BigInteger> wartości są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-241">It then compares the two values to establish that the resulting <xref:System.Numerics.BigInteger> values are the same.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-242">Całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-242">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8d479-243">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości liczby całkowitej ze znakiem 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-243">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 64-bit signed integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-244">Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-244">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> object by using this constructor.</span></span>  
  
 <span data-ttu-id="8d479-245"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.Int64> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-245">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning an <xref:System.Int64> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-246">Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości z tablicy, 64-bitowych liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8d479-246">The following example calls the <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> constructor to instantiate <xref:System.Numerics.BigInteger> values from an array of 64-bit integers.</span></span> <span data-ttu-id="8d479-247">Korzysta również niejawna konwersja można przypisać każdą wartość 64-bitowej liczby całkowitej w celu <xref:System.Numerics.BigInteger> zmiennej.</span><span class="sxs-lookup"><span data-stu-id="8d479-247">It also uses implicit conversion to assign each 64-bit integer value to a <xref:System.Numerics.BigInteger> variable.</span></span> <span data-ttu-id="8d479-248">Następnie porównuje dwie wartości ustalenie, czy wynikowy <xref:System.Numerics.BigInteger> wartości są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-248">It then compares the two values to establish that the resulting <xref:System.Numerics.BigInteger> values are the same.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-249">Wartość zmiennoprzecinkowa pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="8d479-249">A single-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="8d479-250">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowych pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="8d479-250">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a single-precision floating-point value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-251">Wszystkie części ułamkowej `value` parametru zostały obcięte podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-251">Any fractional part of the `value` parameter is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="8d479-252">Ze względu na brak dokładność <xref:System.Single> typu danych, wywoływania tego konstruktora może spowodować utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-252">Because of the lack of precision of the <xref:System.Single> data type, calling this constructor can result in data loss.</span></span>  
  
 <span data-ttu-id="8d479-253"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z jawnie przypisywanie <xref:System.Single> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-253">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from explicitly assigning a <xref:System.Single> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-254">Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-254">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="8d479-255">Ilustruje także utratę dokładności, który może wystąpić, gdy używasz <xref:System.Single> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-255">It also illustrates the loss of precision that may occur when you use the <xref:System.Single> data type.</span></span> <span data-ttu-id="8d479-256">A <xref:System.Single> przypisano dużą wartość ujemną, który jest przypisywany do <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-256">A <xref:System.Single> is assigned a large negative value, which is then assigned to a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="8d479-257">Dane wyjściowe pokazują, to przypisanie pociąga za sobą utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="8d479-257">As the output shows, this assignment involves a loss of precision.</span></span> <span data-ttu-id="8d479-258">Obie wartości są następnie zwiększany o jeden.</span><span class="sxs-lookup"><span data-stu-id="8d479-258">Both values are then incremented by one.</span></span> <span data-ttu-id="8d479-259">Dane wyjściowe pokazują, że <xref:System.Numerics.BigInteger> obiektu odzwierciedla zmieniona wartość, natomiast <xref:System.Single> nie obsługuje obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-259">The output shows that the <xref:System.Numerics.BigInteger> object reflects the changed value, whereas the <xref:System.Single> object does not.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-260"><paramref name="value" /> jest <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-260"><paramref name="value" /> is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-261">Liczba całkowita bez znaku 32-bitowa wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-261">An unsigned 32-bit integer value.</span></span></param>
        <summary><span data-ttu-id="8d479-262">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości bez znaku 32-bitowa liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="8d479-262">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using an unsigned 32-bit integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-263">Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-263">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> using this constructor.</span></span>  
  
 <span data-ttu-id="8d479-264"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.UInt32> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-264">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning a <xref:System.UInt32> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-265">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> Konstruktor i instrukcji przypisania, można zainicjować <xref:System.Numerics.BigInteger> wartości z tablicy liczb całkowitych bez znaku 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-265">The following example uses the <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> constructor and an assignment statement to initialize <xref:System.Numerics.BigInteger> values from an array of unsigned 32-bit integers.</span></span> <span data-ttu-id="8d479-266">Następnie porównuje dwie wartości i Wykaż, że te dwie metody inicjowania <xref:System.Numerics.BigInteger> wartość utworzyć takie same wyniki.</span><span class="sxs-lookup"><span data-stu-id="8d479-266">It then compares the two values to demonstrate that the two methods of initializing a <xref:System.Numerics.BigInteger> value produce identical results.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-267">64-bitowa liczba całkowita bez znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-267">An unsigned 64-bit integer.</span></span></param>
        <summary><span data-ttu-id="8d479-268">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.BigInteger" /> strukturę nieoznaczoną 64-bitowych wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-268">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure with an unsigned 64-bit integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-269">Istnieje bez utraty dokładności, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> za pomocą tego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-269">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> using this constructor.</span></span>  
  
 <span data-ttu-id="8d479-270"><xref:System.Numerics.BigInteger> Wartość będącą wynikiem wywołania tego konstruktora jest taka sama jak wartość, która wynika z przypisaniem <xref:System.UInt64> wartość <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-270">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning a <xref:System.UInt64> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-271">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> Konstruktor do tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość jest równa <xref:System.UInt64.MaxValue>.</span><span class="sxs-lookup"><span data-stu-id="8d479-271">The following example uses the <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object whose value is equal to <xref:System.UInt64.MaxValue>.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-272">Liczba z przedziału.</span><span class="sxs-lookup"><span data-stu-id="8d479-272">A number.</span></span></param>
        <summary><span data-ttu-id="8d479-273">Pobiera wartość bezwzględną liczby <see cref="T:System.Numerics.BigInteger" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-273">Gets the absolute value of a <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <returns><span data-ttu-id="8d479-274">Wartość bezwzględna <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-274">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-275">Wartość bezwzględna liczby jest tę liczbę bez znaku, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-275">The absolute value of a number is that number without its sign, as shown in the following table.</span></span>  
  
|<span data-ttu-id="8d479-276">`value` Parametr</span><span class="sxs-lookup"><span data-stu-id="8d479-276">`value` parameter</span></span>|<span data-ttu-id="8d479-277">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-277">Return value</span></span>|  
|-----------------------|------------------|  
|<span data-ttu-id="8d479-278">`value` >= 0</span><span class="sxs-lookup"><span data-stu-id="8d479-278">`value` >= 0</span></span>|`value`|  
|<span data-ttu-id="8d479-279">`value` < 0</span><span class="sxs-lookup"><span data-stu-id="8d479-279">`value` < 0</span></span>|<span data-ttu-id="8d479-280">`value` \* -1</span><span class="sxs-lookup"><span data-stu-id="8d479-280">`value` \* -1</span></span>|  
  
 <span data-ttu-id="8d479-281"><xref:System.Numerics.BigInteger.Abs%2A> Metoda jest równoważna <xref:System.Math.Abs%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-281">The <xref:System.Numerics.BigInteger.Abs%2A> method is equivalent to the <xref:System.Math.Abs%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-282">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Abs%2A> metodę, aby przekonwertować <xref:System.Numerics.BigInteger> wartości z reprezentacji uzupełnieniem do dwóch na reprezentację w postaci znaku i wielkości przed serializacji go do pliku.</span><span class="sxs-lookup"><span data-stu-id="8d479-282">The following example uses the <xref:System.Numerics.BigInteger.Abs%2A> method to convert a <xref:System.Numerics.BigInteger> value from two's complement representation to sign-and-magnitude representation before serializing it to a file.</span></span> <span data-ttu-id="8d479-283">Dane w pliku jest następnie deserializacji i przypisane do nowego <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-283">Data in the file is then deserialized and assigned to a new <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-284">Pierwsza wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="8d479-284">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-285">Druga wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="8d479-285">The second value to add.</span></span></param>
        <summary><span data-ttu-id="8d479-286">Dodaje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="8d479-286">Adds two <see cref="T:System.Numerics.BigInteger" /> values and returns the result.</span></span></summary>
        <returns><span data-ttu-id="8d479-287">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-287">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-288">Można używać języków, które nie obsługują przeciążanie operatora lub niestandardowych operatorów <xref:System.Numerics.BigInteger.Add%2A> metodę w celu dodania przy użyciu <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-288">Languages that do not support operator overloading or custom operators can use the <xref:System.Numerics.BigInteger.Add%2A> method to perform addition using <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="8d479-289"><xref:System.Numerics.BigInteger.Add%2A> Metoda jest przydatna zastępują operator dodawania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, przypisując go sum, który jest wynikiem dodawania, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8d479-289">The <xref:System.Numerics.BigInteger.Add%2A> method is a useful substitute for the addition operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it a sum that results from addition, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-290">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-290">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-291">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-291">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-292">Porównuje dwa <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca liczbę całkowitą, która wskazuje, czy pierwsza wartość jest mniejsza, równa lub większa niż wartość drugiego.</span><span class="sxs-lookup"><span data-stu-id="8d479-292">Compares two <see cref="T:System.Numerics.BigInteger" /> values and returns an integer that indicates whether the first value is less than, equal to, or greater than the second value.</span></span></summary>
        <returns><span data-ttu-id="8d479-293">Liczba całkowita wskazująca wartości względne <paramref name="left" /> i <paramref name="right" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-293">A signed integer that indicates the relative values of <paramref name="left" /> and <paramref name="right" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="8d479-294">Wartość</span><span class="sxs-lookup"><span data-stu-id="8d479-294">Value</span></span> 
 </term><description> <span data-ttu-id="8d479-295">Warunek</span><span class="sxs-lookup"><span data-stu-id="8d479-295">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="8d479-296">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="8d479-296">Less than zero</span></span> 
 </term><description><span data-ttu-id="8d479-297"><paramref name="left" /> jest mniejsza niż <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-297"><paramref name="left" /> is less than <paramref name="right" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-298">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-298">Zero</span></span> 
 </term><description><span data-ttu-id="8d479-299"><paramref name="left" /> równa się <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-299"><paramref name="left" /> equals <paramref name="right" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-300">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="8d479-300">Greater than zero</span></span> 
 </term><description><span data-ttu-id="8d479-301"><paramref name="left" /> jest większa niż <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-301"><paramref name="left" /> is greater than <paramref name="right" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-302">Mimo że <xref:System.Numerics.BigInteger> typ ma zakres stałych nie porównania <xref:System.Numerics.BigInteger> wartości nie charakteryzują się brak dokładności, który charakteryzuje porównanie liczb zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-302">Although the <xref:System.Numerics.BigInteger> type has no fixed range, comparisons of <xref:System.Numerics.BigInteger> values are not characterized by the lack of precision that characterizes the comparison of floating-point numbers.</span></span> <span data-ttu-id="8d479-303">W poniższym przykładzie porównano dwa <xref:System.Numerics.BigInteger> wartości, które różnią się jednym i że każdy ma 1,896 cyfr.</span><span class="sxs-lookup"><span data-stu-id="8d479-303">The following example compares two <xref:System.Numerics.BigInteger> values that differ by one and that each have 1,896 digits.</span></span> <span data-ttu-id="8d479-304"><xref:System.Numerics.BigInteger.Compare%2A> Metoda zgłasza poprawnie, dwie wartości nie są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-304">The <xref:System.Numerics.BigInteger.Compare%2A> method correctly reports that the two values are not equal.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-305">Porównuje wartość tego wystąpienia przy użyciu innej wartości i zwraca wartość całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa od innych wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-305">Compares the value of this instance with another value and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the other value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="8d479-306">64-bitowej liczby całkowitej ze znakiem do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-306">The signed 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-307">Porównuje to wystąpienie całkowita 64-bitowa i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość całkowita 64-bitowa.</span><span class="sxs-lookup"><span data-stu-id="8d479-307">Compares this instance to a signed 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the signed 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-308">Wartość liczby całkowitej ze znakiem, która określa relację tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-308">A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="8d479-309">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-309">Return value</span></span> 
 </term><description> <span data-ttu-id="8d479-310">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-310">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="8d479-311">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="8d479-311">Less than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-312">Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-312">The current instance is less than <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-313">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-313">Zero</span></span> 
 </term><description> <span data-ttu-id="8d479-314">Bieżące wystąpienie jest równe <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-314">The current instance equals <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-315">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="8d479-315">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-316">Bieżące wystąpienie jest większa niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-316">The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-317">Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość przy <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="8d479-317">If `other` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-318">W poniższym przykładzie pokazano wyniku wywołania metody <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metody za pomocą wartości całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8d479-318">The following example illustrates the result of calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> method with integral values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="8d479-319">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-319">The object to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-320">Porównuje to wystąpienie sekundy <see cref="T:System.Numerics.BigInteger" /> i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-320">Compares this instance to a second <see cref="T:System.Numerics.BigInteger" /> and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</span></span></summary>
        <returns><span data-ttu-id="8d479-321">Wartość liczby całkowitej ze znakiem, która określa relację tego wystąpienia <paramref name="other" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-321">A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="8d479-322">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-322">Return value</span></span> 
 </term><description> <span data-ttu-id="8d479-323">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-323">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="8d479-324">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="8d479-324">Less than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-325">Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-325">The current instance is less than <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-326">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-326">Zero</span></span> 
 </term><description> <span data-ttu-id="8d479-327">Bieżące wystąpienie jest równe <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-327">The current instance equals <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-328">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="8d479-328">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-329">Bieżące wystąpienie jest większa niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-329">The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-330">To przeciążenie <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metodę <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-330">This overload of the <xref:System.Numerics.BigInteger.CompareTo%2A> method implements the <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8d479-331">Jest używana przez obiekty kolekcji ogólnej w celu uporządkowania elementów w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="8d479-331">It is used by generic collection objects to order the items in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-332">Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metody, aby uporządkować listę `StarInfo` obiektów.</span><span class="sxs-lookup"><span data-stu-id="8d479-332">The following example illustrates the use of the <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> method to order a list of `StarInfo` objects.</span></span> <span data-ttu-id="8d479-333">Każdy `StarInfo` obiektu zawiera informacje dotyczące Star oraz jego odległości od ziemi w milach.</span><span class="sxs-lookup"><span data-stu-id="8d479-333">Each `StarInfo` object provides information about a star's name and its distance from the Earth in miles.</span></span> <span data-ttu-id="8d479-334">`StarInfo` implementuje <xref:System.IComparable%601> interfejsu, co pozwoli `StarInfo` obiekty, które mają być sortowane według klasy kolekcji rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="8d479-334">`StarInfo` implements the <xref:System.IComparable%601> interface, which enables `StarInfo` objects to be sorted by generic collection classes.</span></span> <span data-ttu-id="8d479-335">Jego <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementacji jest po prostu zawija wywołanie do <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.</span><span class="sxs-lookup"><span data-stu-id="8d479-335">Its <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementation just wraps a call to <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 <span data-ttu-id="8d479-336">Poniższy kod tworzy następnie cztery `StarInfo` obiekty i przechowuje je w ogólnej metodzie <xref:System.Collections.Generic.List%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-336">The following code then instantiates four `StarInfo` objects and stores them in a generic <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="8d479-337">Po <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> metoda jest wywoływana, `StarInfo` obiekty są wyświetlane w kolejności ich odległości od ziemi.</span><span class="sxs-lookup"><span data-stu-id="8d479-337">After the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method is called, `StarInfo` objects are displayed in order of their distance from the Earth.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="8d479-338">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-338">The object to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-339">Porównuje to wystąpienie określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-339">Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</span></span></summary>
        <returns><span data-ttu-id="8d479-340">Liczba całkowita wskazująca relację bieżącego wystąpienia do <paramref name="obj" /> parametru, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-340">A signed integer that indicates the relationship of the current instance to the <paramref name="obj" /> parameter, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="8d479-341">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-341">Return value</span></span> 
 </term><description> <span data-ttu-id="8d479-342">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-342">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="8d479-343">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="8d479-343">Less than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-344">Bieżące wystąpienie jest mniejsza niż <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-344">The current instance is less than <paramref name="obj" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-345">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-345">Zero</span></span> 
 </term><description> <span data-ttu-id="8d479-346">Bieżące wystąpienie jest równe <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-346">The current instance equals <paramref name="obj" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-347">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="8d479-347">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-348">Bieżące wystąpienie jest większa niż <paramref name="obj" />, lub <paramref name="obj" /> parametr <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-348">The current instance is greater than <paramref name="obj" />, or the <paramref name="obj" /> parameter is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-349">To przeciążenie <xref:System.Numerics.BigInteger.CompareTo%2A> implementuje metodę <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-349">This overload of the <xref:System.Numerics.BigInteger.CompareTo%2A> method implements the <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8d479-350">Jest używana przez obiekty nieogólna kolekcja w celu uporządkowania elementów w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="8d479-350">It is used by non-generic collection objects to order the items in the collection.</span></span>  
  
 <span data-ttu-id="8d479-351">`obj` Parametr musi mieć jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="8d479-351">The `obj` parameter must be one of the following:</span></span>  
  
-   <span data-ttu-id="8d479-352">Obiekt o typie środowiska wykonawczego <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="8d479-352">An object whose run-time type is <xref:System.Numerics.BigInteger>.</span></span>  
  
-   <span data-ttu-id="8d479-353"><xref:System.Object> Zmienna, której wartość jest `null`.</span><span class="sxs-lookup"><span data-stu-id="8d479-353">An <xref:System.Object> variable whose value is `null`.</span></span> <span data-ttu-id="8d479-354">Jeśli wartość `obj` parametr jest `null`, metoda zwraca wartość 1, co wskazuje, czy bieżące wystąpienie jest większa niż `obj`.</span><span class="sxs-lookup"><span data-stu-id="8d479-354">If the value of the `obj` parameter is `null`, the method returns 1, which indicates that the current instance is greater than `obj`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-355">Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodę, aby porównać <xref:System.Numerics.BigInteger> wartość, przy czym każdy element w tablicy obiektu</span><span class="sxs-lookup"><span data-stu-id="8d479-355">The following example calls the <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> method to compare a <xref:System.Numerics.BigInteger> value with each element in an object array</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d479-356"><paramref name="obj" /> nie jest <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-356"><paramref name="obj" /> is not a <see cref="T:System.Numerics.BigInteger" />.</span></span></exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="8d479-357">64-bitowa liczba całkowita bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-357">The unsigned 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-358">Porównuje to wystąpienie na liczbę całkowitą bez znaku 64-bitowych i zwraca wartość całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza, równa lub większa niż wartość Liczba całkowita bez znaku 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-358">Compares this instance to an unsigned 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the unsigned 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-359">Liczby całkowitej ze znakiem, która wskazuje względną wartość tego wystąpienia i <paramref name="other" />, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-359">A signed integer that indicates the relative value of this instance and <paramref name="other" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="8d479-360">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-360">Return value</span></span> 
 </term><description> <span data-ttu-id="8d479-361">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-361">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="8d479-362">Mniej niż zero</span><span class="sxs-lookup"><span data-stu-id="8d479-362">Less than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-363">Bieżące wystąpienie jest mniejsza niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-363">The current instance is less than <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-364">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-364">Zero</span></span> 
 </term><description> <span data-ttu-id="8d479-365">Bieżące wystąpienie jest równe <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-365">The current instance equals <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-366">Większe od zera</span><span class="sxs-lookup"><span data-stu-id="8d479-366">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="8d479-367">Bieżące wystąpienie jest większa niż <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-367">The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="8d479-368">Wartość do podzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-368">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="8d479-369">Wartość do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-369">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="8d479-370">Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartość innym i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="8d479-370">Divides one <see cref="T:System.Numerics.BigInteger" /> value by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="8d479-371">Iloraz z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-371">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-372"><xref:System.Numerics.BigInteger.Divide%2A> Metoda wykonuje dzielenie liczby całkowitej; będącej wynikiem dzielenia reszta zostanie odrzucony.</span><span class="sxs-lookup"><span data-stu-id="8d479-372">The <xref:System.Numerics.BigInteger.Divide%2A> method performs integer division; any remainder that results from the division is discarded.</span></span> <span data-ttu-id="8d479-373">Aby wykonać dzielenie liczby całkowitej, zachowując przy tym resztę, należy wywołać <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-373">To perform integer division while preserving the remainder, call the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span> <span data-ttu-id="8d479-374">Aby pobrać tylko resztę, należy wywołać <xref:System.Numerics.BigInteger.Remainder%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-374">To retrieve only the remainder, call the <xref:System.Numerics.BigInteger.Remainder%2A> method.</span></span>  
  
 <span data-ttu-id="8d479-375"><xref:System.Numerics.BigInteger.Divide%2A> Metoda może być używana przez języki, które nie obsługują przeciążanie operatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-375">The <xref:System.Numerics.BigInteger.Divide%2A> method can be used by languages that do not support operator overloading.</span></span> <span data-ttu-id="8d479-376">Jego zachowanie jest identyczne z dzielenia przy użyciu operator dzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-376">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-377">Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-377">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-378">Następnie używa każdy element jako iloraz w operacji dzielenia, który używa <xref:System.Numerics.BigInteger.Divide%2A> metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-378">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="8d479-379"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-379"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="8d479-380">Wartość do podzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-380">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="8d479-381">Wartość do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-381">The value to divide by.</span></span></param>
        <param name="remainder"><span data-ttu-id="8d479-382">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> wartość, która reprezentuje resztę z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-382">When this method returns, contains a <see cref="T:System.Numerics.BigInteger" /> value that represents the remainder from the division.</span></span> <span data-ttu-id="8d479-383">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8d479-383">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="8d479-384">Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartość i zwraca wynik i zwraca resztę z dzielenia parametr danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-384">Divides one <see cref="T:System.Numerics.BigInteger" /> value by another, returns the result, and returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="8d479-385">Iloraz z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-385">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-386">Ta metoda umożliwia zachowanie zarówno iloraz i resztę, która wynika z dzielenia liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-386">This method preserves both the quotient and the remainder that results from integer division.</span></span> <span data-ttu-id="8d479-387">Jeśli nie jesteś zainteresowany resztę, użyj <xref:System.Numerics.BigInteger.Divide%2A> metoda lub operator dzielenia; jeśli tylko są Państwo zainteresowani resztę, użyj <xref:System.Numerics.BigInteger.Remainder%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-387">If you are not interested in the remainder, use the <xref:System.Numerics.BigInteger.Divide%2A> method or the division operator; if you are only interested in the remainder, use the <xref:System.Numerics.BigInteger.Remainder%2A> method.</span></span>  
  
 <span data-ttu-id="8d479-388">Znak zwracanego `remainder` wartość jest taka sama, jak znak `dividend` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-388">The sign of the returned `remainder` value is the same as the sign of the `dividend` parameter.</span></span>  
  
 <span data-ttu-id="8d479-389">Zachowanie <xref:System.Numerics.BigInteger.DivRem%2A> metody jest taka sama jak w przypadku <xref:System.Math.DivRem%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-389">The behavior of the <xref:System.Numerics.BigInteger.DivRem%2A> method is identical to that of the <xref:System.Math.DivRem%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-390">Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-390">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-391">Następnie używa każdy element jako iloraz w operacji dzielenia, który używa <xref:System.Numerics.BigInteger.Divide%2A> metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-391">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="8d479-392"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-392"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-393">Zwraca wartość wskazującą, czy dwie wartości liczbowe są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-393">Returns a value that indicates whether two numeric values are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="8d479-394">Wartość całkowita 64-bitowa do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-394">The signed 64-bit integer value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-395">Zwraca wartość wskazującą, czy bieżące wystąpienie i całkowita 64-bitowa mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-395">Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.</span></span></summary>
        <returns><span data-ttu-id="8d479-396"><see langword="true" /> Jeśli całkowita 64-bitowa i bieżące wystąpienie ma tę samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-396"><see langword="true" /> if the signed 64-bit integer and the current instance have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-397">Jeśli `other` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość po wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-397">If `other` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the method is called.</span></span>  
  
 <span data-ttu-id="8d479-398">Aby określić relację między dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-398">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-399">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiekt z każdym typem integralnym oprócz <xref:System.UInt64>.</span><span class="sxs-lookup"><span data-stu-id="8d479-399">The following example instantiates a <xref:System.Numerics.BigInteger> object from each integral type except <xref:System.UInt64>.</span></span> <span data-ttu-id="8d479-400">Następnie wywołuje <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metodę, aby porównać <xref:System.Numerics.BigInteger> wartość z oryginalnym wartość całkowitą, która została przekazana do <xref:System.Numerics.BigInteger> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-400">It then calls the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> method to compare the <xref:System.Numerics.BigInteger> value with the original integer value that was passed to the <xref:System.Numerics.BigInteger> constructor.</span></span> <span data-ttu-id="8d479-401">Dane wyjściowe pokazują, wartości są równe, w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="8d479-401">As the output shows, the values are equal in each case.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="8d479-402">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-402">The object to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-403">Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony <see cref="T:System.Numerics.BigInteger" /> obiekt ma taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-403">Returns a value that indicates whether the current instance and a specified <see cref="T:System.Numerics.BigInteger" /> object have the same value.</span></span></summary>
        <returns><span data-ttu-id="8d479-404"><see langword="true" /> Jeśli ten <see cref="T:System.Numerics.BigInteger" /> obiektu i <paramref name="other" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-404"><see langword="true" /> if this <see cref="T:System.Numerics.BigInteger" /> object and <paramref name="other" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-405">Ta metoda implementuje <xref:System.IEquatable%601> interfejs i wykonuje nieco lepiej niż <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , ponieważ nie trzeba przekonwertować `other` parametr <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-405">This method implements the <xref:System.IEquatable%601> interface and performs slightly better than <xref:System.Numerics.BigInteger.Equals%28System.Object%29> because it does not have to convert the `other` parameter to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="8d479-406">Aby określić relacji między tymi dwoma <xref:System.Numerics.BigInteger> obiekty zamiast tylko testowanie pod kątem równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-406">To determine the relationship between the two <xref:System.Numerics.BigInteger> objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-407">W poniższym przykładzie porównano przybliżony odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby ustalić, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-407">The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</span></span> <span data-ttu-id="8d479-408">W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="8d479-408">The example uses each overload of the <xref:System.Numerics.BigInteger.Equals%2A> method to test for equality.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="8d479-409">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-409">The object to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-410">Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt ma taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-410">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="8d479-411"><see langword="true" /> Jeśli <paramref name="obj" /> argument jest <see cref="T:System.Numerics.BigInteger" /> obiekt i jego wartość jest równa wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> wystąpienia; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-411"><see langword="true" /> if the <paramref name="obj" /> argument is a <see cref="T:System.Numerics.BigInteger" /> object, and its value is equal to the value of the current <see cref="T:System.Numerics.BigInteger" /> instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-412">Jeśli `obj` argument nie jest <xref:System.Numerics.BigInteger> wartości, metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="8d479-412">If the `obj` argument is not a <xref:System.Numerics.BigInteger> value, the method returns `false`.</span></span> <span data-ttu-id="8d479-413">Metoda ta zwraca `true` tylko wtedy, gdy `obj` jest <xref:System.Numerics.BigInteger> wystąpienie, którego wartość jest równa bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="8d479-413">The method returns `true` only if `obj` is a <xref:System.Numerics.BigInteger> instance whose value is equal to the current instance.</span></span>  
  
 <span data-ttu-id="8d479-414">Aby określić relację między dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-414">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-415">W poniższym przykładzie zdefiniowano równoległych <xref:System.Object> i <xref:System.Numerics.BigInteger> tablic.</span><span class="sxs-lookup"><span data-stu-id="8d479-415">The following example defines parallel <xref:System.Object> and <xref:System.Numerics.BigInteger> arrays.</span></span> <span data-ttu-id="8d479-416">Każdy element tablicy ma taką samą wartość jak odpowiadający mu element druga tablica.</span><span class="sxs-lookup"><span data-stu-id="8d479-416">Each element of one array has the same value as the corresponding element of the second array.</span></span> <span data-ttu-id="8d479-417">Jak wynika z w przykładzie przedstawiono wystąpienia w <xref:System.Numerics.BigInteger> tablicy jest uważany za równy instancji na listę <xref:System.Object> tablicy tylko wtedy, gdy jest on <xref:System.Numerics.BigInteger> i ich wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-417">As the output from the example shows, the instance in the <xref:System.Numerics.BigInteger> array is considered to be equal to the instance in the <xref:System.Object> array only if the latter is a <xref:System.Numerics.BigInteger> and their values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="8d479-418">64-bitowa liczba całkowita bez znaku do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-418">The unsigned 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-419">Zwraca wartość wskazującą, czy bieżące wystąpienie i liczbą całkowitą bez znaku 64-bitowych mają taką samą wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-419">Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.</span></span></summary>
        <returns><span data-ttu-id="8d479-420"><see langword="true" /> Jeśli bieżące wystąpienie i liczba całkowita bez znaku 64-bitowych mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-420"><see langword="true" /> if the current instance and the unsigned 64-bit integer have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-421">Aby określić relację między dwoma obiektami, a nie tylko testowanie pod kątem równości, należy wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-421">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-422">W poniższym przykładzie porównano przybliżony odległość kilka gwiazdy z ziemi z odległość Wskazywan Epsilon z ziemi, aby ustalić, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-422">The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</span></span> <span data-ttu-id="8d479-423">W przykładzie użyto każdego przeciążenia <xref:System.Numerics.BigInteger.Equals%2A> metody do testowania pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="8d479-423">The example uses each overload of the <xref:System.Numerics.BigInteger.Equals%2A> method to test for equality.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d479-424">Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-424">Returns the hash code for the current <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <returns><span data-ttu-id="8d479-425">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="8d479-425">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-426">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-426">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-427">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-427">The second value.</span></span></param>
        <summary><span data-ttu-id="8d479-428">Umożliwia znalezienie największy wspólny dzielnik dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-428">Finds the greatest common divisor of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-429">Największy wspólny dzielnik <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-429">The greatest common divisor of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-430">Największy wspólny dzielnik jest największą liczbę, w której dwa <xref:System.Numerics.BigInteger> wartości mogą zostać podzielone bez reszty powrotu.</span><span class="sxs-lookup"><span data-stu-id="8d479-430">The greatest common divisor is the largest number into which the two <xref:System.Numerics.BigInteger> values can be divided without returning a remainder.</span></span>  
  
 <span data-ttu-id="8d479-431">Jeśli `left` i `right` parametry są liczbami różna od zera, metoda zawsze zwraca co najmniej wartość 1, ponieważ wszystkie numery można podzielić o 1.</span><span class="sxs-lookup"><span data-stu-id="8d479-431">If the `left` and `right` parameters are non-zero numbers, the method always returns at least a value of 1 because all numbers can be divided by 1.</span></span> <span data-ttu-id="8d479-432">Jeśli albo parametru wynosi zero, metoda zwraca wartość bezwzględną parametru różna od zera.</span><span class="sxs-lookup"><span data-stu-id="8d479-432">If either parameter is zero, the method returns the absolute value of the non-zero parameter.</span></span> <span data-ttu-id="8d479-433">Jeśli obie wartości zero, metoda zwraca wartość zero.</span><span class="sxs-lookup"><span data-stu-id="8d479-433">If both values are zero, the method returns zero.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d479-434">Przetwarzanie największy wspólny dzielnik bardzo dużych wartości `left` i `right` może być bardzo czasochłonnym operacją.</span><span class="sxs-lookup"><span data-stu-id="8d479-434">Computing the greatest common divisor of very large values of `left` and `right` can be a very time-consuming operation.</span></span>  
  
 <span data-ttu-id="8d479-435">Wartość zwrócona przez obiekt <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody zawsze jest dodatnia, niezależnie od jej znaku `left` i `right` parametrów.</span><span class="sxs-lookup"><span data-stu-id="8d479-435">The value returned by the <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> method is always positive regardless of the sign of the `left` and `right` parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-436">W poniższym przykładzie pokazano wywołanie <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody i obsługi konieczne zawierają przydatne informacje dotyczące wyjątków <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-436">The following example illustrates a call to the <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> method and the exception handling necessary to provide useful information about an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="8d479-437">Wynik wskazuje, że największy wspólny dzielnik tych dwóch liczb wynosi 1.</span><span class="sxs-lookup"><span data-stu-id="8d479-437">The result indicates that the greatest common divisor of these two numbers is 1.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-438">Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą.</span><span class="sxs-lookup"><span data-stu-id="8d479-438">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is an even number.</span></span></summary>
        <value><span data-ttu-id="8d479-439"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-439"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is an even number; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-440">Ta właściwość jest funkcją wygody, która wskazuje, czy <xref:System.Numerics.BigInteger> wartość podzielny przez dwa.</span><span class="sxs-lookup"><span data-stu-id="8d479-440">This property is a convenience feature that indicates whether a <xref:System.Numerics.BigInteger> value is evenly divisible by two.</span></span> <span data-ttu-id="8d479-441">Jest to równoważne używając następującego wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="8d479-441">It is equivalent to the following expression:</span></span>  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 <span data-ttu-id="8d479-442">Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiekt jest <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, zwraca właściwości `true`.</span><span class="sxs-lookup"><span data-stu-id="8d479-442">If the value of the current <xref:System.Numerics.BigInteger> object is <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, the property returns `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-443">Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-443">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />.</span></span></summary>
        <value><span data-ttu-id="8d479-444"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.One" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-444"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-445">Ta właściwość zapewnia znacznie lepszą wydajność niż pozostałych porównań, przy użyciu jednego, takich jak `thisBigInteger.Equals(BigInteger.One)`.</span><span class="sxs-lookup"><span data-stu-id="8d479-445">This property offers significantly better performance than other comparisons with one, such as `thisBigInteger.Equals(BigInteger.One)`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-446">Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa.</span><span class="sxs-lookup"><span data-stu-id="8d479-446">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is a power of two.</span></span></summary>
        <value><span data-ttu-id="8d479-447"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest potęgą liczby dwa; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-447"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is a power of two; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-448">Ta właściwość określa, czy <xref:System.Numerics.BigInteger> wartość zawiera pojedynczy niezerowy bit zestawu.</span><span class="sxs-lookup"><span data-stu-id="8d479-448">This property determines whether a <xref:System.Numerics.BigInteger> value has a single non-zero bit set.</span></span> <span data-ttu-id="8d479-449">Oznacza to, że zwraca `true` Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu ma wartość 1 (2 oznacza to,<sup>0</sup>) lub dowolnego większa potęgą liczby dwa.</span><span class="sxs-lookup"><span data-stu-id="8d479-449">This means that it returns `true` if the value of the current <xref:System.Numerics.BigInteger> object is 1 (that is, 2<sup>0</sup>) or any greater power of two.</span></span> <span data-ttu-id="8d479-450">Zwraca `false` Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu wynosi 0.</span><span class="sxs-lookup"><span data-stu-id="8d479-450">It returns `false` if the value of the current <xref:System.Numerics.BigInteger> object is 0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-451">Wskazuje, czy wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-451">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />.</span></span></summary>
        <value><span data-ttu-id="8d479-452"><see langword="true" /> Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiekt jest <see cref="P:System.Numerics.BigInteger.Zero" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-452"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-453">Ta właściwość zapewnia znacznie lepszą wydajność niż `BigInteger.Equals(BigInteger.Zero)`.</span><span class="sxs-lookup"><span data-stu-id="8d479-453">This property offers significantly better performance than `BigInteger.Equals(BigInteger.Zero)`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-454">Zwraca wartość logarytmu określonej liczby.</span><span class="sxs-lookup"><span data-stu-id="8d479-454">Returns the logarithm of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-455">Liczba, której logarytm ma zostać znaleziona.</span><span class="sxs-lookup"><span data-stu-id="8d479-455">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="8d479-456">Zwraca fizyczna (podstawowy <see langword="e" />) logarytmu określonej liczby.</span><span class="sxs-lookup"><span data-stu-id="8d479-456">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="8d479-457">Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="8d479-457">The natural (base <see langword="e" />) logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-458">`value` Parametr jest określony jako podstawowy numer 10.</span><span class="sxs-lookup"><span data-stu-id="8d479-458">The `value` parameter is specified as a base 10 number.</span></span>  
  
 <span data-ttu-id="8d479-459">Dokładne zwracać wartość przez tę metodę jest zależny od jej znaku `value`, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-459">The precise return value of this method depends on the sign of `value`, as the following table shows.</span></span>  
  
|<span data-ttu-id="8d479-460">Zaloguj się z `value` parametru</span><span class="sxs-lookup"><span data-stu-id="8d479-460">Sign of `value` parameter</span></span>|<span data-ttu-id="8d479-461">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-461">Return value</span></span>|  
|-------------------------------|------------------|  
|<span data-ttu-id="8d479-462">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="8d479-462">Positive</span></span>|<span data-ttu-id="8d479-463">Logarytm naturalny `value`; oznacza to, ln `value`, lub dziennika e`value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-463">The natural logarithm of `value`; that is, ln `value`, or log e`value`.</span></span>|  
|<span data-ttu-id="8d479-464">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-464">Zero</span></span>|<span data-ttu-id="8d479-465"><xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="8d479-465"><xref:System.Double.NegativeInfinity>.</span></span>|  
|<span data-ttu-id="8d479-466">Ujemne</span><span class="sxs-lookup"><span data-stu-id="8d479-466">Negative</span></span>|<span data-ttu-id="8d479-467"><xref:System.Double.NaN>.</span><span class="sxs-lookup"><span data-stu-id="8d479-467"><xref:System.Double.NaN>.</span></span>|  
  
 <span data-ttu-id="8d479-468">Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartość, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-468">To calculate the base 10 logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log10%2A> method.</span></span> <span data-ttu-id="8d479-469">Aby obliczyć logarytm liczby w podstawowym innego, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-469">To calculate the logarithm of a number in another base, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> method.</span></span>  
  
 <span data-ttu-id="8d479-470">Możesz znaleźć pierwiastek kwadratowy z liczby, wywołując <xref:System.Numerics.BigInteger.Log%2A> metoda wraz z <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-470">You can find the square root of a number by calling the <xref:System.Numerics.BigInteger.Log%2A> method along with the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8d479-471">Należy zauważyć, że wynik <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Jeśli wynik jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-471">Note that the result is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> if the result is greater than <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-472">W poniższym przykładzie oblicza pierwiastek kwadratowy z każdego elementu w tablicy <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-472">The following example calculates the square root of each element in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 <span data-ttu-id="8d479-473">Ta metoda odnosi się do <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-473">This method corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d479-474">Logarytmu naturalnego <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-474">The natural log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-475">Liczba, której logarytm ma zostać znaleziona.</span><span class="sxs-lookup"><span data-stu-id="8d479-475">A number whose logarithm is to be found.</span></span></param>
        <param name="baseValue"><span data-ttu-id="8d479-476">Podstawa logarytmu.</span><span class="sxs-lookup"><span data-stu-id="8d479-476">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="8d479-477">Zwraca wartość logarytmu określonej liczby, w określonej bazie.</span><span class="sxs-lookup"><span data-stu-id="8d479-477">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="8d479-478">Podstawa <paramref name="baseValue" /> logarytm <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="8d479-478">The base <paramref name="baseValue" /> logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-479">`value` i `baseValue` parametrów są określone jako podstawowa 10 kolejnych liczb.</span><span class="sxs-lookup"><span data-stu-id="8d479-479">The `value` and `baseValue` parameters are specified as base 10 numbers.</span></span>  
  
 <span data-ttu-id="8d479-480">Dokładne zwracają wartość metody zależy od jej znaku `value` znak i wartość `baseValue`, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-480">The precise return value of the method depends on the sign of `value` and on the sign and value of `baseValue`, as the following table shows.</span></span>  
  
|<span data-ttu-id="8d479-481">`value` Parametr</span><span class="sxs-lookup"><span data-stu-id="8d479-481">`value` parameter</span></span>|<span data-ttu-id="8d479-482">`baseValue` Parametr</span><span class="sxs-lookup"><span data-stu-id="8d479-482">`baseValue` parameter</span></span>|<span data-ttu-id="8d479-483">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-483">Return value</span></span>|  
|-----------------------|---------------------------|------------------|  
|<span data-ttu-id="8d479-484">`value` > 0</span><span class="sxs-lookup"><span data-stu-id="8d479-484">`value` > 0</span></span>|<span data-ttu-id="8d479-485">(0 < `baseValue` < 1) - lub -(`baseValue` > 1)</span><span class="sxs-lookup"><span data-stu-id="8d479-485">(0 < `baseValue` < 1) -or-(`baseValue` > 1)</span></span>|<span data-ttu-id="8d479-486">logbaseValue(`value`)</span><span class="sxs-lookup"><span data-stu-id="8d479-486">logbaseValue(`value`)</span></span>|  
|<span data-ttu-id="8d479-487">`value` < 0</span><span class="sxs-lookup"><span data-stu-id="8d479-487">`value` < 0</span></span>|<span data-ttu-id="8d479-488">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="8d479-488">(any value)</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-489">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="8d479-489">(any value)</span></span>|<span data-ttu-id="8d479-490">`baseValue` < 0</span><span class="sxs-lookup"><span data-stu-id="8d479-490">`baseValue` < 0</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-491">`value` != 1</span><span class="sxs-lookup"><span data-stu-id="8d479-491">`value` != 1</span></span>|<span data-ttu-id="8d479-492">`baseValue` = 0</span><span class="sxs-lookup"><span data-stu-id="8d479-492">`baseValue` = 0</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-493">`value` != 1</span><span class="sxs-lookup"><span data-stu-id="8d479-493">`value` != 1</span></span>|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-494">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="8d479-494">(any value)</span></span>|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-495">(dowolna wartość)</span><span class="sxs-lookup"><span data-stu-id="8d479-495">(any value)</span></span>|<span data-ttu-id="8d479-496">`baseValue` = 1</span><span class="sxs-lookup"><span data-stu-id="8d479-496">`baseValue` = 1</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-497">`value` = 0</span><span class="sxs-lookup"><span data-stu-id="8d479-497">`value` = 0</span></span>|<span data-ttu-id="8d479-498">0 < `baseValue` < 1</span><span class="sxs-lookup"><span data-stu-id="8d479-498">0 < `baseValue` < 1</span></span>|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-499">`value` = 0</span><span class="sxs-lookup"><span data-stu-id="8d479-499">`value` = 0</span></span>|<span data-ttu-id="8d479-500">`baseValue` > 1</span><span class="sxs-lookup"><span data-stu-id="8d479-500">`baseValue` > 1</span></span>|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|<span data-ttu-id="8d479-501">`value` = 1</span><span class="sxs-lookup"><span data-stu-id="8d479-501">`value` = 1</span></span>|<span data-ttu-id="8d479-502">`baseValue` = 0</span><span class="sxs-lookup"><span data-stu-id="8d479-502">`baseValue` = 0</span></span>|<span data-ttu-id="8d479-503">0</span><span class="sxs-lookup"><span data-stu-id="8d479-503">0</span></span>|  
|<span data-ttu-id="8d479-504">`value` = 1</span><span class="sxs-lookup"><span data-stu-id="8d479-504">`value` = 1</span></span>|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<span data-ttu-id="8d479-505">0</span><span class="sxs-lookup"><span data-stu-id="8d479-505">0</span></span>|  
  
 <span data-ttu-id="8d479-506">Aby obliczyć logarytm 10 z <xref:System.Numerics.BigInteger> wartość, należy wywołać <xref:System.Numerics.BigInteger.Log10%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-506">To calculate the base 10 logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log10%2A> method.</span></span> <span data-ttu-id="8d479-507">Aby obliczyć logarytm naturalny liczby, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-507">To calculate the natural logarithm of a number, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> method.</span></span>  
  
 <span data-ttu-id="8d479-508">Ta metoda odnosi się do <xref:System.Math.Log%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-508">This method corresponds to the <xref:System.Math.Log%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d479-509">W dzienniku <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-509">The log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-510">Liczba, której logarytm ma zostać znaleziona.</span><span class="sxs-lookup"><span data-stu-id="8d479-510">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="8d479-511">Zwraca logarytm 10 określoną liczbę.</span><span class="sxs-lookup"><span data-stu-id="8d479-511">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="8d479-512">10 logarytm o <paramref name="value" />, jak pokazano w tabeli w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="8d479-512">The base 10 logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-513">`value` Parametr jest określony jako podstawowy numer 10.</span><span class="sxs-lookup"><span data-stu-id="8d479-513">The `value` parameter is specified as a base 10 number.</span></span>  
  
 <span data-ttu-id="8d479-514">Dokładne zwracają wartość metody zależy od jej znaku `value`, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-514">The precise return value of the method depends on the sign of `value`, as the following table shows.</span></span>  
  
|<span data-ttu-id="8d479-515">Znak parametru wartości</span><span class="sxs-lookup"><span data-stu-id="8d479-515">Sign of value parameter</span></span>|<span data-ttu-id="8d479-516">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-516">Return value</span></span>|  
|-----------------------------|------------------|  
|<span data-ttu-id="8d479-517">Dodatnie</span><span class="sxs-lookup"><span data-stu-id="8d479-517">Positive</span></span>|<span data-ttu-id="8d479-518">Dziennik podstawowy 10 `value`; czyli log10`value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-518">The base 10 log of `value`; that is, log10`value`.</span></span>|  
|<span data-ttu-id="8d479-519">Zero</span><span class="sxs-lookup"><span data-stu-id="8d479-519">Zero</span></span>|<span data-ttu-id="8d479-520"><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-520"><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="8d479-521">Ujemne</span><span class="sxs-lookup"><span data-stu-id="8d479-521">Negative</span></span>|<span data-ttu-id="8d479-522"><xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-522"><xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="8d479-523">Aby obliczyć logarytm naturalny <xref:System.Numerics.BigInteger> wartość, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-523">To calculate the natural logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8d479-524">Aby obliczyć logarytm liczby w podstawowym innego, należy wywołać <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-524">To calculate the logarithm of a number in another base, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8d479-525">Ta metoda odnosi się do <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-525">This method corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d479-526">Dziennik podstawowy 10 <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-526">The base 10 log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-527">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-527">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-528">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-528">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-529">Zwraca większy z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-529">Returns the larger of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-530"><paramref name="left" /> Lub <paramref name="right" /> parametru, która kwota jest większa.</span><span class="sxs-lookup"><span data-stu-id="8d479-530">The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-531">Ta metoda odnosi się do <xref:System.Math.Max%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-531">This method corresponds to the <xref:System.Math.Max%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-532">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Max%2A> metodę, aby wybrać największa liczba w tablicy <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-532">The following example uses the <xref:System.Numerics.BigInteger.Max%2A> method to select the largest number in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-533">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-533">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-534">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-534">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-535">Zwraca mniejszy z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-535">Returns the smaller of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-536"><paramref name="left" /> Lub <paramref name="right" /> parametru, która kwota jest mniejsza.</span><span class="sxs-lookup"><span data-stu-id="8d479-536">The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-537">Ta metoda odnosi się do <xref:System.Math.Min%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-537">This method corresponds to the <xref:System.Math.Min%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-538">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Min%2A> metodę, aby wybrać najmniejszą liczbę, tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-538">The following example uses the <xref:System.Numerics.BigInteger.Min%2A> method to select the smallest number in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-539">Pobiera wartość, która reprezentuje liczbę ujemną (-1).</span><span class="sxs-lookup"><span data-stu-id="8d479-539">Gets a value that represents the number negative one (-1).</span></span></summary>
        <value><span data-ttu-id="8d479-540">Liczba całkowita, którego wartość jest ujemna (-1).</span><span class="sxs-lookup"><span data-stu-id="8d479-540">An integer whose value is negative one (-1).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-541"><xref:System.Numerics.BigInteger.MinusOne%2A> Właściwość jest używana do porównania <xref:System.Numerics.BigInteger> wartość -1 lub -1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-541">The <xref:System.Numerics.BigInteger.MinusOne%2A> property is used to compare a <xref:System.Numerics.BigInteger> value to -1 or to assign -1 to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-542">Liczbę, aby podnieść do <paramref name="exponent" /> zasilania.</span><span class="sxs-lookup"><span data-stu-id="8d479-542">The number to raise to the <paramref name="exponent" /> power.</span></span></param>
        <param name="exponent"><span data-ttu-id="8d479-543">Wykładnik, aby podnieść <paramref name="value" /> przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-543">The exponent to raise <paramref name="value" /> by.</span></span></param>
        <param name="modulus"><span data-ttu-id="8d479-544">Liczba, przez którą chcesz podzielić <paramref name="value" /> podniesioną do <paramref name="exponent" /> zasilania.</span><span class="sxs-lookup"><span data-stu-id="8d479-544">The number by which to divide <paramref name="value" /> raised to the <paramref name="exponent" /> power.</span></span></param>
        <summary><span data-ttu-id="8d479-545">Wykonuje dzielenie modulo na liczbę podniesioną do potęgi równej innej liczbie.</span><span class="sxs-lookup"><span data-stu-id="8d479-545">Performs modulus division on a number raised to the power of another number.</span></span></summary>
        <returns><span data-ttu-id="8d479-546">Resztę po podzieleniu <paramref name="value" /> <sup>wykładnik</sup> przez <paramref name="modulus" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-546">The remainder after dividing <paramref name="value" /><sup>exponent</sup> by <paramref name="modulus" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-547"><xref:System.Numerics.BigInteger.ModPow%2A> Metoda oblicza następujące wyrażenie:</span><span class="sxs-lookup"><span data-stu-id="8d479-547">The <xref:System.Numerics.BigInteger.ModPow%2A> method evaluates the following expression:</span></span>  
  
 <span data-ttu-id="8d479-548">(baseValue ^ wykładnik) Mod modulo</span><span class="sxs-lookup"><span data-stu-id="8d479-548">(baseValue ^ exponent) Mod modulus</span></span>  
  
 <span data-ttu-id="8d479-549">Aby wykonać potęgowania na <xref:System.Numerics.BigInteger> użyć wartości bez dzielenie modulo <xref:System.Numerics.BigInteger.Pow%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-549">To perform exponentiation on <xref:System.Numerics.BigInteger> values without modulus division, use the <xref:System.Numerics.BigInteger.Pow%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-550">W poniższym przykładzie przedstawiono prosty ilustracja wywoływania <xref:System.Numerics.BigInteger.ModPow%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-550">The following example provides a simple illustration of calling the <xref:System.Numerics.BigInteger.ModPow%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="8d479-551"><paramref name="modulus" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="8d479-551"><paramref name="modulus" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d479-552"><paramref name="exponent" /> ma wartość ujemną.</span><span class="sxs-lookup"><span data-stu-id="8d479-552"><paramref name="exponent" /> is negative.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-553">Pierwszy numer do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-553">The first number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-554">Druga liczba do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-554">The second number to multiply.</span></span></param>
        <summary><span data-ttu-id="8d479-555">Zwraca iloczyn dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-555">Returns the product of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-556">Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</span><span class="sxs-lookup"><span data-stu-id="8d479-556">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-557"><xref:System.Numerics.BigInteger.Multiply%2A> Metoda jest implementowana dla języków, które nie obsługują przeciążanie operatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-557">The <xref:System.Numerics.BigInteger.Multiply%2A> method is implemented for languages that do not support operator overloading.</span></span> <span data-ttu-id="8d479-558">Jego zachowanie jest identyczne z mnożenia przy użyciu operator mnożenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-558">Its behavior is identical to multiplication using the multiplication operator.</span></span> <span data-ttu-id="8d479-559">Ponadto <xref:System.Numerics.BigInteger.Multiply%2A> metoda jest przydatna zastępują operator mnożenia, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, przypisując go produktu, który jest wynikiem mnożenie, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8d479-559">In addition, the <xref:System.Numerics.BigInteger.Multiply%2A> method is a useful substitute for the multiplication operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it a product that results from multiplication, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 <span data-ttu-id="8d479-560">Jeśli to konieczne, ta metoda automatycznie wykonuje niejawnej konwersji wartości innych typów całkowitych <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="8d479-560">If necessary, this method automatically performs implicit conversion of other integral types to <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="8d479-561">Jest to zilustrowane w przykładzie w następnej sekcji, gdzie <xref:System.Numerics.BigInteger.Multiply%2A> metoda przechodzi przez dwa <xref:System.Int64> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-561">This is illustrated in the example in the next section, where the <xref:System.Numerics.BigInteger.Multiply%2A> method is passed two <xref:System.Int64> values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-562">Poniższy przykład próbuje wykonać mnożenie przy użyciu dwóch długich liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8d479-562">The following example tries to perform multiplication with two long integers.</span></span> <span data-ttu-id="8d479-563">Ponieważ w wyniku przekracza zakres długich liczb całkowitych <xref:System.OverflowException> jest generowany i <xref:System.Numerics.BigInteger.Multiply%2A> metoda jest wywoływana w celu obsługi mnożenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-563">Because the result exceeds the range of a long integer, an <xref:System.OverflowException> is thrown, and the <xref:System.Numerics.BigInteger.Multiply%2A> method is called to handle the multiplication.</span></span> <span data-ttu-id="8d479-564">Pamiętaj, że C# wymaga użycia albo `checked` — słowo kluczowe (jak w poniższym przykładzie) lub `/checked+` opcję kompilatora, aby upewnić się, wyjątek jest generowany na przepełnienie liczbowe.</span><span class="sxs-lookup"><span data-stu-id="8d479-564">Note that C# requires that you use either the `checked` keyword (as in this example) or the `/checked+` compiler option to make sure an exception is thrown on a numeric overflow.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-565">Wartość do wskazania ujemnej.</span><span class="sxs-lookup"><span data-stu-id="8d479-565">The value to negate.</span></span></param>
        <summary><span data-ttu-id="8d479-566">Neguje określonego <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-566">Negates a specified <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-567">Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</span><span class="sxs-lookup"><span data-stu-id="8d479-567">The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-568">Negacja uzyskuje odwrotność dodatku liczby.</span><span class="sxs-lookup"><span data-stu-id="8d479-568">Negation obtains the additive inverse of a number.</span></span> <span data-ttu-id="8d479-569">Odwrotne dodatku liczby jest liczbą, która generuje wartość zero, gdy jest ona dodawana do liczby.</span><span class="sxs-lookup"><span data-stu-id="8d479-569">The additive inverse of a number is a number that produces a value of zero when it is added to the original number.</span></span>  
  
 <span data-ttu-id="8d479-570"><xref:System.Numerics.BigInteger.Negate%2A> Metoda jest implementowana dla języków, które nie obsługują operatorów niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-570">The <xref:System.Numerics.BigInteger.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="8d479-571">Jego zachowanie jest identyczne negacji przy użyciu Jednoargumentowy operator negacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-571">Its behavior is identical to negation using the unary negation operator.</span></span> <span data-ttu-id="8d479-572">Ponadto <xref:System.Numerics.BigInteger.Negate%2A> metoda jest przydatna zastępują operator negacji podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8d479-572">In addition, the <xref:System.Numerics.BigInteger.Negate%2A> method is a useful substitute for the negation operator when instantiating a <xref:System.Numerics.BigInteger> variable, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="8d479-573">Poniższy przykład przedstawia trzy sposoby, aby odwrócić wartość <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-573">The following example illustrates three ways to negate the value of a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-574">Pobiera wartość, która reprezentuje numer jeden (1).</span><span class="sxs-lookup"><span data-stu-id="8d479-574">Gets a value that represents the number one (1).</span></span></summary>
        <value><span data-ttu-id="8d479-575">Obiekt, którego wartość jest jeden (1).</span><span class="sxs-lookup"><span data-stu-id="8d479-575">An object whose value is one (1).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-576"><xref:System.Numerics.BigInteger.One%2A> Jest zazwyczaj używana do porównania <xref:System.Numerics.BigInteger> wartość 1 lub 1, aby przypisać <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-576">The <xref:System.Numerics.BigInteger.One%2A> property is usually used to compare a <xref:System.Numerics.BigInteger> value to 1 or to assign 1 to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-577">Pierwsza wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="8d479-577">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-578">Druga wartość do dodania.</span><span class="sxs-lookup"><span data-stu-id="8d479-578">The second value to add.</span></span></param>
        <summary><span data-ttu-id="8d479-579">Dodaje wartości z dwóch określonych <see cref="T:System.Numerics.BigInteger" /> obiektów.</span><span class="sxs-lookup"><span data-stu-id="8d479-579">Adds the values of two specified <see cref="T:System.Numerics.BigInteger" /> objects.</span></span></summary>
        <returns><span data-ttu-id="8d479-580">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-580">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-581"><xref:System.Numerics.BigInteger.op_Addition%2A> Metoda definiuje operacja dodawania dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-581">The <xref:System.Numerics.BigInteger.op_Addition%2A> method defines the addition operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-582">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-582">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 <span data-ttu-id="8d479-583">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Add%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-583">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Add%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-584">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-584">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-585">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-585">The second value.</span></span></param>
        <summary><span data-ttu-id="8d479-586">Wykonuje bitową operację <see langword="And" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-586">Performs a bitwise <see langword="And" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-587">Wynik zadania poziomu bitowego <see langword="And" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-587">The result of the bitwise <see langword="And" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-588"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda określa operatora testu koniunkcji `And` operacji <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-588">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method defines the bitwise `And` operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-589">Operatora testu koniunkcji `And` operacji Ustawia wynik bitowy tylko wtedy, gdy odpowiednich bitów w `left` i `right` również są ustawione, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-589">The bitwise `And` operation sets a result bit only if the corresponding bits in `left` and `right` are also set, as shown in the following table.</span></span>  
  
|<span data-ttu-id="8d479-590">Bit w `left`</span><span class="sxs-lookup"><span data-stu-id="8d479-590">Bit in `left`</span></span>|<span data-ttu-id="8d479-591">Bit w `right`</span><span class="sxs-lookup"><span data-stu-id="8d479-591">Bit in `right`</span></span>|<span data-ttu-id="8d479-592">Bit w wyniku</span><span class="sxs-lookup"><span data-stu-id="8d479-592">Bit in result</span></span>|  
|-------------------|--------------------|-------------------|  
|<span data-ttu-id="8d479-593">0</span><span class="sxs-lookup"><span data-stu-id="8d479-593">0</span></span>|<span data-ttu-id="8d479-594">0</span><span class="sxs-lookup"><span data-stu-id="8d479-594">0</span></span>|<span data-ttu-id="8d479-595">0</span><span class="sxs-lookup"><span data-stu-id="8d479-595">0</span></span>|  
|<span data-ttu-id="8d479-596">1</span><span class="sxs-lookup"><span data-stu-id="8d479-596">1</span></span>|<span data-ttu-id="8d479-597">0</span><span class="sxs-lookup"><span data-stu-id="8d479-597">0</span></span>|<span data-ttu-id="8d479-598">0</span><span class="sxs-lookup"><span data-stu-id="8d479-598">0</span></span>|  
|<span data-ttu-id="8d479-599">1</span><span class="sxs-lookup"><span data-stu-id="8d479-599">1</span></span>|<span data-ttu-id="8d479-600">1</span><span class="sxs-lookup"><span data-stu-id="8d479-600">1</span></span>|<span data-ttu-id="8d479-601">1</span><span class="sxs-lookup"><span data-stu-id="8d479-601">1</span></span>|  
|<span data-ttu-id="8d479-602">0</span><span class="sxs-lookup"><span data-stu-id="8d479-602">0</span></span>|<span data-ttu-id="8d479-603">1</span><span class="sxs-lookup"><span data-stu-id="8d479-603">1</span></span>|<span data-ttu-id="8d479-604">0</span><span class="sxs-lookup"><span data-stu-id="8d479-604">0</span></span>|  
  
 <span data-ttu-id="8d479-605"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="8d479-605">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <span data-ttu-id="8d479-606"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda wykonuje operatora testu koniunkcji `And` operacji na dwóch <xref:System.Numerics.BigInteger> wartości tak, jakby były one zarówno w dwójki uzupełnienie reprezentacji z rozszerzeniem wirtualnego logowania.</span><span class="sxs-lookup"><span data-stu-id="8d479-606">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method performs the bitwise `And` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-607">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-607">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-608">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-608">The second value.</span></span></param>
        <summary><span data-ttu-id="8d479-609">Wykonuje bitową operację <see langword="Or" /> operacji na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-609">Performs a bitwise <see langword="Or" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-610">Wynik zadania poziomu bitowego <see langword="Or" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-610">The result of the bitwise <see langword="Or" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-611"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda określa operatora testu koniunkcji `Or` operacji <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-611">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method defines the bitwise `Or` operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-612">Operatora testu koniunkcji `Or` operacja służy do ustawiania wynik bitowy tylko wtedy, gdy jeden lub oba odpowiednich bitów w `left` i `right` są ustawione, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-612">The bitwise `Or` operation sets a result bit only if either or both of the corresponding bits in `left` and `right` are set, as shown in the following table.</span></span>  
  
|<span data-ttu-id="8d479-613">Bit w `left`</span><span class="sxs-lookup"><span data-stu-id="8d479-613">Bit in `left`</span></span>|<span data-ttu-id="8d479-614">Bit w `right`</span><span class="sxs-lookup"><span data-stu-id="8d479-614">Bit in `right`</span></span>|<span data-ttu-id="8d479-615">Bit w wyniku</span><span class="sxs-lookup"><span data-stu-id="8d479-615">Bit in result</span></span>|  
|-------------------|--------------------|-------------------|  
|<span data-ttu-id="8d479-616">0</span><span class="sxs-lookup"><span data-stu-id="8d479-616">0</span></span>|<span data-ttu-id="8d479-617">0</span><span class="sxs-lookup"><span data-stu-id="8d479-617">0</span></span>|<span data-ttu-id="8d479-618">0</span><span class="sxs-lookup"><span data-stu-id="8d479-618">0</span></span>|  
|<span data-ttu-id="8d479-619">1</span><span class="sxs-lookup"><span data-stu-id="8d479-619">1</span></span>|<span data-ttu-id="8d479-620">0</span><span class="sxs-lookup"><span data-stu-id="8d479-620">0</span></span>|<span data-ttu-id="8d479-621">1</span><span class="sxs-lookup"><span data-stu-id="8d479-621">1</span></span>|  
|<span data-ttu-id="8d479-622">1</span><span class="sxs-lookup"><span data-stu-id="8d479-622">1</span></span>|<span data-ttu-id="8d479-623">1</span><span class="sxs-lookup"><span data-stu-id="8d479-623">1</span></span>|<span data-ttu-id="8d479-624">1</span><span class="sxs-lookup"><span data-stu-id="8d479-624">1</span></span>|  
|<span data-ttu-id="8d479-625">0</span><span class="sxs-lookup"><span data-stu-id="8d479-625">0</span></span>|<span data-ttu-id="8d479-626">1</span><span class="sxs-lookup"><span data-stu-id="8d479-626">1</span></span>|<span data-ttu-id="8d479-627">1</span><span class="sxs-lookup"><span data-stu-id="8d479-627">1</span></span>|  
  
 <span data-ttu-id="8d479-628"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="8d479-628">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <span data-ttu-id="8d479-629"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda wykonuje operatora testu koniunkcji `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości tak, jakby były one zarówno w dwójki uzupełnienie reprezentacji z rozszerzeniem wirtualnego logowania.</span><span class="sxs-lookup"><span data-stu-id="8d479-629">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method performs the bitwise `Or` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-630">Wartość, aby zmniejszyć.</span><span class="sxs-lookup"><span data-stu-id="8d479-630">The value to decrement.</span></span></param>
        <summary><span data-ttu-id="8d479-631">Dekrementuje <see cref="T:System.Numerics.BigInteger" /> wartość o 1.</span><span class="sxs-lookup"><span data-stu-id="8d479-631">Decrements a <see cref="T:System.Numerics.BigInteger" /> value by 1.</span></span></summary>
        <returns><span data-ttu-id="8d479-632">Wartość <paramref name="value" /> parametru zmniejszona o 1.</span><span class="sxs-lookup"><span data-stu-id="8d479-632">The value of the <paramref name="value" /> parameter decremented by 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-633"><xref:System.Numerics.BigInteger.op_Decrement%2A> Metoda definiuje operacja dekrementacji dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-633">The <xref:System.Numerics.BigInteger.op_Decrement%2A> method defines the decrement operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-634">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-634">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 <span data-ttu-id="8d479-635">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Subtract%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-635">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Subtract%2A> method instead.</span></span> <span data-ttu-id="8d479-636">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="8d479-636">For example:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 <span data-ttu-id="8d479-637">Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Decrement%2A> operator tworzy nową <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden mniejsza niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-637">Because <xref:System.Numerics.BigInteger> objects are immutable, the <xref:System.Numerics.BigInteger.op_Decrement%2A> operator creates a new <xref:System.Numerics.BigInteger> object whose value is one less than the <xref:System.Numerics.BigInteger> object represented by `value`.</span></span> <span data-ttu-id="8d479-638">Oznacza to, że wielokrotne wywołania <xref:System.Numerics.BigInteger.op_Decrement%2A> może być kosztowne.</span><span class="sxs-lookup"><span data-stu-id="8d479-638">This means that repeated calls to <xref:System.Numerics.BigInteger.op_Decrement%2A> may be expensive.</span></span>  
  
 <span data-ttu-id="8d479-639">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-639">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="8d479-640">Wartość do podzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-640">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="8d479-641">Wartość do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-641">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="8d479-642">Dzieli określony <see cref="T:System.Numerics.BigInteger" /> wartość przez inny określony <see cref="T:System.Numerics.BigInteger" /> wartości za pomocą dzielenie liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-642">Divides a specified <see cref="T:System.Numerics.BigInteger" /> value by another specified <see cref="T:System.Numerics.BigInteger" /> value by using integer division.</span></span></summary>
        <returns><span data-ttu-id="8d479-643">Całkowite wyniku podziału.</span><span class="sxs-lookup"><span data-stu-id="8d479-643">The integral result of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-644"><xref:System.Numerics.BigInteger.op_Division%2A> Metoda definiuje operacji dzielenia dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-644">The <xref:System.Numerics.BigInteger.op_Division%2A> method defines the division operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-645">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-645">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 <span data-ttu-id="8d479-646">Języki, które nie obsługują operatorów niestandardowych i przeciążanie operatorów może wywołać <xref:System.Numerics.BigInteger.Divide%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-646">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.BigInteger.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="8d479-647">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8d479-647">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="8d479-648">Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-648">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-649">Następnie używa każdy element jako iloraz w operacji dzielenia, który używa <xref:System.Numerics.BigInteger.Divide%2A> metoda, operator dzielenia (/) i <xref:System.Numerics.BigInteger.DivRem%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-649">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="8d479-650"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-650"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-651">Zwraca wartość wskazującą, czy dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-651">Returns a value that indicates whether two values are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-652">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-652">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-653">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-653">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-654">Zwraca wartość wskazującą, czy wartość liczby całkowitej ze znakiem długie i a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-654">Returns a value that indicates whether a signed long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-655"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-655"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-656"><xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-656">The <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-657">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-657">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 <span data-ttu-id="8d479-658">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-658">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="8d479-659">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-659">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-660">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-660">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-661">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-661">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-662">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-662">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-663">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i wartości liczby całkowitej ze znakiem długie są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-663">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a signed long integer value are equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-664"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-664"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-665"><xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-665">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-666">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-666">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 <span data-ttu-id="8d479-667">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-667">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="8d479-668">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-668">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-669">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-669">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-670">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-670">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-671">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-671">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-672">Zwraca wartość wskazującą, czy wartości dwóch <see cref="T:System.Numerics.BigInteger" /> obiekty są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-672">Returns a value that indicates whether the values of two <see cref="T:System.Numerics.BigInteger" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-673"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-673"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-674"><xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-674">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method defines the operation of the equality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-675">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-675">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 <span data-ttu-id="8d479-676">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-676">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="8d479-677">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-677">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-678">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-678">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-679">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-679">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-680">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartości i niepodpisane długa liczba całkowita wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-680">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and an unsigned long integer value are equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-681"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-681"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-682"><xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-682">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-683">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-683">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 <span data-ttu-id="8d479-684">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-684">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-685">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-685">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-686">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-686">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-687">Zwraca wartość wskazującą, czy wartością niepodpisane długa liczba całkowita, a jeśli tak, to a <see cref="T:System.Numerics.BigInteger" /> wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-687">Returns a value that indicates whether an unsigned long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-688"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-688"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-689"><xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Metoda definiuje operacji porównania równości dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-689">The <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-690">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-690">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 <span data-ttu-id="8d479-691">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-691">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-692">Pierwsza wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-692">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-693">Druga wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-693">The second value.</span></span></param>
        <summary><span data-ttu-id="8d479-694">Wykonuje wyłączny sumy bitowej <see langword="Or" /> (<see langword="XOr" />) operacja na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-694">Performs a bitwise exclusive <see langword="Or" /> (<see langword="XOr" />) operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-695">Wynik zadania poziomu bitowego <see langword="Or" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-695">The result of the bitwise <see langword="Or" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-696">Wynik wyłączny sumy bitowej `Or` operacji `true` w przypadku różnych; w przeciwnym razie wartości dwa bity jest `false`.</span><span class="sxs-lookup"><span data-stu-id="8d479-696">The result of a bitwise exclusive `Or` operation is `true` if the values of the two bits are different; otherwise, it is `false`.</span></span> <span data-ttu-id="8d479-697">W poniższej tabeli przedstawiono jedynego `Or` operacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-697">The following table illustrates the exclusive `Or` operation.</span></span>  
  
|<span data-ttu-id="8d479-698">Bit x `left`</span><span class="sxs-lookup"><span data-stu-id="8d479-698">Bit x in `left`</span></span>|<span data-ttu-id="8d479-699">Bit x `right`</span><span class="sxs-lookup"><span data-stu-id="8d479-699">Bit x in `right`</span></span>|<span data-ttu-id="8d479-700">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="8d479-700">Return value</span></span>|  
|---------------------|----------------------|------------------|  
|<span data-ttu-id="8d479-701">0</span><span class="sxs-lookup"><span data-stu-id="8d479-701">0</span></span>|<span data-ttu-id="8d479-702">0</span><span class="sxs-lookup"><span data-stu-id="8d479-702">0</span></span>|<span data-ttu-id="8d479-703">0</span><span class="sxs-lookup"><span data-stu-id="8d479-703">0</span></span>|  
|<span data-ttu-id="8d479-704">0</span><span class="sxs-lookup"><span data-stu-id="8d479-704">0</span></span>|<span data-ttu-id="8d479-705">1</span><span class="sxs-lookup"><span data-stu-id="8d479-705">1</span></span>|<span data-ttu-id="8d479-706">1</span><span class="sxs-lookup"><span data-stu-id="8d479-706">1</span></span>|  
|<span data-ttu-id="8d479-707">1</span><span class="sxs-lookup"><span data-stu-id="8d479-707">1</span></span>|<span data-ttu-id="8d479-708">0</span><span class="sxs-lookup"><span data-stu-id="8d479-708">0</span></span>|<span data-ttu-id="8d479-709">1</span><span class="sxs-lookup"><span data-stu-id="8d479-709">1</span></span>|  
|<span data-ttu-id="8d479-710">1</span><span class="sxs-lookup"><span data-stu-id="8d479-710">1</span></span>|<span data-ttu-id="8d479-711">1</span><span class="sxs-lookup"><span data-stu-id="8d479-711">1</span></span>|<span data-ttu-id="8d479-712">0</span><span class="sxs-lookup"><span data-stu-id="8d479-712">0</span></span>|  
  
 <span data-ttu-id="8d479-713"><xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="8d479-713">The <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <span data-ttu-id="8d479-714"><xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda wykonuje wyłączny sumy bitowej `Or` operacji na dwóch <xref:System.Numerics.BigInteger> wartości tak, jakby były one zarówno w dwójki uzupełnienie reprezentacji z rozszerzeniem wirtualnego logowania.</span><span class="sxs-lookup"><span data-stu-id="8d479-714">The <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> method performs the bitwise exclusive `Or` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-715">Definiuje jawnej konwersji między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</span><span class="sxs-lookup"><span data-stu-id="8d479-715">Defines an explicit conversion between a <see cref="T:System.Numerics.BigInteger" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-716">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-716">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-717">Definiuje jawna konwersja <see cref="T:System.Decimal" /> obiekt <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-717">Defines an explicit conversion of a <see cref="T:System.Decimal" /> object to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-718">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-718">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-719">Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-719">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="8d479-720">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-720">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-721">Ponieważ konwersja z <xref:System.Decimal> do <xref:System.Numerics.BigInteger> może obejmować obcinanie dowolnej części ułamkowej `value`, Kompilatory języka automatycznie nie wykonuj tę konwersję.</span><span class="sxs-lookup"><span data-stu-id="8d479-721">Because the conversion from <xref:System.Decimal> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="8d479-722">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-722">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-723">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-723">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="8d479-724">W przypadku języków, które nie obsługują operatorów niestandardowych jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-724">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="8d479-725">Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Decimal> wartości <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-725">The following example converts the individual elements in an array of <xref:System.Decimal> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="8d479-726">Należy pamiętać, że wszelkie ułamkową część <xref:System.Decimal> wartość zostanie obcięta podczas konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-726">Note that any fractional part of a <xref:System.Decimal> value is truncated during the conversion.</span></span>   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-727">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-727">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-728">Definiuje jawna konwersja <see cref="T:System.Double" /> wartość <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-728">Defines an explicit conversion of a <see cref="T:System.Double" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-729">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-729">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-730">Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-730">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="8d479-731">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-731">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-732">Ponieważ konwersja z <xref:System.Double> do <xref:System.Numerics.BigInteger> może obejmować obcinanie dowolnej części ułamkowej `value`, Kompilatory języka automatycznie nie wykonuj tę konwersję.</span><span class="sxs-lookup"><span data-stu-id="8d479-732">Because the conversion from <xref:System.Double> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="8d479-733">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-733">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-734">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-734">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="8d479-735">W przypadku języków, które nie obsługują operatorów niestandardowych jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-735">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="8d479-736">Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Double> wartości <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-736">The following example converts the individual elements in an array of <xref:System.Double> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="8d479-737">Należy pamiętać, że wszelkie ułamkową część <xref:System.Double> wartość zostanie obcięta podczas konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-737">Note that any fractional part of a <xref:System.Double> value is truncated during the conversion.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-738"><paramref name="value" /> jest <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, lub <see cref="F:System.Double.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-738"><paramref name="value" /> is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NegativeInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-739">Wartość do przekonwertowania na <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-739">The value to convert to a <see cref="T:System.Byte" />.</span></span></param>
        <summary><span data-ttu-id="8d479-740">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości bajtu bez znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-740">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned byte value.</span></span></summary>
        <returns><span data-ttu-id="8d479-741">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-741">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-742">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-742">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-743">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-743">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-744">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CByte` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-744">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CByte` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-745">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-745">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="8d479-746">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-746">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Byte> data type.</span></span> <span data-ttu-id="8d479-747">Bez utraty dokładności w wynikowym <xref:System.Byte> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-747">There is no loss of precision in the resulting <xref:System.Byte> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-748">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Byte> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-748">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Byte> values.</span></span> <span data-ttu-id="8d479-749">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Byte> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-749">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Byte> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-750"><paramref name="value" /> jest mniejsza niż <see cref="F:System.Byte.MinValue" /> lub większa niż <see cref="F:System.Byte.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-750"><paramref name="value" /> is less than <see cref="F:System.Byte.MinValue" /> or greater than <see cref="F:System.Byte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-751">Wartość do przekonwertowania na <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-751">The value to convert to a <see cref="T:System.Decimal" />.</span></span></param>
        <summary><span data-ttu-id="8d479-752">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiekt <see cref="T:System.Decimal" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-752">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Decimal" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-753">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-753">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-754">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-754">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-755">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-755">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-756">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDec` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-756">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CDec` in Visual Basic) is used.</span></span>   

 <span data-ttu-id="8d479-757">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-757">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Decimal> data type.</span></span> 

## Examples
 <span data-ttu-id="8d479-758">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Decimal> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-758">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Decimal> values.</span></span> <span data-ttu-id="8d479-759">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Decimal> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-759">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Decimal> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-760"><paramref name="value" /> jest mniejsza niż <see cref="F:System.Decimal.MinValue" /> lub większa niż <see cref="F:System.Decimal.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-760"><paramref name="value" /> is less than <see cref="F:System.Decimal.MinValue" /> or greater than <see cref="F:System.Decimal.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-761">Wartość do przekonwertowania na <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-761">The value to convert to a <see cref="T:System.Double" />.</span></span></param>
        <summary><span data-ttu-id="8d479-762">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiekt <see cref="T:System.Double" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-762">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Double" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-763">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-763">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-764">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-764">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-765">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-765">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-766">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CDbl` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-766">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CDbl` in Visual Basic) is used.</span></span>   

 <span data-ttu-id="8d479-767">Ponieważ <xref:System.Numerics.BigInteger> wartość może być poza zakresem <xref:System.Double> typ danych, ta operacja jest konwersją zawężającą.</span><span class="sxs-lookup"><span data-stu-id="8d479-767">Because the <xref:System.Numerics.BigInteger> value can be outside the range of the <xref:System.Double> data type, this operation is a narrowing conversion.</span></span> <span data-ttu-id="8d479-768">Jeśli konwersja nie powiedzie się, nie zostanie zgłoszony <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-768">If the conversion is unsuccessful, it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-769">Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Double.MinValue?displayProperty=nameWithType>, wynikowy <xref:System.Double> wartość <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-769">Instead, if the <xref:System.Numerics.BigInteger> value is less than <xref:System.Double.MinValue?displayProperty=nameWithType>, the resulting <xref:System.Double> value is <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-770">Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>, wynikowy <xref:System.Double> wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-770">If the <xref:System.Numerics.BigInteger> value is greater than <xref:System.Double.MaxValue?displayProperty=nameWithType>, the resulting <xref:System.Double> value is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>
 
 <span data-ttu-id="8d479-771">Konwersja <xref:System.Numerics.BigInteger> do <xref:System.Double> może pociągać za sobą utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="8d479-771">The conversion of a <xref:System.Numerics.BigInteger> to a <xref:System.Double> may involve a loss of precision.</span></span> <span data-ttu-id="8d479-772">W niektórych przypadkach utratę dokładności może spowodować operacji rzutowania lub konwersja powiedzie się nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-772">In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Double> data type.</span></span> <span data-ttu-id="8d479-773">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="8d479-773">The following example provides an illustration.</span></span> <span data-ttu-id="8d479-774">Przypisuje wartość maksymalna <xref:System.Double> dwóch <xref:System.Numerics.BigInteger> zmiennych, w przyrostach co <xref:System.Numerics.BigInteger> zmiennej 9.999e291 i testuje dwie zmienne pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="8d479-774">It assigns the maximum value of a <xref:System.Double> to two <xref:System.Numerics.BigInteger> variables, increments one <xref:System.Numerics.BigInteger> variable by 9.999e291, and tests the two variables for equality.</span></span> <span data-ttu-id="8d479-775">Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metoda ma pokazać, że są nierówne.</span><span class="sxs-lookup"><span data-stu-id="8d479-775">As expected, the call to the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method shows that they are unequal.</span></span> <span data-ttu-id="8d479-776">Jednak konwersja większy <xref:System.Numerics.BigInteger> wartość z powrotem na <xref:System.Double> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-776">However, the conversion of the larger <xref:System.Numerics.BigInteger> value back to a <xref:System.Double> succeeds, although the <xref:System.Numerics.BigInteger> value now exceeds <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 <span data-ttu-id="8d479-777">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Double> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-777">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Double> values.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-778">Wartość do przekonwertowania na całkowita 16-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-778">The value to convert to a 16-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8d479-779">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiekt do 16-bitową liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-779">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 16-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="8d479-780">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-780">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-781">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-781">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-782">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-782">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-783">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CShort` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-783">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CShort` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-784">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-784">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="8d479-785">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-785">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int16> data type.</span></span> <span data-ttu-id="8d479-786">Bez utraty dokładności w wynikowym <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-786">There is no loss of precision in the resulting <xref:System.Int16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-787">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int16> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-787">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int16> values.</span></span> <span data-ttu-id="8d479-788">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int16> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-788">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int16> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-789"><paramref name="value" /> jest mniejsza niż <see cref="F:System.Int16.MinValue" /> lub jest większa niż <see cref="F:System.Int16.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-789"><paramref name="value" /> is less than <see cref="F:System.Int16.MinValue" /> or is greater than <see cref="F:System.Int16.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-790">Wartość do przekonwertowania na całkowita 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-790">The value to convert to a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8d479-791">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości liczby całkowitej ze znakiem 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-791">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 32-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="8d479-792">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-792">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-793">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-793">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-794">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-794">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-795">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CInt` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-795">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CInt` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-796">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-796">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="8d479-797">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-797">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int32> data type.</span></span> <span data-ttu-id="8d479-798">Bez utraty dokładności w wynikowym <xref:System.Int16> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-798">There is no loss of precision in the resulting <xref:System.Int16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-799">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int32> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-799">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int32> values.</span></span> <span data-ttu-id="8d479-800">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int32> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-800">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int32> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-801"><paramref name="value" /> jest mniejsza niż <see cref="F:System.Int32.MinValue" /> lub jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-801"><paramref name="value" /> is less than <see cref="F:System.Int32.MinValue" /> or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-802">Wartość do przekonwertowania na całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-802">The value to convert to a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="8d479-803">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 64-bitową.</span><span class="sxs-lookup"><span data-stu-id="8d479-803">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="8d479-804">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-804">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-805">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-805">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-806">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-806">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-807">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CLng` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-807">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CLng` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-808">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-808">Otherwise, they display a compiler error.</span></span>  

 <span data-ttu-id="8d479-809">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-809">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int64> data type.</span></span> 

## Examples
 <span data-ttu-id="8d479-810">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Int64> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-810">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int64> values.</span></span> <span data-ttu-id="8d479-811">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Int64> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-811">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int64> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-812"><paramref name="value" /> jest mniejsza niż <see cref="F:System.Int64.MinValue" /> lub jest większa niż <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-812"><paramref name="value" /> is less than <see cref="F:System.Int64.MinValue" /> or is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-813">Wartość do przekonwertowania na wartość ze znakiem 8-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-813">The value to convert to a signed 8-bit value.</span></span></param>
        <summary><span data-ttu-id="8d479-814">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu podpisem wartości 8-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-814">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a signed 8-bit value.</span></span>  
  
<span data-ttu-id="8d479-815">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-815">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-816">Alternatywa zgodna ze standardem jest <see cref="T:System.Int16" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-816">The compliant alternative is <see cref="T:System.Int16" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-817">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-817">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-818">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-818">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-819">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-819">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-820">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSByte` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-820">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CSByte` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-821">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-821">Otherwise, they display a compiler error.</span></span>  

 <span data-ttu-id="8d479-822">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-822">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.SByte> data type.</span></span> <span data-ttu-id="8d479-823">Bez utraty dokładności w wynikowym <xref:System.SByte> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-823">There is no loss of precision in the resulting <xref:System.SByte> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-824">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.SByte> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-824">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.SByte> values.</span></span> <span data-ttu-id="8d479-825">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.SByte> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-825">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.SByte> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-826"><paramref name="value" /> jest mniejsza niż <see cref="F:System.SByte.MinValue" /> lub jest większa niż <see cref="F:System.SByte.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-826"><paramref name="value" /> is less than <see cref="F:System.SByte.MinValue" /> or is greater than <see cref="F:System.SByte.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-827">Wartość do przekonwertowania na wartość zmiennoprzecinkową pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="8d479-827">The value to convert to a single-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="8d479-828">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość zmiennoprzecinkową pojedynczej precyzji.</span><span class="sxs-lookup"><span data-stu-id="8d479-828">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a single-precision floating-point value.</span></span></summary>
        <returns><span data-ttu-id="8d479-829">Obiekt, który zawiera najbliższego możliwa reprezentacja <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-829">An object that contains the closest possible representation of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-830">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-830">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-831">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może obejmować, utraty danych lub utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="8d479-831">Language compilers do not perform this conversion automatically because it can involve data loss or a loss of precision.</span></span> <span data-ttu-id="8d479-832">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CSng` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-832">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CSng` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-833">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-833">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="8d479-834">Ponieważ <xref:System.Numerics.BigInteger> wartość może być poza zakresem <xref:System.Single> typ danych, ta operacja jest konwersją zawężającą.</span><span class="sxs-lookup"><span data-stu-id="8d479-834">Because the <xref:System.Numerics.BigInteger> value can be outside the range of the <xref:System.Single> data type, this operation is a narrowing conversion.</span></span> <span data-ttu-id="8d479-835">Jeśli konwersja nie powiedzie się, nie zostanie zgłoszony <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-835">If the conversion is unsuccessful, it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-836">Zamiast tego Jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Single.MinValue?displayProperty=nameWithType>, wynikowy <xref:System.Single> wartość <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-836">Instead, if the <xref:System.Numerics.BigInteger> value is less than <xref:System.Single.MinValue?displayProperty=nameWithType>, the resulting <xref:System.Single> value is <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-837">Jeśli <xref:System.Numerics.BigInteger> wartość jest większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType>, wynikowy <xref:System.Single> wartość <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-837">If the <xref:System.Numerics.BigInteger> value is greater than <xref:System.Single.MaxValue?displayProperty=nameWithType>, the resulting <xref:System.Single> value is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8d479-838">Konwersja <xref:System.Numerics.BigInteger> do <xref:System.Single> może pociągać za sobą utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="8d479-838">The conversion of a <xref:System.Numerics.BigInteger> to a <xref:System.Single> may involve a loss of precision.</span></span> <span data-ttu-id="8d479-839">W niektórych przypadkach utratę dokładności może spowodować operacji rzutowania lub konwersja powiedzie się nawet wtedy, gdy <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Single> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-839">In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Single> data type.</span></span> <span data-ttu-id="8d479-840">Poniższy przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="8d479-840">The following example provides an illustration.</span></span> <span data-ttu-id="8d479-841">Przypisuje wartość maksymalna <xref:System.Single> dwóch <xref:System.Numerics.BigInteger> zmiennych, w przyrostach co <xref:System.Numerics.BigInteger> zmiennej 9.999e291 i testuje dwie zmienne pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="8d479-841">It assigns the maximum value of a <xref:System.Single> to two <xref:System.Numerics.BigInteger> variables, increments one <xref:System.Numerics.BigInteger> variable by 9.999e291, and tests the two variables for equality.</span></span> <span data-ttu-id="8d479-842">Zgodnie z oczekiwaniami, wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metoda ma pokazać, że są nierówne.</span><span class="sxs-lookup"><span data-stu-id="8d479-842">As expected, the call to the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method shows that they are unequal.</span></span> <span data-ttu-id="8d479-843">Jednak konwersja większy <xref:System.Numerics.BigInteger> wartość z powrotem na <xref:System.Single> zakończy się powodzeniem, mimo że <xref:System.Numerics.BigInteger> teraz przekracza wartość <xref:System.Single.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-843">However, the conversion of the larger <xref:System.Numerics.BigInteger> value back to a <xref:System.Single> succeeds, although the <xref:System.Numerics.BigInteger> value now exceeds <xref:System.Single.MaxValue?displayProperty=nameWithType>.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 <span data-ttu-id="8d479-844">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.Single> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-844">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Single> values.</span></span>   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-845">Wartość do przekonwertowania na liczbę całkowitą bez znaku 16-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-845">The value to convert to an unsigned 16-bit integer.</span></span></param>
        <summary><span data-ttu-id="8d479-846">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu nieoznaczoną 16-bitową wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-846">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 16-bit integer value.</span></span>  
  
<span data-ttu-id="8d479-847">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-847">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-848">Alternatywa zgodna ze standardem jest <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-848">The compliant alternative is <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-849">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-849">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-850">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-850">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-851">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-851">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-852">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUShort` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-852">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CUShort` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-853">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-853">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="8d479-854">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-854">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt16> data type.</span></span> <span data-ttu-id="8d479-855">Bez utraty dokładności w wynikowym <xref:System.UInt16> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-855">There is no loss of precision in the resulting <xref:System.UInt16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-856">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt16> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-856">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt16> values.</span></span> <span data-ttu-id="8d479-857">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt16> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-857">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt16> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-858"><paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt16.MinValue" /> lub jest większa niż <see cref="F:System.UInt16.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-858"><paramref name="value" /> is less than <see cref="F:System.UInt16.MinValue" /> or is greater than <see cref="F:System.UInt16.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-859">Wartość do przekonwertowania na liczbę całkowitą bez znaku 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-859">The value to convert to an unsigned 32-bit integer.</span></span></param>
        <summary><span data-ttu-id="8d479-860">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu nieoznaczoną 32-bitowa wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-860">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 32-bit integer value.</span></span>  
  
<span data-ttu-id="8d479-861">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-861">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-862">Alternatywa zgodna ze standardem jest <see cref="T:System.Int64" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-862">The compliant alternative is <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-863">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-863">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-864">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-864">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-865">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-865">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-866">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CUInt` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-866">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CUInt` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-867">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-867">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="8d479-868">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-868">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt32> data type.</span></span> <span data-ttu-id="8d479-869">Bez utraty dokładności w wynikowym <xref:System.UInt32> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-869">There is no loss of precision in the resulting <xref:System.UInt32> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-870">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt32> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-870">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt32> values.</span></span> <span data-ttu-id="8d479-871">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt32> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-871">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt32> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-872"><paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt32.MinValue" /> lub jest większa niż <see cref="F:System.UInt32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-872"><paramref name="value" /> is less than <see cref="F:System.UInt32.MinValue" /> or is greater than <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-873">Wartość do przekonwertowania na liczbę całkowitą bez znaku 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-873">The value to convert to an unsigned 64-bit integer.</span></span></param>
        <summary><span data-ttu-id="8d479-874">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> obiektu na nieoznaczoną 64-bitowych wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-874">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 64-bit integer value.</span></span>  
  
<span data-ttu-id="8d479-875">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-875">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-876">Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-876">The compliant alternative is <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-877">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-877">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-878">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-878">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-879">Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-879">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="8d479-880">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` lub `CULng` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-880">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CULng` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-881">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-881">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="8d479-882">Ponieważ ta operacja definiuje konwersją zawężającą, może ona zgłosić <xref:System.OverflowException> w czasie wykonywania przypadku <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-882">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt64> data type.</span></span> <span data-ttu-id="8d479-883">Bez utraty dokładności w wynikowym <xref:System.UInt64> wartość, jeśli konwersja zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-883">There is no loss of precision in the resulting <xref:System.UInt64> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="8d479-884">W poniższym przykładzie pokazano konwersji <xref:System.Numerics.BigInteger> do <xref:System.UInt64> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-884">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt64> values.</span></span> <span data-ttu-id="8d479-885">Umożliwia on również obsługę <xref:System.OverflowException> , jest generowany, ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.UInt64> typu danych.</span><span class="sxs-lookup"><span data-stu-id="8d479-885">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt64> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-886"><paramref name="value" /> jest mniejsza niż <see cref="F:System.UInt64.MinValue" /> lub jest większa niż <see cref="F:System.UInt64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-886"><paramref name="value" /> is less than <see cref="F:System.UInt64.MinValue" /> or is greater than <see cref="F:System.UInt64.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-887">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-887">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-888">Definiuje jawna konwersja <see cref="T:System.Single" /> wartość <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-888">Defines an explicit conversion of a <see cref="T:System.Single" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-889">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-889">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-890">Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-890">Any fractional part of the `value` parameter is truncated before conversion.</span></span>
 
 <span data-ttu-id="8d479-891">Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiowania typów, do którego lub z którego <xref:System.Numerics.BigInteger> może zostać skonwertowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="8d479-891">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="8d479-892">Ponieważ konwersja z <xref:System.Single> do <xref:System.Numerics.BigInteger> może obejmować obcinanie dowolnej części ułamkowej `value`, Kompilatory języka automatycznie nie wykonuj tę konwersję.</span><span class="sxs-lookup"><span data-stu-id="8d479-892">Because the conversion from <xref:System.Single> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="8d479-893">Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="8d479-893">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="8d479-894">W przeciwnym razie są wyświetlane błędu kompilatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-894">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="8d479-895">W przypadku języków, które nie obsługują operatorów niestandardowych jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-895">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="8d479-896">Poniższy przykład konwertuje poszczególnych elementów w tablicy <xref:System.Single> wartości <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdego konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-896">The following example converts the individual elements in an array of <xref:System.Single> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="8d479-897">Należy pamiętać, że wszelkie ułamkową część <xref:System.Single> wartość zostanie obcięta podczas konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-897">Note that any fractional part of a <xref:System.Single> value is truncated during the conversion.</span></span>
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8d479-898"><paramref name="value" /> jest <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, lub <see cref="F:System.Single.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-898"><paramref name="value" /> is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NegativeInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-899">Zwraca wartość wskazującą, czy określona wartość jest większy niż inny określona wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-899">Returns a value that indicates whether a specified value is greater than another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-900">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-900">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-901">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-901">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-902">Zwraca wartość wskazującą, czy całkowita 64-bitowych jest większy niż <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-902">Returns a value that indicates whether a 64-bit signed integer is greater than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-903"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-903"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-904"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-904">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-905">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-905">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 <span data-ttu-id="8d479-906">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-906">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span> <span data-ttu-id="8d479-907">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-907">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 <span data-ttu-id="8d479-908">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-908">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-909">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-909">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-910">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-910">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-911">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-911">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-912">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> jest większa niż wartość 64-bitową.</span><span class="sxs-lookup"><span data-stu-id="8d479-912">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> is greater than a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="8d479-913"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-913"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-914"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-914">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-915">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-915">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 <span data-ttu-id="8d479-916">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-916">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-917">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-917">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 <span data-ttu-id="8d479-918">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-918">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-919">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-919">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-920">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-920">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-921">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-921">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-922">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż inny <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-922">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-923"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-923"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-924"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-924">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-925">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-925">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 <span data-ttu-id="8d479-926">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-926">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-927">Można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-927">They can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 <span data-ttu-id="8d479-928">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-928">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-929">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-929">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-930">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-930">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-931">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej nieoznaczonej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-931">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-932"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-932"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-933"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-933">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-934">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-934">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 <span data-ttu-id="8d479-935">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-935">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-936">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-936">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-937">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-937">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-938">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-938">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-939">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowej nieoznaczonej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-939">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-940"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-940"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-941"><xref:System.Numerics.BigInteger.op_GreaterThan%2A> Metoda definiuje działania wyższa niż operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-941">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-942">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-942">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 <span data-ttu-id="8d479-943">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-943">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-944">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-944">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-945">Zwraca wartość wskazującą, czy określona wartość jest większa niż lub równe drugiemu określona wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-945">Returns a value that indicates whether a specified value is greater than or equal to another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-946">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-946">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-947">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-947">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-948">Zwraca wartość wskazującą, czy całkowita 64-bitowych jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-948">Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-949"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-949"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-950"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-950">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-951">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-951">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 <span data-ttu-id="8d479-952">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-952">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-953">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-953">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 <span data-ttu-id="8d479-954">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-954">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-955">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-955">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-956">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-956">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-957">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-957">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-958">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równa wartości liczby całkowitej ze znakiem 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-958">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="8d479-959"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-959"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-960"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-960">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-961">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-961">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 <span data-ttu-id="8d479-962">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-962">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-963">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-963">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 <span data-ttu-id="8d479-964">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-964">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-965">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-965">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-966">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-966">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-967">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-967">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-968">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równy innemu <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-968">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-969"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-969"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-970"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-970">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-971">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-971">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 <span data-ttu-id="8d479-972">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-972">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-973">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-973">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 <span data-ttu-id="8d479-974">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-974">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-975">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-975">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-976">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-976">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-977">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż lub równa wartości 64-bitowej nieoznaczonej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-977">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit unsigned integer value.</span></span></summary>
        <returns><span data-ttu-id="8d479-978"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-978"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-979"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-979">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-980">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-980">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 <span data-ttu-id="8d479-981">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-981">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-982">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-982">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 <span data-ttu-id="8d479-983">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-983">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-984">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-984">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-985">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-985">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-986">Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita bez znaku jest większa niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-986">Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-987"><see langword="true" /> Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-987"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-988"><xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Metoda definiuje działania większa lub równa operator <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-988">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-989">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-989">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 <span data-ttu-id="8d479-990">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-990">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-991">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-991">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 <span data-ttu-id="8d479-992">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-992">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-993">Definiuje niejawna konwersja między <see cref="T:System.Numerics.BigInteger" /> obiektu i innego typu.</span><span class="sxs-lookup"><span data-stu-id="8d479-993">Defines an implicit conversion between a <see cref="T:System.Numerics.BigInteger" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-994">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-994">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-995">Definiuje niejawnej konwersji wartości bajtu bez znaku do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-995">Defines an implicit conversion of an unsigned byte to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-996">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-996">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-997">Wszystkie części ułamkowej `value` parametr został obcięty przed dokonaniem konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-997">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="8d479-998">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-998">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="8d479-999">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-999">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1000">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1000">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1001">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Byte> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1001">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1002">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1002">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1003">Definiuje niejawną konwersję podpisem 16-bitową liczbę całkowitą do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1003">Defines an implicit conversion of a signed 16-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1004">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1004">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1005">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1005">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="8d479-1006">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1006">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1007">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1007">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1008">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Int16> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1008">This overload lets the compiler handle conversions from a <xref:System.Int16> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1009">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1009">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1010">Definiuje niejawną konwersję całkowita 32-bitowego do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1010">Defines an implicit conversion of a signed 32-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1011">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1011">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1012">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1012">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="8d479-1013">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1013">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1014">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1014">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1015">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Int32> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1015">This overload lets the compiler handle conversions from a <xref:System.Int32> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1016">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1016">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1017">Definiuje niejawną konwersję całkowita 64-bitowego do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1017">Defines an implicit conversion of a signed 64-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1018">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1018">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1019">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1019">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.</span></span>   
 
 <span data-ttu-id="8d479-1020">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1020">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1021">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1021">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1022">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Int64> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1022">This overload lets the compiler handle conversions from a <xref:System.Int64> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1023">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1023">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1024">Definiuje niejawnej konwersji wartości 8-bitowa liczba całkowita podpisem do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1024">Defines an implicit conversion of an 8-bit signed integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="8d479-1025">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-1025">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-1026">Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1026">The compliant alternative is <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-1027">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1027">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1028">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1028">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="8d479-1029">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1029">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1030">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1030">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1031">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.SByte> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1031">This overload lets the compiler handle conversions from a <xref:System.SByte> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1032">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1032">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1033">Definiuje niejawnej konwersji wartości 16-bitowej nieoznaczonej liczby całkowitej do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1033">Defines an implicit conversion of a 16-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="8d479-1034">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-1034">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-1035">Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1035">The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-1036">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1036">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1037">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1037">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="8d479-1038">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1038">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1039">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1039">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1040">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.UInt16> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1040">This overload lets the compiler handle conversions from a <xref:System.UInt16> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1041">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1041">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1042">Definiuje niejawna konwersja 32-bitowej nieoznaczonej liczby całkowitej do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1042">Defines an implicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="8d479-1043">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-1043">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-1044">Alternatywa zgodna ze standardem jest <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1044">The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-1045">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1045">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1046">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1046">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="8d479-1047">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1047">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1048">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1048">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1049">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.UInt32> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1049">This overload lets the compiler handle conversions from a <xref:System.UInt32> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1050">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1050">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1051">Definiuje niejawną konwersję 64-bitowej nieoznaczonej liczby całkowitej do <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1051">Defines an implicit conversion of a 64-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="8d479-1052">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="8d479-1052">This API is not CLS-compliant.</span></span> <span data-ttu-id="8d479-1053">Alternatywa zgodna ze standardem jest <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1053">The compliant alternative is <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="8d479-1054">Obiekt, który zawiera wartość <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1054">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1055">W przypadku języków, które nie obsługują niejawne operatory jest alternatywną metodą <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1055">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="8d479-1056">Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiowania typów, do którego lub które kompilator może automatycznie konwertować <xref:System.Numerics.BigInteger> wartości bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d479-1056">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="8d479-1057">Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1057">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="8d479-1058">To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.UInt64> wartość <xref:System.Numerics.BigInteger> wartość, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1058">This overload lets the compiler handle conversions from a <xref:System.UInt64> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1059">Wartość do zwiększenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1059">The value to increment.</span></span></param>
        <summary><span data-ttu-id="8d479-1060">Zwiększa <see cref="T:System.Numerics.BigInteger" /> wartość o 1.</span><span class="sxs-lookup"><span data-stu-id="8d479-1060">Increments a <see cref="T:System.Numerics.BigInteger" /> value by 1.</span></span></summary>
        <returns><span data-ttu-id="8d479-1061">Wartość <paramref name="value" /> parametru zwiększane o 1.</span><span class="sxs-lookup"><span data-stu-id="8d479-1061">The value of the <paramref name="value" /> parameter incremented by 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1062"><xref:System.Numerics.BigInteger.op_Increment%2A> Metoda definiuje operacja zwiększenia wartości <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1062">The <xref:System.Numerics.BigInteger.op_Increment%2A> method defines the increment operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1063">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1063">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 <span data-ttu-id="8d479-1064">Niektóre języki (takie jak Visual Basic), które nie mają operatora inkrementacji lub nie obsługują przeciążanie operatora może wywołać <xref:System.Numerics.BigInteger.op_Increment%2A> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1064">Some languages (such as Visual Basic) that lack an increment operator or do not support operator overloading can call the <xref:System.Numerics.BigInteger.op_Increment%2A> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 <span data-ttu-id="8d479-1065">Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne, <xref:System.Numerics.BigInteger.op_Increment%2A> operator tworzy nową <xref:System.Numerics.BigInteger> obiektu, którego wartość jest jeden więcej niż <xref:System.Numerics.BigInteger> obiektu reprezentowanego przez `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1065">Because <xref:System.Numerics.BigInteger> objects are immutable, the <xref:System.Numerics.BigInteger.op_Increment%2A> operator creates a new <xref:System.Numerics.BigInteger> object whose value is one more than the <xref:System.Numerics.BigInteger> object represented by `value`.</span></span> <span data-ttu-id="8d479-1066">W związku z tym, wielokrotne wywołania <xref:System.Numerics.BigInteger.op_Increment%2A> może być kosztowne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1066">Therefore, repeated calls to <xref:System.Numerics.BigInteger.op_Increment%2A> may be expensive.</span></span>  
  
 <span data-ttu-id="8d479-1067">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1067">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-1068">Zwraca wartość wskazującą, czy dwie wartości liczbowe nie są równe.</span><span class="sxs-lookup"><span data-stu-id="8d479-1068">Returns a value that indicates whether two numeric values are not equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1069">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1069">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1070">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1070">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1071">Zwraca wartość, która wskazuje, czy całkowita 64-bitowym a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-1071">Returns a value that indicates whether a 64-bit signed integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-1072"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1072"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1073"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1073">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1074">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1074">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 <span data-ttu-id="8d479-1075">Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:</span><span class="sxs-lookup"><span data-stu-id="8d479-1075">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="8d479-1076">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość podpisem liczba całkowita typu long.</span><span class="sxs-lookup"><span data-stu-id="8d479-1076">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instance method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and a signed long integer value.</span></span>  
  
-   <span data-ttu-id="8d479-1077">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> wystąpienia metody i cofania jej wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1077">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method and reversing its value.</span></span>  
  
 <span data-ttu-id="8d479-1078">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-1078">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1079">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1079">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1080">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1080">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1081">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i całkowita 64-bitowe nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-1081">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit signed integer are not equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-1082"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1082"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1083"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1083">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1084">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1084">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 <span data-ttu-id="8d479-1085">Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:</span><span class="sxs-lookup"><span data-stu-id="8d479-1085">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="8d479-1086">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość podpisem liczba całkowita typu long.</span><span class="sxs-lookup"><span data-stu-id="8d479-1086">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and a signed long integer value.</span></span>  
  
-   <span data-ttu-id="8d479-1087">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metody i cofania jej wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1087">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 <span data-ttu-id="8d479-1088">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-1088">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-1089">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1089">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1090">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1090">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1091">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1091">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1092">Zwraca wartość wskazującą, czy dwa <see cref="T:System.Numerics.BigInteger" /> obiekty mają różne wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1092">Returns a value that indicates whether two <see cref="T:System.Numerics.BigInteger" /> objects have different values.</span></span></summary>
        <returns><span data-ttu-id="8d479-1093"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1093"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1094"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1094">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1095">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1095">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 <span data-ttu-id="8d479-1096">Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:</span><span class="sxs-lookup"><span data-stu-id="8d479-1096">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="8d479-1097">Wywoływanie <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody, która określa relację między dwiema <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1097">Calling the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method, which indicates the relationship between two <xref:System.Numerics.BigInteger> objects.</span></span>  
  
-   <span data-ttu-id="8d479-1098">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody i cofania jej wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1098">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 <span data-ttu-id="8d479-1099">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1099">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1100">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1100">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1101">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1101">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1102">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> nie są takie same wartości i 64-bitowej nieoznaczonej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1102">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit unsigned integer are not equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-1103"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1103"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1104"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1104">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1105">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1105">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 <span data-ttu-id="8d479-1106">Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:</span><span class="sxs-lookup"><span data-stu-id="8d479-1106">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="8d479-1107">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość niepodpisane długa liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="8d479-1107">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and an unsigned long integer value.</span></span>  
  
-   <span data-ttu-id="8d479-1108">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metody i cofania jej wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1108">Calling the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1109">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1109">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1110">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1110">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1111">Zwraca wartość wskazującą, czy 64-bitowej nieoznaczonej liczby całkowitej, a jeśli tak, to a <see cref="T:System.Numerics.BigInteger" /> wartości nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="8d479-1111">Returns a value that indicates whether a 64-bit unsigned integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</span></span></summary>
        <returns><span data-ttu-id="8d479-1112"><see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1112"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1113"><xref:System.Numerics.BigInteger.op_Inequality%2A> Metoda definiuje operacji operator nierówności dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1113">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1114">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1114">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 <span data-ttu-id="8d479-1115">Języki, które nie obsługują operatorów niestandardowych, można sprawdzić pod kątem nierówności przy użyciu jednej z następujących technik:</span><span class="sxs-lookup"><span data-stu-id="8d479-1115">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="8d479-1116">Wywoływanie <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody, która określa relację pomiędzy <xref:System.Numerics.BigInteger> i wartość niepodpisane długa liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="8d479-1116">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and an unsigned long integer value.</span></span>  
  
-   <span data-ttu-id="8d479-1117">Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metody i cofania jej wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1117">Calling the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1118">Wartość, w których bity są lekkie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1118">The value whose bits are to be shifted.</span></span></param>
        <param name="shift"><span data-ttu-id="8d479-1119">Liczba bitów, aby przenieść <paramref name="value" /> po lewej stronie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1119">The number of bits to shift <paramref name="value" /> to the left.</span></span></param>
        <summary><span data-ttu-id="8d479-1120">Przesunięcia <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w lewo.</span><span class="sxs-lookup"><span data-stu-id="8d479-1120">Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the left.</span></span></summary>
        <returns><span data-ttu-id="8d479-1121">Wartość, która ma zostać przesunięty po lewej stronie przez określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1121">A value that has been shifted to the left by the specified number of bits.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1122"><xref:System.Numerics.BigInteger.op_LeftShift%2A> Metoda definiuje operacji bitowy operator przesunięcia w lewo, aby uzyskać <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1122">The <xref:System.Numerics.BigInteger.op_LeftShift%2A> method defines the operation of the bitwise left-shift operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1123">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1123">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1124">W odróżnieniu od bitowe operacji przesunięcia w lewo przy użyciu podstawowych całkowitą <xref:System.Numerics.BigInteger.op_LeftShift%2A> metody zachowuje znak oryginalny <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1124">Unlike the bitwise left-shift operation with integer primitives, the <xref:System.Numerics.BigInteger.op_LeftShift%2A> method preserves the sign of the original <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="8d479-1125">Języki, które nie obsługują operatorów niestandardowych, można wykonać operacji przesunięcia w lewo na poziomie bitowym przez pomnożenie `value` przez `BigInteger.Pow(2, shift)`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1125">Languages that do not support custom operators can perform a bitwise left-shift operation by multiplying `value` by `BigInteger.Pow(2, shift)`.</span></span> <span data-ttu-id="8d479-1126">Poniższy przykład pokazuje, że wyniki są takie same jak wyniki użycia tego operatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-1126">The following example shows that the results are identical to the results of using this operator.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-1127">Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż druga określona wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1127">Returns a value that indicates whether a specified value is less than a second specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1128">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1128">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1129">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1129">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1130">Zwraca wartość wskazującą, czy jest całkowita 64-bitowych, mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1130">Returns a value that indicates whether a 64-bit signed integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1131"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1131"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1132"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1132">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1133">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1133">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 <span data-ttu-id="8d479-1134">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1134">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1135">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1135">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 <span data-ttu-id="8d479-1136">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-1136">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-1137">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1137">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1138">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1138">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1139">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1139">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1140">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1140">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-1141"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1141"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1142"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1142">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1143">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1143">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 <span data-ttu-id="8d479-1144">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1144">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1145">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1145">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 <span data-ttu-id="8d479-1146">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-1146">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-1147">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1147">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1148">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1148">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1149">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1149">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1150">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejszy niż inny <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1150">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1151"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1151"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1152"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1152">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1153">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1153">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 <span data-ttu-id="8d479-1154">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1154">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1155">Niektóre języki można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1155">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 <span data-ttu-id="8d479-1156">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1156">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1157">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1157">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1158">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1158">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1159">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowej nieoznaczonej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1159">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-1160"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1160"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1161"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1161">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1162">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1162">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 <span data-ttu-id="8d479-1163">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1163">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1164">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1164">They can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 <span data-ttu-id="8d479-1165">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1165">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1166">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1166">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1167">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1167">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1168">Zwraca wartość wskazującą, czy jest 64-bitowej nieoznaczonej liczby całkowitej, mniej niż a <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1168">Returns a value that indicates whether a 64-bit unsigned integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1169"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1169"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1170"><xref:System.Numerics.BigInteger.op_LessThan%2A> Metoda definiuje less than-operator dla działania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1170">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1171">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1171">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 <span data-ttu-id="8d479-1172">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1172">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1173">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1173">They can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 <span data-ttu-id="8d479-1174">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1174">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-1175">Zwraca wartość wskazującą, czy określona wartość jest mniejsza niż lub równe inną określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1175">Returns a value that indicates whether a specified value is less than or equal to another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1176">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1176">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1177">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1177">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1178">Zwraca wartość wskazującą, czy całkowita 64-bitowych jest mniejsza niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1178">Returns a value that indicates whether a 64-bit signed integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1179"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1179"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1180"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1180">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1181">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1181">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 <span data-ttu-id="8d479-1182">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1182">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1183">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1183">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 <span data-ttu-id="8d479-1184">Jeśli `left` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-1184">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-1185">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1185">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1186">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1186">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1187">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1187">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1188">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1188">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-1189"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1189"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1190"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1190">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1191">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1191">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 <span data-ttu-id="8d479-1192">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1192">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1193">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1193">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 <span data-ttu-id="8d479-1194">Jeśli `right` jest <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, lub <xref:System.UInt32> wartości, jest niejawnie konwertowany na <xref:System.Int64> wartość, gdy operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="8d479-1194">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="8d479-1195">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1195">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1196">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1196">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1197">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1197">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1198">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równy innemu <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1198">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1199"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1199"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1200"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1200">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1201">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1201">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 <span data-ttu-id="8d479-1202">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Compare%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1202">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A> method instead.</span></span> <span data-ttu-id="8d479-1203">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1203">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 <span data-ttu-id="8d479-1204">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1204">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1205">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1205">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1206">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1206">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1207">Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równe 64-bitowej nieoznaczonej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1207">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="8d479-1208"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1208"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1209"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1209">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1210">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1210">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 <span data-ttu-id="8d479-1211">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1211">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1212">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1212">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 <span data-ttu-id="8d479-1213">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1213">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1214">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1214">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1215">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1215">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="8d479-1216">Zwraca wartość wskazującą, czy 64-bitowej nieoznaczonej liczby całkowitej jest mniejsza niż lub równa <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1216">Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1217"><see langword="true" /> Jeśli <paramref name="left" /> jest mniejsza niż lub równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1217"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1218"><xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Metoda określa operację mniejszą lub równą operatora dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1218">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1219">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1219">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 <span data-ttu-id="8d479-1220">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1220">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="8d479-1221">Można również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metoda bezpośrednio w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="8d479-1221">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 <span data-ttu-id="8d479-1222">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1222">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="8d479-1223">Wartość do podzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1223">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="8d479-1224">Wartość do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-1224">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="8d479-1225">Zwraca resztę, która wynika z podziału przy użyciu dwóch określonych <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1225">Returns the remainder that results from division with two specified <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-1226">Resztę, która wynika z podziału.</span><span class="sxs-lookup"><span data-stu-id="8d479-1226">The remainder that results from the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1227"><xref:System.Numerics.BigInteger.op_Modulus%2A> Metoda definiuje operacji operator modulo <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1227">The <xref:System.Numerics.BigInteger.op_Modulus%2A> method defines the operation of the modulus operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1228">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1228">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 <span data-ttu-id="8d479-1229">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1229">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> method instead.</span></span>  
  
 <span data-ttu-id="8d479-1230">Znak wartości zwróconej przez operacji modulo zależy od jej znaku `dividend`: Jeśli `dividend` jest dodatnia, operacji modulo zwraca wynik dodatni; Jeśli jest ujemna, Operacja modulo zwraca wynik ujemny.</span><span class="sxs-lookup"><span data-stu-id="8d479-1230">The sign of the value returned by the modulus operation depends on the sign of `dividend`: If `dividend` is positive, the modulus operation returns a positive result; if it is negative, the modulus operation returns a negative result.</span></span> <span data-ttu-id="8d479-1231">Zachowanie operacji modulo z <xref:System.Numerics.BigInteger> wartości jest taka sama jak operacja wyznaczania modułu przy użyciu innych typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1231">The behavior of the modulus operation with <xref:System.Numerics.BigInteger> values is identical to the modulus operation with other integral types.</span></span>  
  
 <span data-ttu-id="8d479-1232">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1232">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="8d479-1233"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-1233"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1234">Pierwsza wartość do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1234">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1235">Druga wartość do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1235">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="8d479-1236">Mnoży dwie określone <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1236">Multiplies two specified <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="8d479-1237">Iloczyn <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1237">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1238"><xref:System.Numerics.BigInteger.op_Multiply%2A> Metoda definiuje operacji operator mnożenia dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1238">The <xref:System.Numerics.BigInteger.op_Multiply%2A> method defines the operation of the multiplication operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1239">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1239">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 <span data-ttu-id="8d479-1240">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1240">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1241">Wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-1241">An integer value.</span></span></param>
        <summary><span data-ttu-id="8d479-1242">Zwraca operatora testu koniunkcji, jeden w uzupełniają z <see cref="T:System.Numerics.BigInteger" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1242">Returns the bitwise one's complement of a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1243">Bitowe jednego użytkownika uzupełniają z <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1243">The bitwise one's complement of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1244"><xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda określa operację bitowy operator dopełnienia jednostkowego dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1244">The <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method defines the operation of the bitwise one's complement operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1245">Bitowy operator dopełnienia jednostkowego odwraca każdy bit w wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1245">The bitwise one's complement operator reverses each bit in a numeric value.</span></span> <span data-ttu-id="8d479-1246">Oznacza to, że usługa bits w `value` , które są 0 są ustawione na 1, w wyniku i bity, które są 1 są ustawione na 0 w wyniku.</span><span class="sxs-lookup"><span data-stu-id="8d479-1246">That is, bits in `value` that are 0 are set to 1 in the result, and bits that are 1 are set to 0 in the result.</span></span> <span data-ttu-id="8d479-1247"><xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda umożliwia następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="8d479-1247">The <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 <span data-ttu-id="8d479-1248">Języki, które nie obsługują operatorów niestandardowych mogą mieć możliwość wywoływania <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metoda bezpośrednio do wykonania bitowej, jednostkowego uzupełniają operacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1248">Languages that do not support custom operators may be able to call the <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method directly to perform a bitwise one's complement operation.</span></span> <span data-ttu-id="8d479-1249">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="8d479-1249">For example:</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1250">Wartość, w których bity są lekkie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1250">The value whose bits are to be shifted.</span></span></param>
        <param name="shift"><span data-ttu-id="8d479-1251">Liczba bitów, aby przenieść <paramref name="value" /> po prawej stronie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1251">The number of bits to shift <paramref name="value" /> to the right.</span></span></param>
        <summary><span data-ttu-id="8d479-1252">Przesunięcia <see cref="T:System.Numerics.BigInteger" /> wartość określoną liczbę bitów w prawo.</span><span class="sxs-lookup"><span data-stu-id="8d479-1252">Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the right.</span></span></summary>
        <returns><span data-ttu-id="8d479-1253">Wartość, która ma zostać przesunięty po prawej stronie przez określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1253">A value that has been shifted to the right by the specified number of bits.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1254"><xref:System.Numerics.BigInteger.op_RightShift%2A> Metoda definiuje operacji bitowy operator przesunięcia w prawo, aby uzyskać <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1254">The <xref:System.Numerics.BigInteger.op_RightShift%2A> method defines the operation of the bitwise right-shift operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1255">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1255">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 <span data-ttu-id="8d479-1256">Języki, które nie obsługują operatorów niestandardowych, można wykonać operacji przesunięcia w prawo na poziomie bitowym przez podzielenie `value` przez `BigInteger.Pow(2, shift)` i odejmowanie 1 razy `shift` dla wartości ujemnych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1256">Languages that do not support custom operators can perform a bitwise right-shift operation by dividing `value` by `BigInteger.Pow(2, shift)` and subtracting 1 times `shift` for negative values.</span></span> <span data-ttu-id="8d479-1257">Poniższy przykład pokazuje, że wyniki są takie same jak wyniki użycia tego operatora.</span><span class="sxs-lookup"><span data-stu-id="8d479-1257">The following example shows that the results are identical to the results of using this operator.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 <span data-ttu-id="8d479-1258">Jeśli `shift` jest większa niż lub równa liczbie bitów dodatnią <xref:System.Numerics.BigInteger> , wynik operacji przesunięcia w prawo wartość <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1258">If `shift` is greater than or equal to the number of bits in a positive <xref:System.Numerics.BigInteger> value, the result of the right-shift operation is <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-1259">Jeśli `shift` jest większa niż liczba bitów ujemnych <xref:System.Numerics.BigInteger> , wynik operacji przesunięcia w prawo wartość <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1259">If `shift` is greater than the number of bits in a negative <xref:System.Numerics.BigInteger> value, the result of the right-shift operation is <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1260">Wartość do odjęcia od (odjemna).</span><span class="sxs-lookup"><span data-stu-id="8d479-1260">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1261">Wartość do odjęcia (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="8d479-1261">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="8d479-1262">Odejmuje <see cref="T:System.Numerics.BigInteger" /> wartości z innej <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1262">Subtracts a <see cref="T:System.Numerics.BigInteger" /> value from another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1263">Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1263">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1264"><xref:System.Numerics.BigInteger.op_Subtraction%2A> Metoda definiuje operacji operator odejmowania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1264">The <xref:System.Numerics.BigInteger.op_Subtraction%2A> method defines the operation of the subtraction operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1265">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="8d479-1265">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 <span data-ttu-id="8d479-1266">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1266">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> method instead.</span></span>  
  
 <span data-ttu-id="8d479-1267">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1267">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1268">Wartość do wskazania ujemnej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1268">The value to negate.</span></span></param>
        <summary><span data-ttu-id="8d479-1269">Neguje określoną wartość duża liczba całkowita.</span><span class="sxs-lookup"><span data-stu-id="8d479-1269">Negates a specified BigInteger value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1270">Wynik <paramref name="value" /> parametru pomnożona przez wartość ujemną (-1).</span><span class="sxs-lookup"><span data-stu-id="8d479-1270">The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1271"><xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Metoda określa operację Jednoargumentowy operator negacji (lub operator odwrotność dodatku) dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1271">The <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> method defines the operation of the unary negation operator (or the additive inverse operator) for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1272">Operacja generują wartość, która skutkuje 0 (zero), gdy jest ona dodawana do liczby.</span><span class="sxs-lookup"><span data-stu-id="8d479-1272">The operation produces a value that results in 0 (zero) when it is added to the original number.</span></span> <span data-ttu-id="8d479-1273">Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.BigInteger.Negate%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1273">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="8d479-1274">Jest równoważne metodę dla tego operatora <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8d479-1274">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="8d479-1275">Poniższy przykład przedstawia trzy różne sposoby, aby odwrócić wartość <xref:System.Numerics.BigInteger> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1275">The following example illustrates three different ways to negate the value of a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1276">Wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="8d479-1276">An integer value.</span></span></param>
        <summary><span data-ttu-id="8d479-1277">Zwraca wartość <see cref="T:System.Numerics.BigInteger" /> operand.</span><span class="sxs-lookup"><span data-stu-id="8d479-1277">Returns the value of the <see cref="T:System.Numerics.BigInteger" /> operand.</span></span> <span data-ttu-id="8d479-1278">(Znak argumentu operacji jest bez zmian).</span><span class="sxs-lookup"><span data-stu-id="8d479-1278">(The sign of the operand is unchanged.)</span></span></summary>
        <returns><span data-ttu-id="8d479-1279">Wartość <paramref name="value" /> operand.</span><span class="sxs-lookup"><span data-stu-id="8d479-1279">The value of the <paramref name="value" /> operand.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1280"><xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Metoda definiuje operacji jednoargumentowej dodatnią dla <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1280">The <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> method defines the operation of the unary positive operator for <xref:System.Numerics.BigInteger> values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-1281">Konwertuje ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1281">Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1282">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="8d479-1282">A string that contains the number to convert.</span></span></param>
        <summary><span data-ttu-id="8d479-1283">Konwertuje ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1283">Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="8d479-1284">Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1284">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1285">`value` Parametr powinien być ciąg reprezentujący numer w następującej postaci.</span><span class="sxs-lookup"><span data-stu-id="8d479-1285">The `value` parameter should be the string representation of a number in the following form.</span></span>  
  
 <span data-ttu-id="8d479-1286">[*ws*] [*logowania*]*cyfr*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1286">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1287">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1287">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="8d479-1288">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1288">The following table describes each element.</span></span>  
  
|<span data-ttu-id="8d479-1289">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1289">Element</span></span>|<span data-ttu-id="8d479-1290">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1290">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="8d479-1291">*ws*</span><span class="sxs-lookup"><span data-stu-id="8d479-1291">*ws*</span></span>|<span data-ttu-id="8d479-1292">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="8d479-1292">Optional white space.</span></span>|  
|<span data-ttu-id="8d479-1293">*sign*</span><span class="sxs-lookup"><span data-stu-id="8d479-1293">*sign*</span></span>|<span data-ttu-id="8d479-1294">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="8d479-1294">An optional sign.</span></span> <span data-ttu-id="8d479-1295">Prawidłowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1295">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the current culture.</span></span>|  
|<span data-ttu-id="8d479-1296">*cyfry*</span><span class="sxs-lookup"><span data-stu-id="8d479-1296">*digits*</span></span>|<span data-ttu-id="8d479-1297">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1297">A sequence of digits ranging from 0 to 9.</span></span> <span data-ttu-id="8d479-1298">Wszystkie zera wiodące są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="8d479-1298">Any leading zeros are ignored.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1299">Ciąg określony przez `value` parametr jest interpretowany przy użyciu <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1299">The string specified by the `value` parameter is interpreted by using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="8d479-1300">Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1300">It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
 <span data-ttu-id="8d479-1301">`value` Parametru jest analizowany przy użyciu informacje o formatowaniu w <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> inicjowanym dla bieżącej kultury systemu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1301">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> object that is initialized for the current system culture.</span></span> <span data-ttu-id="8d479-1302">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1302">For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-1303">Aby przeanalizować ciąg przy użyciu informacje o formatowaniu określonej kultury, należy użyć <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-1303">To parse a string by using the formatting information of a specific culture, use the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d479-1304">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1304">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="8d479-1305">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1305">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1306">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1306">The following example uses the <xref:System.Numerics.BigInteger.Parse%28System.String%29> method to instantiate two <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="8d479-1307">Mnoży każdy obiekt przez inną liczbę, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę pozwala ustalić relacji między dwiema wartościami.</span><span class="sxs-lookup"><span data-stu-id="8d479-1307">It multiplies each object by another number and then calls the <xref:System.Numerics.BigInteger.Compare%2A> method to determine the relationship between the two values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d479-1308"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1308"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8d479-1309"><paramref name="value" /> nie jest w poprawnym formacie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1309"><paramref name="value" /> is not in the correct format.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1310">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="8d479-1310">A string that contains a number to convert.</span></span></param>
        <param name="style"><span data-ttu-id="8d479-1311">Bitowa kombinacja wartości wyliczenia, które określają dozwolony format parametru <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1311">A bitwise combination of the enumeration values that specify the permitted format of <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1312">Konwertuje ciąg reprezentujący numer w określony styl do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1312">Converts the string representation of a number in a specified style to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="8d479-1313">Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1313">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1314">`style` Parametru definiuje elementy stylu (takie jak biały znak, symbol znaku dodatniego lub ujemnego, symbol separatora grupy lub symbol separatora dziesiętnego), które są dozwolone w `value` parametr jako warunek powodzenia operacji analizy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1314">The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="8d479-1315">`styles` musi być kombinacją kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1315">`styles` must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="8d479-1316">`style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera ciąg reprezentujący wartość szesnastkową, gdy system numer (dziesiętnych lub szesnastkowych) reprezentowany przez `value` jest znana dopiero w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub symbol znaku w `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1316">The `style` parameter makes this method overload useful when `value` contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by `value` is known only at run time, or when you want to disallow white space or a sign symbol in `value`.</span></span>  
  
 <span data-ttu-id="8d479-1317">W zależności od wartości `style`, `value` parametru może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1317">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="8d479-1318">[*ws*] [*$*] [*logowania*] [*cyfr*,]*cyfr*[. *cyfry_ułamkowe*] [E [*logowania*]*cyfry_szesnastkowe*] [*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1318">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1319">Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametru może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1319">If `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, the `value` parameter may contain the following elements:</span></span>  
  
 <span data-ttu-id="8d479-1320">[*ws*]*cyfry_szesnastkowe*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1320">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1321">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1321">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="8d479-1322">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1322">The following table describes each element.</span></span>  
  
|<span data-ttu-id="8d479-1323">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1323">Element</span></span>|<span data-ttu-id="8d479-1324">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1324">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="8d479-1325">*ws*</span><span class="sxs-lookup"><span data-stu-id="8d479-1325">*ws*</span></span>|<span data-ttu-id="8d479-1326">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="8d479-1326">Optional white space.</span></span> <span data-ttu-id="8d479-1327">Odstęp może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1327">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="8d479-1328">Symbol waluty specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1328">A culture-specific currency symbol.</span></span> <span data-ttu-id="8d479-1329">Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1329">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the current culture.</span></span> <span data-ttu-id="8d479-1330">Symbol waluty bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1330">The current culture's currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1331">*sign*</span><span class="sxs-lookup"><span data-stu-id="8d479-1331">*sign*</span></span>|<span data-ttu-id="8d479-1332">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="8d479-1332">An optional sign.</span></span> <span data-ttu-id="8d479-1333">Znak może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1333">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="8d479-1334">Nawiasy mogą być używane w `value` do wskazania wartości ujemnej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1334">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1335">*cyfry*</span><span class="sxs-lookup"><span data-stu-id="8d479-1335">*digits*</span></span><br /><br /> <span data-ttu-id="8d479-1336">*cyfry_ułamkowe*</span><span class="sxs-lookup"><span data-stu-id="8d479-1336">*fractional_digits*</span></span><br /><br /> <span data-ttu-id="8d479-1337">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="8d479-1337">*exponential_digits*</span></span>|<span data-ttu-id="8d479-1338">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1338">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="8d479-1339">Aby uzyskać *cyfry_ułamkowe*należy korzystać tylko z cyfr 0 jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1339">For *fractional_digits*, only the digit 0 is valid.</span></span>|  
|<span data-ttu-id="8d479-1340">*,*</span><span class="sxs-lookup"><span data-stu-id="8d479-1340">*,*</span></span>|<span data-ttu-id="8d479-1341">Symbol separatora grupy specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1341">A culture-specific group separator symbol.</span></span> <span data-ttu-id="8d479-1342">Separator grupy bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1342">The current culture's group separator can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1343">*.*</span><span class="sxs-lookup"><span data-stu-id="8d479-1343">*.*</span></span>|<span data-ttu-id="8d479-1344">Symbol dziesiętny specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1344">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="8d479-1345">Symbol separatora dziesiętnego bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1345">The current culture's decimal point symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="8d479-1346">Może występować tylko cyfry od 0, wyświetlaną cyfrą ułamkową operacja analizy się powiodła Jeśli *cyfry_ułamkowe* zawiera jakąkolwiek inną cyfrę, <xref:System.FormatException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="8d479-1346">Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, a <xref:System.FormatException> is thrown.</span></span>|  
|<span data-ttu-id="8d479-1347">E</span><span class="sxs-lookup"><span data-stu-id="8d479-1347">E</span></span>|<span data-ttu-id="8d479-1348">Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).</span><span class="sxs-lookup"><span data-stu-id="8d479-1348">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="8d479-1349">`value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1349">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1350">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="8d479-1350">*hexdigits*</span></span>|<span data-ttu-id="8d479-1351">Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.</span><span class="sxs-lookup"><span data-stu-id="8d479-1351">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="8d479-1352">Wszystkie znaki (U + 0000) NUL kończącego w `s` są ignorowane przez operacji analizowania, bez względu na wartość `style` argumentu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1352">Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.</span></span>

 <span data-ttu-id="8d479-1353">Ciąg zawierający tylko cyfry (co odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1353">A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully.</span></span> <span data-ttu-id="8d479-1354">Większość pozostałych <xref:System.Globalization.NumberStyles> składowych kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1354">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in the input string.</span></span> <span data-ttu-id="8d479-1355">Poniższa tabela wskazuje, jak poszczególne <xref:System.Globalization.NumberStyles> członków wpływają na elementy, które mogą być obecne w `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1355">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="8d479-1356">`NumberStyles` Wartość</span><span class="sxs-lookup"><span data-stu-id="8d479-1356">`NumberStyles` value</span></span>|<span data-ttu-id="8d479-1357">Elementy dozwolone w parametrze `value` poza cyframi</span><span class="sxs-lookup"><span data-stu-id="8d479-1357">Elements permitted in `value` in addition to digits</span></span>|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="8d479-1358">*Cyfr* tylko element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1358">The *digits* element only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="8d479-1359">Separatora dziesiętnego (.) i *cyfr ułamkowych, jaka* elementów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1359">The decimal point (.) and *fractional-digits* elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="8d479-1360">"E" lub znak "E", co oznacza zapis wykładniczy, razem z *cyfry_szesnastkowe*.</span><span class="sxs-lookup"><span data-stu-id="8d479-1360">The "e" or "E" character, which indicates exponential notation, along with *exponential_digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="8d479-1361">*Ws* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1361">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="8d479-1362">*Ws* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1362">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="8d479-1363">*Logowania* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1363">The *sign* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="8d479-1364">*Logowania* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1364">The *sign* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="8d479-1365">*Logowania* elementu w postaci nawiasów obejmujących wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1365">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="8d479-1366">Element separatora grupy (,).</span><span class="sxs-lookup"><span data-stu-id="8d479-1366">The group separator (,) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="8d479-1367">Element określający walutę ($).</span><span class="sxs-lookup"><span data-stu-id="8d479-1367">The currency ($) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="8d479-1368">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1368">All elements.</span></span> <span data-ttu-id="8d479-1369">Jednak `value` nie może reprezentować liczby szesnastkowej ani liczby w zapisie wykładniczym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1369">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="8d479-1370">*Ws* element na początku lub końcu `value`, *logowania* na początku `value`i separator dziesiętny (*.*) symbol.</span><span class="sxs-lookup"><span data-stu-id="8d479-1370">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (*.*) symbol.</span></span> <span data-ttu-id="8d479-1371">`value` Parametru można również użyć notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1371">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="8d479-1372">`ws`, `sign`, Separator grupy (*,*) i separator dziesiętny (*.*) elementów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1372">The `ws`, `sign`, group separator (*,*), and decimal point (*.*) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="8d479-1373">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1373">All elements.</span></span> <span data-ttu-id="8d479-1374">Jednak `value` nie może reprezentować liczby szesnastkowej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1374">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d479-1375">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1375">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="8d479-1376">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1376">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="8d479-1377">W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności elementów konkretnego stylu w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> wartość stylu oznacza, że poszczególne znaki numeryczne w `value` są zawsze interpretowane jako znaki szesnastkowe.</span><span class="sxs-lookup"><span data-stu-id="8d479-1377">Unlike the other <xref:System.Globalization.NumberStyles> values, which allow for, but do not require, the presence of particular style elements in `value`, the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> style value means that the individual numeric characters in `value` are always interpreted as hexadecimal characters.</span></span> <span data-ttu-id="8d479-1378">Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f.</span><span class="sxs-lookup"><span data-stu-id="8d479-1378">Valid hexadecimal characters are 0-9, A-F, and a-f.</span></span> <span data-ttu-id="8d479-1379">Jedyne inne flagi, które mogą być łączone z `style` parametru są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1379">The only other flags that can be combined with the `style` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-1380">( <xref:System.Globalization.NumberStyles> Wyliczenia zawiera kompozytowy styl <xref:System.Globalization.NumberStyles.HexNumber>, który zawiera obie flagi odstępu.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1380">(The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1381">Jeśli `value` jest ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym uzupełnieniem (takie jak `0x` lub `&h`) które odróżnia go jako liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1381">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="8d479-1382">To powoduje niepowodzenie konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1382">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="8d479-1383">Jeśli `value` jest ciąg szesnastkowy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metoda `value` jako liczba ujemna przechowywane przy użyciu reprezentacji uzupełnienie dwójki, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równa `0x80`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1383">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="8d479-1384">Innymi słowy, metoda interpretuje bitu najwyższego rzędu pierwszego bajtu w `value` jako bitu znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-1384">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="8d479-1385">Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako liczba dodatnia, pierwsza cyfra w `value` musi mieć wartość zero.</span><span class="sxs-lookup"><span data-stu-id="8d479-1385">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="8d479-1386">Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartości dodatniej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1386">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="8d479-1387">Poniższy przykład ilustruje różnicę między ciągów szesnastkowych, które reprezentują wartości ujemny i dodatni.</span><span class="sxs-lookup"><span data-stu-id="8d479-1387">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 <span data-ttu-id="8d479-1388">`value` Parametru jest analizowany przy użyciu informacje o formatowaniu w <xref:System.Globalization.NumberFormatInfo> inicjowanym dla bieżącej kultury systemu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1388">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture.</span></span> <span data-ttu-id="8d479-1389">Aby określić kulturę, której informacje o formatowaniu jest używany dla udanej operacji, należy wywołać <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1389">To specify the culture whose formatting information is used for the parse operation, call the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1390">Poniższy przykład ilustruje sposób wywołania <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metody za pomocą kilku możliwych wartości dla `style` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1390">The following example illustrates calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method with several possible values for the `style` parameter.</span></span> <span data-ttu-id="8d479-1391">Przedstawia on sposób zinterpretować ciąg jako wartość szesnastkową oraz uniemożliwić miejsca do magazynowania i podpisać symboli.</span><span class="sxs-lookup"><span data-stu-id="8d479-1391">It illustrates how to interpret a string as a hexadecimal value, and how to disallow spaces and sign symbols.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d479-1392"><paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1392"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
<span data-ttu-id="8d479-1393">—lub—</span><span class="sxs-lookup"><span data-stu-id="8d479-1393">-or-</span></span> 
 <span data-ttu-id="8d479-1394"><paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartością.</span><span class="sxs-lookup"><span data-stu-id="8d479-1394"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d479-1395"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1395"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8d479-1396"><paramref name="value" /> nie jest zgodny z wzorca danych wejściowych, określony przez <see cref="T:System.Globalization.NumberStyles" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1396"><paramref name="value" /> does not comply with the input pattern specified by <see cref="T:System.Globalization.NumberStyles" />.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1397">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="8d479-1397">A string that contains a number to convert.</span></span></param>
        <param name="provider"><span data-ttu-id="8d479-1398">Obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury na temat <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1398">An object that provides culture-specific formatting information about <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1399">Konwertuje ciąg reprezentujący numer w określonym formacie specyficzne dla kultury, aby jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1399">Converts the string representation of a number in a specified culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="8d479-1400">Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1400">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1401">`value` Parametr powinien być ciąg reprezentujący numer w następującej postaci:</span><span class="sxs-lookup"><span data-stu-id="8d479-1401">The `value` parameter should be the string representation of a number in the following form:</span></span>  
  
 <span data-ttu-id="8d479-1402">[*ws*] [*logowania*]*cyfr*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1402">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1403">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1403">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="8d479-1404">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1404">The following table describes each element.</span></span>  
  
|<span data-ttu-id="8d479-1405">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1405">Element</span></span>|<span data-ttu-id="8d479-1406">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1406">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="8d479-1407">*ws*</span><span class="sxs-lookup"><span data-stu-id="8d479-1407">*ws*</span></span>|<span data-ttu-id="8d479-1408">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="8d479-1408">Optional white space.</span></span>|  
|<span data-ttu-id="8d479-1409">*sign*</span><span class="sxs-lookup"><span data-stu-id="8d479-1409">*sign*</span></span>|<span data-ttu-id="8d479-1410">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="8d479-1410">An optional sign.</span></span> <span data-ttu-id="8d479-1411">Prawidłowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu, który jest zwracany przez `provider` obiektu <xref:System.IFormatProvider.GetFormat%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-1411">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the <xref:System.Globalization.NumberFormatInfo> object that is returned by the `provider` object's <xref:System.IFormatProvider.GetFormat%2A> method.</span></span>|  
|<span data-ttu-id="8d479-1412">*cyfry*</span><span class="sxs-lookup"><span data-stu-id="8d479-1412">*digits*</span></span>|<span data-ttu-id="8d479-1413">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1413">A sequence of digits ranging from 0 to 9.</span></span> <span data-ttu-id="8d479-1414">Wszystkie zera wiodące są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="8d479-1414">Any leading zeros are ignored.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1415">Ciąg określony przez `value` parametr jest interpretowany przy użyciu <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1415">The string specified by the `value` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="8d479-1416">Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1416">It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d479-1417">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1417">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="8d479-1418">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1418">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="8d479-1419">`provider` Parametr jest <xref:System.IFormatProvider> implementacji którego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1419">The `provider` parameter is an <xref:System.IFormatProvider> implementation whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information.</span></span> <span data-ttu-id="8d479-1420">Gdy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metoda jest wywoływana, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> metody i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1420">When the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> method is invoked, it calls the `provider` parameter's <xref:System.IFormatProvider.GetFormat%2A> method and passes it a <xref:System.Type> object that represents the <xref:System.Globalization.NumberFormatInfo> type.</span></span> <span data-ttu-id="8d479-1421"><xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formacie parametru `value` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1421">The <xref:System.IFormatProvider.GetFormat%2A> method then returns the <xref:System.Globalization.NumberFormatInfo> object that provides information about the format of the `value` parameter.</span></span> <span data-ttu-id="8d479-1422">Istnieją trzy sposoby na wykorzystanie `provider` parametru jako źródła informacji o niestandardowym formatowaniu do operacji analizy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1422">There are three ways to use the `provider` parameter to supply custom formatting information to the parse operation:</span></span>  
  
-   <span data-ttu-id="8d479-1423">Możesz przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1423">You can pass a <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="8d479-1424">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb dla tej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1424">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="8d479-1425">Można przekazać faktyczny <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb.</span><span class="sxs-lookup"><span data-stu-id="8d479-1425">You can pass the actual <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="8d479-1426">(Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1426">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="8d479-1427">Można przekazać niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1427">You can pass a custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="8d479-1428">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1428">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="8d479-1429">Jeśli `provider` jest `null`, formatowanie `value` jest interpretowany na podstawie <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1429">If `provider` is `null`, the formatting of `value` is interpreted based on the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1430">W poniższych przykładach pokazano dwa sposoby definiowania tyldy (~) jako znaku ujemnego formatowania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1430">The following examples show two ways to define the tilde (~) as a negative sign for formatting <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="8d479-1431">Należy pamiętać, że do wyświetlenia <xref:System.Numerics.BigInteger> wartości w tym samym formacie co oryginalny ciągów, kod musi wywoływać <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody i przekazać go <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1431">Note that to display the <xref:System.Numerics.BigInteger> values in the same format as the original strings, your code must call the <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method and pass it the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="8d479-1432">W pierwszym przykładzie zdefiniowano klasę, która implementuje <xref:System.IFormatProvider> i używa <xref:System.IFormatProvider.GetFormat%2A> metodę, aby zwrócić <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1432">The first example defines a class that implements <xref:System.IFormatProvider> and uses the <xref:System.IFormatProvider.GetFormat%2A> method to return the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 <span data-ttu-id="8d479-1433">Element <xref:System.Numerics.BigInteger> obiektu następnie mogą być utworzone z następującym kodem:</span><span class="sxs-lookup"><span data-stu-id="8d479-1433">A <xref:System.Numerics.BigInteger> object can then be instantiated with the following code:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 <span data-ttu-id="8d479-1434">Drugi przykład jest bardziej bezpośredni.</span><span class="sxs-lookup"><span data-stu-id="8d479-1434">The second example is more straightforward.</span></span> <span data-ttu-id="8d479-1435">Przekazuje ono <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu `provider` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1435">It passes the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information to the `provider` parameter.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d479-1436"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1436"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8d479-1437"><paramref name="value" /> nie jest w poprawnym formacie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1437"><paramref name="value" /> is not in the correct format.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1438">Ciąg zawierający liczbę, którą należy przekształcić.</span><span class="sxs-lookup"><span data-stu-id="8d479-1438">A string that contains a number to convert.</span></span></param>
        <param name="style"><span data-ttu-id="8d479-1439">Bitowa kombinacja wartości wyliczenia, które określają dozwolony format parametru <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1439">A bitwise combination of the enumeration values that specify the permitted format of <paramref name="value" />.</span></span></param>
        <param name="provider"><span data-ttu-id="8d479-1440">Obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury na temat <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1440">An object that provides culture-specific formatting information about <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="8d479-1441">Konwertuje ciąg reprezentujący numer w określony styl i formatowanie specyficzne dla kultury do jego <see cref="T:System.Numerics.BigInteger" /> równoważne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1441">Converts the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="8d479-1442">Wartość, która odpowiada liczbie określonej w <paramref name="value" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1442">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1443">`style` Parametru definiuje elementy stylu (takie jak biały znak, symbol znaku dodatniego lub ujemnego, symbol separatora grupy lub symbol separatora dziesiętnego), które są dozwolone w `value` parametr jako warunek powodzenia operacji analizy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1443">The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="8d479-1444">`styles` musi być kombinacją kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1444">`styles` must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="8d479-1445">`style` Parametru sprawia, że ta metoda przeciążenia przydatne, gdy `value` zawiera ciąg reprezentujący wartość szesnastkową, gdy system numer (dziesiętnych lub szesnastkowych) reprezentowany przez `value` jest znana dopiero w czasie wykonywania, lub gdy użytkownik Aby uniemożliwić biały znak lub symbol znaku w `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1445">The `style` parameter makes this method overload useful when `value` contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by `value` is known only at run time, or when you want to disallow white space or a sign symbol in `value`.</span></span>  
  
 <span data-ttu-id="8d479-1446">W zależności od wartości `style`, `value` parametru może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1446">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="8d479-1447">[*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1447">[*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1448">Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` parametru może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1448">If `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="8d479-1449">[*ws*]*cyfry_szesnastkowe*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1449">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1450">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1450">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="8d479-1451">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1451">The following table describes each element.</span></span>  
  
|<span data-ttu-id="8d479-1452">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1452">Element</span></span>|<span data-ttu-id="8d479-1453">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1453">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="8d479-1454">*ws*</span><span class="sxs-lookup"><span data-stu-id="8d479-1454">*ws*</span></span>|<span data-ttu-id="8d479-1455">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="8d479-1455">Optional white space.</span></span> <span data-ttu-id="8d479-1456">Odstęp może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1456">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="8d479-1457">Symbol waluty specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1457">A culture-specific currency symbol.</span></span> <span data-ttu-id="8d479-1458">Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości kultury wskazywanym przez `provider` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1458">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the culture indicated by the `provider` parameter.</span></span> <span data-ttu-id="8d479-1459">Symbol waluty bieżącej kultury może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1459">The current culture's currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1460">*sign*</span><span class="sxs-lookup"><span data-stu-id="8d479-1460">*sign*</span></span>|<span data-ttu-id="8d479-1461">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="8d479-1461">An optional sign.</span></span> <span data-ttu-id="8d479-1462">Znak może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1462">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="8d479-1463">Nawiasy mogą być używane w `value` do wskazania wartości ujemnej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1463">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1464">*cyfry*</span><span class="sxs-lookup"><span data-stu-id="8d479-1464">*digits*</span></span><br /><br /> <span data-ttu-id="8d479-1465">*cyfry_ułamkowe*</span><span class="sxs-lookup"><span data-stu-id="8d479-1465">*fractional_digits*</span></span><br /><br /> <span data-ttu-id="8d479-1466">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="8d479-1466">*exponential_digits*</span></span>|<span data-ttu-id="8d479-1467">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1467">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="8d479-1468">Aby uzyskać *cyfry_ułamkowe*należy korzystać tylko z cyfr 0 jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1468">For *fractional_digits*, only the digit 0 is valid.</span></span>|  
|<span data-ttu-id="8d479-1469">*,*</span><span class="sxs-lookup"><span data-stu-id="8d479-1469">*,*</span></span>|<span data-ttu-id="8d479-1470">Symbol separatora grupy specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1470">A culture-specific group separator symbol.</span></span> <span data-ttu-id="8d479-1471">Symbol separatora grupy kultury określonej parametrem `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1471">The group separator symbol of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1472">*.*</span><span class="sxs-lookup"><span data-stu-id="8d479-1472">*.*</span></span>|<span data-ttu-id="8d479-1473">Symbol dziesiętny specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1473">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="8d479-1474">Symbol separatora dziesiętnego kultury wyznaczonym przez `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1474">The decimal point symbol of the culture designated by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="8d479-1475">Może występować tylko cyfry od 0, wyświetlaną cyfrą ułamkową operacja analizy się powiodła Jeśli *cyfry_ułamkowe* zawiera jakąkolwiek inną cyfrę, <xref:System.FormatException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="8d479-1475">Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, a <xref:System.FormatException> is thrown.</span></span>|  
|<span data-ttu-id="8d479-1476">E</span><span class="sxs-lookup"><span data-stu-id="8d479-1476">E</span></span>|<span data-ttu-id="8d479-1477">Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).</span><span class="sxs-lookup"><span data-stu-id="8d479-1477">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="8d479-1478">`value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1478">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1479">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="8d479-1479">*hexdigits*</span></span>|<span data-ttu-id="8d479-1480">Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.</span><span class="sxs-lookup"><span data-stu-id="8d479-1480">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="8d479-1481">Wszystkie znaki (U + 0000) NUL kończącego w `s` są ignorowane przez operacji analizowania, bez względu na wartość `style` argumentu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1481">Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.</span></span>

 <span data-ttu-id="8d479-1482">Ciąg zawierający tylko cyfry (co odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> styl) zawsze przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1482">A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully.</span></span> <span data-ttu-id="8d479-1483">Większość pozostałych <xref:System.Globalization.NumberStyles> składowych kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1483">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in the input string.</span></span> <span data-ttu-id="8d479-1484">Poniższa tabela wskazuje, jak poszczególne <xref:System.Globalization.NumberStyles> członków wpływają na elementy, które mogą być obecne w `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1484">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="8d479-1485">Wartość wyliczenia NumberStyles</span><span class="sxs-lookup"><span data-stu-id="8d479-1485">NumberStyles value</span></span>|<span data-ttu-id="8d479-1486">Dodatkowe (poza cyframi) elementy dozwolone w wartości</span><span class="sxs-lookup"><span data-stu-id="8d479-1486">Elements permitted in value in addition to digits</span></span>|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="8d479-1487">*Cyfr* tylko element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1487">The *digits* element only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="8d479-1488">Separatora dziesiętnego (.) i *cyfr ułamkowych, jaka* elementów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1488">The decimal point (.) and *fractional-digits* elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="8d479-1489">Znak „e” lub znak „E”, co oznacza zapis wykładniczy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1489">The "e" or "E" character, which indicates exponential notation.</span></span> <span data-ttu-id="8d479-1490">wraz z *cyfry_szesnastkowe*.</span><span class="sxs-lookup"><span data-stu-id="8d479-1490">along with *exponential_digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="8d479-1491">*Ws* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1491">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="8d479-1492">*Ws* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1492">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="8d479-1493">*Logowania* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1493">The *sign* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="8d479-1494">*Logowania* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1494">The *sign* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="8d479-1495">*Logowania* elementu w postaci nawiasów obejmujących wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1495">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="8d479-1496">Element separatora grupy (,).</span><span class="sxs-lookup"><span data-stu-id="8d479-1496">The group separator (,) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="8d479-1497">Element określający walutę ($).</span><span class="sxs-lookup"><span data-stu-id="8d479-1497">The currency ($) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="8d479-1498">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1498">All elements.</span></span> <span data-ttu-id="8d479-1499">Jednak `value` nie może reprezentować liczby szesnastkowej ani liczby w zapisie wykładniczym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1499">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="8d479-1500">*Ws* element na początku lub końcu `value`, *logowania* na początku `value`oraz symbol separatora dziesiętnego (.).</span><span class="sxs-lookup"><span data-stu-id="8d479-1500">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (.) symbol.</span></span> <span data-ttu-id="8d479-1501">`value` Parametru można również użyć notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1501">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="8d479-1502">`ws`, `sign`, Separator grupy (,) i elementy przecinka dziesiętnego (.).</span><span class="sxs-lookup"><span data-stu-id="8d479-1502">The `ws`, `sign`, group separator (,), and decimal point (.) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="8d479-1503">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1503">All elements.</span></span> <span data-ttu-id="8d479-1504">Jednak `value` nie może reprezentować liczby szesnastkowej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1504">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d479-1505">Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1505">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="8d479-1506">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.Parse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1506">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="8d479-1507">W odróżnieniu od innych <xref:System.Globalization.NumberStyles> wartości, które umożliwiają, ale nie wymagają obecności elementów konkretnego stylu w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> wartość stylu oznacza, że poszczególne znaki numeryczne w `value` są zawsze interpretowane jako znaki szesnastkowe.</span><span class="sxs-lookup"><span data-stu-id="8d479-1507">Unlike the other <xref:System.Globalization.NumberStyles> values, which allow for but do not require the presence of particular style elements in `value`, the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> style value means that the individual numeric characters in `value` are always interpreted as hexadecimal characters.</span></span> <span data-ttu-id="8d479-1508">Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f.</span><span class="sxs-lookup"><span data-stu-id="8d479-1508">Valid hexadecimal characters are 0-9, A-F, and a-f.</span></span> <span data-ttu-id="8d479-1509">Jedyne inne flagi, które mogą być łączone z `style` parametru są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1509">The only other flags that can be combined with the `style` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-1510">( <xref:System.Globalization.NumberStyles> Wyliczenia zawiera kompozytowy styl <xref:System.Globalization.NumberStyles.HexNumber>, który zawiera obie flagi odstępu.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1510">(The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1511">Jeśli `value` jest ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym uzupełnieniem (takie jak `0x` lub `&h`) które odróżnia go jako liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1511">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="8d479-1512">To powoduje niepowodzenie konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1512">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="8d479-1513">Jeśli `value` jest ciąg szesnastkowy <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> interpretuje metoda `value` jako liczba ujemna przechowywane przy użyciu reprezentacji uzupełnienie dwójki, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równa `0x80`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1513">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="8d479-1514">Innymi słowy, metoda interpretuje bitu najwyższego rzędu pierwszego bajtu w `value` jako bitu znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-1514">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="8d479-1515">Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako liczba dodatnia, pierwsza cyfra w `value` musi mieć wartość zero.</span><span class="sxs-lookup"><span data-stu-id="8d479-1515">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="8d479-1516">Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartości dodatniej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1516">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="8d479-1517">Poniższy przykład ilustruje różnicę między ciągów szesnastkowych, które reprezentują wartości ujemny i dodatni.</span><span class="sxs-lookup"><span data-stu-id="8d479-1517">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 <span data-ttu-id="8d479-1518">`provider` Parametr <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1518">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="8d479-1519">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie parametru `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1519">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of `value`.</span></span> <span data-ttu-id="8d479-1520">Zazwyczaj `provider` może być jednym z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="8d479-1520">Typically, `provider` can be any one of the following:</span></span>  
  
-   <span data-ttu-id="8d479-1521">Element <xref:System.Globalization.CultureInfo> obiektu, który reprezentuje kulturę, która zapewnia informacje o formatowaniu liczb.</span><span class="sxs-lookup"><span data-stu-id="8d479-1521">A <xref:System.Globalization.CultureInfo> object that represents the culture that provides numeric formatting information.</span></span> <span data-ttu-id="8d479-1522">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb.</span><span class="sxs-lookup"><span data-stu-id="8d479-1522">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span>  
  
-   <span data-ttu-id="8d479-1523">Element <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1523">A <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span> <span data-ttu-id="8d479-1524">(Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1524">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="8d479-1525">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> i używa <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> metodę, aby tworzyć wystąpienie i zwracać <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1525">A custom object that implements <xref:System.IFormatProvider> and uses the <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> method to instantiate and return the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="8d479-1526">Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury jest używane.</span><span class="sxs-lookup"><span data-stu-id="8d479-1526">If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1527">Poniższy przykład wykonuje kilka wywołań do <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody przy użyciu różnych kombinacji wartości dla `style` i `provider` parametrów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1527">The following example makes several calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method using various combinations of values for the `style` and `provider` parameters.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 <span data-ttu-id="8d479-1528">Liczba poszczególnych wywołań dla <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metoda Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku ujemnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1528">A number of the individual calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method pass an instance of the following `BigIntegerFormatProvider` class, which defines a tilde (~) as the negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d479-1529"><paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1529"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
<span data-ttu-id="8d479-1530">—lub—</span><span class="sxs-lookup"><span data-stu-id="8d479-1530">-or-</span></span> 
 <span data-ttu-id="8d479-1531"><paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartością.</span><span class="sxs-lookup"><span data-stu-id="8d479-1531"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d479-1532"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1532"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8d479-1533"><paramref name="value" /> nie jest zgodny z wzorca danych wejściowych, określony przez <paramref name="style" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1533"><paramref name="value" /> does not comply with the input pattern specified by <paramref name="style" />.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1534">Liczbę, aby podnieść do <paramref name="exponent" /> zasilania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1534">The number to raise to the <paramref name="exponent" /> power.</span></span></param>
        <param name="exponent"><span data-ttu-id="8d479-1535">Wykładnik, aby podnieść <paramref name="value" /> przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-1535">The exponent to raise <paramref name="value" /> by.</span></span></param>
        <summary><span data-ttu-id="8d479-1536">Wywołuje <see cref="T:System.Numerics.BigInteger" /> wartości do potęgi określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1536">Raises a <see cref="T:System.Numerics.BigInteger" /> value to the power of a specified value.</span></span></summary>
        <returns><span data-ttu-id="8d479-1537">Wynik wywoływania <paramref name="value" /> do <paramref name="exponent" /> zasilania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1537">The result of raising <paramref name="value" /> to the <paramref name="exponent" /> power.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1538"><xref:System.Numerics.BigInteger.Pow%2A> Metoda zwraca wartość 1, jeśli wartość wykładnika parametru jest 0, lub wartości obu `value` i `exponent` parametry są równe 0.</span><span class="sxs-lookup"><span data-stu-id="8d479-1538">The <xref:System.Numerics.BigInteger.Pow%2A> method returns 1 if the value of the exponent parameter is 0, or if the values of both the `value` and `exponent` parameters are 0.</span></span> <span data-ttu-id="8d479-1539">Jeśli `exponent` wynosi 1, <xref:System.Numerics.BigInteger.Pow%2A> metoda zwraca `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1539">If `exponent` is 1, the <xref:System.Numerics.BigInteger.Pow%2A> method returns `value`.</span></span> <span data-ttu-id="8d479-1540">Jeśli `value` jest ujemna, metoda zwraca wynik ujemny.</span><span class="sxs-lookup"><span data-stu-id="8d479-1540">If `value` is negative, the method returns a negative result.</span></span>  
  
 <span data-ttu-id="8d479-1541">Ta metoda odnosi się do <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1541">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1542">Poniższy przykład ilustruje użycie potęgowania <xref:System.Numerics.BigInteger> wartość i wykładnik, którego wartość zakresu od 0 do 10.</span><span class="sxs-lookup"><span data-stu-id="8d479-1542">The following example illustrates exponentiation using a <xref:System.Numerics.BigInteger> value and an exponent whose value ranges from 0 to 10.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d479-1543"><paramref name="exponent" /> ma wartość ujemną.</span><span class="sxs-lookup"><span data-stu-id="8d479-1543"><paramref name="exponent" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="8d479-1544">Wartość do podzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1544">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="8d479-1545">Wartość do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="8d479-1545">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="8d479-1546">Wykonuje dzielenie liczby całkowitej na dwóch <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca resztę z dzielenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1546">Performs integer division on two <see cref="T:System.Numerics.BigInteger" /> values and returns the remainder.</span></span></summary>
        <returns><span data-ttu-id="8d479-1547">Resztę po podzieleniu <paramref name="dividend" /> przez <paramref name="divisor" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1547">The remainder after dividing <paramref name="dividend" /> by <paramref name="divisor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1548">Znak reszta jest znak `dividend` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1548">The sign of the remainder is the sign of the `dividend` parameter.</span></span>  
  
 <span data-ttu-id="8d479-1549"><xref:System.Numerics.BigInteger.Remainder%2A> Metoda jest implementowana dla języków, które nie obsługują operatorów niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1549">The <xref:System.Numerics.BigInteger.Remainder%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="8d479-1550">Jego zachowanie jest identyczne z dzielenia przy użyciu operator modulo.</span><span class="sxs-lookup"><span data-stu-id="8d479-1550">Its behavior is identical to division using the modulus operator.</span></span>  
  
 <span data-ttu-id="8d479-1551">Jeśli to konieczne, metoda automatycznie przeprowadza niejawnej konwersji wartości innych typów całkowitych <xref:System.Numerics.BigInteger> obiektów przed wykonaniem operacji modulo.</span><span class="sxs-lookup"><span data-stu-id="8d479-1551">If necessary, the method automatically performs implicit conversion of other integral types to <xref:System.Numerics.BigInteger> objects before it performs the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1552">W poniższym przykładzie porównano reszty z <xref:System.Numerics.BigInteger.DivRem%2A> metody za pomocą pozostałej zwrócony przez <xref:System.Numerics.BigInteger.Remainder%2A> metody do ustalenia, czy dwie metody obliczanie reszt identyczne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1552">The following example compares the remainder from the <xref:System.Numerics.BigInteger.DivRem%2A> method with the remainder returned by the <xref:System.Numerics.BigInteger.Remainder%2A> method to establish that the two methods calculate identical remainders.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="8d479-1553"><paramref name="divisor" /> to 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-1553"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-1554">Pobiera liczbę, która określa znak (ujemny i dodatni, lub wartość zero) bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1554">Gets a number that indicates the sign (negative, positive, or zero) of the current <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <value><span data-ttu-id="8d479-1555">Liczba, która określa znak <see cref="T:System.Numerics.BigInteger" /> obiektu, jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="8d479-1555">A number that indicates the sign of the <see cref="T:System.Numerics.BigInteger" /> object, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="8d479-1556">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="8d479-1556">Number</span></span> 
 </term><description> <span data-ttu-id="8d479-1557">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1557">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="8d479-1558">-1</span><span class="sxs-lookup"><span data-stu-id="8d479-1558">-1</span></span> 
 </term><description> <span data-ttu-id="8d479-1559">Wartość tego obiektu jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="8d479-1559">The value of this object is negative.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-1560">0</span><span class="sxs-lookup"><span data-stu-id="8d479-1560">0</span></span> 
 </term><description> <span data-ttu-id="8d479-1561">Wartość tego obiektu jest 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-1561">The value of this object is 0 (zero).</span></span>  
  
 </description></item><item><term> <span data-ttu-id="8d479-1562">1</span><span class="sxs-lookup"><span data-stu-id="8d479-1562">1</span></span> 
 </term><description> <span data-ttu-id="8d479-1563">Wartość tego obiektu jest dodatni.</span><span class="sxs-lookup"><span data-stu-id="8d479-1563">The value of this object is positive.</span></span>  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1564"><xref:System.Numerics.BigInteger.Sign%2A> Właściwość jest równoważna <xref:System.Math.Sign%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1564">The <xref:System.Numerics.BigInteger.Sign%2A> property is equivalent to the <xref:System.Math.Sign%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="8d479-1565">Wartość do odjęcia od (odjemna).</span><span class="sxs-lookup"><span data-stu-id="8d479-1565">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="8d479-1566">Wartość do odjęcia (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="8d479-1566">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="8d479-1567">Odejmuje jeden <see cref="T:System.Numerics.BigInteger" /> wartości z innego i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="8d479-1567">Subtracts one <see cref="T:System.Numerics.BigInteger" /> value from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="8d479-1568">Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1568">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1569">Można używać języków, które nie obsługują operatorów niestandardowych <xref:System.Numerics.BigInteger.Subtract%2A> metodę, aby wykonać za pomocą odejmowania <xref:System.Numerics.BigInteger> wartości.</span><span class="sxs-lookup"><span data-stu-id="8d479-1569">Languages that do not support custom operators can use the <xref:System.Numerics.BigInteger.Subtract%2A> method to perform subtraction using <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="8d479-1570"><xref:System.Numerics.BigInteger.Subtract%2A> Metoda jest przydatna zastępują operator odejmowania, podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, przypisując go różnica, który jest wynikiem odejmowania, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1570">The <xref:System.Numerics.BigInteger.Subtract%2A> method is a useful substitute for the subtraction operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it the difference that results from subtraction, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d479-1571">Konwertuje <see cref="T:System.Numerics.BigInteger" /> wartości do tablicy typu byte.</span><span class="sxs-lookup"><span data-stu-id="8d479-1571">Converts a <see cref="T:System.Numerics.BigInteger" /> value to a byte array.</span></span></summary>
        <returns><span data-ttu-id="8d479-1572">Wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiekt jest konwertowany na tablicę bajtów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1572">The value of the current <see cref="T:System.Numerics.BigInteger" /> object converted to an array of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1573">Poszczególne bajty w tablicy zwracanej przez tę metodę są wyświetlane w kolejności little-endian.</span><span class="sxs-lookup"><span data-stu-id="8d479-1573">The individual bytes in the array returned by this method appear in little-endian order.</span></span> <span data-ttu-id="8d479-1574">Oznacza to, że wartość w bajtach niższego rzędu poprzedzać bajtów wyższego rzędu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1574">That is, the lower-order bytes of the value precede the higher-order bytes.</span></span> <span data-ttu-id="8d479-1575">Pierwszy bajt tablicy odzwierciedla pierwsze osiem bitów <xref:System.Numerics.BigInteger> wartość, drugi bajt odzwierciedla dalej osiem bitów i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1575">The first byte of the array reflects the first eight bits of the <xref:System.Numerics.BigInteger> value, the second byte reflects the next eight bits, and so on.</span></span> <span data-ttu-id="8d479-1576">Na przykład wartość 1024 lub 0x0400, są przechowywane jako tablica następujące dwa bajty:</span><span class="sxs-lookup"><span data-stu-id="8d479-1576">For example, the value 1024, or 0x0400, is stored as the following array of two bytes:</span></span>  
  
|<span data-ttu-id="8d479-1577">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1577">Element</span></span>|<span data-ttu-id="8d479-1578">Wartość bajtu</span><span class="sxs-lookup"><span data-stu-id="8d479-1578">Byte value</span></span>|  
|-------------|----------------|  
|<span data-ttu-id="8d479-1579">0</span><span class="sxs-lookup"><span data-stu-id="8d479-1579">0</span></span>|<span data-ttu-id="8d479-1580">0x00</span><span class="sxs-lookup"><span data-stu-id="8d479-1580">0x00</span></span>|  
|<span data-ttu-id="8d479-1581">1</span><span class="sxs-lookup"><span data-stu-id="8d479-1581">1</span></span>|<span data-ttu-id="8d479-1582">0x04</span><span class="sxs-lookup"><span data-stu-id="8d479-1582">0x04</span></span>|  
  
 <span data-ttu-id="8d479-1583">Wartości ujemne są zapisywane do tablicy przy użyciu reprezentacji uzupełnienie dwójki w najbardziej zwięzłą możliwe formularza.</span><span class="sxs-lookup"><span data-stu-id="8d479-1583">Negative values are written to the array using two's complement representation in the most compact form possible.</span></span> <span data-ttu-id="8d479-1584">Na przykład, wartość -1 jest reprezentowany jako jednobajtowych, którego wartością jest `0xFF` zamiast jako tablicę z wieloma elementami, takich jak `0xFF`, `0xFF` lub `0xFF`, `0xFF`, `0xFF`, `0xFF`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1584">For example, -1 is represented as a single byte whose value is `0xFF` instead of as an array with multiple elements, such as `0xFF`, `0xFF` or `0xFF`, `0xFF`, `0xFF`, `0xFF`.</span></span>  
  
 <span data-ttu-id="8d479-1585">Ponieważ dwójki uzupełniają reprezentacji zawsze interpretuje bitu najwyższego rzędu ostatniego bajtu w tablicy (bajt na pozycji <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) jako bitu znaku, Metoda ta zwraca tablicę bajtów z dodatkowy element, którego wartość jest równa zero do odróżnić wartości dodatnich, które w przeciwnym razie może zostać zinterpretowane jako posiadające bitów ich logowania.</span><span class="sxs-lookup"><span data-stu-id="8d479-1585">Because two's complement representation always interprets the highest-order bit of the last byte in the array (the byte at position <xref:System.Array.Length%2A?displayProperty=nameWithType>`- 1`) as the sign bit, the method returns a byte array with an extra element whose value is zero to disambiguate positive values that could otherwise be interpreted as having their sign bits set.</span></span> <span data-ttu-id="8d479-1586">Na przykład, wartość 120 lub `0x78` jest reprezentowany jako tablica jednobajtowe: `0x78`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1586">For example, the value 120 or `0x78` is represented as a single-byte array: `0x78`.</span></span> <span data-ttu-id="8d479-1587">Jednakże, jest to 128, lub `0x80`, jest reprezentowana w postaci tablicy bajtów dwa: `0x80`, `0x00`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1587">However, 128, or `0x80`, is represented as a two-byte array: `0x80`, `0x00`.</span></span>  
  
 <span data-ttu-id="8d479-1588">Możesz Rundy <xref:System.Numerics.BigInteger> wartość przez zapisanie go do tablicy typu byte, a następnie przywróceniu go za pomocą <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="8d479-1588">You can round-trip a <xref:System.Numerics.BigInteger> value by storing it to a byte array and then restoring it using the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8d479-1589">Jeżeli kod modyfikuje wartość pojedynczych bajtów w tablicy zwracanej przez tę metodę, przed jego przywraca wartość, upewnij się, że nie przypadkowo zmienić bitu znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-1589">If your code modifies the value of individual bytes in the array returned by this method before it restores the value, you must make sure that you do not unintentionally change the sign bit.</span></span> <span data-ttu-id="8d479-1590">Na przykład jeśli modyfikacje zwiększyć wartość dodatnią, dzięki czemu najwyższego rzędu bit w ostatnim elemencie tablicy bajtowej staje się ustawić, można dodać nowego typu byte, którego wartość jest równa zero do końca tablicy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1590">For example, if your modifications increase a positive value so that the highest-order bit in the last element of the byte array becomes set, you can add a new byte whose value is zero to the end of the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1591">W poniższym przykładzie pokazano, jak niektóre <xref:System.Numerics.BigInteger> wartości są reprezentowane w tablice typu byte.</span><span class="sxs-lookup"><span data-stu-id="8d479-1591">The following example illustrates how some <xref:System.Numerics.BigInteger> values are represented in byte arrays.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-1592">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1592">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d479-1593">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1593">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="8d479-1594">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1594">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1595"><xref:System.Numerics.BigInteger.ToString> Formaty metoda <xref:System.Numerics.BigInteger> wartości w "R" lub przesyłania danych, format bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1595">The <xref:System.Numerics.BigInteger.ToString> method formats a <xref:System.Numerics.BigInteger> value in the "R", or round-trip, format of the current culture.</span></span> <span data-ttu-id="8d479-1596">Jeśli chcesz określić inny format lub kultury, należy używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8d479-1596">If you want to specify a different format or culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="8d479-1597">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="8d479-1597">To use format</span></span>|<span data-ttu-id="8d479-1598">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1598">For culture</span></span>|<span data-ttu-id="8d479-1599">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="8d479-1599">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="8d479-1600">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="8d479-1600">Round-trip ("R") format</span></span>|<span data-ttu-id="8d479-1601">Określonej kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1601">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%2A>|  
|<span data-ttu-id="8d479-1602">Określony format</span><span class="sxs-lookup"><span data-stu-id="8d479-1602">A specific format</span></span>|<span data-ttu-id="8d479-1603">(Domyślne bieżącej) kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1603">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|<span data-ttu-id="8d479-1604">Określony format</span><span class="sxs-lookup"><span data-stu-id="8d479-1604">A specific format</span></span>|<span data-ttu-id="8d479-1605">Określonej kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1605">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="8d479-1606">Reprezentacja ciągu <xref:System.Numerics.BigInteger> wartość zawiera znak ujemny, jeśli jego wartość jest ujemna i sekwencję cyfr od 0 do 9, bez zer wiodących.</span><span class="sxs-lookup"><span data-stu-id="8d479-1606">The string representation of the <xref:System.Numerics.BigInteger> value includes a negative sign if its value is negative, and a sequence of digits ranging from 0 to 9 without leading zeros.</span></span> <span data-ttu-id="8d479-1607">Znak ujemny jest definiowany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1607">The negative sign is defined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1608">Poniższy przykład wyświetla <xref:System.Numerics.BigInteger> wartość przy użyciu domyślnej <xref:System.Numerics.BigInteger.ToString> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-1608">The following example displays a <xref:System.Numerics.BigInteger> value by using the default <xref:System.Numerics.BigInteger.ToString> method.</span></span> <span data-ttu-id="8d479-1609">Wyświetla również ciągów reprezentujących <xref:System.Numerics.BigInteger> wartość będącą wynikiem przy użyciu niektóre specyfikatory formatu standardowego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1609">It also displays the string representations of the <xref:System.Numerics.BigInteger> value that results from using some standard format specifiers.</span></span> <span data-ttu-id="8d479-1610">W przykładach jest używana konwencja formatowania kultury en-US.</span><span class="sxs-lookup"><span data-stu-id="8d479-1610">The examples are displayed using the formatting conventions of the en-US culture.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8d479-1611">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="8d479-1611">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8d479-1612">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="8d479-1612">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8d479-1613">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1613">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8d479-1614">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu określonego specyficzne dla kultury informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1614">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="8d479-1615">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="provider" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1615">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="provider" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1616"><xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Formaty metoda <xref:System.Numerics.BigInteger> wartość "R" lub Rundy formatowania za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1616">The <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> method formats a <xref:System.Numerics.BigInteger> value in the "R", or round-trip, format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture.</span></span> <span data-ttu-id="8d479-1617">Jeśli chcesz określić inny format lub bieżącej kultury, należy używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8d479-1617">If you want to specify a different format or the current culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="8d479-1618">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="8d479-1618">To use format</span></span>|<span data-ttu-id="8d479-1619">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1619">For culture</span></span>|<span data-ttu-id="8d479-1620">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="8d479-1620">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="8d479-1621">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="8d479-1621">Round-trip ("R") format</span></span>|<span data-ttu-id="8d479-1622">(Domyślne bieżącej) kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1622">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="8d479-1623">Określony format</span><span class="sxs-lookup"><span data-stu-id="8d479-1623">A specific format</span></span>|<span data-ttu-id="8d479-1624">(Domyślne bieżącej) kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1624">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|<span data-ttu-id="8d479-1625">Określony format</span><span class="sxs-lookup"><span data-stu-id="8d479-1625">A specific format</span></span>|<span data-ttu-id="8d479-1626">Określonej kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1626">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="8d479-1627">`provider` Parametr <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1627">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="8d479-1628">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie ciągu zwracanego przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8d479-1628">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string returned by this method.</span></span> <span data-ttu-id="8d479-1629">Jeśli `provider` jest `null`, <xref:System.Numerics.BigInteger> wartość jest formatowana przy użyciu <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1629">If `provider` is `null`, the <xref:System.Numerics.BigInteger> value is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span> <span data-ttu-id="8d479-1630">Tylko właściwości <xref:System.Globalization.NumberFormatInfo> obiekt, który kontroluje reprezentację ciągu <xref:System.Numerics.BigInteger> jest wartość przy użyciu specyfikatora formatu ogólnego <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, która określa znak, który reprezentuje znak ujemny.</span><span class="sxs-lookup"><span data-stu-id="8d479-1630">The only property of the <xref:System.Globalization.NumberFormatInfo> object that controls the string representation of the <xref:System.Numerics.BigInteger> value using the general format specifier is <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, which defines the character that represents the negative sign.</span></span>  
  
 <span data-ttu-id="8d479-1631">`provider` Parametr może być jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="8d479-1631">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="8d479-1632">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1632">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="8d479-1633"><xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1633">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="8d479-1634">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1634">A custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="8d479-1635">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1635">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1636">Poniższy przykład tworzy niestandardowy <xref:System.Globalization.NumberFormatInfo> obiekt, który definiuje tyldy (~) jako znaku ujemnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1636">The following example instantiates a custom <xref:System.Globalization.NumberFormatInfo> object that defines the tilde (~) as a negative sign.</span></span> <span data-ttu-id="8d479-1637"><xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Metoda następnie używa niestandardowego <xref:System.Globalization.NumberFormatInfo> obiektu, aby wyświetlić ujemnych <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1637">The <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> method then uses the custom <xref:System.Globalization.NumberFormatInfo> object to display a negative <xref:System.Numerics.BigInteger> value.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8d479-1638">Standardowy lub niestandardowy ciąg formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1638">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="8d479-1639">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu określonego formatu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1639">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format.</span></span></summary>
        <returns><span data-ttu-id="8d479-1640">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym przez <paramref name="format" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1640">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="format" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1641"><xref:System.Numerics.BigInteger.ToString%28System.String%29> Formaty metoda <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiekt, który reprezentuje konwencje bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1641">The <xref:System.Numerics.BigInteger.ToString%28System.String%29> method formats a <xref:System.Numerics.BigInteger> value in a specified format by using a <xref:System.Globalization.NumberFormatInfo> object that represents the conventions of the current culture.</span></span> <span data-ttu-id="8d479-1642">Jeśli chcesz użyć "R" lub dwustronnej konwersji formatu lub określić inną kulturę, używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8d479-1642">If you want to use the "R", or round-trip, format or specify a different culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="8d479-1643">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="8d479-1643">To use format</span></span>|<span data-ttu-id="8d479-1644">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1644">For culture</span></span>|<span data-ttu-id="8d479-1645">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="8d479-1645">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="8d479-1646">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="8d479-1646">Round-trip ("R") format</span></span>|<span data-ttu-id="8d479-1647">(Domyślne bieżącej) kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1647">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="8d479-1648">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="8d479-1648">Round-trip ("R") format</span></span>|<span data-ttu-id="8d479-1649">Określonej kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1649">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|<span data-ttu-id="8d479-1650">Określony format</span><span class="sxs-lookup"><span data-stu-id="8d479-1650">A specific format</span></span>|<span data-ttu-id="8d479-1651">Określonej kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1651">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="8d479-1652">`format` Parametr może być dowolne, prawidłowe [standardowego ciągu numerycznego](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolnej kombinacji [ciągi niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8d479-1652">The `format` parameter can be any valid [standard numeric string](~/docs/standard/base-types/standard-numeric-format-strings.md), or any combination of [custom numeric format strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="8d479-1653">Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest formatowana przy użyciu specyfikatora formatu Rundy ("R").</span><span class="sxs-lookup"><span data-stu-id="8d479-1653">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the return value of the current <xref:System.Numerics.BigInteger> object is formatted with the round-trip format specifier ("R").</span></span> <span data-ttu-id="8d479-1654">Jeśli `format` ma jakąkolwiek inną wartość, metoda zgłasza wyjątek <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1654">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="8d479-1655">Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:</span><span class="sxs-lookup"><span data-stu-id="8d479-1655">The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</span></span>  
  
-   <span data-ttu-id="8d479-1656">Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8d479-1656">For more information about numeric format specifiers, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="8d479-1657">Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="8d479-1657">For more information about support for formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="8d479-1658">Format zwracanego ciągu jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1658">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="8d479-1659">W zależności od `format` parametr, ten obiekt kontroluje symbole takie jak znak ujemny, separator grupy i symbol seperatora dziesiętnego w ciągu wyjściowym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1659">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="8d479-1660">Aby podać informacje o formatowaniu dla języków innych niż bieżącej kultury, należy wywołać <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1660">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1661">Poniższy przykład inicjuje <xref:System.Numerics.BigInteger> wartość i wyświetla je przy użyciu każdego ciągu formatu standardowego i niektóre ciągi formatu niestandardowego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1661">The following example initializes a <xref:System.Numerics.BigInteger> value and displays it by using each standard format string and some custom format strings.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8d479-1662"><paramref name="format" /> nie jest ciągiem nieprawidłowy format.</span><span class="sxs-lookup"><span data-stu-id="8d479-1662"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8d479-1663">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="8d479-1663">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8d479-1664">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="8d479-1664">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8d479-1665">Standardowy lub niestandardowy ciąg formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1665">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="8d479-1666">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1666">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8d479-1667">Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego reprezentację ciągu równoważnego przy użyciu podanego formatu i informacji o formacie specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1667">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format and culture-specific format information.</span></span></summary>
        <returns><span data-ttu-id="8d479-1668">Reprezentacja ciągu bieżącego <see cref="T:System.Numerics.BigInteger" /> wartość określoną przez <paramref name="format" /> i <paramref name="provider" /> parametrów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1668">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value as specified by the <paramref name="format" /> and <paramref name="provider" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1669"><xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Formaty metoda <xref:System.Numerics.BigInteger> wartości w określonym formacie za pomocą <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1669">The <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method formats a <xref:System.Numerics.BigInteger> value in a specified format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture.</span></span> <span data-ttu-id="8d479-1670">Jeśli chcesz użyć formatu obustronne lub domyślne ustawienia kultury, należy używać innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="8d479-1670">If you want to use the round-trip format or default culture settings, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="8d479-1671">Aby użyć formatu</span><span class="sxs-lookup"><span data-stu-id="8d479-1671">To use format</span></span>|<span data-ttu-id="8d479-1672">Dla kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1672">For culture</span></span>|<span data-ttu-id="8d479-1673">Użyj przeciążenia</span><span class="sxs-lookup"><span data-stu-id="8d479-1673">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="8d479-1674">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="8d479-1674">Round-trip ("R") format</span></span>|<span data-ttu-id="8d479-1675">(Domyślne bieżącej) kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1675">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="8d479-1676">Round-trip ("R") format</span><span class="sxs-lookup"><span data-stu-id="8d479-1676">Round-trip ("R") format</span></span>|<span data-ttu-id="8d479-1677">Określonej kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1677">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|<span data-ttu-id="8d479-1678">Określony format</span><span class="sxs-lookup"><span data-stu-id="8d479-1678">A specific format</span></span>|<span data-ttu-id="8d479-1679">(Domyślne bieżącej) kultury</span><span class="sxs-lookup"><span data-stu-id="8d479-1679">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 <span data-ttu-id="8d479-1680">`format` Parametr może być dowolne, prawidłowe [standardowego ciągu numerycznego](~/docs/standard/base-types/standard-numeric-format-strings.md), lub dowolnej kombinacji [ciągi niestandardowego formatu liczb](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8d479-1680">The `format` parameter can be any valid  [standard numeric string](~/docs/standard/base-types/standard-numeric-format-strings.md), or any combination of [custom numeric format strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="8d479-1681">Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, zwracana wartość bieżącej <xref:System.Numerics.BigInteger> obiektu jest formatowana przy użyciu specyfikatora formatu Rundy ("R").</span><span class="sxs-lookup"><span data-stu-id="8d479-1681">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the return value of the current <xref:System.Numerics.BigInteger> object is formatted with the round-trip format specifier ("R").</span></span> <span data-ttu-id="8d479-1682">Jeśli `format` ma jakąkolwiek inną wartość, metoda zgłasza wyjątek <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1682">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="8d479-1683">Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:</span><span class="sxs-lookup"><span data-stu-id="8d479-1683">The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</span></span>  
  
-   <span data-ttu-id="8d479-1684">Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8d479-1684">For more information about numeric format specifiers, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="8d479-1685">Aby uzyskać więcej informacji na temat obsługi formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="8d479-1685">For more information about support for formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="8d479-1686">`provider` Parametr <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1686">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="8d479-1687">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie ciągu zwracanego przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="8d479-1687">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string returned by this method.</span></span> <span data-ttu-id="8d479-1688">Gdy <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metoda jest wywoływana, wywołuje `provider` parametru <xref:System.IFormatProvider.GetFormat%2A> metody i przekazuje je <xref:System.Type> obiekt, który reprezentuje <xref:System.Globalization.NumberFormatInfo> typu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1688">When the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method is invoked, it calls the `provider` parameter's <xref:System.IFormatProvider.GetFormat%2A> method and passes it a <xref:System.Type> object that represents the <xref:System.Globalization.NumberFormatInfo> type.</span></span> <span data-ttu-id="8d479-1689"><xref:System.IFormatProvider.GetFormat%2A> Następnie metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje o formatowaniu `value` parametru, takie jak symbol znaku ujemnego, symbol separatora grupy lub symbol separatora dziesiętnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1689">The <xref:System.IFormatProvider.GetFormat%2A> method then returns the <xref:System.Globalization.NumberFormatInfo> object that provides information for formatting the `value` parameter, such as the negative sign symbol, the group separator symbol, or the decimal point symbol.</span></span> <span data-ttu-id="8d479-1690">Istnieją trzy sposoby na wykorzystanie `provider` parametru, aby podać informacje o formatowaniu <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metody:</span><span class="sxs-lookup"><span data-stu-id="8d479-1690">There are three ways to use the `provider` parameter to supply formatting information to the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method:</span></span>  
  
-   <span data-ttu-id="8d479-1691">Możesz przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1691">You can pass a <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="8d479-1692">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb dla tej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1692">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="8d479-1693">Można przekazać faktyczny <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb.</span><span class="sxs-lookup"><span data-stu-id="8d479-1693">You can pass the actual <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="8d479-1694">(Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1694">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="8d479-1695">Można przekazać niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1695">You can pass a custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="8d479-1696">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1696">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="8d479-1697">Jeśli `provider` jest `null`, formatowaniem zwracanego ciągu jest oparty na <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1697">If `provider` is `null`, the formatting of the returned string is based on the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1698">Poniższy przykład inicjuje <xref:System.Numerics.BigInteger> wartości i wyświetla go w konsoli przy użyciu ciągu formatu standardowego i <xref:System.Globalization.NumberFormatInfo> obiekt, który definiuje tyldy (~) jako znaku ujemnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1698">The following example initializes a <xref:System.Numerics.BigInteger> value, and displays it to the console using a standard format string and a <xref:System.Globalization.NumberFormatInfo> object that defines the tilde (~) as a negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8d479-1699"><paramref name="format" /> nie jest ciągiem nieprawidłowy format.</span><span class="sxs-lookup"><span data-stu-id="8d479-1699"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8d479-1700">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="8d479-1700">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8d479-1701">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="8d479-1701">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d479-1702">Próbuje przekonwertować ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1702">Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1703">Ciąg reprezentujący liczbę.</span><span class="sxs-lookup"><span data-stu-id="8d479-1703">The string representation of a number.</span></span></param>
        <param name="result"><span data-ttu-id="8d479-1704">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> równoważna liczbie zawartej w <paramref name="value" />, lub wartość zero (0), jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1704">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <paramref name="value" />, or zero (0) if the conversion fails.</span></span> <span data-ttu-id="8d479-1705">Jeśli konwersja nie powiedzie się <paramref name="value" /> parametr <see langword="null" /> albo nie jest w poprawnym formacie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1705">The conversion fails if the <paramref name="value" /> parameter is <see langword="null" /> or is not of the correct format.</span></span> <span data-ttu-id="8d479-1706">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8d479-1706">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="8d479-1707">Próbuje przekonwertować ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1707">Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="8d479-1708"><see langword="true" /> Jeśli <paramref name="value" /> został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1708"><see langword="true" /> if <paramref name="value" /> was converted successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1709"><xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Metoda przypomina <xref:System.Numerics.BigInteger.Parse%28System.String%29> metody, z wyjątkiem, że nie zgłosi wyjątek, jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1709">The <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> method is like the <xref:System.Numerics.BigInteger.Parse%28System.String%29> method, except that it does not throw an exception if the conversion fails.</span></span> <span data-ttu-id="8d479-1710">Ta metoda eliminuje potrzebę używania wyjątków do testowania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie można pomyślnie przeanalizować.</span><span class="sxs-lookup"><span data-stu-id="8d479-1710">This method eliminates the need to use exception handling to test for a <xref:System.FormatException> if `value` is invalid and cannot be successfully parsed.</span></span>  
  
 <span data-ttu-id="8d479-1711">`value` Parametr powinien być ciąg reprezentujący liczbę dziesiętną w następującej postaci:</span><span class="sxs-lookup"><span data-stu-id="8d479-1711">The `value` parameter should be the string representation of a decimal number in the following form:</span></span>  
  
 <span data-ttu-id="8d479-1712">[*ws*] [*logowania*]*cyfr*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1712">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1713">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1713">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="8d479-1714">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1714">The following table describes each element.</span></span>  
  
|<span data-ttu-id="8d479-1715">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1715">Element</span></span>|<span data-ttu-id="8d479-1716">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1716">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="8d479-1717">*ws*</span><span class="sxs-lookup"><span data-stu-id="8d479-1717">*ws*</span></span>|<span data-ttu-id="8d479-1718">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="8d479-1718">Optional white space.</span></span>|  
|<span data-ttu-id="8d479-1719">*sign*</span><span class="sxs-lookup"><span data-stu-id="8d479-1719">*sign*</span></span>|<span data-ttu-id="8d479-1720">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="8d479-1720">An optional sign.</span></span> <span data-ttu-id="8d479-1721">Prawidłowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1721">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the current culture.</span></span>|  
|<span data-ttu-id="8d479-1722">*cyfry*</span><span class="sxs-lookup"><span data-stu-id="8d479-1722">*digits*</span></span>|<span data-ttu-id="8d479-1723">Sekwencja cyfr dziesiętnych od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1723">A sequence of decimal digits ranging from 0 to 9.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1724">Ciąg określony przez `value` parametr nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych i nie może mieć części dziesiętnych.</span><span class="sxs-lookup"><span data-stu-id="8d479-1724">The string specified by the `value` parameter cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
 <span data-ttu-id="8d479-1725">`value` Parametr jest interpretowany przy użyciu <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stylu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1725">The `value` parameter is interpreted by using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="8d479-1726">Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe z wiodącym znakiem.</span><span class="sxs-lookup"><span data-stu-id="8d479-1726">In addition to the decimal digits, only leading and trailing spaces with a leading sign are allowed.</span></span> <span data-ttu-id="8d479-1727">Jawnie definiuje elementy stylu dla kultury informacje formatowania, które mogą być obecne w `value`, wywołaj <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody.</span><span class="sxs-lookup"><span data-stu-id="8d479-1727">To explicitly define the style elements with the culture-specific formatting information that can be present in `value`, call the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method.</span></span>  
  
 <span data-ttu-id="8d479-1728">`value` Parametru jest analizowany przy użyciu informacje o formatowaniu w <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1728">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="8d479-1729">Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1729">For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8d479-1730">To przeciążenie interpretuje wszystkie cyfry w `value` parametru jako cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1730">This overload interprets all digits in the `value` parameter as decimal digits.</span></span> <span data-ttu-id="8d479-1731">Aby przeanalizować ciąg reprezentujący liczbę szesnastkową, należy wywołać <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> zamiast tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1731">To parse the string representation of a hexadecimal number, call the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> overload instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1732">W poniższym przykładzie użyto <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodę, aby utworzyć dwa wystąpienia <xref:System.Numerics.BigInteger> obiektów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1732">The following example uses the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> method to instantiate two <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="8d479-1733">Jeśli konwersja powiodła się, mnoży każdy obiekt przez inną liczbę, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę pozwala ustalić relacji między dwoma obiektami.</span><span class="sxs-lookup"><span data-stu-id="8d479-1733">If the conversions succeed, it multiplies each object by another number and then calls the <xref:System.Numerics.BigInteger.Compare%2A> method to determine the relationship between the two objects.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d479-1734"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1734"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8d479-1735">Ciąg reprezentujący liczbę.</span><span class="sxs-lookup"><span data-stu-id="8d479-1735">The string representation of a number.</span></span> <span data-ttu-id="8d479-1736">Ten ciąg jest interpretowany przy użyciu stylu określonego parametrem <paramref name="style" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1736">The string is interpreted using the style specified by <paramref name="style" />.</span></span></param>
        <param name="style"><span data-ttu-id="8d479-1737">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1737">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="value" />.</span></span> <span data-ttu-id="8d479-1738">To typowa wartość do określenia <see cref="F:System.Globalization.NumberStyles.Integer" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1738">A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</span></span></param>
        <param name="provider"><span data-ttu-id="8d479-1739">Obiekt, który dostarcza specyficzne dla kultury informacje o formatowaniu <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1739">An object that supplies culture-specific formatting information about <paramref name="value" />.</span></span></param>
        <param name="result"><span data-ttu-id="8d479-1740">Po powrocie z tej metody zawiera <see cref="T:System.Numerics.BigInteger" /> równoważna liczbie zawartej w <paramref name="value" />, lub <see cref="P:System.Numerics.BigInteger.Zero" /> Jeśli konwersja nie powiodła się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1740">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <paramref name="value" />, or <see cref="P:System.Numerics.BigInteger.Zero" /> if the conversion failed.</span></span> <span data-ttu-id="8d479-1741">Jeśli konwersja nie powiedzie się <paramref name="value" /> parametr jest <see langword="null" /> lub nie jest w formacie, który jest zgodny ze <paramref name="style" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1741">The conversion fails if the <paramref name="value" /> parameter is <see langword="null" /> or is not in a format that is compliant with <paramref name="style" />.</span></span> <span data-ttu-id="8d479-1742">Ten parametr jest przekazywany niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="8d479-1742">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="8d479-1743">Próbuje przekonwertować ciąg reprezentujący numer w określony styl i formatowanie specyficzne dla kultury do jego <see cref="T:System.Numerics.BigInteger" /> równoważne i zwraca wartość wskazującą, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1743">Tries to convert the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="8d479-1744"><see langword="true" /> Jeśli <paramref name="value" /> parametr został przekonwertowany pomyślnie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d479-1744"><see langword="true" /> if the <paramref name="value" /> parameter was converted successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1745"><xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Metoda przypomina <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody, z wyjątkiem, że nie zgłosi wyjątek, jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="8d479-1745">The <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method is like the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method, except that it does not throw an exception if the conversion fails.</span></span> <span data-ttu-id="8d479-1746">Ta metoda eliminuje potrzebę używania wyjątków do testowania <xref:System.FormatException> Jeśli `value` jest nieprawidłowy i nie może zostać przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1746">This method eliminates the need to use exception handling to test for a <xref:System.FormatException> if `value` is invalid and cannot be parsed successfully.</span></span>  
  
 <span data-ttu-id="8d479-1747">`style` Parametru definiuje elementy stylu (takie jak odstępy czy znak dodatnia lub ujemna), które są dozwolone w `value` parametr jako warunek powodzenia operacji analizy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1747">The `style` parameter defines the style elements (such as white space or a positive or negative sign) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="8d479-1748">Musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="8d479-1748">It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="8d479-1749">W zależności od wartości `style`, `value` parametru może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1749">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="8d479-1750">[*ws*] [*$*] [*logowania*] [*cyfr*,]*cyfr*[. *cyfry_ułamkowe*] [E [*logowania*]*cyfry_szesnastkowe*] [*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1750">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1751">Jeśli `style` zawiera parametr <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` parametru może zawierać następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="8d479-1751">If the `style` parameter includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="8d479-1752">[*ws*]*cyfry_szesnastkowe*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="8d479-1752">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="8d479-1753">Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1753">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="8d479-1754">W tabeli poniżej opisano każdy element.</span><span class="sxs-lookup"><span data-stu-id="8d479-1754">The following table describes each element.</span></span>  
  
|<span data-ttu-id="8d479-1755">Element</span><span class="sxs-lookup"><span data-stu-id="8d479-1755">Element</span></span>|<span data-ttu-id="8d479-1756">Opis</span><span class="sxs-lookup"><span data-stu-id="8d479-1756">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="8d479-1757">*ws*</span><span class="sxs-lookup"><span data-stu-id="8d479-1757">*ws*</span></span>|<span data-ttu-id="8d479-1758">Opcjonalny odstęp.</span><span class="sxs-lookup"><span data-stu-id="8d479-1758">Optional white space.</span></span> <span data-ttu-id="8d479-1759">Odstęp może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagi, lub na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1759">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="8d479-1760">Symbol waluty specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1760">A culture-specific currency symbol.</span></span> <span data-ttu-id="8d479-1761">Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez <xref:System.IFormatProvider.GetFormat%2A> metody `provider` parametru.</span><span class="sxs-lookup"><span data-stu-id="8d479-1761">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter.</span></span> <span data-ttu-id="8d479-1762">Symbol waluty może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1762">The currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1763">*sign*</span><span class="sxs-lookup"><span data-stu-id="8d479-1763">*sign*</span></span>|<span data-ttu-id="8d479-1764">Opcjonalny znak.</span><span class="sxs-lookup"><span data-stu-id="8d479-1764">An optional sign.</span></span> <span data-ttu-id="8d479-1765">Znak może występować na początku `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę która może znajdować się na końcu `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1765">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="8d479-1766">Nawiasy mogą być używane w `value` do wskazania wartości ujemnej, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1766">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1767">*cyfry*</span><span class="sxs-lookup"><span data-stu-id="8d479-1767">*digits*</span></span>|<span data-ttu-id="8d479-1768">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1768">A sequence of digits from 0 through 9.</span></span>|  
|<span data-ttu-id="8d479-1769">*,*</span><span class="sxs-lookup"><span data-stu-id="8d479-1769">*,*</span></span>|<span data-ttu-id="8d479-1770">Separator grupy specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1770">A culture-specific group separator.</span></span> <span data-ttu-id="8d479-1771">Separator grupy kultury określonej parametrem `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1771">The group separator of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1772">*.*</span><span class="sxs-lookup"><span data-stu-id="8d479-1772">*.*</span></span>|<span data-ttu-id="8d479-1773">Symbol dziesiętny specyficzny dla kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1773">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="8d479-1774">Symbol separatora dziesiętnego kultury określonej przez `provider` może znajdować się w `value` Jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1774">The decimal point symbol of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1775">*cyfry_ułamkowe*</span><span class="sxs-lookup"><span data-stu-id="8d479-1775">*fractional_digits*</span></span>|<span data-ttu-id="8d479-1776">Jedno lub więcej wystąpień cyfry 0.</span><span class="sxs-lookup"><span data-stu-id="8d479-1776">One or more occurrences of the digit 0.</span></span> <span data-ttu-id="8d479-1777">Cyfry ułamkowe mogą pojawiać się w `value` tylko wtedy, gdy `style` obejmuje <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1777">Fractional digits can appear in `value` only if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1778">E</span><span class="sxs-lookup"><span data-stu-id="8d479-1778">E</span></span>|<span data-ttu-id="8d479-1779">Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym).</span><span class="sxs-lookup"><span data-stu-id="8d479-1779">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="8d479-1780">`value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1780">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1781">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="8d479-1781">*exponential_digits*</span></span>|<span data-ttu-id="8d479-1782">Sekwencja cyfr od 0 do 9.</span><span class="sxs-lookup"><span data-stu-id="8d479-1782">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="8d479-1783">`value` Parametr może reprezentować liczbę w zapisie wykładniczym, jeśli `style` obejmuje <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="8d479-1783">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="8d479-1784">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="8d479-1784">*hexdigits*</span></span>|<span data-ttu-id="8d479-1785">Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.</span><span class="sxs-lookup"><span data-stu-id="8d479-1785">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="8d479-1786">Wszystkie znaki (U + 0000) NUL kończącego w `s` są ignorowane przez operacji analizowania, bez względu na wartość `style` argumentu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1786">Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.</span></span>

 <span data-ttu-id="8d479-1787">Ciąg zawierający tylko cyfry dziesiętne (co odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flagi) zawsze przeanalizowany pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="8d479-1787">A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flag) always parses successfully.</span></span> <span data-ttu-id="8d479-1788">Większość pozostałych <xref:System.Globalization.NumberStyles> składowych kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w tym ciągu wejściowym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1788">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in this input string.</span></span> <span data-ttu-id="8d479-1789">Poniższa tabela wskazuje, jak poszczególne <xref:System.Globalization.NumberStyles> członków wpływają na elementy, które mogą być obecne w `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1789">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="8d479-1790">Niezłożone `NumberStyles` wartości</span><span class="sxs-lookup"><span data-stu-id="8d479-1790">Non-composite `NumberStyles` values</span></span>|<span data-ttu-id="8d479-1791">Dodatkowe (poza cyframi) elementy dozwolone w wartości</span><span class="sxs-lookup"><span data-stu-id="8d479-1791">Elements permitted in value in addition to digits</span></span>|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="8d479-1792">Tylko cyfry dziesiętne.</span><span class="sxs-lookup"><span data-stu-id="8d479-1792">Decimal digits only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="8d479-1793">Punkt dziesiętny (*.*) i *cyfry_ułamkowe* elementów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1793">The decimal point (*.*) and *fractional_digits* elements.</span></span> <span data-ttu-id="8d479-1794">Jednak *cyfry_ułamkowe* musi zawierać wyłącznie jedną lub więcej cyfr 0, metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1794">However, *fractional_digits* must consist of only one or more 0 digits, or the method returns `false`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="8d479-1795">"E" lub znak "E", co oznacza zapis wykładniczy, razem z *cyfry_szesnastkowe*.</span><span class="sxs-lookup"><span data-stu-id="8d479-1795">The "e" or "E" character, which indicates exponential notation, along with *exponential_digits*.</span></span> <span data-ttu-id="8d479-1796">Jeśli `value` reprezentuje liczbę w zapisie wykładniczym nie ma składnika różna od zera, ułamkowe.</span><span class="sxs-lookup"><span data-stu-id="8d479-1796">If `value` represents a number in exponential notation, it cannot have a non-zero, fractional component.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="8d479-1797">*Ws* element na początku `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1797">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="8d479-1798">*Ws* element na końcu `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1798">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="8d479-1799">*Logowania* przed elementem *cyfr*.</span><span class="sxs-lookup"><span data-stu-id="8d479-1799">The *sign* element before *digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="8d479-1800">*Logowania* elementu po *cyfr*.</span><span class="sxs-lookup"><span data-stu-id="8d479-1800">The *sign* element after *digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="8d479-1801">*Logowania* elementu w postaci nawiasów obejmujących wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1801">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="8d479-1802">Separator grupy (*,*) elementu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1802">The group separator (*,*) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="8d479-1803">Waluta (*$*) elementu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1803">The currency (*$*) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="8d479-1804">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1804">All elements.</span></span> <span data-ttu-id="8d479-1805">Jednak `value` nie może reprezentować liczby szesnastkowej ani liczby w zapisie wykładniczym.</span><span class="sxs-lookup"><span data-stu-id="8d479-1805">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="8d479-1806">*Ws* element na początku lub końcu `value`, *logowania* na początku `value`i separator dziesiętny (*.*) symbol.</span><span class="sxs-lookup"><span data-stu-id="8d479-1806">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (*.*) symbol.</span></span> <span data-ttu-id="8d479-1807">`value` Parametru można również użyć notacji wykładniczej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1807">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="8d479-1808">*Ws*, *logowania*, separator grupy (*,*) i separator dziesiętny (*.*) elementów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1808">The *ws*, *sign*, group separator (*,*), and decimal point (*.*) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="8d479-1809">Wszystkie elementy.</span><span class="sxs-lookup"><span data-stu-id="8d479-1809">All elements.</span></span> <span data-ttu-id="8d479-1810">Jednak `value` nie może reprezentować liczby szesnastkowej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1810">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d479-1811">Jeśli używasz <xref:System.Numerics.BigInteger.TryParse%2A> metody dwustronnej konwersji ciągu reprezentującego z <xref:System.Numerics.BigInteger> wartość, która została generowane przez <xref:System.Numerics.BigInteger.ToString%2A> metody, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody przy użyciu specyfikatora formatu "R", aby wygenerować reprezentacji w postaci ciągu <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1811">If you use the <xref:System.Numerics.BigInteger.TryParse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="8d479-1812">W przeciwnym razie reprezentację ciągu <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej istotnych cyfr części oryginalnej wartości, a dane mogą zostać utracone, gdy używasz <xref:System.Numerics.BigInteger.TryParse%2A> metoda przywracania <xref:System.Numerics.BigInteger> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1812">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.TryParse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="8d479-1813">Jeśli <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flaga jest używana, `value` musi mieć wartość szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1813">If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `value` must be a hexadecimal value.</span></span> <span data-ttu-id="8d479-1814">Jedyne inne flagi, które mogą być obecne w `style` są <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> i <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1814">The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d479-1815">( <xref:System.Globalization.NumberStyles> Wyliczenie ma styl kompozytowy <xref:System.Globalization.NumberStyles.HexNumber>, który zawiera obie flagi odstępu.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1815">(The <xref:System.Globalization.NumberStyles> enumeration has a composite style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d479-1816">Jeśli `value` jest ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym uzupełnieniem (takie jak `0x` lub `&h`) które odróżnia go jako liczbę szesnastkową.</span><span class="sxs-lookup"><span data-stu-id="8d479-1816">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="8d479-1817">To powoduje niepowodzenie konwersji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1817">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="8d479-1818">Jeśli `value` jest ciąg szesnastkowy <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> interpretuje metoda `value` jako liczba ujemna przechowywane przy użyciu reprezentacji uzupełnienie dwójki, jeśli jego pierwsze dwie cyfry szesnastkowe są większe niż lub równa `0x80`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1818">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="8d479-1819">Innymi słowy, metoda interpretuje bitu najwyższego rzędu pierwszego bajtu w `value` jako bitu znaku.</span><span class="sxs-lookup"><span data-stu-id="8d479-1819">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="8d479-1820">Aby upewnić się, że ciąg szesnastkowy poprawnie jest interpretowana jako liczba dodatnia, pierwsza cyfra w `value` musi mieć wartość zero.</span><span class="sxs-lookup"><span data-stu-id="8d479-1820">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="8d479-1821">Na przykład metoda interpretuje `0x80` zgodnie z wartością ujemną, ale interpretuje albo `0x080` lub `0x0080` jako wartości dodatniej.</span><span class="sxs-lookup"><span data-stu-id="8d479-1821">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="8d479-1822">Poniższy przykład ilustruje różnicę między ciągów szesnastkowych, które reprezentują wartości ujemny i dodatni.</span><span class="sxs-lookup"><span data-stu-id="8d479-1822">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 <span data-ttu-id="8d479-1823">`provider` Parametr <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="8d479-1823">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="8d479-1824">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie parametru `value`.</span><span class="sxs-lookup"><span data-stu-id="8d479-1824">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of `value`.</span></span> <span data-ttu-id="8d479-1825">`provider` Parametru może być jednym z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="8d479-1825">The `provider` parameter can be any one of the following:</span></span>  
  
-   <span data-ttu-id="8d479-1826">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1826">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="8d479-1827">Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb dla tej kultury.</span><span class="sxs-lookup"><span data-stu-id="8d479-1827">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="8d479-1828">Element <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu liczb.</span><span class="sxs-lookup"><span data-stu-id="8d479-1828">A <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="8d479-1829">(Jego implementacja obiektu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> zwraca samą siebie.)</span><span class="sxs-lookup"><span data-stu-id="8d479-1829">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="8d479-1830">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="8d479-1830">A custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="8d479-1831">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda tworzy i zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="8d479-1831">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="8d479-1832">Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury jest używane.</span><span class="sxs-lookup"><span data-stu-id="8d479-1832">If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d479-1833">Poniższy przykład wykonuje kilka wywołań <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody przy użyciu różnych kombinacji wartości dla `style` i `provider` parametrów.</span><span class="sxs-lookup"><span data-stu-id="8d479-1833">The following example makes some calls to the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method using various combinations of values for the `style` and `provider` parameters.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 <span data-ttu-id="8d479-1834">Liczba poszczególnych wywołań dla <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metoda Przekaż wystąpienie następujących `BigIntegerFormatProvider` klasy, która definiuje tyldy (~) jako znaku ujemnego.</span><span class="sxs-lookup"><span data-stu-id="8d479-1834">A number of the individual calls to the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method pass an instance of the following `BigIntegerFormatProvider` class, which defines a tilde (~) as the negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d479-1835"><paramref name="style" /> nie jest <see cref="T:System.Globalization.NumberStyles" /> wartość.</span><span class="sxs-lookup"><span data-stu-id="8d479-1835"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
<span data-ttu-id="8d479-1836">—lub—</span><span class="sxs-lookup"><span data-stu-id="8d479-1836">-or-</span></span> 
 <span data-ttu-id="8d479-1837"><paramref name="style" /> obejmuje <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> lub <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flagi wraz z inną wartością.</span><span class="sxs-lookup"><span data-stu-id="8d479-1837"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d479-1838">Pobiera wartość, która reprezentuje numer 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-1838">Gets a value that represents the number 0 (zero).</span></span></summary>
        <value><span data-ttu-id="8d479-1839">Liczba całkowita, którego wartość jest równa 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="8d479-1839">An integer whose value is 0 (zero).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d479-1840"><xref:System.Numerics.BigInteger> Obiektu zwróconego przez tę właściwość udostępnia wygodne źródło wartość zero dla przypisania i porównań.</span><span class="sxs-lookup"><span data-stu-id="8d479-1840">The <xref:System.Numerics.BigInteger> object returned by this property provides a convenient source of a zero value for use in assignments and comparisons.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>
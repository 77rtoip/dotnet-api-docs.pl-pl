<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje arbitralnie dużą liczbę całkowitą ze znakiem.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Typ jest niezmiennym typem, który reprezentuje arbitralnie dużą liczbę całkowitą, której wartość teoretyczna nie ma górnych lub dolnych granic. Elementy <xref:System.Numerics.BigInteger> członkowskie typu ściśle równoleżnika na inne typy całkowite <xref:System.SByte> <xref:System.Byte> <xref:System.Int64> <xref:System.Int16> <xref:System.Int32>( <xref:System.UInt64> ,, ,<xref:System.UInt32>,,, i). <xref:System.UInt16> Ten typ różni się od innych typów całkowitych w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], które mają zakres wskazany przez ich `MinValue` i `MaxValue` właściwości.  
  
> [!NOTE]
>  Ponieważ typ jest niezmienny (zobacz [zmienność i struktura BigInteger](#mutability)) i ponieważ nie ma żadnych górnych lub dolnych <xref:System.OutOfMemoryException> granic, może być zgłaszany dla każdej operacji, która powoduje, że wartość jest <xref:System.Numerics.BigInteger> zbyt duża. <xref:System.Numerics.BigInteger>  
  
## <a name="instantiating-a-biginteger-object"></a>Utworzenie wystąpienia obiektu BigInteger  
 Można utworzyć wystąpienie <xref:System.Numerics.BigInteger> obiektu na kilka sposobów:  
  
-   Możesz użyć `new` słowa kluczowego i podać dowolną wartość całkowitą lub zmiennoprzecinkową jako parametr <xref:System.Numerics.BigInteger> do konstruktora. (Wartości zmiennoprzecinkowe są obcinane przed przypisaniem ich do <xref:System.Numerics.BigInteger>.) Poniższy przykład ilustruje sposób użycia `new` słowa kluczowego w celu utworzenia wystąpienia <xref:System.Numerics.BigInteger> wartości.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Można zadeklarować <xref:System.Numerics.BigInteger> zmienną i przypisać ją do wartości tak samo jak dowolnego typu liczbowego, o ile ta wartość jest typem całkowitym. Poniższy przykład używa przypisania, aby utworzyć <xref:System.Numerics.BigInteger> wartość <xref:System.Int64>z.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Można przypisać wartość dziesiętną lub zmiennoprzecinkową do <xref:System.Numerics.BigInteger> obiektu w przypadku rzutowania wartości lub jej pierwszej konwersji. Poniższy przykład jawnie rzutuje ( C#in) lub konwertuje (w Visual Basic) <xref:System.Double> a i <xref:System.Decimal> wartość na <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Te metody umożliwiają utworzenie wystąpienia <xref:System.Numerics.BigInteger> obiektu, którego wartość należy do zakresu jednego z istniejących tylko typów liczbowych. Można utworzyć wystąpienie <xref:System.Numerics.BigInteger> obiektu, którego wartość może przekroczyć zakres istniejących typów liczbowych na jeden z trzech sposobów:  
  
-   Możesz użyć `new` słowa kluczowego i udostępnić tablicę bajtową dowolnego rozmiaru <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> konstruktorowi. Na przykład:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Można wywołać metody lub <xref:System.Numerics.BigInteger.Parse%2A> <xref:System.Numerics.BigInteger.TryParse%2A> , aby przekonwertować ciąg reprezentujący liczbę na <xref:System.Numerics.BigInteger>. Na przykład:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Można wywołać `static` metodę (`Shared` w Visual Basic) <xref:System.Numerics.BigInteger> , która wykonuje kilka operacji na wyrażeniu liczbowym i zwraca obliczony <xref:System.Numerics.BigInteger> wynik. Poniższy przykład wykonuje to przez Cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> i przypisuje wynik <xref:System.Numerics.BigInteger>do.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Niezainicjowana wartość <xref:System.Numerics.BigInteger> klasy is <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Wykonywanie operacji na wartościach typu BigInteger  
 Można użyć <xref:System.Numerics.BigInteger> wystąpienia, jak używać dowolnego innego typu całkowitego. <xref:System.Numerics.BigInteger>przeciążenia standardowych operatorów liczbowych, aby umożliwić wykonywanie podstawowych operacji matematycznych, takich jak dodawanie, odejmowanie, dzielenie, mnożenie, odejmowanie, Negacja i Jednoargumentowa Negacja. Można również użyć standardowych operatorów liczbowych, aby porównać dwie <xref:System.Numerics.BigInteger> wartości ze sobą. Podobnie jak w przypadku innych typów <xref:System.Numerics.BigInteger> całkowitych, obsługiwane `And`są również `XOr`operatory bitowe, `Or`,, przesunięcie w lewo i przesunięcia w prawo. W przypadku języków, które nie obsługują operatorów niestandardowych, <xref:System.Numerics.BigInteger> struktura zapewnia również równoważne metody wykonywania operacji matematycznych. Należą <xref:System.Numerics.BigInteger.Add%2A>do nich <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>,, i kilkainnych.<xref:System.Numerics.BigInteger.Subtract%2A>  
  
 Wiele elementów członkowskich <xref:System.Numerics.BigInteger> struktury odpowiada bezpośrednio członkom innych typów całkowitych. Ponadto program dodaje <xref:System.Numerics.BigInteger> elementy członkowskie, takie jak następujące:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, która zwraca wartość wskazującą znak <xref:System.Numerics.BigInteger> wartości.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, która zwraca wartość <xref:System.Numerics.BigInteger> bezwzględną wartości.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, która zwraca iloraz i resztę operacji dzielenia.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, która zwraca największy wspólny dzielnik dwóch <xref:System.Numerics.BigInteger> wartości.  
  
 Wiele z tych dodatkowych członków odpowiada członkom <xref:System.Math> klasy, która zapewnia funkcjonalność do pracy z pierwotnymi typami liczbowymi.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Zmienność i struktura BigInteger  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu, a następnie zwiększa jego wartość o jeden.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Mimo że ten przykład pojawia się, aby zmodyfikować wartość istniejącego obiektu, nie jest to przypadek. <xref:System.Numerics.BigInteger>obiekty są niezmienne, co oznacza, że wewnętrznie środowisko uruchomieniowe języka wspólnego w rzeczywistości <xref:System.Numerics.BigInteger> tworzy nowy obiekt i przypisuje mu wartość większą od poprzedniej wartości. Ten nowy obiekt jest następnie zwracany do obiektu wywołującego.  
  
> [!NOTE]
>  Inne typy liczbowe w .NET Framework są również niezmienne. Ponieważ <xref:System.Numerics.BigInteger> jednak typ nie ma górnych lub dolnych granic, jego wartości mogą rosnąć bardzo duże i mieć wymierny wpływ na wydajność.  
  
 Mimo że ten proces jest niewidoczny dla obiektu wywołującego, wiąże się z nim spadek wydajności. W niektórych przypadkach, zwłaszcza gdy powtarzające się operacje są wykonywane w pętli na bardzo <xref:System.Numerics.BigInteger> dużych wartościach, spadek wydajności może być znaczny. Na przykład w poniższym przykładzie operacja jest wykonywana wielokrotnie do miliona, a <xref:System.Numerics.BigInteger> wartość jest zwiększana o jeden za każdym razem, gdy operacja się powiedzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 W takim przypadku można poprawić wydajność, wykonując wszystkie przydziały pośrednie do <xref:System.Int32> zmiennej. Końcowa wartość zmiennej można następnie przypisać do obiektu, <xref:System.Numerics.BigInteger> gdy pętla zostanie zakończona. Poniższy przykład stanowi ilustrację.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Praca z tablicami bajtowymi i ciągami znaków szesnastkowych  
 W przypadku konwersji <xref:System.Numerics.BigInteger> wartości na tablice typu Byte lub przekonwertowania tablic bajtowych na <xref:System.Numerics.BigInteger> wartości należy wziąć pod uwagę kolejność bajtów. <xref:System.Numerics.BigInteger> Struktura oczekuje, że poszczególne bajty w tablicy bajtów mają być wyświetlane w kolejności little-endian (oznacza to, że bajty o niższej kolejności wartości poprzedzają bajty wyższego rzędu). Można zaokrąglić <xref:System.Numerics.BigInteger> wartość przez <xref:System.Numerics.BigInteger.ToByteArray%2A> wywołanie metody, a następnie przekazanie <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> otrzymanej tablicy bajtowej do konstruktora, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy bajtowej, która reprezentuje wartość innego typu całkowitego, można przekazać wartość całkowitą <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> do metody, a następnie przekazać <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> uzyskaną tablicę bajtów do konstruktora. Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy bajtowej, która <xref:System.Int16> reprezentuje wartość.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger> Struktura zakłada, że wartości ujemne są przechowywane przy użyciu reprezentacji uzupełniającej. Ponieważ struktura reprezentuje wartość liczbową bez stałej długości <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> , Konstruktor zawsze interpretuje najbardziej znaczący bit ostatniego bajtu w tablicy jako bit znaku. <xref:System.Numerics.BigInteger> Aby uniemożliwić <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> konstruktorowi mylące reprezentację uzupełniającą wartości ujemnej z reprezentacją znaku i wielkością wartości dodatniej, wartości dodatnie, w których najbardziej znaczący bit ostatniego bajtu w tablicy bajtów zwykle należy ustawić dodatkowy bajt, którego wartość wynosi 0. Na przykład 0xC0 0xBD 0xF0 0xFF jest reprezentacją szesnastkową w formacie-1 000 000 lub 4 293 967 296. Ponieważ najbardziej znaczący bit ostatniego bajtu w tej tablicy jest włączony, wartość tablicy bajtowej byłaby interpretowana przez <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor jako-1 000 000. Aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> , którego wartość jest dodatnia, tablica bajtowa, której elementy są 0xC0 0xBD 0xF0 0xFF 0x00 muszą zostać przesłane do konstruktora. Ilustruje to poniższy przykład.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Tablice bajtowe utworzone przez <xref:System.Numerics.BigInteger.ToByteArray%2A> metodę z wartości dodatnich zawierają ten dodatkowy bajt o wartości zero. W <xref:System.Numerics.BigInteger> związku z tym struktura może pomyślnie zaokrąglić wartości, przypisując je do, a następnie przywracając z tablic bajtowych, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Jednak może być konieczne dodanie tego dodatkowego bajtu wartości zerowej do tablic bajtowych, które są tworzone dynamicznie przez dewelopera lub które są zwracane przez metody, które konwertują liczby całkowite bez znaku na tablice <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>bajtowe ( <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>takie jak, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>i).  
  
 Podczas analizowania ciągu <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> szesnastkowego metody i <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> zakładają, że jeśli najbardziej znaczący bit pierwszego bajtu w ciągu jest ustawiony lub jeśli Pierwsza cyfra szesnastkowa ciągu reprezentuje mniejsze cztery bity wartości Byte, wartość jest reprezentowane przy użyciu reprezentacji uzupełniającej. Na przykład zarówno "FF01", jak i "F01" reprezentują wartość dziesiętną-255. Aby odróżnić wartość dodatnią od wartości ujemnych, wartości dodatnie powinny zawierać zero wiodące. Odpowiednie przeciążenia <xref:System.Numerics.BigInteger.ToString%2A> metody, gdy są przenoszone ciągu formatu "X", Dodaj wiodące zero do zwracanego ciągu szesnastkowego dla wartości dodatnich. Dzięki temu można zaokrąglić <xref:System.Numerics.BigInteger> wartości przy <xref:System.Numerics.BigInteger.ToString%2A> użyciu metod i <xref:System.Numerics.BigInteger.Parse%2A> , jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Jednak ciągi szesnastkowe tworzone przez wywołanie `ToString` metod innych typów całkowitych lub przeciążeń <xref:System.Convert.ToString%2A> metody, która zawiera `toBase` parametr, nie wskazują znaku wartości ani typu danych źródłowych, z których ciąg szesnastkowy został pochodny. Pomyślnie utworzono wystąpienie <xref:System.Numerics.BigInteger> wartości z takiego ciągu wymaga pewnej dodatkowej logiki. W poniższym przykładzie przedstawiono jedną możliwą implementację.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica wartości bajtów w kolejności little-endian.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości w tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne bajty w `value` tablicy powinny znajdować się w kolejności little-endian z najniższego bajtu do najwyższego rzędu. Na przykład wartość liczbowa 1 000 000 000 000 jest reprezentowana jak pokazano w poniższej tabeli:  
  
|||  
|-|-|  
|Ciąg szesnastkowy|E8D4A51000|  
|Tablica bajtów (najpierw najniższy indeks)|00 10 A5 D4 E8 00|  
  
 Większość metod, które konwertują wartości numeryczne na tablice bajtowe <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, takie jak <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> i, zwracają tablice bajtowe w kolejności little-endian.  
  
 Konstruktor oczekuje wartości dodatnich w tablicy bajtowej, aby można było użyć reprezentacji znaku i wielkości oraz wartości ujemnych, aby użyć reprezentacji uzupełniającej. Innymi słowy, jeśli ustawiono największą liczbę bajtów najwyższego rzędu w `value` zestawie, wartość wynikowa <xref:System.Numerics.BigInteger> jest ujemna. W zależności od źródła tablicy bajtów może to spowodować, że wartość dodatnia będzie interpretowana jako wartość ujemna. Tablice bajtowe są zazwyczaj generowane w następujący sposób:  
  
-   Przez wywołanie <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> metody. Ponieważ ta metoda zwraca tablicę bajtową z największą ilością bajtów najwyższego rzędu w tablicy ustawionej na zero dla wartości dodatnich, nie ma możliwości interpretowania wartości dodatniej jako ujemnej. Niezmodyfikowane tablice bajtowe utworzone <xref:System.Numerics.BigInteger.ToByteArray%2A> przez metodę są zawsze prawidłowo przenoszone po przekazaniu ich <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> do konstruktora.  
  
-   Przez wywołanie <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody i przekazanie jej jako parametru liczby całkowitej ze znakiem. Ze względu na to, że podpisane liczby całkowite obsługują zarówno reprezentację, jak i reprezentację uzupełnienia, nie ma możliwości interpretowania wartości dodatniej jako ujemnej.  
  
-   Przez wywołanie <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metody i przekazanie jej jako parametru liczby całkowitej bez znaku. Ponieważ liczby całkowite bez znaku są reprezentowane tylko przez ich wielkości, wartości dodatnie mogą być interpretowane jako wartości ujemne. Aby uniknąć tej błędnej interpretacji, można dodać wartość zero-bajtową do końca tablicy. Przykład w następnej sekcji zawiera ilustrację.  
  
-   Tworząc tablicę bajtową dynamicznie lub statycznie bez konieczności wywoływania którejkolwiek z powyższych metod lub modyfikując istniejącą tablicę bajtów. Aby zapobiec błędnej interpretacji wartości dodatnich jako wartości ujemnych, można dodać wartość zero-bajtową do końca tablicy.  
  
 Jeśli `value` jest tablicą <xref:System.Byte> pustą, nowy <xref:System.Numerics.BigInteger> obiekt zostanie zainicjowany do wartości <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Jeśli `value` jest `null` ,<xref:System.ArgumentNullException>Konstruktor zgłasza.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu z 5-elementowej tablicy bajtów, której wartość wynosi {5, 4, 3, 2, 1}. Następnie w konsoli programu <xref:System.Numerics.BigInteger> zostanie wyświetlona wartość reprezentowana jako liczba dziesiętna i szesnastkowa. Porównanie tablicy wejściowej z tekstem wyjściowym sprawia, że to Przeciążenie <xref:System.Numerics.BigInteger> konstruktora klasy tworzy obiekt, <xref:System.Numerics.BigInteger> którego wartością jest 4328719365 (lub 0x102030405). Pierwszy element tablicy bajtowej, której wartością jest 5, definiuje wartość najniższego bajtu <xref:System.Numerics.BigInteger> obiektu, który jest 0x05. Drugi element tablicy bajtowej, którego wartość to 4, definiuje wartość drugiego bajtu <xref:System.Numerics.BigInteger> obiektu, który jest 0x04 i tak dalej.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Poniższy przykład tworzy wystąpienie wartości dodatniej i ujemnej <xref:System.Numerics.BigInteger> , przekazuje je <xref:System.Numerics.BigInteger.ToByteArray%2A> do metody, a następnie przywraca pierwotne <xref:System.Numerics.BigInteger> wartości z wynikowej tablicy bajtów. Należy zauważyć, że dwie wartości są reprezentowane przez identyczne tablice bajtowe. Jedyną różnicą między nimi jest najbardziej znaczący bit ostatniego elementu w tablicy bajtów. Ten bit jest ustawiony (wartość bajtu to 0xFF), jeśli tablica jest tworzona na podstawie wartości ujemnej <xref:System.Numerics.BigInteger> . Bit nie jest ustawiony (wartość bajtu jest równa zero), jeśli tablica jest tworzona z wartości dodatniej <xref:System.Numerics.BigInteger> .  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Poniższy przykład ilustruje, jak upewnić się, że wartość dodatnia nie jest nieprawidłowo tworzona jako wartość ujemna przez dodanie bajtu, którego wartość jest równa zero do końca tablicy.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Liczba dziesiętna.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury <see cref="T:System.Decimal" /> przy użyciu wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wywołania tego konstruktora jest identyczny, aby jawnie przypisywać <xref:System.Decimal> wartość <xref:System.Numerics.BigInteger> do zmiennej.  
  
 Wywołanie tego konstruktora może spowodować utratę danych; Każda część `value` ułamkowa jest obcinana podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> konstruktora do <xref:System.Numerics.BigInteger> utworzenia wystąpienia obiektu. Definiuje tablicę <xref:System.Decimal> wartości, a następnie przekazuje każdą wartość <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> do konstruktora. Należy pamiętać, <xref:System.Decimal> że wartość jest obcinana zamiast zaokrąglana, gdy jest przypisana <xref:System.Numerics.BigInteger> do obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość zmiennoprzecinkowa o podwójnej precyzji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowej o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda część `value` ułamkowa parametru zostanie obcięta podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
 Ze względu na brak dokładności <xref:System.Double> typu danych wywoływanie tego konstruktora może spowodować utratę danych.  
  
 Wartość, która wynika z wywołania tego konstruktora, jest taka sama jak wartość będąca wynikiem jawnie <xref:System.Double> przypisywania wartości <xref:System.Numerics.BigInteger>do. <xref:System.Numerics.BigInteger>  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> konstruktora do <xref:System.Numerics.BigInteger> utworzenia wystąpienia obiektu. Przedstawiono w nim również utratę precyzji, która może wystąpić w przypadku użycia <xref:System.Double> typu danych. Ma przypisaną dużą wartość, która następnie jest przypisana <xref:System.Numerics.BigInteger> do obiektu. <xref:System.Double> W miarę wyświetlania danych wyjściowych to przypisanie obejmuje utratę precyzji. Obie wartości są następnie zwiększane o jeden. Dane wyjściowe wskazują, że <xref:System.Numerics.BigInteger> obiekt odzwierciedla zmienione wartości, <xref:System.Double> podczas gdy obiekt nie jest.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, lub <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowa liczba całkowita ze znakiem.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu 32-bitowej podpisanej wartości całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora nie ma żadnej żadnej dokładności.  
  
 Wartość, która wynika z wywołania tego konstruktora, jest taka sama jak wartość będąca wynikiem <xref:System.Int32> przypisywania wartości <xref:System.Numerics.BigInteger>do. <xref:System.Numerics.BigInteger>  
  
 <xref:System.Int16> <xref:System.Byte> <xref:System.UInt16> <xref:System.SByte>Struktura nie obejmuje konstruktorów z parametrem typu,,, lub. <xref:System.Numerics.BigInteger> Jednak <xref:System.Int32> Typ obsługuje niejawną konwersję 8-bitowych i 16-bitowych liczb całkowitych ze znakiem i bez znaku, aby podpisały 32-bitowe liczby całkowite. W efekcie ten konstruktor jest wywoływany, jeśli `value` jest jednym z tych czterech typów całkowitych.  
  
   
  
## Examples  
 Poniższy przykład wywołuje konstruktora, <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy 32-bitowych liczb całkowitych. Stosuje również niejawną konwersję, aby przypisać każde 32-bitową <xref:System.Numerics.BigInteger> wartość całkowitą do zmiennej. Następnie porównuje dwie wartości w celu ustalenia, że <xref:System.Numerics.BigInteger> wartości będą takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">64-bitowa liczba całkowita ze znakiem.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu 64-bitowej podpisanej wartości całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu za pomocą tego konstruktora nie ma żadnej żadnej dokładności.  
  
 Wartość, która wynika z wywołania tego konstruktora, jest taka sama jak wartość będąca wynikiem <xref:System.Int64> przypisywania wartości <xref:System.Numerics.BigInteger>do. <xref:System.Numerics.BigInteger>  
  
   
  
## Examples  
 Poniższy przykład wywołuje konstruktora, <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> aby utworzyć wystąpienie <xref:System.Numerics.BigInteger> wartości z tablicy 64-bitowych liczb całkowitych. Stosuje również niejawną konwersję, aby przypisać każde 64-bitową <xref:System.Numerics.BigInteger> wartość całkowitą do zmiennej. Następnie porównuje dwie wartości w celu ustalenia, że <xref:System.Numerics.BigInteger> wartości będą takie same.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość zmiennoprzecinkowa o pojedynczej precyzji.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu wartości zmiennoprzecinkowej o pojedynczej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda część `value` ułamkowa parametru zostanie obcięta podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> obiektu.  
  
 Ze względu na brak dokładności <xref:System.Single> typu danych wywoływanie tego konstruktora może spowodować utratę danych.  
  
 Wartość, która wynika z wywołania tego konstruktora, jest taka sama jak wartość będąca wynikiem jawnie <xref:System.Single> przypisywania wartości <xref:System.Numerics.BigInteger>do. <xref:System.Numerics.BigInteger>  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> konstruktora do <xref:System.Numerics.BigInteger> utworzenia wystąpienia obiektu. Przedstawiono w nim również utratę precyzji, która może wystąpić w przypadku użycia <xref:System.Single> typu danych. Ma przypisaną dużą wartość ujemną, która następnie jest przypisana <xref:System.Numerics.BigInteger> do obiektu. <xref:System.Single> W miarę wyświetlania danych wyjściowych to przypisanie obejmuje utratę precyzji. Obie wartości są następnie zwiększane o jeden. Dane wyjściowe wskazują, że <xref:System.Numerics.BigInteger> obiekt odzwierciedla zmienione wartości, <xref:System.Single> podczas gdy obiekt nie jest.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, lub <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Niepodpisana wartość 32-bitowa liczba całkowita.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury przy użyciu niepodpisanej 32-bitowej liczby całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia wystąpienia z <xref:System.Numerics.BigInteger> użyciem tego konstruktora nie ma żadnej żadnej dokładności.  
  
 Wartość, która wynika z wywołania tego konstruktora, jest taka sama jak wartość będąca wynikiem <xref:System.UInt32> przypisywania wartości <xref:System.Numerics.BigInteger>do. <xref:System.Numerics.BigInteger>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> konstruktora i instrukcji przypisania, aby zainicjować <xref:System.Numerics.BigInteger> wartości z tablicy bez znaku 32-bitowych liczb całkowitych. Następnie porównuje dwie wartości, aby wykazać, że dwie metody inicjowania <xref:System.Numerics.BigInteger> wartości dają identyczne wyniki.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">64-bitowa liczba całkowita bez znaku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.BigInteger" /> struktury z niepodpisanym 64-bitową wartością całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia wystąpienia z <xref:System.Numerics.BigInteger> użyciem tego konstruktora nie ma żadnej żadnej dokładności.  
  
 Wartość, która wynika z wywołania tego konstruktora, jest taka sama jak wartość będąca wynikiem <xref:System.UInt64> przypisywania wartości <xref:System.Numerics.BigInteger>do. <xref:System.Numerics.BigInteger>  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> konstruktora, aby utworzyć wystąpienie obiektu <xref:System.Numerics.BigInteger> , <xref:System.UInt64.MaxValue>którego wartość jest równa.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba.</param>
        <summary>Pobiera wartość <see cref="T:System.Numerics.BigInteger" /> bezwzględną obiektu.</summary>
        <returns>Wartość bezwzględna <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna liczby to liczba bez znaku, jak pokazano w poniższej tabeli.  
  
|`value`konstruktora|Wartość zwracana|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Metoda jest równoważna <xref:System.Math.Abs%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych. <xref:System.Numerics.BigInteger.Abs%2A>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.BigInteger.Abs%2A> metodę, aby <xref:System.Numerics.BigInteger> przekonwertować wartość z dwóch reprezentacji uzupełniającej na reprezentację typu "-i-value" przed serializacji jej do pliku. Dane w pliku są następnie deserializowane i przypisywane do nowego <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje dwie <see cref="T:System.Numerics.BigInteger" /> wartości i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W językach, które nie obsługują przeciążania operatora lub operatorów niestandardowych, <xref:System.Numerics.BigInteger.Add%2A> można użyć metody, aby wykonać Dodawanie przy użyciu <xref:System.Numerics.BigInteger> wartości.  
  
 Metoda jest użytecznym zamiennikiem operatora dodawania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przez przypisanie jej sum, która wynika z dodania, jak pokazano w poniższym przykładzie. <xref:System.Numerics.BigInteger.Add%2A>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Porównuje <see cref="T:System.Numerics.BigInteger" /> dwie wartości i zwraca liczbę całkowitą, która wskazuje, czy pierwsza wartość jest mniejsza niż, równa lub większa od drugiej wartości.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje wartości <paramref name="left" /> względne i <paramref name="right" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Warunek 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="left" />jest mniejsze niż <paramref name="right" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="left" />równa <paramref name="right" />się.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="left" />jest większa niż <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż typ nie ma stałego zakresu, <xref:System.Numerics.BigInteger> porównania wartości nie są scharakteryzowane przez brak precyzji, która charakteryzuje porównanie liczb zmiennoprzecinkowych. <xref:System.Numerics.BigInteger> Poniższy przykład porównuje dwie <xref:System.Numerics.BigInteger> wartości, które różnią się od siebie, a każdy z nich ma 1 896 cyfr. <xref:System.Numerics.BigInteger.Compare%2A> Metoda prawidłowo zgłasza, że dwie wartości nie są równe.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje wartość tego wystąpienia z inną wartością i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż inna wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Podpisana 64-bitowa liczba całkowita do porównania.</param>
        <summary>Porównuje to wystąpienie z podpisaną 64-bitową liczbą całkowitą i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość podpisanej 64-bitowej liczby całkowitej.</summary>
        <returns>Wartość całkowita ze znakiem, która wskazuje związek tego wystąpienia <paramref name="other" />z, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Bieżące wystąpienie jest mniejsze niż <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Bieżące wystąpienie jest równe <paramref name="other" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Bieżące wystąpienie jest większe niż <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `other` jest<xref:System.Int16>, ,,<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> , lub<xref:System.Int64> wartość, jest niejawnie konwertowana na wartość, gdy wywoływana jest metoda. <xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.SByte> <xref:System.UInt16>  
  
   
  
## Examples  
 Poniższy przykład ilustruje wynik wywołania <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metody z wartości całkowitych.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania.</param>
        <summary>Porównuje to wystąpienie z drugim <see cref="T:System.Numerics.BigInteger" /> i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Wartość całkowita ze znakiem, która wskazuje związek tego wystąpienia <paramref name="other" />z, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Bieżące wystąpienie jest mniejsze niż <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Bieżące wystąpienie jest równe <paramref name="other" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Bieżące wystąpienie jest większe niż <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Numerics.BigInteger.CompareTo%2A> metody <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementuje metodę. Jest on używany przez obiekty kolekcji ogólnej do porządkowania elementów w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metody w celu uporządkowania `StarInfo` listy obiektów. Każdy `StarInfo` obiekt zawiera informacje o nazwie gwiazdki i jej odległości od ziemi w milach. `StarInfo`implementuje interfejs, który umożliwia `StarInfo` sortowanie obiektów przez klasy kolekcji generycznej. <xref:System.IComparable%601> Jego <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementacja powoduje jedynie zawijanie wywołania do <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Poniższy kod tworzy wystąpienie czterech `StarInfo` obiektów i zapisuje je w obiekcie ogólnym. <xref:System.Collections.Generic.List%601> <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> Po wywołaniumetodyobiektysąwyświetlanewkolejności`StarInfo` ich odległości od ziemi.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Porównuje to wystąpienie do określonego obiektu i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość określonego obiektu.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje związek bieżącego wystąpienia <paramref name="obj" /> z parametrem, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Bieżące wystąpienie jest mniejsze niż <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> Bieżące wystąpienie jest równe <paramref name="obj" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Bieżące wystąpienie jest większe niż <paramref name="obj" /> <paramref name="obj" /> lub parametr jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Numerics.BigInteger.CompareTo%2A> metody <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> implementuje metodę. Jest on używany przez obiekty kolekcji nieogólnej w celu uporządkowania elementów w kolekcji.  
  
 `obj` Parametr musi mieć jedną z następujących wartości:  
  
-   Obiekt, którego typem czasu wykonywania jest <xref:System.Numerics.BigInteger>.  
  
-   Zmienna <xref:System.Object> , której wartość to `null`. Jeśli wartość `obj` parametru to `null`, metoda zwraca wartość 1, co oznacza, że bieżące wystąpienie jest większe niż `obj`.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodę w celu <xref:System.Numerics.BigInteger> porównania wartości z każdym elementem w tablicy obiektów  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />nie <see cref="T:System.Numerics.BigInteger" />jest.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowa liczba całkowita bez znaku do porównania.</param>
        <summary>Porównuje to wystąpienie do niepodpisanej 64-bitowej liczby całkowitej i zwraca liczbę całkowitą, która wskazuje, czy wartość tego wystąpienia jest mniejsza niż, równa lub większa niż wartość niepodpisanej liczby całkowitej 64-bitowej.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje wartość względną tego <paramref name="other" />wystąpienia i, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> Mniej niż zero 
 </term><description> Bieżące wystąpienie jest mniejsze niż <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Bieżące wystąpienie jest równe <paramref name="other" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description> Bieżące wystąpienie jest większe niż <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość, która ma zostać podzielona.</param>
        <param name="divisor">Wartość do podziału przez.</param>
        <summary>Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartość przez inną i zwraca wynik.</summary>
        <returns>Iloraz dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A> Metoda wykonuje dzielenie liczby całkowitej; wszelkie pozostałe wyniki z dzielenia są odrzucane. Aby wykonać dzielenie liczby całkowitej podczas zachowywania reszty, wywołaj <xref:System.Numerics.BigInteger.DivRem%2A> metodę. Aby pobrać tylko resztę, wywołaj <xref:System.Numerics.BigInteger.Remainder%2A> metodę.  
  
 <xref:System.Numerics.BigInteger.Divide%2A> Metoda może być używana przez Języki, które nie obsługują przeciążania operatora. Zachowanie jest takie samo jak w przypadku dzielenia przy użyciu operatora dzielenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdego elementu jako ilorazu w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> metody, operatora dzielenia (/) <xref:System.Numerics.BigInteger.DivRem%2A> i metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />ma wartość 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość, która ma zostać podzielona.</param>
        <param name="divisor">Wartość do podziału przez.</param>
        <param name="remainder">Gdy ta metoda zwraca, zawiera <see cref="T:System.Numerics.BigInteger" /> wartość, która reprezentuje resztę z dzielenia. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Dzieli jedną <see cref="T:System.Numerics.BigInteger" /> wartość przez inną, zwraca wynik i zwraca resztę w parametrze wyjściowym.</summary>
        <returns>Iloraz dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zachowuje iloraz i resztę z dzielenia liczb całkowitych. Jeśli pozostała część nie jest interesująca, użyj <xref:System.Numerics.BigInteger.Divide%2A> metody lub operatora dzielenia. Jeśli jesteś zainteresowany tylko resztą, <xref:System.Numerics.BigInteger.Remainder%2A> Użyj metody.  
  
 Znak zwracanej `remainder` wartości jest taki sam jak znak `dividend` parametru.  
  
 Zachowanie <xref:System.Numerics.BigInteger.DivRem%2A> metody jest takie samo jak <xref:System.Math.DivRem%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdego elementu jako ilorazu w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> metody, operatora dzielenia (/) <xref:System.Numerics.BigInteger.DivRem%2A> i metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />ma wartość 0 (zero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości liczbowe są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Podpisana 64-bitowa liczba całkowita do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i podpisaną 64-bitową liczbę całkowitą mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli podpisana 64-bitowa liczba całkowita i bieżące wystąpienie ma tę samą wartość; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `other` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowana na wartość, gdy wywoływana jest metoda. <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 Aby określić relację między dwoma obiektami zamiast tylko do testowania równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.BigInteger> obiektu z każdego typu całkowitego z wyjątkiem. <xref:System.UInt64> Następnie wywołuje <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metodę w celu <xref:System.Numerics.BigInteger> porównania wartości z oryginalną wartością całkowitą <xref:System.Numerics.BigInteger> , która została przeniesiona do konstruktora. W miarę wyświetlania danych wyjściowych wartości są równe w każdym przypadku.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określony <see cref="T:System.Numerics.BigInteger" /> obiekt mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli ten <see cref="T:System.Numerics.BigInteger" /> obiekt i <paramref name="other" /> ma tę <see langword="false" />samą wartość; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje <xref:System.IEquatable%601> interfejs i wykonuje nieco lepsze niż <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , ponieważ nie musi on <xref:System.Numerics.BigInteger> konwertować `other` parametru do obiektu.  
  
 Aby określić relację między dwoma <xref:System.Numerics.BigInteger> obiektami zamiast tylko do testowania równości, <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład porównuje przybliżoną odległość kilku gwiazdek od uziemienia z odległością Epsilon Wskazywan od ziemi, aby określić, czy są równe. W przykładzie zastosowano każde Przeciążenie <xref:System.Numerics.BigInteger.Equals%2A> metody w celu przetestowania pod kątem równości.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określony obiekt mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli argument jest obiekt, a jego wartość jest równa wartości bieżącego <see cref="T:System.Numerics.BigInteger" /> wystąpienia; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Numerics.BigInteger" /> <paramref name="obj" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli argument nie jest wartością, metoda zwraca `false`. <xref:System.Numerics.BigInteger> `obj` Metoda zwraca `true` tylko wtedy, `obj` gdy jest <xref:System.Numerics.BigInteger> wystąpieniem, którego wartość jest równa bieżącemu wystąpieniu.  
  
 Aby określić relację między dwoma obiektami zamiast tylko do testowania równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano <xref:System.Object> równoległe i <xref:System.Numerics.BigInteger> tablice. Każdy element jednej tablicy ma taką samą wartość jak odpowiadający element drugiej tablicy. Ponieważ dane wyjściowe z przykładu pokazują, wystąpienie w <xref:System.Numerics.BigInteger> tablicy jest uznawane za równe wystąpieniu <xref:System.Object> w tablicy tylko wtedy, <xref:System.Numerics.BigInteger> gdy jest to i ich wartości są równe.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">64-bitowa liczba całkowita bez znaku do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i niepodpisane 64-bitowe liczby całkowite mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie i niepodpisane 64-bitowe liczby całkowite mają tę samą wartość; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić relację między dwoma obiektami zamiast tylko do testowania równości, wywołaj <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 Poniższy przykład porównuje przybliżoną odległość kilku gwiazdek od uziemienia z odległością Epsilon Wskazywan od ziemi, aby określić, czy są równe. W przykładzie zastosowano każde Przeciążenie <xref:System.Numerics.BigInteger.Equals%2A> metody w celu przetestowania pod kątem równości.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned"><see langword="true" />Aby użyć kodowania bez znaku; w przeciwnym razie. <see langword="false" /></param>
        <summary>Pobiera liczbę bajtów, które będą wyprowadzane przez <see cref="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" /> i. <see cref="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" /></summary>
        <returns>Liczba bajtów.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Znajduje największy wspólny dzielnik dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Największy wspólny dzielnik <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Największy wspólny dzielnik to największą liczbę, w której można podzielić dwie <xref:System.Numerics.BigInteger> wartości bez zwracania reszty.  
  
 Jeśli parametry `right` i są liczbami niezerowymi, Metoda zawsze zwraca co najmniej wartość 1, ponieważ wszystkie cyfry mogą być podzielone przez 1. `left` Jeśli oba parametry mają wartość zero, metoda zwraca bezwzględną wartość parametru niezerowego. Jeśli obie wartości są równe zero, metoda zwraca wartość zero.  
  
> [!NOTE]
>  Obliczanie największego wspólnego dzielnika bardzo dużych wartości `left` i `right` może być bardzo czasochłonną operacją.  
  
 Wartość zwracana przez <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metodę jest zawsze dodatnia, niezależnie od znaku `left` i `right` .  
  
   
  
## Examples  
 Poniższy przykład ilustruje wywołanie <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metody i niezbędną obsługę wyjątków w celu zapewnienia użytecznych informacji na <xref:System.ArgumentOutOfRangeException>temat. Wynik wskazuje, że największy wspólny dzielnik tych dwóch liczb wynosi 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą.</summary>
        <value><see langword="true" />Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu jest liczbą parzystą, <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wygodną funkcją, która wskazuje, <xref:System.Numerics.BigInteger> czy wartość jest równo podzielna przez dwa. Jest to równoważne z następującym wyrażeniem:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu to <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, właściwość zwraca `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu to. <see cref="P:System.Numerics.BigInteger.One" /></summary>
        <value><see langword="true" />Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu to <see cref="P:System.Numerics.BigInteger.One" />; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia znacznie lepszą wydajność niż inne porównania z jednym, np `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu jest potęgą liczby dwa.</summary>
        <value><see langword="true" />Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu jest potęgą liczby dwa; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa, czy <xref:System.Numerics.BigInteger> wartość ma ustawiony jeden bit inny niż zero. Oznacza to, że zwraca `true` , jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu wynosi 1 (to znaczy, 2<sup>0</sup>) lub większą moc dwóch. Zwraca `false` , jeśli wartość bieżącego <xref:System.Numerics.BigInteger> obiektu wynosi 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu to. <see cref="P:System.Numerics.BigInteger.Zero" /></summary>
        <value><see langword="true" />Jeśli wartość <see cref="T:System.Numerics.BigInteger" /> obiektu to <see cref="P:System.Numerics.BigInteger.Zero" />; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia znacznie lepszą wydajność niż `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość logarytmu określonej liczby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której LOGARYTM ma zostać znaleziony.</param>
        <summary>Zwraca logarytm naturalny (podstawowy <see langword="e" />) podanej liczby.</summary>
        <returns>Logarytm naturalny (podstawowy <see langword="e" />) ,jakpokazanowtabeliwsekcjiuwagi.<paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr jest określony jako numer podstawowy 10.  
  
 Dokładna wartość zwracana przez tę metodę zależy od znaku `value`, jak pokazano w poniższej tabeli.  
  
|`value` Znak parametru|Wartość zwracana|  
|-------------------------------|------------------|  
|Dodatnie|Logarytm naturalny z `value`; to jest, LN `value`lub log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Ujemne|<xref:System.Double.NaN>.|  
  
 Aby obliczyć logarytm <xref:System.Numerics.BigInteger> dziesiętny wartości, <xref:System.Numerics.BigInteger.Log10%2A> Wywołaj metodę. Aby obliczyć logarytm liczby w innej bazie, wywołaj <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> metodę.  
  
 Pierwiastek kwadratowy liczby można znaleźć, wywołując <xref:System.Numerics.BigInteger.Log%2A> metodę wraz <xref:System.Math.Exp%2A?displayProperty=nameWithType> z metodą. Zwróć uwagę, że wynik <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> jest większy niż. <xref:System.Double.MaxValue?displayProperty=nameWithType> Poniższy przykład oblicza pierwiastek kwadratowy każdego elementu w tablicy <xref:System.Numerics.BigInteger> wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Ta metoda odpowiada <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Naturalny dziennik <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której LOGARYTM ma zostać znaleziony.</param>
        <param name="baseValue">Podstawa logarytmu.</param>
        <summary>Zwraca logarytm o podanej liczbie w określonej bazie.</summary>
        <returns>LOGARYTM podstawowy <paramref name="baseValue" />,jakpokazanow tabeliwsekcjiuwagi.<paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `value` i`baseValue` są określone jako liczby podstawowe 10.  
  
 Dokładna wartość zwracana metody zależy od znaku `value` i od znaku i `baseValue`wartości, jak pokazano w poniższej tabeli.  
  
|`value`konstruktora|`baseValue`konstruktora|Wartość zwracana|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1)-lub-(`baseValue` > 1)|logbaseValue(`value`)|  
|`value` < 0|(dowolna wartość)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(dowolna wartość)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Aby obliczyć logarytm <xref:System.Numerics.BigInteger> dziesiętny wartości, <xref:System.Numerics.BigInteger.Log10%2A> Wywołaj metodę. Aby obliczyć logarytm naturalny liczby, wywołaj <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> metodę.  
  
 Ta metoda odpowiada <xref:System.Math.Log%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dziennik <paramref name="value" /> jest poza zakresem <see cref="T:System.Double" /> typu danych.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, której LOGARYTM ma zostać znaleziony.</param>
        <summary>Zwraca logarytm dziesiętny z podanej liczby.</summary>
        <returns>Logarytm dziesiętny z <paramref name="value" />, jak pokazano w tabeli w sekcji uwagi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr jest określony jako numer podstawowy 10.  
  
 Dokładna wartość zwracana metody zależy od znaku `value`, jak pokazano w poniższej tabeli.  
  
|Wartość parametru wartości|Wartość zwracana|  
|-----------------------------|------------------|  
|Dodatnie|Log `value`Base 10; czyli log10 —`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Ujemne|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Aby obliczyć logarytm <xref:System.Numerics.BigInteger> naturalny wartości, <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Wywołaj metodę. Aby obliczyć logarytm liczby w innej bazie, wywołaj <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> metodę.  
  
 Ta metoda odpowiada <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dziennik <paramref name="value" /> Base 10 nie należy do zakresu <see cref="T:System.Double" /> typu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca większą liczbę dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Parametr <paramref name="left" /> lub<paramref name="right" /> , w zależności od tego, który jest większy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odpowiada <xref:System.Math.Max%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.BigInteger.Max%2A> metodę, aby wybrać największą liczbę w <xref:System.Numerics.BigInteger> tablicy wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca mniejsze z dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Parametr <paramref name="left" /> lub<paramref name="right" /> , w zależności od tego, który jest mniejszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odpowiada <xref:System.Math.Min%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.BigInteger.Min%2A> metodę w celu wybrania najmniejszej liczby w <xref:System.Numerics.BigInteger> tablicy wartości.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą liczbę ujemną (-1).</summary>
        <value>Liczba całkowita, której wartość jest ujemna (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość służy do <xref:System.Numerics.BigInteger> porównywania wartości z-1 lub do <xref:System.Numerics.BigInteger> przypisywania-1 do obiektu. <xref:System.Numerics.BigInteger.MinusOne%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, która ma zostać podniesiona do <paramref name="exponent" /> potęgi.</param>
        <param name="exponent">Wykładnik do podniesienia <paramref name="value" /> przez.</param>
        <param name="modulus">Liczba <paramref name="value" /> podniesioną <paramref name="exponent" /> do potęgi.</param>
        <summary>Wykonuje dzielenie modulo na liczbę podniesioną do potęgi innej liczby.</summary>
        <returns>Resztę po <paramref name="value" />podzieleniu wykładnika przez. <sup></sup> <paramref name="modulus" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A> Metoda szacuje następujące wyrażenie:  
  
 (baseValue ^ wykładnik) Mod — moduł  
  
 Aby wykonać potęgowanie <xref:System.Numerics.BigInteger> wartości bez dzielenia modulo, <xref:System.Numerics.BigInteger.Pow%2A> Użyj metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia prostą ilustrację wywołania <xref:System.Numerics.BigInteger.ModPow%2A> metody.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" />ma wartość zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" />jest wartością ujemną.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba do pomnożenia.</param>
        <param name="right">Druga liczba do pomnożenia.</param>
        <summary>Zwraca iloczyn dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A> Metoda jest implementowana dla języków, które nie obsługują przeciążania operatora. Zachowanie jest takie samo jak mnożenie przy użyciu operatora mnożenia. Ponadto <xref:System.Numerics.BigInteger.Multiply%2A> Metoda jest użytecznym zamiennikiem dla operatora mnożenia podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przez przypisanie jej iloczynu wyników mnożenia, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 W razie potrzeby ta metoda automatycznie wykonuje niejawną konwersję innych typów <xref:System.Numerics.BigInteger> całkowitych na obiekty. Jest to zilustrowane w przykładzie w następnej sekcji, gdzie <xref:System.Numerics.BigInteger.Multiply%2A> Metoda jest przenoszona dwie <xref:System.Int64> wartości.  
  
   
  
## Examples  
 Poniższy przykład próbuje wykonać mnożenie z dwoma długimi liczbami całkowitymi. Ponieważ wynik przekracza zakres długiej liczby całkowitej, <xref:System.OverflowException> jest zgłaszany, <xref:System.Numerics.BigInteger.Multiply%2A> a metoda jest wywoływana w celu obsłużenia mnożenia. Należy pamiętać C# , że wymaga użycia `checked` słowa kluczowego (jak w tym `/checked+` przykładzie) lub opcji kompilatora, aby upewnić się, że wyjątek jest zgłaszany w przepełnieniu liczbowym.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Negacja określonej <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik <paramref name="value" /> parametru pomnożony przez wartość ujemną (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negacja uzyskuje dodatek odwrotny do liczby. Dodatek odwrotny do liczby jest liczbą, która produkuje wartość zero, gdy zostanie ona dodana do pierwotnej liczby.  
  
 <xref:System.Numerics.BigInteger.Negate%2A> Metoda jest implementowana dla języków, które nie obsługują niestandardowych operatorów. Zachowanie jest takie samo jak Negacja przy użyciu jednoargumentowego operatora negacji. Ponadto <xref:System.Numerics.BigInteger.Negate%2A> Metoda jest użytecznym zamiennikiem operatora negacji podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje trzy sposoby Negate wartości <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą liczbę (1).</summary>
        <value>Obiekt, którego wartością jest jeden (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest zwykle używana do <xref:System.Numerics.BigInteger> porównywania wartości z 1 lub <xref:System.Numerics.BigInteger> do przypisywania 1 do obiektu. <xref:System.Numerics.BigInteger.One%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje wartości dwóch określonych <see cref="T:System.Numerics.BigInteger" /> obiektów.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację dodawania dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Addition%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Add%2A> metodę zamiast.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje operację bitową <see langword="And" /> dla dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik operacji bitowej <see langword="And" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje bitowe `And` dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Operacja bitowa `And` ustawia bit wynikowy tylko wtedy, gdy odpowiednie bity w `left` i `right` są również ustawione, jak pokazano w poniższej tabeli.  
  
|Bit in`left`|Bit in`right`|Bit w wyniku|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Metoda umożliwia wykonywanie następujących czynności:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Metoda wykonuje operacje bitowe `And` na dwóch <xref:System.Numerics.BigInteger> wartościach tak, jakby znajdowały się one w reprezentacji uzupełniającej z rozszerzeniem. <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje operację bitową <see langword="Or" /> dla dwóch <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Wynik operacji bitowej <see langword="Or" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje bitowe `Or` dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Operacja bitowa `Or` ustawia bit wynikowy tylko wtedy, gdy lub obie odpowiednie bity w `left` i `right` są ustawione, jak pokazano w poniższej tabeli.  
  
|Bit in`left`|Bit in`right`|Bit w wyniku|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Metoda umożliwia wykonywanie następujących czynności:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Metoda wykonuje operacje bitowe `Or` na dwóch <xref:System.Numerics.BigInteger> wartościach tak, jakby znajdowały się one w reprezentacji uzupełniającej z rozszerzeniem. <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zmniejszenia.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> Zmniejsza wartość o 1.</summary>
        <returns>Wartość <paramref name="value" /> parametru zmniejszana przez 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację zmniejszania <xref:System.Numerics.BigInteger>wartości. <xref:System.Numerics.BigInteger.op_Decrement%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Subtract%2A> metodę zamiast. Przykład:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne <xref:System.Numerics.BigInteger.op_Decrement%2A> , operator tworzy nowy <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger> obiekt, którego wartość jest mniejsza od obiektu reprezentowanego przez `value`. Oznacza to, że powtarzające <xref:System.Numerics.BigInteger.op_Decrement%2A> się wywołania mogą być kosztowne.  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość, która ma zostać podzielona.</param>
        <param name="divisor">Wartość do podziału przez.</param>
        <summary>Dzieli określoną <see cref="T:System.Numerics.BigInteger" /> wartość przez inną określoną <see cref="T:System.Numerics.BigInteger" /> wartość przy użyciu dzielenia liczb całkowitych.</summary>
        <returns>Całkowity wynik dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację dzielenia <xref:System.Numerics.BigInteger>wartości. <xref:System.Numerics.BigInteger.op_Division%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.BigInteger.Divide%2A> metodę zamiast.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.BigInteger> wartości. Następnie używa każdego elementu jako ilorazu w operacji dzielenia, która używa <xref:System.Numerics.BigInteger.Divide%2A> metody, operatora dzielenia (/) <xref:System.Numerics.BigInteger.DivRem%2A> i metody.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />ma wartość 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy podpisana wartość długa Long i <see cref="T:System.Numerics.BigInteger" /> wartość są równe.</summary>
        <returns><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację porównywania równości dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia.  
  
 Jeśli `left` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i ze znakową wartością Long integer są równe.</summary>
        <returns><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację porównywania równości dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia.  
  
 Jeśli `right` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartości dwóch <see cref="T:System.Numerics.BigInteger" /> obiektów są równe.</summary>
        <returns><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora równości dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodę wystąpienia.  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i niepodpisana wartość Long integer są równe.</summary>
        <returns><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację porównywania równości dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodę wystąpienia.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy wartość długa Long integer i <see cref="T:System.Numerics.BigInteger" /> wartość są równe.</summary>
        <returns><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację porównywania równości dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodę wystąpienia.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość.</param>
        <param name="right">Druga wartość.</param>
        <summary>Wykonuje bitową operację <see langword="Or" /> wykluczającą (<see langword="XOr" />) dla <see cref="T:System.Numerics.BigInteger" /> dwóch wartości.</summary>
        <returns>Wynik operacji bitowej <see langword="Or" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynikiem operacji na wyłączeniu `Or` bitowym jest to `true` , czy wartości dwóch bitów są różne; w przeciwnym razie jest to `false`. W poniższej tabeli przedstawiono operację wyłączną `Or` .  
  
|Bit x w`left`|Bit x w`right`|Wartość zwracana|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Metoda umożliwia wykonywanie następujących czynności:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Metoda wykonuje bitową operację wykluczania `Or` na <xref:System.Numerics.BigInteger> dwie wartości tak, jakby znajdowały się one w reprezentacji uzupełniającej z rozszerzeniem Virtual Sign. <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje jawną konwersję między <see cref="T:System.Numerics.BigInteger" /> obiektem a innym typem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Decimal" /> obiektu <see cref="T:System.Numerics.BigInteger" /> na wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda część `value` ułamkowa parametru jest obcinana przed konwersją.

 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Ponieważ konwersja z <xref:System.Decimal> do programu <xref:System.Numerics.BigInteger> może dotyczyć obcinania części `value`ułamkowej, kompilatory języka nie wykonują tej konwersji automatycznie. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.   

 W przypadku języków, które nie obsługują operatorów niestandardowych, Metoda alternatywna <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>to.


## Examples
 Poniższy przykład konwertuje poszczególne elementy w tablicy <xref:System.Decimal> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdej konwersji. Należy zauważyć, że każda część <xref:System.Decimal> ułamkowa wartości zostanie obcięta podczas konwersji.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Double" /> wartości <see cref="T:System.Numerics.BigInteger" /> do wartości.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda część `value` ułamkowa parametru jest obcinana przed konwersją.

 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Ponieważ konwersja z <xref:System.Double> do programu <xref:System.Numerics.BigInteger> może dotyczyć obcinania części `value`ułamkowej, kompilatory języka nie wykonują tej konwersji automatycznie. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.

 W przypadku języków, które nie obsługują operatorów niestandardowych, Metoda alternatywna <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>to.


## Examples
 Poniższy przykład konwertuje poszczególne elementy w tablicy <xref:System.Double> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdej konwersji. Należy zauważyć, że każda część <xref:System.Double> ułamkowa wartości zostanie obcięta podczas konwersji.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, lub <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Byte" />.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość bajtu bez znaku.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CByte` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.   

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.Byte> spoza zakresu typu danych. Wartość wynikowa <xref:System.Byte> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Byte> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.Byte> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsze niż <see cref="F:System.Byte.MinValue" /> lub większe niż <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Decimal" />.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu <see cref="T:System.Decimal" /> na wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CDec` na przykład Visual Basic).   

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.Decimal> spoza zakresu typu danych. 

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Decimal> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.Decimal> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsze niż <see cref="F:System.Decimal.MinValue" /> lub większe niż <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Double" />.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu <see cref="T:System.Double" /> na wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CDbl` na przykład Visual Basic).   

 Ponieważ wartość może być spoza zakresu <xref:System.Double> typu danych, ta operacja jest konwersją wąskią. <xref:System.Numerics.BigInteger> Jeśli konwersja nie powiedzie się, nie generuje <xref:System.OverflowException>. Zamiast tego, jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Double.MinValue?displayProperty=nameWithType>, obliczona <xref:System.Double> wartość to <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Jeśli wartość jest większa niż <xref:System.Double.MaxValue?displayProperty=nameWithType>, obliczona <xref:System.Double> wartość to <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Numerics.BigInteger>
 
 Konwersja a <xref:System.Numerics.BigInteger> do a <xref:System.Double> może pociągnąć za utratę precyzji. W niektórych przypadkach utrata dokładności może spowodować pomyślne wykonanie operacji rzutowania lub konwersji nawet wtedy, <xref:System.Numerics.BigInteger> gdy wartość znajduje się poza zakresem <xref:System.Double> typu danych. Poniższy przykład stanowi ilustrację. Przypisuje wartość <xref:System.Double> maksymalną do dwóch <xref:System.Numerics.BigInteger> zmiennych, zwiększa jedną <xref:System.Numerics.BigInteger> zmienną przez 9.999 e291 i sprawdza dwie zmienne pod kątem równości. Zgodnie z oczekiwaniami wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody pokazuje, że są one nierówne. Jednak konwersja większej <xref:System.Numerics.BigInteger> wartości z powrotem <xref:System.Double> na <xref:System.Numerics.BigInteger> pomyślne, chociaż wartość przekracza <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Double> wartości.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 16-bitową liczbę całkowitą ze znakiem.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CShort` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.   

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.Int16> spoza zakresu typu danych. Wartość wynikowa <xref:System.Int16> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Int16> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.Int16> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.Int16.MinValue" /> lub większa niż. <see cref="F:System.Int16.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 32-bitową liczbę całkowitą ze znakiem.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na 32-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CInt` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.   

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.Int32> spoza zakresu typu danych. Wartość wynikowa <xref:System.Int16> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Int32> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.Int32> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.Int32.MinValue" /> lub większa niż. <see cref="F:System.Int32.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 64-bitową liczbę całkowitą ze znakiem.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na 64-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CLng` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.  

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.Int64> spoza zakresu typu danych. 

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Int64> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.Int64> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.Int64.MinValue" /> lub większa niż. <see cref="F:System.Int64.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać przekonwertowana na podpisaną wartość 8-bitową.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu do podpisanej wartości 8-bitowej.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="T:System.Int16" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CSByte` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.  

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.SByte> spoza zakresu typu danych. Wartość wynikowa <xref:System.SByte> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.SByte> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.SByte> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.SByte.MinValue" /> lub większa niż. <see cref="F:System.SByte.MaxValue" /></exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na wartość zmiennoprzecinkową o pojedynczej precyzji.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu do wartości zmiennoprzecinkowej o pojedynczej precyzji.</summary>
        <returns>Obiekt, który zawiera najbliższą możliwą reprezentację <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one powodować utratę danych lub utratę precyzji. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CSng` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.    

 Ponieważ wartość może być spoza zakresu <xref:System.Single> typu danych, ta operacja jest konwersją wąskią. <xref:System.Numerics.BigInteger> Jeśli konwersja nie powiedzie się, nie generuje <xref:System.OverflowException>. Zamiast tego, jeśli <xref:System.Numerics.BigInteger> wartość jest mniejsza niż <xref:System.Single.MinValue?displayProperty=nameWithType>, obliczona <xref:System.Single> wartość to <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Jeśli wartość jest większa niż <xref:System.Single.MaxValue?displayProperty=nameWithType>, obliczona <xref:System.Single> wartość to <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Numerics.BigInteger>

 Konwersja a <xref:System.Numerics.BigInteger> do a <xref:System.Single> może pociągnąć za utratę precyzji. W niektórych przypadkach utrata dokładności może spowodować pomyślne wykonanie operacji rzutowania lub konwersji nawet wtedy, <xref:System.Numerics.BigInteger> gdy wartość znajduje się poza zakresem <xref:System.Single> typu danych. Poniższy przykład stanowi ilustrację. Przypisuje wartość <xref:System.Single> maksymalną do dwóch <xref:System.Numerics.BigInteger> zmiennych, zwiększa jedną <xref:System.Numerics.BigInteger> zmienną przez 9.999 e291 i sprawdza dwie zmienne pod kątem równości. Zgodnie z oczekiwaniami wywołanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody pokazuje, że są one nierówne. Jednak konwersja większej <xref:System.Numerics.BigInteger> wartości z powrotem <xref:System.Single> na <xref:System.Numerics.BigInteger> pomyślne, chociaż wartość przekracza <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.Single> wartości.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 16-bitową liczbę całkowitą bez znaku.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na 16-bitową liczbę całkowitą bez znaku.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="T:System.Int32" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CUShort` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.    

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.UInt16> spoza zakresu typu danych. Wartość wynikowa <xref:System.UInt16> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.UInt16> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.UInt16> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.UInt16.MinValue" /> lub większa niż. <see cref="F:System.UInt16.MaxValue" /></exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 32-bitową liczbę całkowitą bez znaku.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 32-bitową liczbę całkowitą bez znaku.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="T:System.Int64" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CUInt` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.    

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.UInt32> spoza zakresu typu danych. Wartość wynikowa <xref:System.UInt32> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.UInt32> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.UInt32> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.UInt32.MinValue" /> lub większa niż. <see cref="F:System.UInt32.MaxValue" /></exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na 64-bitową liczbę całkowitą bez znaku.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> obiektu na wartość 64-bitową liczbę całkowitą bez znaku.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="T:System.Double" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` `CULng` na przykład Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.    

 Ponieważ ta operacja definiuje zawężanie konwersji, może zgłosić <xref:System.OverflowException> w czasie wykonywania, <xref:System.Numerics.BigInteger> Jeśli wartość jest <xref:System.UInt64> spoza zakresu typu danych. Wartość wynikowa <xref:System.UInt64> nie jest tracona w przypadku pomyślnego przeprowadzenia konwersji.

## Examples
 Poniższy przykład ilustruje konwersję <xref:System.Numerics.BigInteger> do <xref:System.UInt64> wartości. Obsługuje <xref:System.OverflowException> ona również wygenerowane, <xref:System.Numerics.BigInteger> ponieważ wartość jest <xref:System.UInt64> spoza zakresu typu danych.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />jest mniejsza niż <see cref="F:System.UInt64.MinValue" /> lub większa niż. <see cref="F:System.UInt64.MaxValue" /></exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Single" /> wartości <see cref="T:System.Numerics.BigInteger" /> do wartości.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda część `value` ułamkowa parametru jest obcinana przed konwersją.
 
 Przeciążenia <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metody definiują typy, do których lub z <xref:System.Numerics.BigInteger> których można dokonać konwersji obiektu. Ponieważ konwersja z <xref:System.Single> do programu <xref:System.Numerics.BigInteger> może dotyczyć obcinania części `value`ułamkowej, kompilatory języka nie wykonują tej konwersji automatycznie. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.

 W przypadku języków, które nie obsługują operatorów niestandardowych, Metoda alternatywna <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>to.


## Examples
 Poniższy przykład konwertuje poszczególne elementy w tablicy <xref:System.Single> wartości do <xref:System.Numerics.BigInteger> obiektów, a następnie wyświetla wynik każdej konwersji. Należy zauważyć, że każda część <xref:System.Single> ułamkowa wartości zostanie obcięta podczas konwersji.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, lub <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest większa niż inna określona wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita ze znakiem jest większa niż <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego niż dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę wystąpienia. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Jeśli `left` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowa liczba całkowita ze znakiem.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego niż dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Jeśli `right` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż inna <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego niż dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowa liczba całkowita bez znaku.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego niż dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa niż 64-bitowa liczba całkowita bez znaku.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora większego niż dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest większa lub równa innej określonej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita ze znakiem jest większa lub równa <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora "większe niż lub równe" dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Jeśli `left` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa 64-bitowej podpisanej wartości całkowitej.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora "większe niż lub równe" dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Jeśli `right` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa innej <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora "większe niż lub równe" dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest większa lub równa wartości 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora "większe niż lub równe" dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita bez znaku jest większa lub równa <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora "większe niż lub równe" dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niejawną konwersję <see cref="T:System.Numerics.BigInteger" /> między obiektem a innym typem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję bajtu bez znaku <see cref="T:System.Numerics.BigInteger" /> na wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda część `value` ułamkowa parametru jest obcinana przed konwersją.

 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>alternatywna to.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Byte> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję 16-bitowej liczby całkowitej ze znakiem na <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>alternatywna to.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Int16> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję podpisanej 32-bitowej liczby całkowitej <see cref="T:System.Numerics.BigInteger" /> na wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>alternatywna to.  

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Int32> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję podpisanej 64-bitowej liczby całkowitej <see cref="T:System.Numerics.BigInteger" /> na wartość.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>alternatywna to.   
 
 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Int64> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję 8-bitowej podpisanej liczby całkowitej <see cref="T:System.Numerics.BigInteger" /> na wartość.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>alternatywna to.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.SByte> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję 16-bitowej liczby całkowitej bez znaku <see cref="T:System.Numerics.BigInteger" /> na wartość.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>alternatywna to.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.UInt16> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję 32-bitowej liczby całkowitej bez znaku <see cref="T:System.Numerics.BigInteger" /> na wartość.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>alternatywna to.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.UInt32> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiuje niejawną konwersję 64-bitowej liczby całkowitej bez znaku <see cref="T:System.Numerics.BigInteger" /> na wartość.  
  
Ten interfejs API nie jest zgodny ze specyfikacją CLS. Zgodna alternatywa to <see cref="T:System.Double" />.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku języków, które nie obsługują operatorów niejawnych, Metoda <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>alternatywna to.   

 Przeciążenia <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metody definiują typy, do których kompilator może automatycznie <xref:System.Numerics.BigInteger> skonwertować wartość bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>. To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.UInt64> wartości <xref:System.Numerics.BigInteger> do wartości, jak pokazano w poniższym przykładzie.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zwiększenia.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> Zwiększa wartość o 1.</summary>
        <returns>Wartość <paramref name="value" /> parametru zwiększana o 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację zwiększania <xref:System.Numerics.BigInteger>wartości. <xref:System.Numerics.BigInteger.op_Increment%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Niektóre języki (takie jak Visual Basic), które nie mają operatora przyrostu lub nie obsługują przeciążania operatora, mogą <xref:System.Numerics.BigInteger.op_Increment%2A> wywołać metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Ponieważ <xref:System.Numerics.BigInteger> obiekty są niezmienne <xref:System.Numerics.BigInteger.op_Increment%2A> , operator tworzy nowy <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger> obiekt, którego wartość jest większa niż obiekt reprezentowany przez `value`. W związku z tym powtarzające się <xref:System.Numerics.BigInteger.op_Increment%2A> wywołania mogą być kosztowne.  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie wartości liczbowe nie są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita ze znakiem i <see cref="T:System.Numerics.BigInteger" /> wartość nie jest równa.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora nierówności dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Inequality%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywoływanie metody <xref:System.Numerics.BigInteger> instance,którawskazujerelacjęmiędzyaizeznakową<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> wartością Long Integer.  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metody Instance i odwracanie jej wartości.  
  
 Jeśli `left` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i 64-bitowa liczba całkowita ze znakiem nie jest równa.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora nierówności dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Inequality%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywołanie metody, która wskazuje relację <xref:System.Numerics.BigInteger> między a i ze znakową wartością Long Integer. <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metody i odwracanie jej wartości.  
  
 Jeśli `right` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.Numerics.BigInteger" /> obiekty mają różne wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora nierówności dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Inequality%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywołanie metody, która wskazuje relację między dwoma <xref:System.Numerics.BigInteger> obiektami. <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metody i odwracanie jej wartości.  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość i 64-bitowa liczba całkowita bez znaku nie jest równa.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora nierówności dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Inequality%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywołanie metody, która wskazuje związek <xref:System.Numerics.BigInteger> między wartością a i niepustą liczbą całkowitą. <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metody i odwracanie jej wartości.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita bez znaku i <see cref="T:System.Numerics.BigInteger" /> wartość nie są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora nierówności dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Inequality%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przy użyciu jednej z następujących metod:  
  
-   Wywołanie metody, która wskazuje związek <xref:System.Numerics.BigInteger> między wartością a i niepustą liczbą całkowitą. <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>  
  
-   Wywoływanie <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metody i odwracanie jej wartości.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której bity mają zostać przesunięte.</param>
        <param name="shift">Liczba bitów, które mają zostać <paramref name="value" /> przesunięte w lewo.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> Przenosi wartość o określoną liczbę bitów z lewej strony.</summary>
        <returns>Wartość, która została przeniesiona w lewo o określoną liczbę bitów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje bitowego operatora przesunięcia w lewo dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_LeftShift%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  W przeciwieństwie do binarnej operacji przesunięcia w lewo z liczbami <xref:System.Numerics.BigInteger.op_LeftShift%2A> pierwotnymi, metoda zachowuje znak oryginalnej <xref:System.Numerics.BigInteger> wartości.  
  
 Języki, które nie obsługują niestandardowych operatorów, mogą wykonywać bitowe operacje przesunięcia w lewo przez `value` pomnożenie `BigInteger.Pow(2, shift)`przez. Poniższy przykład pokazuje, że wyniki są identyczne z wynikami użycia tego operatora.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest mniejsza od drugiej określonej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita ze znakiem jest mniejsza niż <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację <xref:System.Numerics.BigInteger> operatora mniejszego niż wartość. <xref:System.Numerics.BigInteger.op_LessThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Jeśli `left` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowa liczba całkowita ze znakiem.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację <xref:System.Numerics.BigInteger> operatora mniejszego niż wartość. <xref:System.Numerics.BigInteger.op_LessThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Jeśli `right` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza od innej <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację <xref:System.Numerics.BigInteger> operatora mniejszego niż wartość. <xref:System.Numerics.BigInteger.op_LessThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodę zamiast. Niektóre języki mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż 64-bitowa liczba całkowita bez znaku.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację <xref:System.Numerics.BigInteger> operatora mniejszego niż wartość. <xref:System.Numerics.BigInteger.op_LessThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita bez znaku jest mniejsza niż <see cref="T:System.Numerics.BigInteger" /> wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację <xref:System.Numerics.BigInteger> operatora mniejszego niż wartość. <xref:System.Numerics.BigInteger.op_LessThan%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określona wartość jest mniejsza lub równa innej określonej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita ze znakiem jest mniejsza lub równa <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego lub równego dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Jeśli `left` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równa 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego lub równego dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Jeśli `right` jest<xref:System.Int16>, ,,<xref:System.SByte>, lub <xref:System.Int64> wartość, jest niejawnie konwertowananawartośćpodczaswykonywaniaoperacji.<xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równa innej <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego lub równego dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Compare%2A> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy <see cref="T:System.Numerics.BigInteger" /> wartość jest mniejsza niż lub równa 64-bitowej nieoznaczonej liczby całkowitej.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego lub równego dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy 64-bitowa liczba całkowita bez znaku jest mniejsza lub równa <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora mniejszego lub równego dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodę zamiast. Mogą również wywołać <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodę bezpośrednio, jak pokazano w poniższym przykładzie.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość, która ma zostać podzielona.</param>
        <param name="divisor">Wartość do podziału przez.</param>
        <summary>Zwraca resztę z dzielenia na dwie określone <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Reszta powstała w wyniku dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora modułu dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Modulus%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metodę zamiast.  
  
 Znak wartości zwracanej przez operację modulo zależy od znaku `dividend`: Jeśli `dividend` jest dodatnia, operacja modulo zwraca wynik dodatni; jeśli jest ujemna, operacja modulo zwraca wynik ujemny. Zachowanie operacji modułu z <xref:System.Numerics.BigInteger> wartościami jest takie samo jak w przypadku operacji modulo z innymi typami całkowitymi.  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />ma wartość 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do pomnożenia.</param>
        <param name="right">Druga wartość do pomnożenia.</param>
        <summary>Mnoży dwie określone <see cref="T:System.Numerics.BigInteger" /> wartości.</summary>
        <returns>Produkt <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora mnożenia dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Multiply%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość całkowita.</param>
        <summary>Zwraca <see cref="T:System.Numerics.BigInteger" /> wartość z przesunięcia bitowego z jednej wartości.</summary>
        <returns>Dopełnienie bitowe <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację dla <xref:System.Numerics.BigInteger> operatora dopełnienia bitowego jednego z wartości. <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Operator dopełnienia bitowego, który odwraca każdy bit w wartości liczbowej. Oznacza to, że bity `value` w wartości 0 są ustawione na 1 w wyniku, a bity o wartości 1 są ustawione na 0 w wyniku. <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Metoda umożliwia wykonywanie następujących czynności:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać metodę bezpośrednio, <xref:System.Numerics.BigInteger.op_OnesComplement%2A> aby wykonać operację dopełnienia bitowego. Na przykład:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której bity mają zostać przesunięte.</param>
        <param name="shift">Liczba bitów, które mają zostać <paramref name="value" /> przesunięte w prawo.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> Przesuwa wartość o określoną liczbę bitów w prawo.</summary>
        <returns>Wartość, która została przeniesiona w prawo o określoną liczbę bitów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje działanie operatora przesunięcia bitowego w prawo dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_RightShift%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Języki, które nie obsługują niestandardowych operatorów, mogą wykonywać bitowe operacje przesunięcia w prawo przez dzielenie `value` przez `BigInteger.Pow(2, shift)` i odejmowanie 1 razy `shift` dla wartości ujemnych. Poniższy przykład pokazuje, że wyniki są identyczne z wynikami użycia tego operatora.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Jeśli `shift` jest większa lub równa liczbie bitów w wartości dodatniej <xref:System.Numerics.BigInteger> , wynik operacji przesunięcia w <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>prawo. Jeśli `shift` jest większa niż liczba bitów w wartości ujemnej <xref:System.Numerics.BigInteger> , wynik operacji przesunięcia w <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>prawo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odejmowania (odjemna).</param>
        <param name="right">Wartość do odejmowania (odjemnik).</param>
        <summary>Odejmuje wartość od innej <see cref="T:System.Numerics.BigInteger" />wartości. <see cref="T:System.Numerics.BigInteger" /></summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje operatora odejmowania dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_Subtraction%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metodę zamiast.  
  
 Równoważna Metoda dla tego operatora to <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Wyklucza określoną wartość BigInteger.</summary>
        <returns>Wynik <paramref name="value" /> parametru pomnożony przez wartość ujemną (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operacje jednoargumentowego operatora negacji (lub znaku odwrotnego operatora) dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Operacja generuje wartość, która daje w wyniku 0 (zero), gdy zostanie dodany do pierwotnej liczby. Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.BigInteger.Negate%2A> metodę zamiast.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład ilustruje trzy różne sposoby Negate wartości <xref:System.Numerics.BigInteger> obiektu.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość całkowita.</param>
        <summary>Zwraca wartość <see cref="T:System.Numerics.BigInteger" /> operandu. (Znak operandu jest niezmieniony).</summary>
        <returns>Wartość <paramref name="value" /> operandu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora jednoargumentowego pozytywnego dla <xref:System.Numerics.BigInteger> wartości. <xref:System.Numerics.BigInteger.op_UnaryPlus%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik.</summary>
        <returns>Wartość odpowiadająca liczbie określonej w <paramref name="value" /> parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr powinien być ciągiem reprezentującym liczbę w następującej postaci.  
  
 [*WS*] [*Sign*] *cyfry* [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Prawidłowe znaki znakowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> i bieżącej kultury.|  
|*cyfr*|Sekwencja cyfr od 0 do 9. Wszystkie zera wiodące są ignorowane.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr jest interpretowany przy <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> użyciu stylu. Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `value` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Aby przeanalizować ciąg przy użyciu informacji o formatowaniu określonej kultury, użyj <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metody.  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody do rundy ciągu reprezentacji <xref:System.Numerics.BigInteger> wartości <xref:System.Numerics.BigInteger.ToString%2A> , która była wynikiem przez metodę, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody ze specyfikatorem formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie ciąg reprezentujący <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej znaczące cyfry oryginalnej wartości, a dane mogą zostać utracone podczas <xref:System.Numerics.BigInteger.Parse%2A> korzystania z metody w celu przywrócenia <xref:System.Numerics.BigInteger> wartości.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Numerics.BigInteger.Parse%28System.String%29> metody do tworzenia wystąpienia dwóch <xref:System.Numerics.BigInteger> obiektów. Mnoży każdy obiekt przez inną liczbę, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę w celu określenia relacji między tymi dwiema wartościami.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />nie ma poprawnego formatu.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia, które określają dozwolony format <paramref name="value" />.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik.</summary>
        <returns>Wartość odpowiadająca liczbie określonej w <paramref name="value" /> parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr definiuje elementy stylu (takie jak odstępy, symbol znaku dodatniego lub ujemnego, symbol separatora grupy lub symbol przecinka dziesiętnego), które są dozwolone `value` w parametrze dla operacji analizy. `style` `styles`musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Parametr sprawia, że ta metoda jest przeciążona, gdy `value` zawiera ciąg reprezentujący wartość szesnastkową, gdy system liczbowy (dziesiętny lub szesnastkowy `value` ) reprezentowany przez jest znany tylko w czasie wykonywania, lub gdy `style` chcesz nie zezwalać na biały znak ani symbol znaku `value`w.  
  
 W zależności od wartości `style` `value` , parametr może zawierać następujące elementy:  
  
 [*WS*] [*$*] [*Sign*] [*cyfry*,]*cyfry*[. *fractional_digits*] [E [*Sign*]*exponential_digits*] [*WS*]  
  
 Jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> ,`value` parametr może zawierać następujące elementy:  
  
 [*WS*] *hexdigits* [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak może pojawić się na początku `value` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę i może <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> pojawić się na końcu elementu `value` if `style` zawiera flagę.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> właściwości i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> bieżącej kultury. Symbol waluty bieżącej kultury może pojawić się w `value` , `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Opcjonalny znak. Znak może pojawić `value` się na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `value` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> pojawić się na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `value` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*cyfr*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Sekwencja cyfr od 0 do 9. Dla *fractional_digits*tylko cyfra 0 jest prawidłowa.|  
|*,*|Symbol separatora grupy specyficzny dla kultury. Separator grupy bieżącej kultury może pojawić się w `value` przypadku `style` , <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> gdy zawiera flagę.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol dziesiętny bieżącej kultury może pojawić się w `value` , `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> jeśli zawiera flagę. Aby operacja analizy zakończyła się powodzeniem, tylko cyfra 0 może być wyświetlana jako cyfry ułamkowe. Jeśli *fractional_digits* zawiera dowolną inną cyfrę, <xref:System.FormatException> jest zgłaszany.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `value`|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> elementów członkowskich kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela zawiera informacje o <xref:System.Globalization.NumberStyles> tym, w jaki sposób poszczególne elementy członkowskie wpływają `value`na elementy, które mogą być obecne w.  
  
|`NumberStyles`wartościami|Elementy dozwolone jako `value` uzupełnienie cyfr|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *cyfr* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy dziesiętne (.) i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak "e" lub "E", który oznacza notację wykładniczą oraz *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `value` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na `value`końcu, ** `value`znak na początku i symbol dziesiętny (*.*). `value` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws`, `sign`separator grup (*,*) i punkt dziesiętny (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `value` Jednak nie może reprezentować liczby szesnastkowej.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody do rundy ciągu reprezentacji <xref:System.Numerics.BigInteger> wartości <xref:System.Numerics.BigInteger.ToString%2A> , która była wynikiem przez metodę, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody ze specyfikatorem formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie ciąg reprezentujący <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej znaczące cyfry oryginalnej wartości, a dane mogą zostać utracone podczas <xref:System.Numerics.BigInteger.Parse%2A> korzystania z metody w celu przywrócenia <xref:System.Numerics.BigInteger> wartości.  
  
 W przeciwieństwie do <xref:System.Globalization.NumberStyles> innych wartości, które zezwalają na, ale nie wymagają, obecność określonych elementów stylu w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> wartość stylu oznacza, że poszczególne znaki numeryczne w `value` są zawsze interpretowane jako znaki szesnastkowe. Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f. Jedyne inne flagi, które mogą być połączone z `style` parametrem <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> to <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>i. (Wyliczenie zawiera złożony styl liczb, <xref:System.Globalization.NumberStyles.HexNumber>który obejmuje flagi białych znaków). <xref:System.Globalization.NumberStyles>  
  
> [!NOTE]
>  Jeśli `value` jest to ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym dekoracją ( `0x` np. lub `&h`), który odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> , Metoda interpretuje `value` jako liczbę ujemną przechowywaną przy użyciu reprezentacji uzupełniającej dwóch, jeśli jej pierwsze dwie cyfry `0x80`szesnastkowe są większe lub równe. Innymi słowy metoda interpretuje największą liczbę bitów pierwszego bajtu `value` jako bit znaku. Aby upewnić się, że ciąg szesnastkowy jest poprawnie interpretowany jako liczba dodatnia, pierwsza `value` cyfra w musi mieć wartość zero. Na przykład Metoda interpretuje `0x80` jako wartość ujemną, ale interpretuje `0x0080` albo `0x080` jako wartość dodatnią. Poniższy przykład ilustruje różnicę między ciągami szesnastkowymi, które reprezentują wartości ujemne i dodatnie.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie, który jest zainicjowany dla bieżącej kultury systemowej. `value` Aby określić kulturę, której informacje o formatowaniu są używane dla operacji analizowania, <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Wywołaj Przeciążenie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wywołania <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metody z kilkoma możliwymi wartościami `style` parametru. Ilustruje on sposób interpretowania ciągu jako wartości szesnastkowej i sposób niezezwalania na znaki spacji i znaku podpisywania.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" />zawiera flagę <see cref="F:System.Globalization.NumberStyles.HexNumber" />orwraz z inną wartością. <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />nie jest zgodna ze wzorcem wejściowym określonym przez <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="value" />o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym formacie specyficznym dla kultury na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik.</summary>
        <returns>Wartość odpowiadająca liczbie określonej w <paramref name="value" /> parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr powinien być ciągiem reprezentującym liczbę w następującej postaci:  
  
 [*WS*] [*Sign*] *cyfry* [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Prawidłowe znaki znakowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> obiektu, który jest zwracany przez `provider` metodę obiektu.|  
|*cyfr*|Sekwencja cyfr od 0 do 9. Wszystkie zera wiodące są ignorowane.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr jest interpretowany <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> przy użyciu stylu. Nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych, a także mieć części dziesiętnej.  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody do rundy ciągu reprezentacji <xref:System.Numerics.BigInteger> wartości <xref:System.Numerics.BigInteger.ToString%2A> , która była wynikiem przez metodę, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody ze specyfikatorem formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie ciąg reprezentujący <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej znaczące cyfry oryginalnej wartości, a dane mogą zostać utracone podczas <xref:System.Numerics.BigInteger.Parse%2A> korzystania z metody w celu przywrócenia <xref:System.Numerics.BigInteger> wartości.  
  
 Parametr jest <xref:System.IFormatProvider.GetFormat%2A> implementacją, której metoda zwraca obiekt,którydostarczainformacjeoformatowaniuspecyficznedlakultury.<xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider> `provider` <xref:System.Type> `provider` <xref:System.IFormatProvider.GetFormat%2A> Gdy metoda jest wywoływana, wywołuje metodę parametru<xref:System.Globalization.NumberFormatInfo> i przekazuje ją do obiektu, który reprezentuje typ. <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> Metoda następnie zwraca obiekt, który zawiera informacje `value` o formacie parametru. <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> Istnieją trzy sposoby, aby użyć `provider` parametru w celu dostarczenia niestandardowych informacji o formatowaniu do operacji analizy:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Można przekazać rzeczywisty <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu liczb. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Można przekazać obiekt niestandardowy, który implementuje <xref:System.IFormatProvider>. Metoda tworzy wystąpienia i <xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.NumberFormatInfo> formatowanie `value` jest interpretowane na podstawie obiektu bieżącej kultury.  
  
   
  
## Examples  
 W poniższych przykładach pokazano dwa sposoby definiowania tyldy (~) jako znaku ujemnego na potrzeby <xref:System.Numerics.BigInteger> formatowania wartości. Należy pamiętać, że aby <xref:System.Numerics.BigInteger> wyświetlić wartości w tym samym formacie co oryginalne ciągi, kod musi <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> wywołać metodę i przekazać go do <xref:System.Globalization.NumberFormatInfo> obiektu, który zawiera informacje o formatowaniu.  
  
 Pierwszy przykład definiuje klasę, która implementuje <xref:System.IFormatProvider> i <xref:System.IFormatProvider.GetFormat%2A> używa metody do zwrócenia <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje o formatowaniu.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Następnie można utworzyć wystąpienie obiektuprzyużyciunastępującegokodu:<xref:System.Numerics.BigInteger>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Drugi przykład jest bardziej prosty. Przekazuje <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu `provider` do parametru.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />nie ma poprawnego formatu.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający liczbę, którą należy przekształcić.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia, które określają dozwolony format <paramref name="value" />.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="value" />o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje ciąg reprezentujący liczbę w określonym stylu i formacie specyficznym dla kultury na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik.</summary>
        <returns>Wartość odpowiadająca liczbie określonej w <paramref name="value" /> parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr definiuje elementy stylu (takie jak odstępy, symbol znaku dodatniego lub ujemnego, symbol separatora grupy lub symbol przecinka dziesiętnego), które są dozwolone `value` w parametrze dla operacji analizy. `style` `styles`musi być kombinacją flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. Parametr sprawia, że ta metoda jest przeciążona, gdy `value` zawiera ciąg reprezentujący wartość szesnastkową, gdy system liczbowy (dziesiętny lub szesnastkowy `value` ) reprezentowany przez jest znany tylko w czasie wykonywania, lub gdy `style` chcesz nie zezwalać na biały znak ani symbol znaku `value`w.  
  
 W zależności od wartości `style` `value` , parametr może zawierać następujące elementy:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> ,`value` parametr może zawierać następujące elementy:  
  
 [*WS*] *hexdigits* [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak może pojawić się na początku `value` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę i może <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> pojawić się na końcu elementu `value` if `style` zawiera flagę.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana przez <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> i <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> właściwości kultury wskazanej przez `provider` parametr. Symbol waluty bieżącej kultury może pojawić się w `value` , `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Opcjonalny znak. Znak może pojawić `value` się na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `value` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> pojawić się na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `value` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*cyfr*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Sekwencja cyfr od 0 do 9. Dla *fractional_digits*tylko cyfra 0 jest prawidłowa.|  
|*,*|Symbol separatora grupy specyficzny dla kultury. Symbol `provider` separatora grupy kultury określony przez może pojawić się w `value` if `style` zawiera <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagę.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol separatora dziesiętnego kultury oznaczonej przez `provider` może pojawić `value` się `style` w parametrze if zawiera <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flagę. Aby operacja analizy zakończyła się powodzeniem, tylko cyfra 0 może być wyświetlana jako cyfry ułamkowe. Jeśli *fractional_digits* zawiera dowolną inną cyfrę, <xref:System.FormatException> jest zgłaszany.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `value`|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi (który odpowiada <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stylowi) zawsze jest analizowany pomyślnie. Większość pozostałych <xref:System.Globalization.NumberStyles> elementów członkowskich kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w ciągu wejściowym. Poniższa tabela zawiera informacje o <xref:System.Globalization.NumberStyles> tym, w jaki sposób poszczególne elementy członkowskie wpływają `value`na elementy, które mogą być obecne w.  
  
|Wartość wyliczenia NumberStyles|Dodatkowe (poza cyframi) elementy dozwolone w wartości|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko elementy *cyfr* .|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy dziesiętne (.) i *cyfry ułamkowe* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak „e” lub znak „E”, co oznacza zapis wykładniczy. wraz z *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element określający walutę ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `value` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na końcu `value`, ** `value`znak na początku i symbol dziesiętny (.). `value` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy `ws` ,`sign`separator grup (,) i punkt dziesiętny (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `value` Jednak nie może reprezentować liczby szesnastkowej.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.Parse%2A> metody do rundy ciągu reprezentacji <xref:System.Numerics.BigInteger> wartości <xref:System.Numerics.BigInteger.ToString%2A> , która była wynikiem przez metodę, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody ze specyfikatorem formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie ciąg reprezentujący <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej znaczące cyfry oryginalnej wartości, a dane mogą zostać utracone podczas <xref:System.Numerics.BigInteger.Parse%2A> korzystania z metody w celu przywrócenia <xref:System.Numerics.BigInteger> wartości.  
  
 W przeciwieństwie do <xref:System.Globalization.NumberStyles> innych wartości, które umożliwiają, ale nie wymagają obecności określonych elementów stylu w `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> wartość stylu oznacza, że poszczególne znaki numeryczne w `value` są zawsze interpretowane jako znaki szesnastkowe. Prawidłowe znaki szesnastkowe to 0-9, A-F i a-f. Jedyne inne flagi, które mogą być połączone z `style` parametrem <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> to <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>i. (Wyliczenie zawiera złożony styl liczb, <xref:System.Globalization.NumberStyles.HexNumber>który obejmuje flagi białych znaków). <xref:System.Globalization.NumberStyles>  
  
> [!NOTE]
>  Jeśli `value` jest to ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym dekoracją ( `0x` np. lub `&h`), który odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> , Metoda interpretuje `value` jako liczbę ujemną przechowywaną przy użyciu reprezentacji uzupełniającej dwóch, jeśli jej pierwsze dwie cyfry `0x80`szesnastkowe są większe lub równe. Innymi słowy metoda interpretuje największą liczbę bitów pierwszego bajtu `value` jako bit znaku. Aby upewnić się, że ciąg szesnastkowy jest poprawnie interpretowany jako liczba dodatnia, pierwsza `value` cyfra w musi mieć wartość zero. Na przykład Metoda interpretuje `0x80` jako wartość ujemną, ale interpretuje `0x0080` albo `0x080` jako wartość dodatnią. Poniższy przykład ilustruje różnicę między ciągami szesnastkowymi, które reprezentują wartości ujemne i dodatnie.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda `value`zwraca obiekt, który zawiera informacje specyficzne dla kultury o formacie. <xref:System.Globalization.NumberFormatInfo> `provider` Zwykle może to być jeden z następujących:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę, która zawiera informacje o formatowaniu liczb. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb.  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który zawiera informacje o formatowaniu. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider> i <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> używa metody <xref:System.Globalization.NumberFormatInfo> do tworzenia wystąpienia i zwracania obiektu, który dostarcza informacje o formatowaniu.  
  
 Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> używany jest obiekt dla bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład tworzy kilka wywołań <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody przy użyciu różnych kombinacji wartości `style` parametrów i `provider` .  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Liczba pojedynczych wywołań <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metody przekazującej wystąpienie następującej `BigIntegerFormatProvider` klasy, która definiuje tyldę (~) jako znak ujemny.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" />zawiera flagę <see cref="F:System.Globalization.NumberStyles.HexNumber" />orwraz z inną wartością. <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />nie jest zgodna ze wzorcem wejściowym określonym przez <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Liczba, która ma zostać podniesiona do <paramref name="exponent" /> potęgi.</param>
        <param name="exponent">Wykładnik do podniesienia <paramref name="value" /> przez.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> Podnosi wartość do potęgi określonej wartości.</summary>
        <returns>Wynik podniesienia <paramref name="value" /> <paramref name="exponent" /> do potęgi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca 1, jeśli wartość parametru wykładnik jest równa 0, lub jeśli wartości `value` obu parametrów i `exponent` są równe 0. <xref:System.Numerics.BigInteger.Pow%2A> Jeśli `exponent` jest 1 <xref:System.Numerics.BigInteger.Pow%2A> , metoda zwraca `value`. Jeśli `value` jest ujemna, metoda zwraca wynik ujemny.  
  
 Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
   
  
## Examples  
 Poniższy przykład ilustruje potęgowanie przy użyciu <xref:System.Numerics.BigInteger> wartości i wykładnika, której wartość należy do zakresu od 0 do 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" />jest wartością ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Wartość, która ma zostać podzielona.</param>
        <param name="divisor">Wartość do podziału przez.</param>
        <summary>Wykonuje dzielenie liczby całkowitej na <see cref="T:System.Numerics.BigInteger" /> dwie wartości i zwraca resztę.</summary>
        <returns>Resztę po <paramref name="dividend" /> podzieleniu <paramref name="divisor" />przez.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak reszty jest znakiem `dividend` parametru.  
  
 <xref:System.Numerics.BigInteger.Remainder%2A> Metoda jest implementowana dla języków, które nie obsługują niestandardowych operatorów. Zachowanie jest takie samo jak w przypadku dzielenia przy użyciu operatora modulo.  
  
 W razie potrzeby Metoda automatycznie wykonuje niejawną konwersję innych typów całkowitych na <xref:System.Numerics.BigInteger> obiekty przed wykonaniem operacji modułu.  
  
   
  
## Examples  
 Poniższy przykład porównuje resztę z <xref:System.Numerics.BigInteger.DivRem%2A> metody z resztą zwróconą <xref:System.Numerics.BigInteger.Remainder%2A> przez metodę w celu ustalenia, że dwie metody obliczą identyczne reszty.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />ma wartość 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wskazującą znak (ujemny, dodatni lub zero) bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu.</summary>
        <value>Liczba wskazująca znak <see cref="T:System.Numerics.BigInteger" /> obiektu, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość liczbowa 
 </term><description> Opis 
 </description></listheader><item><term> -1 
 </term><description> Wartość tego obiektu jest ujemna.  
  
 </description></item><item><term> 0 
 </term><description> Wartość tego obiektu wynosi 0 (zero).  
  
 </description></item><item><term> 1 
 </term><description> Wartość tego obiektu jest dodatnia.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest równoważna <xref:System.Math.Sign%2A?displayProperty=nameWithType> z metodą dla pierwotnych typów liczbowych. <xref:System.Numerics.BigInteger.Sign%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odejmowania (odjemna).</param>
        <param name="right">Wartość do odejmowania (odjemnik).</param>
        <summary>Odejmuje jedną <see cref="T:System.Numerics.BigInteger" /> wartość od innej i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Języki nieobsługujące niestandardowych operatorów mogą używać <xref:System.Numerics.BigInteger.Subtract%2A> metody do wykonywania odejmowania przy użyciu <xref:System.Numerics.BigInteger> wartości.  
  
 Metoda jest użytecznym zamiennikiem operatora odejmowania podczas tworzenia wystąpienia <xref:System.Numerics.BigInteger> zmiennej przez przypisanie do niej różnicy wynikającej z odejmowania, jak pokazano w poniższym przykładzie. <xref:System.Numerics.BigInteger.Subtract%2A>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Numerics.BigInteger" /> Konwertuje wartość na tablicę bajtów.</summary>
        <returns>Wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu konwertowana na tablicę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne bajty w tablicy zwrócone przez tę metodę są wyświetlane w kolejności little-endian. Oznacza to, że Dolna kolejność bajtów wartości poprzedza bajty wyższego rzędu. Pierwszy bajt tablicy odzwierciedla pierwsze osiem bitów <xref:System.Numerics.BigInteger> wartości, drugi bajt odzwierciedla następne osiem bitów itd. Na przykład wartość 1024 lub 0x0400 jest przechowywana jako następująca tablica dwóch bajtów:  
  
|Element|Wartość bajtu|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Wartości ujemne są zapisywane w tablicy przy użyciu reprezentacji uzupełniającej na najbardziej zwartej postaci. Na przykład-1 jest reprezentowane jako pojedynczy bajt `0xFF` , którego wartość jest zamiast tablicy z wieloma elementami, takimi jak `0xFF`, `0xFF` lub `0xFF`, `0xFF` `0xFF`,, `0xFF`.  
  
 Ponieważ reprezentacja uzupełniająca jest zawsze interpretowana najwyższego rzędu ostatniego bajtu w tablicy (bajt w położeniu <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) jako bit znaku, metoda zwraca tablicę bajtową z dodatkowym elementem, którego wartość jest równa zero można odróżnić wartości dodatnie, które w przeciwnym razie mogą być interpretowane jako mają ustawione bity podpisywania. Na przykład wartość 120 lub `0x78` jest reprezentowana jako tablica jednobajtowa:. `0x78` Jednakże 128, lub `0x80`, jest reprezentowane jako tablica dwubajtowa: `0x80`, `0x00`.  
  
 Możesz zaokrąglić <xref:System.Numerics.BigInteger> wartość, przechowując ją w tablicy bajtów, a następnie przywracając <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> przy użyciu konstruktora.  
  
> [!CAUTION]
>  Jeśli kod modyfikuje wartość poszczególnych bajtów w tablicy zwracanej przez tę metodę przed przywróceniem wartości, należy się upewnić, że nie można przypadkowo zmienić bitu znaku. Na przykład jeśli modyfikacje zwiększają wartość dodatnią, tak aby bit najwyższego rzędu w ostatnim elemencie tablicy bajtowej stał się ustawiony, można dodać nowy bajt, którego wartość jest równa zero do końca tablicy.  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak niektóre <xref:System.Numerics.BigInteger> wartości są reprezentowane w tablicach bajtów.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned"><see langword="true" />Aby użyć kodowania bez znaku; w przeciwnym razie. <see langword="false" /></param>
        <param name="isBigEndian"><see langword="true" />Aby zapisać bajty w kolejności bajtów big-endian; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwraca wartość tej <see cref="T:System.Numerics.BigInteger" /> wartości jako tablicę bajtową przy użyciu możliwie najmniejszej liczby bajtów. Jeśli wartość jest równa zero, zwraca tablicę z jednym bajtem, którego element jest 0x00.</summary>
        <returns>Wartość bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu konwertowana na tablicę bajtów.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Wartość `33022` całkowitą można wyeksportować w czterech różnych tablicach:

| Właściwości                           | Wynik                          |
|--------------------------------------|---------------------------------|
| `isUnsigned: false, isBigEndian: false` | `new byte[] { 0xFE, 0x80, 0x00 }` |
| `isUnsigned: false, isBigEndian: true`  | `new byte[] { 0x00, 0x80, 0xFE }` |
| `isUnsigned: true, isBigEndian: false`  | `new byte[] { 0xFE, 0x80 } `      |
| `isUnsigned: true, isBigEndian: true`   | `new byte[] { 0x80, 0xFE }`       |

          ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Jeśli <paramref name="isUnsigned" /> jest <see langword="true" /> i<see cref="P:System.Numerics.BigInteger.Sign" /> jest wartością ujemną.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego równoważną reprezentację w postaci ciągu.</summary>
        <returns>Ciąg reprezentujący bieżącą <see cref="T:System.Numerics.BigInteger" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString> Metoda formatujewartośćwformacie"R"lub"Round-<xref:System.Numerics.BigInteger> trip" bieżącej kultury. Jeśli chcesz określić inny format lub kulturę, użyj innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format rundy ("R")|Określona kultura|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Określony format|Domyślna kultura (bieżąca)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Określony format|Określona kultura|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Ciąg reprezentujący <xref:System.Numerics.BigInteger> wartość zawiera znak ujemny, jeśli jego wartość jest ujemna, a sekwencja cyfr od 0 do 9 bez zer wiodących. Znak ujemny jest definiowany przez <xref:System.Globalization.NumberFormatInfo> obiekt dla bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wyświetla <xref:System.Numerics.BigInteger> wartość przy użyciu metody domyślnej <xref:System.Numerics.BigInteger.ToString> . Wyświetla również reprezentacje <xref:System.Numerics.BigInteger> ciągów wartości, które wynikają z użycia niektórych specyfikatorów formatu standardowego. W przykładach jest używana konwencja formatowania kultury en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego równoważną reprezentację w postaci ciągu przy użyciu określonych informacji o formatowaniu specyficznych dla kultury.</summary>
        <returns>Ciąg reprezentujący bieżącą <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym <paramref name="provider" /> przez parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda formatuje wartość w formacie "R" lub "Round-Trip" przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Jeśli chcesz określić inny format lub bieżącą kulturę, użyj innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format rundy ("R")|Domyślna kultura (bieżąca)|<xref:System.Numerics.BigInteger.ToString>|  
|Określony format|Domyślna kultura (bieżąca)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Określony format|Określona kultura|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje specyficzne dla kultury dotyczące formatu ciągu zwracanego przez tę metodę. Jeśli `provider` jest `null` <xref:System.Globalization.NumberFormatInfo> , wartośćjestformatowanaprzyużyciuobiektubieżącejkultury<xref:System.Numerics.BigInteger> . Jedyną właściwością <xref:System.Globalization.NumberFormatInfo> obiektu, który kontroluje reprezentację <xref:System.Numerics.BigInteger> ciągu wartości przy użyciu specyfikatora formatu ogólnego, jest <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, który definiuje znak, który reprezentuje znak ujemny.  
  
 `provider` Parametr może mieć jedną z następujących wartości:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu.  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.  
  
-   Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider>. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie niestandardowego <xref:System.Globalization.NumberFormatInfo> obiektu, który definiuje tyldę (~) jako znak ujemny. Metoda następnie używa obiektu niestandardowego <xref:System.Globalization.NumberFormatInfo> do wyświetlania wartości ujemnej <xref:System.Numerics.BigInteger>. <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego równoważną reprezentację w postaci ciągu przy użyciu określonego formatu.</summary>
        <returns>Ciąg reprezentujący bieżącą <see cref="T:System.Numerics.BigInteger" /> wartość w formacie określonym <paramref name="format" /> przez parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda formatuje wartość w określonym formacie przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu, który reprezentuje konwencje bieżącej kultury. <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger.ToString%28System.String%29> Jeśli chcesz użyć "R" lub rundy, sformatuj lub określić inną kulturę, użyj innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format rundy ("R")|Domyślna kultura (bieżąca)|<xref:System.Numerics.BigInteger.ToString>|  
|Format rundy ("R")|Określona kultura|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Określony format|Określona kultura|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Parametr może być dowolnym prawidłowym [standardowym ciągiem numerycznym](~/docs/standard/base-types/standard-numeric-format-strings.md)lub dowolną kombinacją [niestandardowych ciągów formatu liczbowego.](~/docs/standard/base-types/custom-numeric-format-strings.md) `format` Jeśli `format` jest `null` <xref:System.Numerics.BigInteger> równe lub jest, wartość zwracana bieżącego obiektu jest formatowana przy użyciu specyfikatora formatu okrężnego ("R"). <xref:System.String.Empty?displayProperty=nameWithType> Jeśli `format` jest dowolną inną wartością, Metoda <xref:System.FormatException>zgłasza.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o obsłudze formatowania w .NET Framework, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Format zwracanego ciągu jest określany przez <xref:System.Globalization.NumberFormatInfo> obiekt dla bieżącej kultury. W zależności `format` od parametru ten obiekt kontroluje symbole, takie jak znak minus, separator grupy i symbol separatora dziesiętnego w ciągu danych wyjściowych. Aby zapewnić informacje o formatowaniu dla kultur innych niż bieżąca kultura, wywołaj <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Przeciążenie.  
  
   
  
## Examples  
 Poniższy przykład inicjuje <xref:System.Numerics.BigInteger> wartość i wyświetla go przy użyciu każdego ciągu formatu standardowego i niektórych niestandardowych ciągów formatu.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />nie jest prawidłowym ciągiem formatu.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość liczbową bieżącego <see cref="T:System.Numerics.BigInteger" /> obiektu na jego równoważną reprezentację w postaci ciągu przy użyciu określonego formatu i informacji o formacie specyficznym dla kultury.</summary>
        <returns>Ciąg reprezentujący bieżącą <see cref="T:System.Numerics.BigInteger" /> wartość określoną <paramref name="format" /> przez parametry i <paramref name="provider" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda formatuje wartość w określonym formacie przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu określonej kultury. <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Jeśli chcesz użyć formatu rundy lub domyślnych ustawień kultury, użyj innych przeciążeń <xref:System.Numerics.BigInteger.ToString%2A> metody w następujący sposób:  
  
|Aby użyć formatu|Dla kultury|Użyj przeciążenia|  
|-------------------|-----------------|----------------------|  
|Format rundy ("R")|Domyślna kultura (bieżąca)|<xref:System.Numerics.BigInteger.ToString>|  
|Format rundy ("R")|Określona kultura|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Określony format|Domyślna kultura (bieżąca)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Parametr może być dowolnym prawidłowym [standardowym ciągiem numerycznym](~/docs/standard/base-types/standard-numeric-format-strings.md)lub dowolną kombinacją [niestandardowych ciągów formatu liczbowego.](~/docs/standard/base-types/custom-numeric-format-strings.md) `format` Jeśli `format` jest `null` <xref:System.Numerics.BigInteger> równe lub jest, wartość zwracana bieżącego obiektu jest formatowana przy użyciu specyfikatora formatu okrężnego ("R"). <xref:System.String.Empty?displayProperty=nameWithType> Jeśli `format` jest dowolną inną wartością, Metoda <xref:System.FormatException>zgłasza.  
  
 Środowisko .NET Framework zapewnia rozbudowaną obsługę formatowania. Opisano to szczegółowo w następujących tematach poświęconych formatowaniu:  
  
-   Aby uzyskać więcej informacji na temat specyfikatorów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów liczb niestandardowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji o obsłudze formatowania w .NET Framework, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje specyficzne dla kultury dotyczące formatu ciągu zwracanego przez tę metodę. <xref:System.Type> `provider` <xref:System.IFormatProvider.GetFormat%2A> Gdy metoda jest wywoływana, wywołuje metodę parametru<xref:System.Globalization.NumberFormatInfo> i przekazuje ją do obiektu, który reprezentuje typ. <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Metoda zwraca obiekt, który dostarcza informacji do formatowania `value` parametru, takich jak symbol znaku minus, symbol separatora grupy lub symbol przecinka dziesiętnego. <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A> Istnieją trzy sposoby, aby użyć `provider` parametru w celu dostarczenia informacji o formatowaniu <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> do metody:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   Można przekazać rzeczywisty <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu liczb. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Można przekazać obiekt niestandardowy, który implementuje <xref:System.IFormatProvider>. Metoda tworzy wystąpienia i <xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Jeśli `provider` <xref:System.Globalization.NumberFormatInfo> jest `null`, formatowanie zwracanego ciągu jest zależne od obiektu bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład inicjuje <xref:System.Numerics.BigInteger> wartość i wyświetla go w konsoli przy użyciu standardowego ciągu formatu <xref:System.Globalization.NumberFormatInfo> i obiektu, który definiuje tyldę (~) jako znak ujemny.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />nie jest prawidłowym ciągiem formatu.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje przekonwertować ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg reprezentujący liczbę.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Numerics.BigInteger" /> odpowiednik liczby zawartej w <paramref name="value" />, lub zero (0), jeśli konwersja nie powiedzie się. Konwersja nie powiedzie się <paramref name="value" /> , jeśli <see langword="null" /> parametr ma wartość lub ma niepoprawny format. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje przekonwertować ciąg reprezentujący liczbę na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> został przekonwertowany pomyślnie; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest taka <xref:System.Numerics.BigInteger.Parse%28System.String%29> sama jak metoda, z tą różnicą, że nie zgłasza wyjątku, jeśli konwersja nie powiedzie się. <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Ta metoda eliminuje konieczność użycia obsługi wyjątków do testowania w <xref:System.FormatException> przypadku, gdy `value` jest nieprawidłowa i nie można jej pomyślnie przeanalizować.  
  
 `value` Parametr powinien być ciągiem reprezentującym liczbę dziesiętną w następującej postaci:  
  
 [*WS*] [*Sign*] *cyfry* [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp.|  
|*sign*|Opcjonalny znak. Prawidłowe znaki znakowe są określane przez <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> właściwości <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> i bieżącej kultury.|  
|*cyfr*|Sekwencja cyfr dziesiętnych od 0 do 9.|  
  
> [!NOTE]
>  Ciąg określony przez `value` parametr nie może zawierać żadnych separatorów grup ani separatorów dziesiętnych i nie może mieć części dziesiętnej.  
  
 Parametr jest interpretowany przy <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> użyciu stylu. `value` Poza cyframi dziesiętnymi dopuszcza się tylko spacje początkowe i końcowe z wiodącym znakiem. Aby jawnie zdefiniować elementy stylu z informacjami o formatowaniu specyficznym dla kultury, które mogą być `value`obecne w, <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Wywołaj metodę.  
  
 Parametr jest analizowany przy użyciu informacji o formatowaniu <xref:System.Globalization.NumberFormatInfo> w obiekcie dla bieżącej kultury. `value` Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 To Przeciążenie interpretuje wszystkie cyfry w `value` parametrze jako cyfry dziesiętne. Aby przeanalizować ciąg reprezentujący liczbę szesnastkową, wywołaj metodę <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metody do tworzenia wystąpienia dwóch <xref:System.Numerics.BigInteger> obiektów. Jeśli konwersje powiodło się, mnoży każdy obiekt przez inną liczbę, a następnie wywołuje <xref:System.Numerics.BigInteger.Compare%2A> metodę w celu określenia relacji między tymi dwoma obiektami.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg reprezentujący liczbę. Ciąg jest interpretowany przy użyciu stylu określonego przez <paramref name="style" />.</param>
        <param name="style">Bitowa kombinacja wartości wyliczenia wskazująca elementy stylu, które mogą być obecne w <paramref name="value" />. Typową wartością do określenia jest <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Obiekt, który dostarcza informacje <paramref name="value" />o formatowaniu specyficzne dla kultury.</param>
        <param name="result">Gdy ta metoda zwraca, zawiera <see cref="T:System.Numerics.BigInteger" /> odpowiednik liczby zawartej w <paramref name="value" />lub <see cref="P:System.Numerics.BigInteger.Zero" /> Jeśli konwersja zakończyła się niepowodzeniem. Konwersja nie powiedzie się <paramref name="value" /> , jeśli <see langword="null" /> parametr ma wartość lub nie jest w formacie zgodnym <paramref name="style" />z. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje przekonwertować ciąg reprezentujący liczbę w określonym stylu i formacie specyficznym dla kultury na jego <see cref="T:System.Numerics.BigInteger" /> odpowiednik, a następnie zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns><see langword="true" />Jeśli parametr został przekonwertowany pomyślnie; w przeciwnym <see langword="false" />razie,. <paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest taka <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> sama jak metoda, z tą różnicą, że nie zgłasza wyjątku, jeśli konwersja nie powiedzie się. <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Ta metoda eliminuje konieczność użycia obsługi wyjątków do testowania w <xref:System.FormatException> przypadku, gdy `value` jest nieprawidłowa i nie można jej przeanalizować pomyślnie.  
  
 Parametr definiuje elementy stylu (takie jak odstępy czy znak dodatni lub ujemny), które są dozwolone `value` w parametrze dla operacji analizy. `style` Musi to być kombinacja flag bitowych z <xref:System.Globalization.NumberStyles> wyliczenia. W zależności od wartości `style` `value` , parametr może zawierać następujące elementy:  
  
 [*WS*] [*$*] [*Sign*] [*cyfry*,]*cyfry*[. *fractional_digits*] [E [*Sign*]*exponential_digits*] [*WS*]  
  
 Jeśli parametr zawiera <xref:System.Globalization.NumberStyles.AllowHexSpecifier> ,`value` parametr może zawierać następujące elementy: `style`  
  
 [*WS*] *hexdigits* [*WS*]  
  
 Elementy w nawiasach kwadratowych ([ i ]) są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*ws*|Opcjonalny odstęp. Biały znak może pojawić się na początku `value` , `style` jeśli zawiera <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flagę <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> lub na końcu elementu `value` if `style` zawiera flagę.|  
|*$*|Symbol waluty specyficzny dla kultury. Jego pozycja w ciągu jest definiowana <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> przez właściwość <xref:System.Globalization.NumberFormatInfo> obiektu zwracanego `provider` przez <xref:System.IFormatProvider.GetFormat%2A> metodę parametru. Symbol waluty może pojawić się `value` w `style` , <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> jeśli zawiera flagę.|  
|*sign*|Opcjonalny znak. Znak może pojawić `value` się na początku, jeśli `style` zawiera <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flagę `value` i może <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> pojawić się na końcu, jeśli `style` zawiera flagę. Nawiasów można używać w `value` celu wskazania wartości ujemnej, <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Jeśli `style` zawiera flagę.|  
|*cyfr*|Sekwencja cyfr od 0 do 9.|  
|*,*|Separator grupy specyficzny dla kultury. Separator grupy kultury określonej przez może pojawić `provider` się w `value` parametrze `style` if zawiera <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flagę.|  
|*.*|Symbol dziesiętny specyficzny dla kultury. Symbol separatora dziesiętnego kultury określonej przez `provider` może pojawić się w `style` `value` parametrze <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> if zawiera flagę.|  
|*fractional_digits*|Jedno lub więcej wystąpień cyfry 0. Cyfry ułamkowe mogą pojawiać `value` się tylko `style` wtedy, <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> gdy zawierają flagę.|  
|E|Znak „e” lub „E”, który wskazuje, że wartość jest reprezentowana w zapisie wykładniczym (naukowym). Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `value`|  
|*exponential_digits*|Sekwencja cyfr od 0 do 9. Parametr może reprezentować liczbę w notacji wykładniczej, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Jeśli `style` zawiera flagę. `value`|  
|*hexdigits*|Sekwencja cyfr szesnastkowych od 0 do f lub od 0 do F.|  
  
> [!NOTE]
> Wszelkie kończące się znaki NUL (U + 0000 `s` ) w programie są ignorowane przez operację analizowania, niezależnie od wartości `style` argumentu.

 Ciąg z tylko cyframi dziesiętnymi (które odnosi się <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> do flagi) zawsze analizuje się prawidłowo. Większość pozostałych <xref:System.Globalization.NumberStyles> elementów członkowskich kontroluje elementy, które mogą być obecne, ale nie muszą być obecne w tym ciągu wejściowym. Poniższa tabela zawiera informacje o <xref:System.Globalization.NumberStyles> tym, w jaki sposób poszczególne elementy członkowskie wpływają `value`na elementy, które mogą być obecne w.  
  
|Niezłożone `NumberStyles` wartości|Dodatkowe (poza cyframi) elementy dozwolone w wartości|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Tylko cyfry dziesiętne.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Elementy przecinka dziesiętnego (*.*) i *fractional_digits* . Jednak *fractional_digits* musi zawierać tylko jedną lub więcej cyfr 0 lub metoda zwraca `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Znak "e" lub "E", który oznacza notację wykładniczą oraz *exponential_digits*. Jeśli `value` reprezentuje liczbę w notacji wykładniczej, nie może ona mieć części ułamkowej.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Element *WS* na początku `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Element *WS* na końcu `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Element *Sign* przed *cyframi*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Element *Sign* po *cyfrach*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Element *Sign* w postaci nawiasów otaczających wartość liczbową.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Element separatora grupy (*,*).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Element Currency (*$*).|  
|<xref:System.Globalization.NumberStyles.Currency>|Wszystkie elementy. `value` Jednak nie może reprezentować liczby szesnastkowej ani liczby w notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Float>|Element *WS* na początku lub na `value`końcu, ** `value`znak na początku i symbol dziesiętny (*.*). `value` Parametr może również używać notacji wykładniczej.|  
|<xref:System.Globalization.NumberStyles.Number>|Elementy *WS*, *Sign*, separator grupy (*,*) i punkt dziesiętny (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Wszystkie elementy. `value` Jednak nie może reprezentować liczby szesnastkowej.|  
  
> [!IMPORTANT]
>  Jeśli używasz <xref:System.Numerics.BigInteger.TryParse%2A> metody do rundy ciągu reprezentacji <xref:System.Numerics.BigInteger> wartości <xref:System.Numerics.BigInteger.ToString%2A> , która była wynikiem przez metodę, należy użyć <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metody ze specyfikatorem formatu "R", aby wygenerować reprezentację ciągu <xref:System.Numerics.BigInteger> wartość. W przeciwnym razie ciąg reprezentujący <xref:System.Numerics.BigInteger> zachowuje tylko 50 najbardziej znaczące cyfry oryginalnej wartości, a dane mogą zostać utracone podczas <xref:System.Numerics.BigInteger.TryParse%2A> korzystania z metody w celu przywrócenia <xref:System.Numerics.BigInteger> wartości.  
  
 Jeśli flaga jest używana, `value` musi być wartością szesnastkową. <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> Jedyne inne flagi, które mogą być obecne `style` w <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> to <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>i. (Wyliczenie ma <xref:System.Globalization.NumberStyles.HexNumber>styl złożony, który zawiera zarówno flagi białych znaków). <xref:System.Globalization.NumberStyles>  
  
> [!NOTE]
>  Jeśli `value` jest to ciąg reprezentujący liczbę szesnastkową, nie może być poprzedzony żadnym dekoracją ( `0x` np. lub `&h`), który odróżnia go jako liczbę szesnastkową. To powoduje niepowodzenie konwersji.  
  
 Jeśli `value` jest ciągiem szesnastkowym <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> , Metoda interpretuje `value` jako liczbę ujemną przechowywaną przy użyciu reprezentacji uzupełniającej dwóch, jeśli jej pierwsze dwie cyfry `0x80`szesnastkowe są większe lub równe. Innymi słowy metoda interpretuje największą liczbę bitów pierwszego bajtu `value` jako bit znaku. Aby upewnić się, że ciąg szesnastkowy jest poprawnie interpretowany jako liczba dodatnia, pierwsza `value` cyfra w musi mieć wartość zero. Na przykład Metoda interpretuje `0x80` jako wartość ujemną, ale interpretuje `0x0080` albo `0x080` jako wartość dodatnią. Poniższy przykład ilustruje różnicę między ciągami szesnastkowymi, które reprezentują wartości ujemne i dodatnie.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda `value`zwraca obiekt, który zawiera informacje specyficzne dla kultury o formacie. <xref:System.Globalization.NumberFormatInfo> `provider` Parametr może mieć jedną z następujących wartości:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu. Jego <xref:System.Globalization.CultureInfo.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu liczb dla tej kultury.  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który zawiera informacje o formatowaniu liczb. (Jego implementacja <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> po prostu zwraca samą siebie).  
  
-   Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider>. Metoda tworzy wystąpienia i <xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Jeśli `provider` jest `null` ,<xref:System.Globalization.NumberFormatInfo> używany jest obiekt dla bieżącej kultury.  
  
   
  
## Examples  
 Poniższy przykład wykonuje pewne wywołania <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody przy użyciu różnych kombinacji wartości `style` parametrów i `provider` .  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Liczba pojedynczych wywołań <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metody przekazującej wystąpienie następującej `BigIntegerFormatProvider` klasy, która definiuje tyldę (~) jako znak ujemny.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />nie <see cref="T:System.Globalization.NumberStyles" /> jest wartością.  
  
—lub— 
 <paramref name="style" />zawiera flagę <see cref="F:System.Globalization.NumberStyles.HexNumber" />orwraz z inną wartością. <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">Zakres docelowy, do którego powinny być zapisywane otrzymane bajty.</param>
        <param name="bytesWritten">Liczba bajtów, do <paramref name="destination" />których zapisano.</param>
        <param name="isUnsigned"><see langword="true" />Aby użyć kodowania bez znaku; w przeciwnym razie. <see langword="false" /></param>
        <param name="isBigEndian"><see langword="true" />Aby zapisać bajty w kolejności bajtów big-endian; w przeciwnym razie. <see langword="false" /></param>
        <summary>Kopiuje wartość tego <see cref="T:System.Numerics.BigInteger" /> elementu jako bajty parach-uzupełnienie w postaci little-endian przy użyciu najmniejszej liczby możliwych bajtów. Jeśli wartość jest równa zero, wyprowadza jeden bajt, którego element jest 0x00.</summary>
        <returns><see langword="true" />Jeśli bajty mieszczą się <paramref name="destination" />w; <see langword="false" /> Jeśli nie wszystkie bajty mogą być zapisywane z powodu braku miejsca.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><paramref name="isUnsigned" />jest <see langword="true" /> i<see cref="P:System.Numerics.BigInteger.Sign" /> ma wartość ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą liczbę 0 (zero).</summary>
        <value>Liczba całkowita, której wartością jest 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> Obiekt zwrócony przez tę właściwość zapewnia wygodne źródło wartości zerowej do użycia w przypisaniach i porównaniach.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="06c376bc48310dbe39a6d2e5ecd3a1937dc7a094" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52358058" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje liczbą.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczby zespolonej jest liczbą, która składa się z częścią liczba rzeczywista i urojone numer. Z liczby zespolonej są zwykle zapisywane w postaci z = x + yi, gdzie *x* i *y* są liczby rzeczywiste i *i* jest jednostką imaginery, która ma właściwość *i* <sup>2</sup> = -1. Rzeczywiste część liczby zespolonej jest reprezentowany przez *x*, i urojone części liczb zespolonych jest reprezentowany przez *y*.  
  
 <xref:System.Numerics.Complex> Kartezjański układ współrzędnych (real, imaginery) używa typ podczas tworzenia wystąpienia i manipulowanie nimi liczby zespolone. Liczby zespolonej może być reprezentowany jako punkt w dwuwymiarowej współrzędnych, który jest znany jako płaszczyzny złożone. Rzeczywiste część liczby zespolonej znajduje się na osi x (osi poziomej) i urojone części znajduje się na osi y (oś pionowa).  
  
 Dowolne miejsce w płaszczyźnie złożone można również wyrażać oparte na wartość bezwzględna za pomocą polar współrzędnych., w Współrzędne biegunowe, punkt charakteryzuje się dwie liczby:  
  
-   Jego wielkości, która jest odległość punktu ze źródła (oznacza to, że 0,0 lub punktu, w jakim przecięcia osi x i y).  
  
-   Jego faza, która to kąt między osią rzeczywistych i wiersz pobierane z punktu początkowego do punktu.  
  
## <a name="instantiating-a-complex-number"></a>Utworzenie wystąpienia liczby zespolonej  
 Można przypisać wartość do liczby zespolonej w jednym z następujących sposobów:  
  
-   Przekazując dwa <xref:System.Double> wartości dla jego konstruktora. Pierwsza wartość reprezentuje część rzeczywista liczby zespolonej, a druga wartość reprezentuje jego urojone części. Wartości te reprezentują pozycji liczby zespolonej w dwuwymiarowej kartezjański układ współrzędnych.  
  
-   Przez wywołanie metody statyczne (`Shared` w języku Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> metodę w celu utworzenia liczby zespolonej z jego Współrzędne biegunowe.  
  
-   Przypisując <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, lub <xref:System.Double> wartość <xref:System.Numerics.Complex> obiektu. Wartość staje się częścią rzeczywistych liczby zespolonej, a jego urojone części jest równa 0.  
  
-   Rzutowanie (w języku C#) lub konwersji (w języku Visual Basic) <xref:System.Decimal> lub <xref:System.Numerics.BigInteger> wartość <xref:System.Numerics.Complex> obiektu. Wartość staje się częścią rzeczywistych liczby zespolonej, a jego urojone części jest równa 0.  
  
-   Przypisując liczby zespolonej, który jest zwracany przez metodę lub operatora <xref:System.Numerics.Complex> obiektu. Na przykład <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> jest metoda statyczna zwraca liczby zespolonej, która jest sumą dwóch liczb zespolonych i <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator dodaje dwie liczby zespolone i zwraca wynik.  
  
 W poniższym przykładzie pokazano każdego z tych pięciu sposobów przypisywania wartości do liczby zespolonej.  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a>Operacje na liczbach zespolonych  
 <xref:System.Numerics.Complex> Struktury w programie .NET Framework zawiera elementy członkowskie, które zapewniają następujące funkcje:  
  
-   Metody do porównania dwóch liczb zespolonych, aby ustalić, czy są równe.  
  
-   Operatory, aby wykonywać operacje arytmetyczne na liczbach zespolonych. <xref:System.Numerics.Complex> Operatory umożliwiają wykonywanie Dodawanie, odejmowanie, mnożenie, dzielenie i Negacja Jednoargumentowa liczbach zespolonych.  
  
-   Metody do wykonywania innych wartości liczbowych operacji na liczbach zespolonych. Oprócz cztery podstawowe operacje arytmetyczne można zwiększyć liczby zespolonej do określonej potęgi, Znajdź pierwiastek kwadratowy liczby zespolonej i uzyskać wartość bezwzględną liczby zespolonej.  
  
-   Wykonaj operacje trygonometryczne na liczbach zespolonych metody. Na przykład można obliczyć tangens kąta reprezentowany przez liczbą.  
  
 Należy zauważyć, że ponieważ <xref:System.Numerics.Complex.Real%2A> i <xref:System.Numerics.Complex.Imaginary%2A> są właściwości tylko do odczytu, nie można zmodyfikować wartości istniejącego <xref:System.Numerics.Complex> obiektu.  Wszystkie metody, które wykonują operację na <xref:System.Numerics.Complex> numer, jeśli ich wartości zwracanej jest typu <xref:System.Numerics.Complex>, zwraca nową <xref:System.Numerics.Complex> numer.  
  
## <a name="precision-and-complex-numbers"></a>Precyzja i liczby zespolone  
 Rzeczywiste i urojone części liczb zespolonych są reprezentowane przez dwie wartości zmiennoprzecinkowe podwójnej precyzji. Oznacza to, że <xref:System.Numerics.Complex> wartości, takich jak różne wartości zmiennoprzecinkowe podwójnej precyzji, mogą tracić dokładność wyniku operacji liczbowych. Oznacza to, że to strict porównania dla równości dwóch <xref:System.Numerics.Complex> wartości może zakończyć się niepowodzeniem, nawet w przypadku różnicy między dwiema wartościami ze względu na utratę precyzji. Aby uzyskać więcej informacji, zobacz <xref:System.Double>.  
  
 Na przykład przeprowadzania potęgowania logarytm liczby powinien zwrócić oryginalny numer. Jednak w niektórych przypadkach utratę precyzji wartości zmiennoprzecinkowych może spowodować niewielkie różnice między dwiema wartościami, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 Podobnie poniższy przykład, który oblicza pierwiastek kwadratowy liczby <xref:System.Numerics.Complex> numer generuje wyniki nieco inaczej na 32-bitowych i IA64 wersje programu .NET Framework.  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a>Liczby zespolone, nieskończoność i NaN  
 Rzeczywiste i urojone części liczb zespolonych są reprezentowane przez <xref:System.Double> wartości. Oprócz od <xref:System.Double.MinValue?displayProperty=nameWithType> do <xref:System.Double.MaxValue?displayProperty=nameWithType>, rzeczywiste i urojone części liczby zespolonej może mieć wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType>. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Double.NaN?displayProperty=nameWithType> wszystkie propagowane podczas korzystania z żadnych operacji arytmetycznych lub trygonometrycznych.  
  
 W poniższym przykładzie, dzielenie przez <xref:System.Numerics.Complex.Zero> generuje liczby zespolonej, w których rzeczywiste i urojone części są <xref:System.Double.NaN?displayProperty=nameWithType>. W wyniku wykonywania mnożenia wartość tworzy również liczby zespolonej, w których rzeczywiste i urojone części są <xref:System.Double.NaN?displayProperty=nameWithType>. Podobnie, wykonując mnożenia, która przepełnienia zakres <xref:System.Double> typu generuje liczby zespolonej, w których części rzeczywistych <xref:System.Double.NaN?displayProperty=nameWithType> i którego urojone części <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Następnie wykonywanie dzielenia o tym numerze złożone zwraca liczby zespolonej, w których części rzeczywistych <xref:System.Double.NaN?displayProperty=nameWithType> i którego urojone części <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 Operacje matematyczne na liczbach zespolonych, które są nieprawidłowe lub który przepełnienie <xref:System.Double> typu danych nie zgłasza wyjątku. Zamiast tego zwracają <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> w następujących warunkach:  
  
-   Dzielenia przez zero zwraca liczbę dodatnią <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
-   Każdej operacji, która przepełnienia górną granicę <xref:System.Double> zwraca typ danych <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
-   Dzielenie liczby ujemnej, zerowego zwraca <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
-   Każdej operacji, która przepełnienia dolna granica <xref:System.Double> zwraca typ danych <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
-   Zwraca dzielenia przez zero zero <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
-   Każdej operacji, która jest wykonywana w przypadku argumentów operacji, których wartości są <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType>, w zależności od określonej operacji.  
  
 Należy zauważyć, że dotyczy to wszelkie pośrednie obliczenia wykonywane przez metodę. Na przykład, mnożenie `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` używa formuły (ac - bd) + (ad + bc) i. Obliczanie rzeczywisty składnik, która wynika z mnożeniem ocenia 9e308 wyrażenie * 2.5 — 9e308 * 3.5. Zwraca każdego mnożenia pośredni, w tym wyrażeniu <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>i próbę na potrzeby odejmowania <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> z <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
## <a name="formatting-a-complex-number"></a>Formatowanie liczby zespolonej  
 Domyślnie reprezentację liczby zespolonej ma postać `(` *rzeczywistych* `,` *urojone*`)`, gdzie *rzeczywistych* i *urojone* są ciągów reprezentujących <xref:System.Double> wartości, które tworzą liczby zespolonej rzeczywiste i urojone części. Niektóre przeciążenia <xref:System.Numerics.Complex.ToString%2A> metody umożliwienia dostosowania ciągów reprezentujących tych <xref:System.Double> wartości, aby odzwierciedlić Konwencji formatowania określonej kultury lub pojawią się w określonym formacie definicją liczbowe standardowych lub niestandardowych Ciąg formatu. (Aby uzyskać więcej informacji, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
 Typowe sposoby może przedstawiać reprezentację liczby zespolonej ma postać + bi, gdzie jest liczby zespolonej rzeczywisty składnik, a b liczby zespolonej urojone części. W elektrotechnice, liczby zespolonej najczęściej jest wyrażona jako + bj. Reprezentacja tekstowa liczby zespolonej może zwrócić w jednej z tych dwóch formach. Aby to zrobić, należy zdefiniować dostawcy niestandardowego formatu implementując <xref:System.ICustomFormatter> i <xref:System.IFormatProvider> interfejsów, a następnie wywołania <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metody.  
  
 W poniższym przykładzie zdefiniowano `ComplexFormatter` klasa, która reprezentuje liczby zespolonej jako ciąg w postaci + bi lub + bj.  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 W poniższym przykładzie użyto tego niestandardowego elementu formatującego następnie, aby wyświetlić reprezentację liczby zespolonej.  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">Rzeczywiste część liczby zespolonej.</param>
        <param name="imaginary">Urojone części liczb zespolonych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.Complex" /> struktury przy użyciu określonych wartości rzeczywiste i urojone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `real` Lub `imaginary` argumenty mogą tracić dokładność, jeśli są typy danych, które wymaga jawnego rzutowania na <xref:System.Double>.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwie liczby zespolone, a następnie są one używane w przypadku operacji dodawania, odejmowania, mnożenia i dzielenia.  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Pobiera wartość bezwzględna (lub wielkości) liczby zespolonej.</summary>
        <returns>Wartość bezwzględna <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna liczby zespolonej jest równoważne z jej <xref:System.Numerics.Complex.Magnitude%2A> właściwości. Wartość bezwzględna liczby rzeczywistym + bi jest obliczana w następujący sposób:  
  
-   Jeśli b = 0, wynik jest równy 0.  
  
-   Jeśli > b, wynik jest *<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).  
  
-   Jeśli b >, wynik jest b * <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 +<sup>2</sup>/b<sup>2</sup>).  
  
 Jeśli obliczenie wartości bezwzględne powoduje przepełnienie, metoda zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Jeśli <xref:System.Numerics.Complex.Real%2A> lub <xref:System.Numerics.Complex.Imaginary%2A> właściwość <xref:System.Double.NaN?displayProperty=nameWithType> i innych właściwości nie jest ani <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ani <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie oblicza wartość bezwzględną liczby zespolonej i pokazuje, że jest odpowiednikiem wartości <xref:System.Numerics.Complex.Magnitude%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczby zespolonej, który reprezentuje cosinus.</param>
        <summary>Zwraca kąt, będącego arcus cosinus liczby zespolonej określony.</summary>
        <returns>Kąt wyrażony w radianach, czyli arcus cosinus z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Acos%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Acos%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Acos%2A> Metoda wykorzystuje następującą formułę:  
  
 (-<xref:System.Numerics.Complex.ImaginaryOne>) * <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` * `value`)))    
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Acos%2A> metody. Pokazuje, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Acos%2A> metody <xref:System.Numerics.Complex.Cos%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba złożonych do dodania.</param>
        <param name="right">Druga liczba złożonych do dodania.</param>
        <summary>Dodaje dwie liczby zespolone i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodanie złożony numer + analizy biznesowej, a druga liczba złożonych, c + di, ma następującą postać:  
  
 (a + c) + (b + d) i.  
  
 Jeśli metoda wyniki wywołania przepełnienie w czasie albo rzeczywiste i urojone części, wartość składnik to <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Można używać języków, które nie obsługują operatorów niestandardowych <xref:System.Numerics.Complex.Add%2A> metodę, aby przeprowadzić Dodawanie liczbach zespolonych.  
  
   
  
## Examples  
 Poniższy przykład ilustruje dodanie liczbach zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca kąt, będącego funkcji arcus sinus liczby zespolonej określony.</summary>
        <returns>Czyli arcus sinus kąta z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Asin%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Asin%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Asin%2A> Metoda wykorzystuje następującą formułę:  
  
 -<xref:System.Numerics.Complex.ImaginaryOne> * <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> * wartość + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> — wartość * wartość))    
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Asin%2A> metody. Pokazuje, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Asin%2A> metody <xref:System.Numerics.Complex.Sin%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca kąt, będącego funkcji arcus tangens liczby zespolonej określony.</summary>
        <returns>Będący arcus tangens kąta <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Atan%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Atan%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Atan%2A> Metoda wykorzystuje następującą formułę:  
  
 <xref:System.Numerics.Complex.ImaginaryOne> / Nowy złożonych (w wersji 2.0, 0.0)) * (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> * wartość)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne * wartość)   
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Atan%2A> metody. Pokazuje, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Atan%2A> metody <xref:System.Numerics.Complex.Tan%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Oblicza sprzężenie liczbą i zwraca wynik.</summary>
        <returns>Sprzężenie z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprzężenie liczby zespolonej odwraca znak urojone części; oznacza to, że dotyczy ona Negacja Jednoargumentowa urojone części. Jeśli + bi jest liczbą, jest jego sprzężenie - analizy biznesowej.  
  
   
  
## Examples  
 Poniższy przykład wyświetla sprzężenie dwóch liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca cosinus liczby zespolonej określony.</summary>
        <returns>Cosinus <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Cos%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Cos%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Cos%2A> Metoda używa następującej formuły można obliczyć cosinus liczby zespolonej + bi:  
  
 (<xref:System.Math.Cos%2A>() * <xref:System.Math.Cosh%2A>(b)-(<xref:System.Math.Sin%2A>() * <xref:System.Math.Sinh%2A>(b)))  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Acos%2A> metody. Pokazuje, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Acos%2A> metody <xref:System.Numerics.Complex.Cos%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca cosinus hiperboliczny liczby zespolonej określony.</summary>
        <returns>Cosinus hiperboliczny liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Cosh%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Cosh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Cosh%2A> Metoda używa następującej formuły można obliczyć cosinus hiperboliczny liczby zespolonej + bi:  
  
 (<xref:System.Math.Cosh%2A>() * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>() * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">Liczby zespolonej podzielenia.</param>
        <param name="divisor">Liczby zespolonej dzielnikiem.</param>
        <summary>Dzieli jeden liczby zespolonej żadnego innego i zwraca wynik.</summary>
        <returns>Iloraz z dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzielenie liczby zespolonej + bi przez drugi liczby zespolonej, liczby, c + di, ma następującą postać:  
  
 ((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i  
  
 Jeśli obliczenie ilorazu powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 <xref:System.Numerics.Complex.Divide%2A> Metoda może być używana przez języki, które nie obsługują operatorów niestandardowych. Jego zachowanie jest identyczne z dzielenia przy użyciu operator dzielenia.  
  
   
  
## Examples  
 Poniższy przykład dzieli liczby zespolonej przez każdy element w tablicy liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie liczby zespolone są takie same.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczby zespolonej do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określonej liczby zespolonej mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli ta liczba złożonych i <paramref name="value" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda zapewnia <xref:System.IEquatable%601> implementację <xref:System.Numerics.Complex> struktury. Sprawdzi się nieco lepiej niż <xref:System.Numerics.Complex.Equals%28System.Object%29> metody, ponieważ nie trzeba przekonwertować jako parametr z liczbą.  
  
 Dwie liczby zespolone są równe, jeżeli ich rzeczywistego części są równe, i ich urojone części są takie same. <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda jest odpowiednikiem następujące wyrażenie:  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Użyj <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metoda ostrożnie, ponieważ dwie wartości, które są najwyraźniej równoważne mogą być uważane za nierówne ze względu na zróżnicowane dokładność ich rzeczywiste i urojone części. Poniższy przykład informuje, że <c>(3.33333, 0.142857)</c> i <c>(10/3, 1/7)</c> nie są takie same.  
  
[! code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! kodu vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)] 
Jeden zalecana technika polega na zdefiniowaniu dopuszczalnych margines różnicę między dwiema wartościami (np. 01% jeden ze składników wartości rzeczywiste i urojone) zamiast porównywania wartości dla równości. Jeśli wartość bezwzględna różnicę między dwiema wartościami jest mniejsza niż lub równe margines, różnica będzie prawdopodobnie z powodu różnic w dokładności i, w związku z tym, wartości są mogą być równe. W poniższym przykładzie użyto tej techniki, aby porównać dwie wartości złożonych, które zostały odnalezione w poprzednim przykładzie kodu, będą traktowane jako różne. Znajdzie dwóch liczb zespolonych równe.  
  
[! code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! kodu vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt ma taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> parametr jest <see cref="T:System.Numerics.Complex" /> obiektu lub stanie niejawna konwersja na typ <see cref="T:System.Numerics.Complex" /> obiekt i jego wartość jest równa bieżącego <see cref="T:System.Numerics.Complex" /> obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwie liczby zespolone są równe, jeżeli ich rzeczywistego części są równe, i ich urojone części są takie same. <xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda jest odpowiednikiem następujące wyrażenie:  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 Jeśli `obj` parametr nie jest <xref:System.Numerics.Complex> obiektu, ale jest typu danych, dla którego zdefiniowano niejawną konwersję, <xref:System.Numerics.Complex.Equals%28System.Object%29> konwertuje metody `obj` do <xref:System.Numerics.Complex> obiektu, którego część rzeczywista jest równa wartości `obj`i którego urojone części jest równa zero, przed wykonaniem porównania. Poniższy przykład ilustruje ten, wyszukując liczby zespolonej i wartość zmiennoprzecinkową podwójnej precyzji są równe.  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Użyj <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metoda ostrożnie, ponieważ dwie wartości, które są najwyraźniej równoważne mogą być uważane za nierówne ze względu na zróżnicowane dokładność ich rzeczywiste i urojone części. Ten problem może być accentuated, jeśli <paramref name="obj" /> muszą zostać skonwertowane do <see cref="T:System.Double" /> przed przystąpieniem do wykonywania porównania. W poniższym przykładzie porównano liczby zespolonej, której rzeczywisty składnik wydaje się być taka sama jak <see cref="T:System.Single" /> wartością, która <see cref="T:System.Single" /> wartość. Dane wyjściowe pokazują, zwraca porównania dla równości <see langword="False" />.  
  
[! code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! kodu vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)] 
Jeden zalecana technika polega na zdefiniowaniu dopuszczalnych margines różnicę między dwiema wartościami (np. 01% jeden ze składników wartości rzeczywiste i urojone) zamiast porównywania wartości dla równości. Jeśli wartość bezwzględna różnicę między dwiema wartościami jest mniejsza niż lub równe margines, różnica będzie prawdopodobnie z powodu różnic w dokładności i w związku z tym, wartości są mogą być równe. W poniższym przykładzie użyto tej techniki, aby porównać dwie wartości, które będą traktowane jako różne znalezione w poprzednim przykładzie kodu. Teraz znajduje się być równe.  
  
[! code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! kodu vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych, która określa potęgi.</param>
        <summary>Zwraca <see langword="e" /> podniesioną do potęgi określonej przez liczbą.</summary>
        <returns>Liczba <see langword="e" /> podniesioną do potęgi <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Numerics.Complex.Pow%2A> metodę, aby obliczyć potęgi innych podstaw.  
  
 <xref:System.Numerics.Complex.Exp%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych. <xref:System.Numerics.Complex.Exp%2A> jest przeciwieństwem <xref:System.Numerics.Complex.Log%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Exp%2A> metody. Pokazuje, że, z niektórych dopuszczalna braku dokładność <xref:System.Double> typu danych, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Log%2A> metody <xref:System.Numerics.Complex.Exp%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">Wielkość, czyli odległość od źródła (punkt przecięcia osi x i y) do liczby.</param>
        <param name="phase">Faza, czyli kąta linii osi poziomej, wyrażony w radianach.</param>
        <summary>Tworzy liczby zespolonej Współrzędne biegunowe punktu.</summary>
        <returns>Liczbą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Metoda tworzy wystąpienia liczby zespolonej, w oparciu o jego Współrzędne biegunowe.  
  
 Ponieważ istnieje wiele reprezentacji punktu na płaszczyźnie złożone, wartość zwracana przez <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody jest znormalizować. Wartość jest znormalizować dodatnią liczbę i fazy jest znormalizować wartość z zakresu od -<xref:System.Math.PI> do <xref:System.Math.PI>. W wyniku wartości <xref:System.Numerics.Complex.Phase%2A> i <xref:System.Numerics.Complex.Magnitude%2A> właściwości wynikowy liczby zespolonej nie może mieć wartość równą oryginalne wartości parametru `magnitude` i `phase` parametrów.  
  
 Można przekonwertować wartości ze stopni na radiany dla `phase` parametru wielokrotnie jej  <xref:System.Math.PI?displayProperty=nameWithType> /180.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodę, aby utworzyć wystąpienia liczby zespolonej oparte na jego Współrzędne biegunowe, a następnie wyświetla wartość jego <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera urojone części bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <value>Składnik urojone liczbą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biorąc pod uwagę liczby zespolonej + analizy biznesowej, <xref:System.Numerics.Complex.Imaginary%2A> właściwość zwraca wartość b.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.Complex> obiektów i wyświetla składniki rzeczywiste i urojone każdego w formie + analizy biznesowej.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienie z liczbą rzeczywistą równa zero i liczbą imaginery równa jeden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości za pomocą <xref:System.Numerics.Complex.ImaginaryOne> właściwości. Następnie porównuje tę wartość na inną wartość, który zostanie uruchomiony, wywołując <xref:System.Numerics.Complex> konstruktora z rzeczywistych równa zero i urojone część równa jeden. Dane wyjściowe z przykładu pokazują, dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca logarytm liczby zespolonej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca fizyczna (podstawowy <see langword="e" />) logarytmu określonej liczby złożone.</summary>
        <returns>Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Log%2A> metody. Pokazuje, że, z niektórych dopuszczalna braku dokładność <xref:System.Double> typu danych, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Log%2A> metody <xref:System.Numerics.Complex.Exp%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <param name="baseValue">Podstawa logarytmu.</param>
        <summary>Zwraca wartość logarytmu określonej liczby zespolonej w określonej bazie.</summary>
        <returns>Logarytm <paramref name="value" /> w podstawowym <paramref name="baseValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca logarytm base 10 określonej liczby złożone.</summary>
        <returns>Logarytm base 10 <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log10%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Log10%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość (lub wartość bezwzględną) liczby zespolonej.</summary>
        <value>Wartość bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Magnitude%2A> Właściwość jest równoważna wartość bezwzględną liczby zespolonej. Określa odległość ze źródła (punkt przecięcia osi x i y w układzie współrzędnych formułuje) do punktu dwuwymiarowe, reprezentowane przez liczbą. Wartość bezwzględna jest obliczana w następujący sposób:  
  
 &#124;+ bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(* + b * b)  
  
 Jeśli obliczenie wartości bezwzględne powoduje przepełnienie, właściwość ta zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości definiują położenie punktu, który reprezentuje liczby zespolonej w systemie Utwórz Współrzędne biegunowe.  
  
 Można utworzyć wystąpienia liczby zespolonej, w oparciu o jego Współrzędne biegunowe, zamiast współrzędnych Kartezjańskiego przez wywołanie metody <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie oblicza wartość bezwzględną liczby zespolonej i pokazuje, że jest odpowiednikiem wartości <xref:System.Numerics.Complex.Magnitude%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba złożonych do pomnożenia.</param>
        <param name="right">Druga liczba złożonych do pomnożenia.</param>
        <summary>Zwraca iloczyn dwóch liczb zespolonych.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mnożenie złożony numer + analizy biznesowej, a druga liczba złożonych, c + di, ma następującą postać:  
  
 (ac - bd) + (ad + bc) i  
  
 Jeśli mnożenia powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 <xref:System.Numerics.Complex.Multiply%2A> Metoda jest implementowana dla języków, które nie obsługują operatorów niestandardowych. Jego zachowanie jest identyczne z mnożenia przy użyciu operator mnożenia.  
  
   
  
## Examples  
 Poniższy przykład wielokrotności a liczby zespolonej przez każdy element w tablicy liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca odwrotność dodatku określonej liczby złożone.</summary>
        <returns>Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki <paramref name="value" /> parametru pomnożona przez wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwrotność dodatku liczby zespolonej jest liczbą, która generuje wartość <xref:System.Numerics.Complex> po dodaniu do oryginalnego liczby zespolonej. Ta metoda zwraca wartość liczby zespolonej pomnożyć rzeczywiste i urojone części oryginalny numer złożone przez -1.  
  
 <xref:System.Numerics.Complex.Negate%2A> Metoda jest implementowana dla języków, które nie obsługują operatorów niestandardowych. Jego zachowanie jest taka sama jak za pomocą Jednoargumentowy operator negacji negacji <xref:System.Numerics.Complex.op_UnaryNegation%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano odwrotność dodatku każdego elementu w tablicy liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienie z liczbą rzeczywistą równą jeden a liczbą imaginery równa zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości za pomocą <xref:System.Numerics.Complex.One> właściwości. Następnie porównuje tę wartość na inną wartość, który zostanie uruchomiony, wywołując <xref:System.Numerics.Complex> konstruktora z rzeczywistych równą jeden i urojone część równa zero. Dane wyjściowe z przykładu pokazują, dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje dwie liczby złożone.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Addition%2A> Metoda definiuje operacja dodawania dla liczby zespolone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 Dodanie złożony numer + analizy biznesowej, a druga liczba złożonych, c + di, ma następującą postać:  
  
 (a + c) + (b + d) i  
  
 Jeśli metoda wyniki wywołania przepełnienie w czasie albo rzeczywiste i urojone części, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.Complex.Add%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład ilustruje dodanie liczbach zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do podzielenia.</param>
        <param name="right">Wartość do podzielenia przez.</param>
        <summary>Dzieli określonej liczby zespolonej przez inną określoną liczbę złożone.</summary>
        <returns>Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Division%2A> Metoda definiuje operacji dzielenia liczb zespolonych. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 Podział złożony numer + analizy biznesowej, a druga liczba złożonych, c + di, ma następującą postać:  
  
 ((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i  
  
 Jeśli podział powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Języki, które nie obsługują operatorów niestandardowych i przeciążanie operatorów może wywołać <xref:System.Numerics.Complex.Divide%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba złożonych do porównania.</param>
        <param name="right">Druga liczba złożonych do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie liczby zespolone są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.Complex> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody zamiast tego.  
  
 Dwie liczby zespolone są równe, jeżeli ich rzeczywistego części są równe, i ich urojone części są takie same. <xref:System.Numerics.Complex.op_Equality%2A> Metoda jest odpowiednikiem następujące wyrażenie:  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 Należy zauważyć, że z powodu różnic w dokładności, dwóch liczb zespolonych, które są równoważne najwyraźniej jest uznawana za nierówne. Aby uzyskać więcej informacji i możliwym obejściem zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje jawnej konwersji między <see cref="T:System.Numerics.Complex" /> obiektu i innego typu.</summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Decimal" /> wartość liczby zespolonej.</summary>
        <returns>Liczby zespolonej, który ma rzeczywisty składnik równa <paramref name="value" /> i urojone części równa zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operatory konwersji jawnej definiować typy, które mogą być konwertowane na <xref:System.Numerics.Complex> obiektu. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.

 Konwersja <xref:System.Decimal> wartości rzeczywistych część liczby zespolonej może spowodować utratę dokładności, ponieważ <xref:System.Double>, który jest typem liczby zespolonej <xref:System.Numerics.Complex.Real%2A> właściwości ma mniej cyfr znaczących niż <xref:System.Decimal>.



## Examples
 W poniższym przykładzie pokazano jawną konwersję <xref:System.Decimal> wartości <xref:System.Numerics.Complex> wartości.

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> wartość liczby zespolonej.</summary>
        <returns>Liczby zespolonej, który ma rzeczywisty składnik równa <paramref name="value" /> i urojone części równa zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operatory konwersji jawnej definiować typy, które mogą być konwertowane na <xref:System.Numerics.Complex> obiektu. Kompilatory języka nie wykonać tę konwersję automatycznie, ponieważ może pociągać za sobą utratę danych. Zamiast tego wykonują konwersję tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie są wyświetlane błędu kompilatora.

 Konwersja <xref:System.Numerics.BigInteger> wartości rzeczywistych część liczby zespolonej może spowodować utratę dokładności, ponieważ <xref:System.Double>, który jest typem liczby zespolonej <xref:System.Numerics.Complex.Real%2A> właściwości ma mniej cyfr znaczących niż <xref:System.Numerics.BigInteger>.

 Jeśli konwersja powiodła się ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> typu operacji nie zgłasza <xref:System.OverflowException>. Zamiast tego Jeśli `value` jest mniejsza niż <xref:System.Double.MinValue>, wynik jest liczbą, która ma <xref:System.Numerics.Complex.Real%2A> wartość właściwości jest równa <xref:System.Double.NegativeInfinity>. Jeśli `value` jest większa niż <xref:System.Double.MaxValue>, wynik jest liczbą, która ma <xref:System.Numerics.Complex.Real%2A> wartość właściwości jest równa <xref:System.Double.PositiveInfinity>.



## Examples
 W poniższym przykładzie pokazano jawną konwersję <xref:System.Numerics.BigInteger> wartości <xref:System.Numerics.Complex> wartości.

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niejawna konwersja między <see cref="T:System.Numerics.Complex" /> obiektu i innego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawnej konwersji wartości bajtu bez znaku liczby zespolonej.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Byte> wartość liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, w których część rzeczywista jest równa <xref:System.Byte> wartość i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje liczby zespolonej niejawną konwersję liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Double> wartość liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, w których część rzeczywista jest równa <xref:System.Double> wartość i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawną konwersję całkowita 16-bitową liczbą.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z całkowita 16-bitową liczbą, jak w poniższym przykładzie pokazano. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista jest równa liczby całkowitej ze znakiem 16-bitowych i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawną konwersję całkowita 32-bitowe liczby zespolonej.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z całkowita 32-bitowe liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista jest równa całkowita 32-bitowa i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawną konwersję całkowita 64-bitowej liczby zespolonej.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z całkowita 64-bitowa liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista jest równa całkowita 64-bitowa i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawnej konwersji wartości bajtowych ze znakiem liczby zespolonej.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z bajtowych ze znakiem liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista jest równa bajtowych ze znakiem i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje liczby zespolonej niejawną konwersję liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z <xref:System.Single> wartość liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, w których część rzeczywista jest równa <xref:System.Single> wartość i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawnej konwersji wartości 16-bitowa liczba całkowita bez znaku liczby zespolonej.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z liczbą całkowitą bez znaku 16-bitową liczbą, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista wynosi liczba całkowita bez znaku 16-bitowych i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawna konwersja 32-bitowa liczba całkowita bez znaku liczby zespolonej.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z liczbą całkowitą bez znaku 32-bitowe liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista wynosi liczba całkowita bez znaku 32-bitowe i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczby zespolonej.</param>
        <summary>Definiuje niejawną konwersję 64-bitowej nieoznaczonej liczby całkowitej liczby zespolonej.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jej część rzeczywistych i zero jako jego urojone części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operator definiowania typów, z których kompilator może automatycznie konwertować <xref:System.Numerics.Complex> obiekt bez jawnego operatora rzutowania (w języku C#) lub wywołać funkcję konwersji (w języku Visual Basic). Są one poszerzeniem konwersji, nie obejmują strat danych, które nie zgłaszają wyjątków <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługi konwersji z liczbą całkowitą bez znaku 64-bitowej liczby zespolonej, co ilustruje poniższy przykład. Należy pamiętać, że wynik konwersji liczby zespolonej, którego część rzeczywista wynosi liczba całkowita bez znaku 64-bitowych i którego urojone części jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie liczby zespolone nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje operacji operator nierówności dla liczby zespolone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 Języki, które nie obsługują operatorów niestandardowych można przetestować pod kątem nierówności, wywołując <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody i cofania jej wartość.  
  
 Należy zauważyć, że z powodu różnic w dokładności, dwóch liczb zespolonych, które są równoważne najwyraźniej jest uznawana za nierówne. Jednym możliwym obejściem jest implementacja metody porównania, która zwraca `true` tylko wtedy, gdy jest to różnica między dwoma rzeczywiste i urojone części liczb zespolonych przekroczy określony próg (np. 01% wartości rzeczywiste i urojone składnika jeden z liczby zespolone). Aby uzyskać więcej informacji, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do pomnożenia.</param>
        <param name="right">Druga wartość do pomnożenia.</param>
        <summary>Mnoży dwie liczby zespolonej określony.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Multiply%2A> Metoda definiuje operacji operator mnożenia dla liczb zespolonych. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 Mnożenie złożony numer + analizy biznesowej, a druga liczba złożonych, c + di, ma następującą postać:  
  
 (ac - bd) + (ad + bc) i  
  
 Jeśli mnożenia powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.Complex.Multiply%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odjęcia od (odjemna).</param>
        <param name="right">Wartość do odjęcia (odjemnik).</param>
        <summary>Odejmuje liczby zespolonej z innej liczby zespolonej.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Subtraction%2A> Metoda definiuje działania operator odejmowania liczb zespolonych. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 Jeśli metoda wyniki wywołania przepełnienie w czasie albo rzeczywiste i urojone części, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Odejmowanie liczby zespolonej, c + di z innej liczby zespolonej, + bi ma następującą postać:  
  
 (c) + (b - d) i  
  
 Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.Complex.Subtract%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Zwraca odwrotność dodatku określonej liczby złożone.</summary>
        <returns>Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki <paramref name="value" /> parametru pomnożona przez wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_UnaryNegation%2A> Metoda definiuje obsługę liczby zespolone Jednoargumentowy operator negacji (odwrotność dodatku). Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 Wynikowy liczby zespolonej generuje wartość <xref:System.Numerics.Complex> 0 (zero), gdy jest ona dodawana do oryginalnego liczby zespolonej. Języki, które nie obsługują operatorów niestandardowych, można wywołać <xref:System.Numerics.Complex.Negate%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera fazy liczbą.</summary>
        <value>Faza liczby zespolonej, w radianach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla liczby zespolonej i analizy biznesowej, fazy jest obliczana jako <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b).  
  
 Można określić liczby zespolonej według współrzędnych Kartezjańskiego na płaszczyźnie złożonych lub jego Współrzędne biegunowe. Faza (argument) liczby zespolonej to kąt do rzeczywistych osi linią od punktu pochodzenia (punkt przecięcia osi x i y) do punktu, reprezentowane przez liczby zespolonej. Wielkość (reprezentowane przez <xref:System.Numerics.Complex.Magnitude%2A> właściwość) jest odległość między punkt początkowy punkt, który jest reprezentowany przez liczby zespolonej.  
  
 Można utworzyć wystąpienia liczby zespolonej, w oparciu o jego Współrzędne biegunowe, zamiast współrzędnych Kartezjańskiego przez wywołanie metody <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody.  
  
 Aby dokonać konwersji w fazie z radianów na stopnie, należy go pomnożyć przez 180 /<xref:System.Math.PI?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodę, aby utworzyć wystąpienia liczby zespolonej oparte na jego Współrzędne biegunowe, a następnie wyświetla wartość jego <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca określoną liczbę złożone podniesioną do określonej potęgi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczby zespolonej podniesione do potęgi.</param>
        <param name="power">Liczba zmiennoprzecinkowa podwójnej precyzji, która określa potęgi.</param>
        <summary>Zwraca określoną liczbę złożone podniesioną do potęgi określonej przez liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Liczby zespolonej <paramref name="value" /> podniesioną do potęgi <paramref name="power" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>. Dla innych wartości Jeśli `power` ma wartość 0, metoda zwraca <xref:System.Numerics.Complex.One?displayProperty=nameWithType>i jeśli `power` wynosi 1, funkcja zwraca `value`.  
  
 Ta metoda odnosi się do <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodę pierwotnych typów liczbowych.  
  
   
  
## Examples  
 Poniższy przykład ilustruje potęgowania przy użyciu liczby zespolonej i wykładnik, którego wartość z zakresu od -1 do 10.  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczby zespolonej podniesione do potęgi.</param>
        <param name="power">Liczba złożonych, która określa potęgi.</param>
        <summary>Zwraca określoną liczbę złożone podniesioną do potęgi określonej przez liczbą.</summary>
        <returns>Liczby zespolonej <paramref name="value" /> podniesioną do potęgi <paramref name="power" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rzeczywisty składnik bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <value>Rzeczywisty składnik liczby zespolonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biorąc pod uwagę liczby zespolonej + analizy biznesowej, <xref:System.Numerics.Complex.Real%2A> właściwość zwraca wartość.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.Complex> obiektów i wyświetla składniki rzeczywiste i urojone każdego w formie + analizy biznesowej.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca odwrotność multiplicative liczbą.</summary>
        <returns>Odwrotność <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwracanie, czyli odwrotność multiplicative liczbą *x* jest liczbą *y* gdzie *x* pomnożona przez *y* daje 1. Odwrotność liczby zespolonej jest liczby zespolonej, która tworzy <xref:System.Numerics.Complex.One?displayProperty=nameWithType> kiedy są mnożone dwóch liczb. Jeśli liczbą jest reprezentowany przez + analizy biznesowej, jego odwrotność jest reprezentowana przez wyrażenie / (<sup>2</sup>+ b<sup>2</sup>) + -b / (<sup>2</sup> + b<sup>2</sup>).  
  
 Jeśli wartość jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>. W przeciwnym razie zwraca wynik wyrażenia <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.Complex.Reciprocal%2A> metoda obliczania wartości wzajemnego kilka liczb zespolonych. Ilustruje też to wynik mnożenia wartości liczby zespolonej przez jego odwrotność <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca sinus liczby zespolonej określony.</summary>
        <returns>Sinus <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Sin%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Sin%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Sin%2A> Metoda używa następującej formuły można obliczyć sinus liczby zespolonej + bi:  
  
 (<xref:System.Math.Sin%2A>() * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>() * <xref:System.Math.Sinh%2A>(b))  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Sin%2A> metody. Pokazuje, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Asin%2A> metody <xref:System.Numerics.Complex.Sin%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca sinus hiperboliczny liczby zespolonej określony.</summary>
        <returns>Sinus hiperboliczny liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Sinh%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Sinh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Sinh%2A> Metoda używa następującej formuły można obliczyć sinus hiperboliczny liczby zespolonej + bi:  
  
 (<xref:System.Math.Sinh%2A>() * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>() * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca pierwiastek kwadratowy liczby zespolonej określony.</summary>
        <returns>Pierwiastek kwadratowy liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwiastek kwadratowy liczby zespolonej `value` jest obliczana przy użyciu następującej formuły:  
  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)   
  
 <xref:System.Numerics.Complex.Sqrt%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odjęcia od (odjemna).</param>
        <param name="right">Wartość do odjęcia (odjemnik).</param>
        <summary>Odejmuje jeden liczby zespolonej z innego i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odejmowanie liczby zespolonej, c + di z innej liczby zespolonej, + bi ma następującą postać:  
  
 (c) + (b - d) i  
  
 Jeśli metoda wyniki wywołania przepełnienie w czasie albo rzeczywiste i urojone części, wartość danego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Można używać języków, które nie obsługują operatorów niestandardowych <xref:System.Numerics.Complex.Subtract%2A> metodę w celu przy użyciu liczb zespolonych odejmowania.  
  
   
  
## Examples  
 Poniższy przykład odejmuje każdej liczby zespolonej w tablicy z liczbą.  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca tangens liczby zespolonej określony.</summary>
        <returns>Tangens <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Tan%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Tan%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Tan%2A> Metoda używa następującej formuły można obliczyć tangens liczby zespolonej `value`:  
  
 <xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Numerics.Complex.Tan%2A> metody. Pokazuje, przekazując wartość zwrócona przez obiekt <xref:System.Numerics.Complex.Atan%2A> metody <xref:System.Numerics.Complex.Tan%2A> metoda zwraca oryginalny <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczbą.</param>
        <summary>Zwraca tangens hiperboliczny liczby zespolonej określony.</summary>
        <returns>Tangens hiperboliczny liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Tanh%2A> Metodę dla liczby zespolone odnosi się do <xref:System.Math.Tanh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Tanh%2A> Metoda używa następującej formuły można obliczyć tangens hiperboliczny dla liczby zespolonej `value`:  
  
 <xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczby zespolonej na jego reprezentację ciągu równoważnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jego reprezentację ciągu równoważnego w postaci kartezjańskich wizualizacji.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w postaci kartezjańskich wizualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja ciągu domyślnej liczby zespolonej Wyświetla liczbę przy użyciu współrzędnych kartezjańskich wizualizacji w formie `(` ** `,` *b*`)`, gdzie ** jest częścią rzeczywistych liczby zespolonej i *b* jest jej urojone części. Zarówno ** i *b* są formatowane przy użyciu specyfikatora formatu ogólnego ("G") i Konwencji bieżącej kultury systemu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla ciąg reprezentujący kilka liczb zespolonych. Dane wyjściowe użyto Konwencji formatowania Angielski — Stany Zjednoczone ("en US") kultury, która w tym przypadku jest bieżącą kulturą systemu.  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jego reprezentację ciągu równoważnego w postaci kartezjańskich wizualizacji przy użyciu określonego specyficzne dla kultury informacje o formatowaniu.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w formie Kartezjańskiego, określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa liczby zespolonej zwracanego przez tę metodę przedstawia liczbę przy użyciu współrzędnych kartezjańskich wizualizacji w formie `(` ** `,` *b*`)`, gdzie ** jest częścią rzeczywistych liczby zespolonej i *b* jest jej urojone części. Zarówno ** i *b* są formatowane przy użyciu specyfikatora formatu ogólnego ("G") i Konwencji kultury definicją `provider`.  
  
 `provider` Parametr <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie real a imaginery liczb w zwracanym ciągu. Jeśli `provider` jest `null`, zwracanego ciągu jest formatowana przy użyciu <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.  
  
 `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla ciąg reprezentujący kilka liczb zespolonych. Wynik używa konwencji formatowania Angielski - Stany Zjednoczone ("en US") i Francuski — Francja ("fr-FR") kultur.  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jego reprezentację ciągu równoważnego w postaci kartezjańskich wizualizacji przy użyciu określonego formatu dla jego rzeczywiste i urojone części.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w postaci kartezjańskich wizualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa liczby zespolonej zwracanego przez tę metodę przedstawia liczbę przy użyciu współrzędnych kartezjańskich wizualizacji w formie `(` ** `,` *b*`)`, gdzie ** jest częścią rzeczywistych liczby zespolonej i *b* jest jej urojone części. Zarówno ** i *b* są formatowane przy użyciu ciągu formatu określony przez `format`. `format` Parametr może być dowolnym prawidłowy standardowy specyfikator formatu liczbowego lub dowolna kombinacja specyfikatorów niestandardowego formatu liczb. Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, rzeczywiste i urojone części liczb zespolonych są formatowane przy użyciu specyfikatora formatu ogólnego ("G"). Jeśli `format` ma jakąkolwiek inną wartość, metoda zgłasza wyjątek <xref:System.FormatException>.  
  
 .NET Framework zapewnia rozbudowaną obsługę formatowania, który jest opisany bardziej szczegółowo w następujących tematach:  
  
-   Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Format zwracanego ciągu jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury. W zależności od `format` parametr, ten obiekt kontroluje symbole takie jak znak ujemny, separator grupy i symbol seperatora dziesiętnego w ciągu wyjściowym. Aby podać informacje o formatowaniu dla języków innych niż bieżącej kultury, należy wywołać <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład inicjuje liczby zespolonej i wyświetla je przy użyciu kilka ciągów formatu standardowego.  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest ciągiem nieprawidłowy format.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jego reprezentację ciągu równoważnego w postaci kartezjańskich wizualizacji przy użyciu podanego formatu i informacji o formacie specyficzne dla kultury dla jego rzeczywiste i urojone części.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w formie Kartezjańskiego, określony przez <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja tekstowa liczby zespolonej zwracanego przez tę metodę przedstawia liczbę przy użyciu współrzędnych kartezjańskich wizualizacji w formie `(` ** `,` *b*`)`, gdzie ** jest częścią rzeczywistych liczby zespolonej i *b* jest jej urojone części. Zarówno ** i *b* są formatowane przy użyciu ciągu formatu określony przez `format`. `format` Parametr może być dowolnym prawidłowy standardowy specyfikator formatu liczbowego lub dowolna kombinacja specyfikatorów niestandardowego formatu liczb. Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, rzeczywiste i urojone części liczb zespolonych są formatowane przy użyciu specyfikatora formatu ogólnego ("G"). Jeśli `format` ma jakąkolwiek inną wartość, metoda zgłasza wyjątek <xref:System.FormatException>.  
  
 .NET Framework zapewnia rozbudowaną obsługę formatowania, który jest opisany bardziej szczegółowo w następujących tematach:  
  
-   Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Parametr <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje specyficzne dla kultury o formacie real a imaginery liczb w zwracanym ciągu. W zależności od `format` parametr, ten obiekt kontroluje symbole takie jak znak ujemny, separator grupy i symbol seperatora dziesiętnego w ciągu wyjściowym. Jeśli `provider` jest `null`, zwracanego ciągu jest formatowana przy użyciu <xref:System.Globalization.NumberFormatInfo> obiekt bieżącej kultury.  
  
 `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który dostarcza informacje o formatowaniu.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę liczb zespolonych i wyświetla każdy przy użyciu kilka ciągów formatu standardowego także <xref:System.Globalization.CultureInfo> obiektami, które reprezentują kultury Angielski — Stany Zjednoczone ("en US") i Francuski — Francja ("fr-FR").  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest ciągiem nieprawidłowy format.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienie z liczbą rzeczywistą równa zero i liczbą imaginery równa zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Zero> Jest najczęściej używana do porównania <xref:System.Numerics.Complex> wartość zero.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości za pomocą <xref:System.Numerics.Complex.Zero> właściwości. Następnie porównuje tę wartość na inną wartość, który zostanie uruchomiony, wywołując <xref:System.Numerics.Complex> konstruktora z rzeczywistych równa zero i urojone część równa zero. Dane wyjściowe z przykładu pokazują, dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>
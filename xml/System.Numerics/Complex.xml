<Type Name="Complex" FullName="System.Numerics.Complex">
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje liczbę zespoloną.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba zespolona to liczba, która składa się z części liczby rzeczywistej i części urojonej. Liczba złożona z jest zwykle zapisywana w postaci z = x + yi, gdzie *x* i *y* są liczbami rzeczywistymi, a *jestem* jednostką urojoną, która ma właściwość *i*<sup>2</sup> =-1. Rzeczywista część liczby zespolonej jest reprezentowana przez *x*, a część urojona liczby zespolonej jest reprezentowana przez *y*.  
  
 <xref:System.Numerics.Complex> Typ używa układu współrzędnych kartezjańskiego (rzeczywistą, urojoną) podczas tworzenia wystąpienia i manipulowania liczbami złożonymi. Liczba zespolona może być reprezentowana jako punkt w dwuwymiarowym układzie współrzędnych, który jest znany jako Płaszczyzna złożona. Rzeczywista część liczby zespolonej jest umieszczana na osi x (osi poziomej), a część urojona jest umieszczana na osi y (oś pionowa).  
  
 Każdy punkt w płaszczyźnie złożonej może być również wyrażony na podstawie jego wartości bezwzględnej przy użyciu układu współrzędnych biegunowych. We współrzędnych polarnych punkt jest scharakteryzowany przez dwie liczby:  
  
-   Jego wielkość, czyli odległość punktu od początku (to jest, 0, 0, lub punkt, w którym oś x i oś y przecinają).  
  
-   Jej faza, która jest kątem między osią rzeczywistą i linią pochodzącą od początku do punktu.  
  
## <a name="instantiating-a-complex-number"></a>Utworzenie wystąpienia liczby zespolonej  
 Można przypisać wartość do liczby zespolonej w jeden z następujących sposobów:  
  
-   Przekazując dwie <xref:System.Double> wartości do jego konstruktora. Pierwsza wartość reprezentuje rzeczywistą część liczby zespolonej, a druga wartość reprezentuje jej część urojoną. Te wartości reprezentują pozycję liczby zespolonej w dwuwymiarowym układzie współrzędnych kartezjańskiego.  
  
-   Wywołując metodę static (`Shared` w Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> , aby utworzyć liczbę zespoloną na podstawie współrzędnych biegunowych.  
  
-   <xref:System.Byte>Przypisanie, ,,<xref:System.UInt64> ,,<xref:System.Numerics.Complex> ,,,, lub doobiektu.<xref:System.Double> <xref:System.UInt16> <xref:System.Int32> <xref:System.UInt32> <xref:System.Int16> <xref:System.SByte> <xref:System.Int64> <xref:System.Single> Wartość jest rzeczywistą częścią liczby zespolonej, a jej część urojona jest równa 0.  
  
-   Przez rzutowanie ( C#in) lub konwertowanie (w Visual Basic) <xref:System.Decimal> a <xref:System.Numerics.BigInteger> <xref:System.Numerics.Complex> lub wartości do obiektu. Wartość jest rzeczywistą częścią liczby zespolonej, a jej część urojona jest równa 0.  
  
-   Przypisanie liczby zespolonej zwracanej przez metodę lub operator do <xref:System.Numerics.Complex> obiektu. Na przykład <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> jest metodą statyczną zwracającą liczbę zespoloną, która jest sumą dwóch liczb zespolonych, <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> a operator dodaje dwie liczby zespolone i zwraca wynik.  
  
 Poniższy przykład ilustruje każdy z tych pięciu sposobów przypisywania wartości do liczby zespolonej.  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a>Operacje na liczbach zespolonych  
 <xref:System.Numerics.Complex> Struktura w .NET Framework zawiera elementy członkowskie, które zapewniają następujące funkcje:  
  
-   Metody porównywania dwóch liczb zespolonych, aby określić, czy są równe.  
  
-   Operatory wykonywania operacji arytmetycznych na liczbach złożonych. <xref:System.Numerics.Complex>Operatory umożliwiają dodawanie, odejmowanie, mnożenie, dzielenie i jednoargumentowe negację z liczbami złożonymi.  
  
-   Metody wykonywania innych operacji numerycznych na liczbach zespolonych. Oprócz czterech podstawowych operacji arytmetycznych można podnieść liczbę zespoloną do określonej potęgi, znaleźć pierwiastek kwadratowy liczby zespolonej i uzyskać wartość bezwzględną liczby zespolonej.  
  
-   Metody wykonywania operacji trygonometrycznych na liczbach zespolonych. Na przykład można obliczyć tangens kąta reprezentowanego przez liczbę zespoloną.  
  
 Należy zauważyć, że ponieważ <xref:System.Numerics.Complex.Real%2A> właściwości <xref:System.Numerics.Complex.Imaginary%2A> i są tylko do odczytu, nie można zmodyfikować wartości istniejącego <xref:System.Numerics.Complex> obiektu.  Wszystkie metody, które wykonują operacje na <xref:System.Numerics.Complex> liczbie, jeśli ich wartość zwracana jest typu <xref:System.Numerics.Complex>, zwracają nowy <xref:System.Numerics.Complex> numer.  
  
## <a name="precision-and-complex-numbers"></a>Precyzja i liczby zespolone  
 Rzeczywiste i urojone części liczby zespolonej są reprezentowane przez dwie wartości zmiennoprzecinkowe podwójnej precyzji. Oznacza to, <xref:System.Numerics.Complex> że wartości, takie jak wartości zmiennoprzecinkowe podwójnej precyzji, mogą utracić dokładność w wyniku operacji numerycznych. Oznacza to, że ścisłe porównania dla równości <xref:System.Numerics.Complex> dwóch wartości mogą zakończyć się niepowodzeniem, nawet jeśli różnica między tymi dwiema wartościami jest spowodowana utratą precyzji. Aby uzyskać więcej informacji, zobacz <xref:System.Double>.  
  
 Na przykład wykonywanie potęgowania na logarytmie liczby powinno zwracać pierwotną liczbę. Jednak w niektórych przypadkach utrata dokładności wartości zmiennoprzecinkowych może spowodować niewielkie różnice między tymi dwiema wartościami, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 Podobnie Poniższy przykład, który oblicza pierwiastek kwadratowy <xref:System.Numerics.Complex> liczby, tworzy nieco inne wyniki na 32-bitowej i ia64 wersjach .NET Framework.  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a>Liczby zespolone, nieskończoność i NaN  
 Rzeczywiste i urojone części liczby zespolonej są reprezentowane przez <xref:System.Double> wartości. Oprócz <xref:System.Double.MinValue?displayProperty=nameWithType> zakresu od <xref:System.Double.NaN?displayProperty=nameWithType>do <xref:System.Double.MaxValue?displayProperty=nameWithType>, rzeczywista lub urojona część liczby zespolonej <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>może mieć wartość, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> i<xref:System.Double.NaN?displayProperty=nameWithType> wszystkie są propagowane w każdej operacji arytmetycznej lub trygonometrycznej.  
  
 W poniższym przykładzie dzielenie przez <xref:System.Numerics.Complex.Zero> tworzy liczbę zespoloną, której elementy rzeczywiste i urojone są oba. <xref:System.Double.NaN?displayProperty=nameWithType> W efekcie wykonywanie mnożenia z tą wartością również daje liczbę zespoloną, której części rzeczywiste i urojone są <xref:System.Double.NaN?displayProperty=nameWithType>. Podobnie wykonywanie operacji mnożenia, która przepełni zakres <xref:System.Double> typu, daje liczbę zespoloną, której część rzeczywista jest <xref:System.Double.NaN?displayProperty=nameWithType> i której części urojonej jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Następnie wykonanie dzielenia przy użyciu tej liczby zespolonej zwraca liczbę zespoloną, której <xref:System.Double.NaN?displayProperty=nameWithType> część rzeczywista jest i której <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>części urojonej jest.  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 Operacje matematyczne ze złożonymi liczbami, które są nieprawidłowe lub które przepełnią zakres <xref:System.Double> typu danych, nie generują wyjątku. Zamiast tego zwracają <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>lub <xref:System.Double.NaN?displayProperty=nameWithType> w następujących warunkach:  
  
-   Dzielenie liczby dodatniej przez zero zwraca wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
-   Każda operacja, która przepełni górną granicę <xref:System.Double> zwracanego <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>typu danych.  
  
-   Dzielenie ujemnej liczby przez zero zwraca wartość <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
-   Każda operacja, która przepełniła dolną granicę <xref:System.Double> zwracanego <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>typu danych.  
  
-   Podział wartości zerowej przez zero zwraca wartość <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
-   Każda operacja wykonywana w przypadku operandów, których wartości to <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>lub <xref:System.Double.NaN?displayProperty=nameWithType>, w zależności od określonej operacji.  
  
 Należy zauważyć, że dotyczy to wszelkich obliczeń pośrednich wykonanych przez metodę. Na przykład mnożenia `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` używa formuły (AC-BD) + (AD + BC) i. Obliczenie składnika rzeczywistego, który powstał w wyniku mnożenia, oblicza wyrażenie 9e308 * 2,5-9e308 * 3,5. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>Każde pośrednie mnożenie w tym wyrażeniu zwraca i próba odejmowania <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> od <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Return. <xref:System.Double.NaN?displayProperty=nameWithType>  
  
## <a name="formatting-a-complex-number"></a>Formatowanie liczby zespolonej  
 `(`Domyślnie ciąg reprezentujący liczbę zespoloną przyjmuje postać`)` *rzeczywistej* `,` <xref:System.Double> *urojonej*, gdzie *rzeczywiste* i urojone są ** reprezentacjami ciągu wartości, które tworzą rzeczywiste i urojone składniki liczby zespolonej. Niektóre przeciążenia <xref:System.Numerics.Complex.ToString%2A> metody umożliwiają dostosowanie ciągu reprezentacji tych <xref:System.Double> wartości w celu odzwierciedlenia Konwencji formatowania określonej kultury lub wyświetlania w określonym formacie zdefiniowanym przez standardową lub niestandardową wartość ciąg formatu. (Aby uzyskać więcej informacji, zobacz [Standardowe ciągi formatujące numeryczne](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatu niestandardowego](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
 Jednym z najpopularniejszych sposobów wyrażania ciągu reprezentującego liczbę zespoloną jest forma a + bi, gdzie a to prawdziwy składnik liczby zespolonej, a b to składnik urojony liczby zespolonej. W inżynierii elektrycznej liczba złożona jest najczęściej wyrażona jako + BJ. Można zwrócić ciąg reprezentujący liczbę zespoloną w jednej z tych dwóch form. Aby to zrobić, zdefiniuj niestandardowego dostawcę formatowania <xref:System.ICustomFormatter> <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> , implementując interfejsy i <xref:System.IFormatProvider> , a następnie Wywołaj metodę.  
  
 W poniższym przykładzie zdefiniowano `ComplexFormatter` klasę, która reprezentuje liczbę zespoloną jako ciąg w postaci a + bi lub + BJ.  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 Poniższy przykład używa tego niestandardowego programu formatującego do wyświetlania ciągu reprezentującego liczbę zespoloną.  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">Rzeczywista część liczby zespolonej.</param>
        <param name="imaginary">Część urojona liczby zespolonej.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Numerics.Complex" /> struktury przy użyciu określonych wartości rzeczywistych i urojonych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Argumenty `real` <xref:System.Double>lub `imaginary` mogą utracić precyzję, jeśli są typami danych, które wymagają jawnego rzutowania do.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie dwóch liczb zespolonych, a następnie używa ich w operacjach dodawania, odejmowania, mnożenia i dzielenia.  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Pobiera wartość bezwzględną (lub wielkości) liczby zespolonej.</summary>
        <returns>Wartość bezwzględna <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna liczby zespolonej jest równoważna z <xref:System.Numerics.Complex.Magnitude%2A> jej właściwością. Wartość bezwzględna liczby rzeczywistej a + bi jest obliczana w następujący sposób:  
  
-   Jeśli b = 0, wynik wynosi 0.  
  
-   Jeśli > b, wynikiem jest *<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).  
  
-   Jeśli b > a, wynikiem jest b * <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).  
  
 Jeśli Obliczanie wartości bezwzględnej powoduje przepełnienie, metoda zwraca albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Numerics.Complex.Imaginary%2A> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType>Jeśli właściwość <xref:System.Numerics.Complex.Real%2A> or ma<xref:System.Double.NaN?displayProperty=nameWithType> wartość, a druga właściwość nie jest ani ani, metoda zwraca.  
  
   
  
## Examples  
 Poniższy przykład oblicza wartość bezwzględną liczby zespolonej i pokazuje, że jest ona równoważna z wartością <xref:System.Numerics.Complex.Magnitude%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zespolona reprezentująca cosinus.</param>
        <summary>Zwraca kąt, który jest cosinusem łuku określonego numeru zespolonego.</summary>
        <returns>Kąt mierzony w radianach, który jest cosinusem <paramref name="value" />łuku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Acos%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Acos%2A>  
  
 <xref:System.Numerics.Complex.Acos%2A> Metoda używa następującej formuły:  
  
 (-<xref:System.Numerics.Complex.ImaginaryOne>) * <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` * `value`)))    
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Acos%2A> metodę. Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <Docs>
        <summary>Dodaje określoną liczbę do innej określonej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <xref:System.Numerics.Complex.Add%2A> Metody umożliwiają wykonywanie operacji dodawania, które obejmują liczby zespolone. 
  
 Jeśli metoda wywołuje wyniki w przepełnieniu w składniku rzeczywistym lub urojonym, wartość składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>  
  
 W językach, które nie obsługują niestandardowych operatorów, <xref:System.Numerics.Complex.Add%2A> można używać metody do dodawania liczb złożonych.  

 <xref:System.Numerics.Complex.Add%2A> Metody, które odbierają jeden podwójnie są wydajniejsze niż metody, które odbierają dwie liczby zespolone.
  
## Examples  

 Poniższy przykład ilustruje Dodawanie liczb złożonych.  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość rzeczywista podwójnej precyzji do dodania.</param>
        <param name="right">Wartość złożona do dodania.</param>
        <summary>Dodaje liczbę rzeczywistą o podwójnej precyzji do liczby zespolonej i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Dodanie liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczby zespolonej (c + di) przyjmuje następującą formę:

(a + c) + di
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona do dodania.</param>
        <param name="right">Wartość rzeczywista podwójnej precyzji do dodania.</param>
        <summary>Dodaje liczbę zespoloną do liczby rzeczywistej o podwójnej precyzji i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Dodanie liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:

(a + c) + BI
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba zespolona do dodania.</param>
        <param name="right">Druga liczba zespolona do dodania.</param>
        <summary>Dodaje dwie liczby zespolone i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodanie liczby zespolonej, a + bi i drugiej liczby zespolonej, c + di, ma następującą postać:  
  
 (a + c) + (b + d) i.  

  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca kąt, który jest sinusem łuku określonego numeru zespolonego.</summary>
        <returns>Kąt, który jest sinusem <paramref name="value" />łuku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Asin%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Asin%2A>  
  
 <xref:System.Numerics.Complex.Asin%2A> Metoda używa następującej formuły:  
  
 -<xref:System.Numerics.Complex.ImaginaryOne> * <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> * wartość + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -Value * wartość))    
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Asin%2A> metodę. Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca kąt, który jest tangens łuku określonego numeru zespolonego.</summary>
        <returns>Kąt, który jest tangens <paramref name="value" />łuku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Atan%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Atan%2A>  
  
 <xref:System.Numerics.Complex.Atan%2A> Metoda używa następującej formuły:  
  
 (<xref:System.Numerics.Complex.ImaginaryOne> /New Complex (2.0, 0,0)) * (<xref:System.Numerics.Complex.Log%2A><xref:System.Numerics.Complex.ImaginaryOne> (<xref:System.Numerics.Complex.One>  -  * wartość)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne * Value))   
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Atan%2A> metodę. Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Oblicza sprzężenie liczby zespolonej i zwraca wynik.</summary>
        <returns>Sprzężenie <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprzężenie liczby zespolonej odwraca znak części urojonej; oznacza to, że stosuje jednoargumentowe negację do części urojonej. Jeśli program + BI jest liczbą zespoloną, jej sprzężenie jest typu-BI.  
  
   
  
## Examples  
 Poniższy przykład wyświetla sprzężenie dwóch liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca cosinus podanej liczby zespolonej.</summary>
        <returns>Cosinus <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Cos%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Cos%2A>  
  
 <xref:System.Numerics.Complex.Cos%2A> Metoda używa następującej formuły, aby obliczyć cosinus liczby zespolonej a + bi:  
  
 (<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Acos%2A> metodę. Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca cosinus hiperboliczny podanej liczby zespolonej.</summary>
        <returns>Cosinus hiperboliczny <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Cosh%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Cosh%2A>  
  
 <xref:System.Numerics.Complex.Cosh%2A> Metoda używa następującej formuły, aby obliczyć cosinus hiperboliczny liczby zespolonej a + bi:  
  
 (<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <Docs>
        <summary>Dzieli określoną liczbę przez inny określony numer, gdzie co najmniej jeden z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <xref:System.Numerics.Complex.Divide%2A> Metody umożliwiają wykonywanie operacji dzielenia, które obejmują liczby zespolone. 
  
 Jeśli obliczenie ilorazu spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>  
  
 <xref:System.Numerics.Complex.Divide%2A> Metoda może być używana przez Języki, które nie obsługują operatorów niestandardowych. Zachowanie jest takie samo jak w przypadku dzielenia przy użyciu operatora dzielenia.  

 <xref:System.Numerics.Complex.Divide%2A> Metody, które odbierają jeden podwójnie są wydajniejsze niż metody, które odbierają dwie liczby zespolone.

## Examples  
 Poniższy przykład dzieli liczbę zespoloną przez każdy element w tablicy liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
   
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (double dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(float64 dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Double, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(double dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="dividend">Liczba rzeczywista podwójnej precyzji, która ma zostać podzielona.</param>
        <param name="divisor">Liczba złożona do podzielenia przez.</param>
        <summary>Dzieli jedną liczbę rzeczywistą o podwójnej precyzji przez liczbę zespoloną i zwraca wynik.</summary>
        <returns>Iloraz dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Podział liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:

 (AC/(c<sup>2</sup> + d<sup>2</sup>)) + (AD/(c<sup>2</sup> + d<sup>2</sup>) i

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, double divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, float64 divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, double divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="divisor" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="dividend">Liczba zespolona, która ma zostać podzielona.</param>
        <param name="divisor">Liczba rzeczywista podwójnej precyzji do podzielenia przez.</param>
        <summary>Dzieli jedną liczbę zespoloną przez liczbę rzeczywistą o podwójnej precyzji i zwraca wynik.</summary>
        <returns>Iloraz dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Podział liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:

 (AC/c<sup>2</sup>) + (BC/c<sup>2</sup>) i

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">Liczba zespolona, która ma zostać podzielona.</param>
        <param name="divisor">Liczba złożona do podzielenia przez.</param>
        <summary>Dzieli jedną liczbę zespoloną przez inną i zwraca wynik.</summary>
        <returns>Iloraz dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzielenie liczby zespolonej z + BI, przez drugą liczbę zespoloną, Number, c + di, ma następującą postać:  
  
 ((AC + BD)/(c<sup>2</sup> + d<sup>2</sup>)) + ((BC-AD)/(c<sup>2</sup> + d<sup>2</sup>) i  
    
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie liczby zespolone są równe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba zespolona do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określona liczba złożona mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli ta liczba złożona i <paramref name="value" /> ma tę samą wartość; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia implementację <xref:System.Numerics.Complex>struktury. <xref:System.IEquatable%601> <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Jest wykonywane nieco lepiej niż <xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda, ponieważ nie musi skonwertować jej parametru na liczbę zespoloną.  
  
 Dwie liczby zespolone są równe, jeśli ich rzeczywiste części są równe, a ich części urojone są równe. <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda jest równoważna z następującym wyrażeniem:  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> Użyj metody z zachowaniem ostrożności, ponieważ dwie wartości, które są uważane za równoważne mogą być uznawane za nierówne ze względu na zróżnicowaną precyzję ich rzeczywistych i urojonych składników. Następujące przykładowe raporty <c>(3,33333, 0,142857)</c> i <c>(10/3, 1/7)</c> nie są równe.  
  
[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)] 
Jedną z zalecanych technik jest zdefiniowanie akceptowalnego marginesu różnicy między tymi dwiema wartościami (na przykład .01% jednego z wartości rzeczywistych i urojonych) zamiast porównywania wartości dla równości. Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza lub równa marginesowi, różnica jest prawdopodobnie spowodowana różnicą precyzji i dlatego wartości mogą być równe. Poniższy przykład korzysta z tej techniki, aby porównać dwie wartości złożone, których poprzedni przykład kodu nie jest równy. Znaleziono dwie liczby zespolone jako równe.  
  
[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określony obiekt mają tę samą wartość.</summary>
        <returns><see langword="true" /><see langword="false" /> <see cref="T:System.Numerics.Complex" /> <see cref="T:System.Numerics.Complex" /> Jeśli parametr jest obiektem lub typem umożliwiającym niejawną konwersję do obiektu, a jego wartość jest równa bieżącemu obiektowi; w przeciwnym razie,. <see cref="T:System.Numerics.Complex" /> <paramref name="obj" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwie liczby zespolone są równe, jeśli ich rzeczywiste części są równe, a ich części urojone są równe. <xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda jest równoważna z następującym wyrażeniem:  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <xref:System.Numerics.Complex> <xref:System.Numerics.Complex.Equals%28System.Object%29> `obj` Jeśli parametr nie jest obiektem,alejesttypemdanych,dlaktóregozdefiniowanoniejawnąkonwersję,Metodakonwertujedoobiektu,któregoczęśćrzeczywistajestrównawartości<xref:System.Numerics.Complex> `obj` `obj`i których część urojona jest równa zero przed przeprowadzeniem porównania. Poniższy przykład ilustruje to poprzez znalezienie, że liczba zespolona i wartość zmiennoprzecinkową o podwójnej precyzji są równe.  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> Użyj metody z zachowaniem ostrożności, ponieważ dwie wartości, które są uważane za równoważne mogą być uznawane za nierówne ze względu na zróżnicowaną precyzję ich rzeczywistych i urojonych składników. Problem może być accentuated, jeśli <paramref name="obj" /> musi zostać przekonwertowany na <see cref="T:System.Double" /> a przed przeprowadzeniem porównania. Poniższy przykład porównuje liczbę zespoloną, której prawdziwy składnik wydaje się być równy <see cref="T:System.Single" /> wartości tej <see cref="T:System.Single" /> wartości. Jak widać, porównanie dla zwracanych <see langword="False" />danych.  
  
[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)] 
Jedną z zalecanych technik jest zdefiniowanie akceptowalnego marginesu różnicy między tymi dwiema wartościami (na przykład .01% jednego z wartości rzeczywistych i urojonych) zamiast porównywania wartości dla równości. Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza lub równa marginesowi, różnica jest prawdopodobnie spowodowana różnicą precyzji i dlatego wartości mogą być równe. Poniższy przykład korzysta z tej techniki, aby porównać dwie wartości, które nie zostały odnalezione przez poprzedni przykład kodu. Teraz znajdzie je na równe.  
  
[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona, która określa potęgę.</param>
        <summary>Zwraca <see langword="e" /> wartość podniesioną do potęgi określonej przez liczbę zespoloną.</summary>
        <returns>Liczba <see langword="e" /> podniesiona do potęgi <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Pow%2A> Użyj metody, aby obliczyć uprawnienia innych baz.  
  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Exp%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Exp%2A> <xref:System.Numerics.Complex.Exp%2A>jest odwrotnością <xref:System.Numerics.Complex.Log%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Exp%2A> metodę. Pokazuje to <xref:System.Double> , że z pewnym <xref:System.Numerics.Complex.Log%2A> wpływem na brak dokładności typu danych, przekazując wartość zwróconą przez metodę do <xref:System.Numerics.Complex.Exp%2A> metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">Wartość, czyli odległość od początku (część wspólna osi x i oś y) do liczby.</param>
        <param name="phase">Faza, która jest kątem od linii do osi poziomej, mierzona w radianach.</param>
        <summary>Tworzy liczbę zespoloną na podstawie współrzędnych bieguna punktu.</summary>
        <returns>Liczba złożona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Metoda tworzy wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych.  
  
 Ponieważ istnieje wiele reprezentacji punktu na złożonej płaszczyźnie, wartość <xref:System.Numerics.Complex.FromPolarCoordinates%2A> zwracana metody jest znormalizowana. Wartość jest znormalizowana na liczbę dodatnią, a faza jest znormalizowana do wartości z zakresu od<xref:System.Math.PI> do. <xref:System.Math.PI> W związku z tym <xref:System.Numerics.Complex.Phase%2A> wartości i <xref:System.Numerics.Complex.Magnitude%2A> właściwości wynikowej liczby zespolonej nie mogą być równe oryginalnymi wartościom `magnitude` parametrów i `phase` .  
  
 Aby przekonwertować wartość z stopni na radiany dla `phase` parametru, pomnóż ją przez <xref:System.Math.PI?displayProperty=nameWithType>/180.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodę w celu utworzenia wystąpienia liczby zespolonej na podstawie współrzędnych bieguna, a następnie <xref:System.Numerics.Complex.Magnitude%2A> wyświetlenia <xref:System.Numerics.Complex.Phase%2A> wartości właściwości i.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik urojony bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <value>Składnik urojony liczby zespolonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwzględniając liczbę zespoloną a + bi, <xref:System.Numerics.Complex.Imaginary%2A> Właściwość zwraca wartość b.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie tablicy <xref:System.Numerics.Complex> obiektów i wyświetla rzeczywiste i urojone składniki każdego z nich w formie a + bi.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowe <see cref="T:System.Numerics.Complex" /> wystąpienie o liczbie rzeczywistej równej zero i liczbie urojonej równej jednemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości przy <xref:System.Numerics.Complex.ImaginaryOne> użyciu właściwości. Następnie porównuje tę wartość z inną wartością, która jest tworzona przez wywołanie <xref:System.Numerics.Complex> konstruktora z częścią rzeczywistą równą zero i części urojonej równej jednej. Ponieważ dane wyjściowe z przykładu są wyświetlane, te dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Infinity" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Infinity As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Infinity;" />
      <MemberSignature Language="F#" Value=" staticval mutable Infinity : System.Numerics.Complex" Usage="System.Numerics.Complex.Infinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje nieskończoność jako liczbę zespoloną.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsFinite(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsFinite : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsFinite value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Określa, czy określony numer złożony jest skończona.</summary>
        <returns><see langword="true" />Jeśli obie wartości, rzeczywiste i urojone części są ograniczone (zero, subnormal lub Normal); w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInfinity value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca wartość wskazującą, czy określona liczba złożona ma być wartością nieskończoną.</summary>
        <returns><see langword="true"/>w przypadku obu, części rzeczywistej lub urojonej <see cref="F:System.Double.PositiveInfinity" /> są <see cref="F:System.Double.NegativeInfinity" />lub; w <see langword="false"/>przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNaN(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsNaN : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNaN value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca wartość wskazującą, czy określone wystąpienie złożone nie jest liczbą (NaN).</summary>
        <returns><see langword="true"/>Jeśli określona wartość nie jest skończona ani nieskończona; w przeciwnym razie. <see langword="false"/></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca logarytm liczby zespolonej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca logarytm naturalny (podstawowy <see langword="e" />) podanej liczby zespolonej.</summary>
        <returns>Logarytm naturalny (podstawowy <see langword="e" />) elementu. <paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29>  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Log%2A> metodę. Pokazuje to <xref:System.Double> , że z pewnym <xref:System.Numerics.Complex.Log%2A> wpływem na brak dokładności typu danych, przekazując wartość zwróconą przez metodę do <xref:System.Numerics.Complex.Exp%2A> metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <param name="baseValue">Podstawa logarytmu.</param>
        <summary>Zwraca logarytm o określonej liczbie zespolonej w określonej bazie.</summary>
        <returns>LOGARYTM <paramref name="value" /> w elemencie Base <paramref name="baseValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca logarytm dziesiętny dla podanej liczby zespolonej.</summary>
        <returns>Logarytm dziesiętny <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Log10%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość (lub bezwzględną) liczby zespolonej.</summary>
        <value>Wielkość bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Magnitude%2A> Właściwość jest równoważna z wartością bezwzględną liczby zespolonej. Określa odległość od początku (część wspólna osi x i oś y w układzie współrzędnych kartezjańskiego) do dwuwymiarowego punktu reprezentowanego przez liczbę zespoloną. Wartość bezwzględna jest obliczana w następujący sposób:  
  
 &#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)  
  
 Jeśli Obliczanie wartości bezwzględnej spowoduje przepełnienie, ta właściwość zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> albo lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>  
  
 <xref:System.Numerics.Complex.Magnitude%2A> Iwłaściwościdefiniująpozycjępunktu,któryreprezentujeliczbęzespolonąwukładziewspółrzędnych<xref:System.Numerics.Complex.Phase%2A> biegunowych.  
  
 Można utworzyć wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych zamiast jej współrzędnych kartezjańskiego <xref:System.Numerics.Complex.FromPolarCoordinates%2A> przez wywołanie metody.  
  
   
  
## Examples  
 Poniższy przykład oblicza wartość bezwzględną liczby zespolonej i pokazuje, że jest ona równoważna z wartością <xref:System.Numerics.Complex.Magnitude%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary>Mnoży określoną liczbę przez inny określony numer, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

 <xref:System.Numerics.Complex.Multiply%2A> Metody umożliwiają wykonywanie operacji mnożenia obejmujących liczby zespolone.

 Jeśli mnożenie spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>  
 
 <xref:System.Numerics.Complex.Multiply%2A> Metoda jest implementowana dla języków, które nie obsługują niestandardowych operatorów. Zachowanie jest takie samo jak mnożenie przy użyciu operatora mnożenia.  

  
## Examples  
 Poniższy przykład tworzy wiele liczb zespolonych przez każdy element w tablicy liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Liczba rzeczywista podwójnej precyzji do pomnożenia.</param>
        <param name="right">Liczba zespolona do pomnożenia.</param>
        <summary>Zwraca iloczyn liczby rzeczywistej o podwójnej precyzji i liczby zespolonej.</summary>
        <returns>Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Liczebność liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:
 
 AC + ADI
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Liczba zespolona do pomnożenia.</param>
        <param name="right">Liczba rzeczywista podwójnej precyzji do pomnożenia.</param>
        <summary>Zwraca iloczyn liczby zespolonej i liczby rzeczywistej o podwójnej precyzji.</summary>
        <returns>Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Iloczyn liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:

AC + BCI
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba zespolona do pomnożenia.</param>
        <param name="right">Druga liczba zespolona do pomnożenia.</param>
        <summary>Zwraca iloczyn dwóch liczb zespolonych.</summary>
        <returns>Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mnożenie liczby zespolonej, analizy biznesowej i drugiej liczby zespolonej, c + di, ma następującą postać:  
  
 (AC-BD) + (AD + BC) i  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex NaN" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NaN As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex NaN;" />
      <MemberSignature Language="F#" Value=" staticval mutable NaN : System.Numerics.Complex" Usage="System.Numerics.Complex.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje wystąpienie złożone, które nie jest liczbą (NaN).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca wartość z przewidzianą przez funkcję odwrotną do określonej liczby zespolonej.</summary>
        <returns>Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki parametrupomnożoneprzez-1.<paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodatek odwrotny do liczby zespolonej jest liczbą zespoloną, która tworzy wartość <xref:System.Numerics.Complex> , gdy zostanie dodana do oryginalnej liczby zespolonej. Ta metoda zwraca liczbę zespoloną, w której rzeczywiste i urojone składniki oryginalnej liczby zespolonej są mnożone przez-1.  
  
 <xref:System.Numerics.Complex.Negate%2A> Metoda jest implementowana dla języków, które nie obsługują niestandardowych operatorów. Zachowanie jest takie samo jak Negacja przy użyciu jednoargumentowego operatora <xref:System.Numerics.Complex.op_UnaryNegation%2A>negacji.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje dodatkową funkcję odwrotną dla każdego elementu w tablicy liczb zespolonych.  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowe <see cref="T:System.Numerics.Complex" /> wystąpienie o liczbie rzeczywistej równej jednej i liczbie urojonej równej zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości przy <xref:System.Numerics.Complex.One> użyciu właściwości. Następnie porównuje tę wartość z inną wartością, która jest tworzona przez wywołanie <xref:System.Numerics.Complex> konstruktora z częścią rzeczywistą równą jednej i części urojonej równej zero. Ponieważ dane wyjściowe z przykładu są wyświetlane, te dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <Docs>
        <summary>Dodaje określoną liczbę do innej określonej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<xref:System.Numerics.Complex.op_Addition%2A> Operator umożliwia wykonywanie operacji dodawania, które obejmują liczby zespolone. Umożliwia stosowanie kodu takiego jak następujący:

[!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
[!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]

Jeśli dodanie spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%2A> równoważną grupę metod.

<xref:System.Numerics.Complex.op_Addition%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.

## Examples

Poniższy przykład ilustruje Dodawanie liczb złożonych:

[!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
[!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość rzeczywista podwójnej precyzji do dodania.</param>
        <param name="right">Wartość złożona do dodania.</param>
        <summary>Dodaje liczbę rzeczywistą o podwójnej precyzji do liczby zespolonej.</summary>
        <returns>Suma <paramref name="left" /> i<paramref name="right" /> jako liczba złożona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dodanie liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczby zespolonej (c + di) przyjmuje następującą formę:

(a + c) + di

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona do dodania.</param>
        <param name="right">Wartość rzeczywista podwójnej precyzji do dodania.</param>
        <summary>Dodaje liczbę zespoloną do liczby rzeczywistej o podwójnej precyzji.</summary>
        <returns>Suma <paramref name="left" /> i<paramref name="right" /> jako liczba złożona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dodanie liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:

(a + c) + BI

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość złożona do dodania.</param>
        <param name="right">Druga wartość złożona do dodania.</param>
        <summary>Dodaje dwie liczby zespolone.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dodanie liczby zespolonej, a + bi i drugiej liczby zespolonej, c + di, ma następującą postać:

(a + c) + (b + d)i

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Division">
      <Docs>
        <summary>Dzieli określoną liczbę przez inny określony numer, gdzie co najmniej jeden z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<xref:System.Numerics.Complex.op_Division%2A> Operator umożliwia wykonywanie operacji dzielenia, które obejmują liczby zespolone. Umożliwia stosowanie kodu takiego jak następujący:

[!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
[!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]

Jeśli podział powoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>

Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%2A> równoważną grupę metod.

<xref:System.Numerics.Complex.op_Division%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość rzeczywista podwójnej precyzji, która ma zostać podzielona.</param>
        <param name="right">Wartość złożona do podzielenia przez.</param>
        <summary>Dzieli określoną liczbę rzeczywistą o podwójnej precyzji o określoną liczbę zespoloną.</summary>
        <returns>Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />, jako liczbę zespoloną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Podział liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:

(AC/(c<sup>2</sup> + d<sup>2</sup>)) + (AD/(c<sup>2</sup> + d<sup>2</sup>) i

Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona, która ma zostać podzielona.</param>
        <param name="right">Wartość rzeczywista podwójnej precyzji, która ma zostać podzielona przez.</param>
        <summary>Dzieli określoną liczbę zespoloną przez określoną liczbę rzeczywistą o podwójnej precyzji.</summary>
        <returns>Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />, jako liczbę zespoloną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Podział liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:

(AC/c<sup>2</sup>) + (BC/c<sup>2</sup>) i

Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona, która ma zostać podzielona.</param>
        <param name="right">Wartość złożona do podzielenia przez.</param>
        <summary>Dzieli określoną liczbę zespoloną przez inną określoną liczbę zespoloną.</summary>
        <returns>Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Podział liczby zespolonej, analizy biznesowej i drugiej liczby zespolonej, c + di, ma następującą postać:

((AC + BD)/(c<sup>2</sup> + d<sup>2</sup>)) + ((BC-AD)/(c<sup>2</sup> + d<sup>2</sup>) i

Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza liczba zespolona do porównania.</param>
        <param name="right">Druga liczba zespolona do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie liczby zespolone są równe.</summary>
        <returns><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda definiuje operację operatora równości dla <xref:System.Numerics.Complex> wartości. <xref:System.Numerics.Complex.op_Equality%2A> Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodę zamiast.  
  
 Dwie liczby zespolone są równe, jeśli ich rzeczywiste części są równe, a ich części urojone są równe. <xref:System.Numerics.Complex.op_Equality%2A> Metoda jest równoważna z następującym wyrażeniem:  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 Należy zauważyć, że ze względu na różnice, dwie złożone liczby, które są równie równoważne mogą być uznawane za nierówne. Aby uzyskać więcej informacji i możliwe obejście, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodę.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje jawną konwersję między <see cref="T:System.Numerics.Complex" /> obiektem a innym typem.</summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Decimal" /> wartości na liczbę zespoloną.</summary>
        <returns>Liczba zespolona, która ma prawdziwy składnik równy <paramref name="value" /> i składnik urojony równy zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operatory jawnej konwersji definiują typy, które można przekonwertować <xref:System.Numerics.Complex> na obiekt. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.

 Konwersja <xref:System.Decimal> wartości do rzeczywistej części liczby zespolonej może spowodować utratę precyzji <xref:System.Double>, ponieważ typ, który jest typem <xref:System.Numerics.Complex.Real%2A> <xref:System.Decimal>właściwości zespolonej, ma mniejszą liczbę cyfr znaczących niż.



## Examples
 Poniższy przykład ilustruje jawną konwersję <xref:System.Decimal> wartości na <xref:System.Numerics.Complex> wartości.

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> wartości na liczbę zespoloną.</summary>
        <returns>Liczba zespolona, która ma prawdziwy składnik równy <paramref name="value" /> i składnik urojony równy zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operatory jawnej konwersji definiują typy, które można przekonwertować <xref:System.Numerics.Complex> na obiekt. Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych. Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic). W przeciwnym razie wyświetla błąd kompilatora.

 Konwersja <xref:System.Numerics.BigInteger> wartości do rzeczywistej części liczby zespolonej może spowodować utratę precyzji <xref:System.Double>, ponieważ typ, który jest typem <xref:System.Numerics.Complex.Real%2A> <xref:System.Numerics.BigInteger>właściwości zespolonej, ma mniejszą liczbę cyfr znaczących niż.

 Jeśli konwersja nie powiedzie się, ponieważ <xref:System.Numerics.BigInteger> wartość znajduje się poza zakresem <xref:System.Double> typu, operacja nie generuje elementu <xref:System.OverflowException>. Zamiast tego, `value` jeśli jest mniejsza <xref:System.Double.MinValue>niż, wynik jest liczbą <xref:System.Numerics.Complex.Real%2A> zespoloną, która ma wartość właściwości równą <xref:System.Double.NegativeInfinity>. Jeśli `value` jest większa niż <xref:System.Double.MaxValue>, wynik jest liczbą <xref:System.Numerics.Complex.Real%2A> zespoloną, która ma wartość właściwości równą <xref:System.Double.PositiveInfinity>.



## Examples
 Poniższy przykład ilustruje jawną konwersję <xref:System.Numerics.BigInteger> wartości na <xref:System.Numerics.Complex> wartości.

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niejawną konwersję <see cref="T:System.Numerics.Complex" /> między obiektem a innym typem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję niepodpisanego bajtu na liczbę zespoloną.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Byte> wartości na liczbę zespoloną, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa <xref:System.Byte> wartości i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję liczby zmiennoprzecinkowej o podwójnej precyzji na liczbę zespoloną.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Double> wartości na liczbę zespoloną, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa <xref:System.Double> wartości i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję 16-bitowej podpisanej liczby całkowitej na liczbę zespoloną.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 Dzięki temu przeciążeniu można przeprowadzić konwersję na podstawie 16-bitowej liczby całkowitej ze znakiem na liczbę zespoloną, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa podpisanej 16-bitowej liczbie całkowitej, a której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję 32-bitowej podpisanej liczby całkowitej na liczbę zespoloną.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 Dzięki temu przeciążeniu można przeprowadzić konwersję dojścia kompilatora ze podpisanej 32-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa podpisanej 32-bitowej liczbie całkowitej i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję 64-bitowej podpisanej liczby całkowitej na liczbę zespoloną.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 Dzięki temu przeciążeniu można przeprowadzić konwersję dojścia kompilatora ze podpisanej 64-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa podpisanej 64-bitowej liczbie całkowitej i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję podpisanego bajtu na liczbę zespoloną.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługę konwersji z podpisanego bajtu na liczbę zespoloną, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa bajtowi podpisanemu i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję liczby zmiennoprzecinkowej o pojedynczej precyzji na liczbę zespoloną.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Single> wartości na liczbę zespoloną, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa <xref:System.Single> wartości i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję 16-bitowej liczby całkowitej bez znaku na liczbę zespoloną.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 Dzięki temu przeciążeniu można przeprowadzić konwersje z niepodpisanej 16-bitową liczbą całkowitą do liczby zespolonej, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa 16-bitowej liczbie całkowitej bez znaku i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję 32-bitowej liczby całkowitej bez znaku na liczbę zespoloną.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 Dzięki temu przeciążeniu kompilator obsługuje konwersje z niepodpisanej 32-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa niepodpisanej 32-bitowej liczbie całkowitej i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę zespoloną.</param>
        <summary>Definiuje niejawną konwersję 64-bitowej liczby całkowitej bez znaku na liczbę zespoloną.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic). Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.

 Dzięki temu przeciążeniu kompilator obsługuje konwersje z niepodpisanej 64-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie. Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa niepodpisanej 64-bitowej liczbie całkowitej i której część urojona jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie liczby zespolone nie są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje operacje operatora nierówności dla liczb zespolonych. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przez wywołanie <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody i odwrócenie jej wartości.  
  
 Należy zauważyć, że ze względu na różnice, dwie złożone liczby, które są równie równoważne mogą być uznawane za nierówne. Jednym z możliwych obejść jest zaimplementowanie metody porównania `true` , która zwraca tylko wtedy, gdy różnica między dwoma rzeczywistą i urojoną częścią liczb złożonych przekracza określony próg (na przykład .01% wartości rzeczywistego lub urojonego składnika Jedna z liczb zespolonych). Aby uzyskać więcej informacji, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodę.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary>Mnoży określoną liczbę przez inny określony numer, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<xref:System.Numerics.Complex.op_Multiply%2A> Operator umożliwia wykonywanie operacji mnożenia obejmujących liczby zespolone. Umożliwia stosowanie kodu takiego jak następujący:

[!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
[!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]

Jeśli mnożenie spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%2A> równoważną grupę metod.

<xref:System.Numerics.Complex.op_Multiply%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość rzeczywista podwójnej precyzji do pomnożenia.</param>
        <param name="right">Wartość złożona do pomnożenia.</param>
        <summary>Mnoży określoną liczbę rzeczywistą o podwójnej precyzji przez określoną liczbę zespoloną.</summary>
        <returns>Iloczyn <paramref name="left" /> i<paramref name="right" />, jako liczba złożona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Liczebność liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:

AC + ADI

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.


          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona do pomnożenia.</param>
        <param name="right">Wartość rzeczywista podwójnej precyzji do pomnożenia.</param>
        <summary>Mnoży określoną liczbę zespoloną przez określoną liczbę rzeczywistą o podwójnej precyzji.</summary>
        <returns>Iloczyn <paramref name="left" /> i<paramref name="right" />, jako liczba złożona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Iloczyn liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:

AC + BCI

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza złożona wartość do pomnożenia.</param>
        <param name="right">Druga wartość złożona do pomnożenia.</param>
        <summary>Mnoży dwa określone liczby zespolone.</summary>
        <returns>Produkt <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Mnożenie liczby zespolonej, analizy biznesowej i drugiej liczby zespolonej, c + di, ma następującą postać:

(AC-BD) + (AD + BC) i

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <Docs>
        <summary>Odejmuje określoną liczbę od innej podanej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<xref:System.Numerics.Complex.op_Subtraction%2A> Operator umożliwia wykonywanie operacji odejmowania obejmujących liczby zespolone. Umożliwia stosowanie kodu takiego jak następujący:

[!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
[!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]

Jeśli odejmowanie powoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%2A> równoważną grupę metod.

<xref:System.Numerics.Complex.op_Addition%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemna).</param>
        <param name="right">Wartość złożona do odejmowania (odjemnik).</param>
        <summary>Odejmuje liczbę zespoloną od liczby rzeczywistej o podwójnej precyzji.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Odejmowanie liczby zespolonej (c + di) z liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) przyjmuje następującą formę:

(a-c)-di

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> metodę zamiast.
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona do odejmowania (odjemna).</param>
        <param name="right">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemnik).</param>
        <summary>Odejmuje liczbę rzeczywistą o podwójnej precyzji od liczby zespolonej.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Odejmowanie liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) z liczby zespolonej (a i analizy biznesowej):

(a-c) + BI

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> metodę zamiast.
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odejmowania (odjemna).</param>
        <param name="right">Wartość do odejmowania (odjemnik).</param>
        <summary>Odejmuje liczbę zespoloną od innego numeru zespolonego.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Odejmowanie liczby zespolonej, c + di z innej liczby zespolonej, a bi, ma następującą formę:

(a-c) + (b-d) i

Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> metodę zamiast.
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Zwraca wartość z przewidzianą przez funkcję odwrotną do określonej liczby zespolonej.</summary>
        <returns>Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki parametrupomnożoneprzez-1.<paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_UnaryNegation%2A> Metoda definiuje operacje operatora jednoargumentowego negacji (addytywne) dla liczb złożonych. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 Wynikowa liczba złożona daje wartość <xref:System.Numerics.Complex> 0 (zero), gdy zostanie dodana do oryginalnej liczby zespolonej. Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Negate%2A> metodę zamiast.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera fazę liczby zespolonej.</summary>
        <value>Faza liczby zespolonej w radianach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku liczby zespolonej a + bi faza jest obliczana jako <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).  
  
 Można zidentyfikować liczbę zespoloną przez współrzędne kartezjańskiego na płaszczyźnie złożonej lub przez współrzędne biegunowe. Faza (argument) liczby zespolonej to kąt do osi rzeczywistej linii rysowanej od punktu początkowego (część wspólna osi x i oś y) do punktu reprezentowanego przez liczbę zespoloną. Wartość (reprezentowana przez <xref:System.Numerics.Complex.Magnitude%2A> Właściwość) to odległość od punktu początkowego do punktu, który jest reprezentowany przez liczbę zespoloną.  
  
 Można utworzyć wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych zamiast jej współrzędnych kartezjańskiego <xref:System.Numerics.Complex.FromPolarCoordinates%2A> przez wywołanie metody.  
  
 Aby przekonwertować fazę z radianów na stopnie, pomnóż ją przez 180/<xref:System.Math.PI?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodę, aby utworzyć wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych, a następnie wyświetlić <xref:System.Numerics.Complex.Magnitude%2A> wartość <xref:System.Numerics.Complex.Phase%2A> właściwości i.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca określoną liczbę zespoloną podniesioną do określonej potęgi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona, która zostanie podniesiona do potęgi.</param>
        <param name="power">Liczba zmiennoprzecinkowa podwójnej precyzji, która określa potęgę.</param>
        <summary>Zwraca określoną liczbę zespoloną podniesioną do potęgi określonej przez liczbę zmiennoprzecinkową o podwójnej precyzji.</summary>
        <returns>Liczba <paramref name="value" /> złożona przyniesiona do potęgi <paramref name="power" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca. W przypadku innych wartości, `power` jeśli jest równa 0, <xref:System.Numerics.Complex.One?displayProperty=nameWithType>Metoda zwraca wartość `power` , a jeśli jest 1 `value`, zwraca wartość.  
  
 Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.  
  
   
  
## Examples  
 Poniższy przykład ilustruje potęgowanie przy użyciu liczby zespolonej i wykładnika, której wartość należy do zakresu od-1 do 10.  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona, która zostanie podniesiona do potęgi.</param>
        <param name="power">Liczba złożona, która określa potęgę.</param>
        <summary>Zwraca określoną liczbę zespoloną podniesioną do potęgi określonej przez liczbę zespoloną.</summary>
        <returns>Liczba <paramref name="value" /> złożona przyniesiona do potęgi <paramref name="power" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prawdziwy składnik bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <value>Prawdziwy składnik liczby zespolonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwzględniając liczbę zespoloną a + bi, <xref:System.Numerics.Complex.Real%2A> Właściwość zwraca wartość.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie tablicy <xref:System.Numerics.Complex> obiektów i wyświetla rzeczywiste i urojone składniki każdego z nich w formie a + bi.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca mnożenia odwrotności liczby zespolonej.</summary>
        <returns>Odwrotność <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja odwrotna lub mnożenia odwracania od liczby *x* jest liczbą *y* , gdzie *x* pomnożona przez *y* daje 1. Odwrotność liczby zespolonej to liczba złożona, która powstaje <xref:System.Numerics.Complex.One?displayProperty=nameWithType> , gdy dwie liczby są mnożone. Jeśli liczba złożona jest reprezentowana przez + BI, jego wzajemna wartość jest reprezentowana przez wyrażenie a/(a<sup>2</sup>+ b<sup>2</sup>) +-b/(a<sup>2</sup> + b<sup>2</sup>).  
  
 Jeśli wartość jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca. <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> W przeciwnym razie zwraca wynik wyrażenia <xref:System.Numerics.Complex.One?displayProperty=nameWithType>. / `value`  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Numerics.Complex.Reciprocal%2A> metodę, aby obliczyć wzajemne wartości kilku liczb zespolonych. Pokazuje również, że wynik mnożenia liczby zespolonej przez jej wzajemny wpływ wynosi <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca sinus określonego numeru złożonego.</summary>
        <returns>Sinus <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Sin%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Sin%2A>  
  
 <xref:System.Numerics.Complex.Sin%2A> Metoda używa następującej formuły, aby obliczyć sinus liczby zespolonej a + bi:  
  
 (<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Sin%2A> metodę. Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca sinus hiperboliczny podanej liczby zespolonej.</summary>
        <returns>Sinus hiperboliczny <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Sinh%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Sinh%2A>  
  
 <xref:System.Numerics.Complex.Sinh%2A> Metoda używa następującej formuły, aby obliczyć sinus hiperboliczny liczby zespolonej a + bi:  
  
 (<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca pierwiastek kwadratowy z podanej liczby zespolonej.</summary>
        <returns>Pierwiastek kwadratowy <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwiastek kwadratowy liczby `value` zespolonej jest obliczany przy użyciu następującej formuły:  
  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> /2,0)   
  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Sqrt%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <Docs>
        <summary>Odejmuje określoną liczbę od innej podanej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji i zwraca wynik.</summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

Metoda <xref:System.Numerics.Complex.Subtract%2A> zezwala na operacje odejmowania, które obejmują liczby zespolone.

Jeśli odejmowanie powoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>

Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%2A> równoważnej grupy operatorów.

<xref:System.Numerics.Complex.Subtract%2A> Metody, które odbierają jeden podwójnie są wydajniejsze niż metoda, która otrzymuje dwie liczby zespolone.

## Examples

Poniższy przykład odejmuje każdą liczbę zespoloną w tablicy od liczby zespolonej:

[!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
[!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemna).</param>
        <param name="right">Wartość złożona do odejmowania (odjemnik).</param>
        <summary>Odejmuje jedną liczbę zespoloną od liczby rzeczywistej o podwójnej precyzji i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Odejmowanie liczby zespolonej (c + di) z liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) przyjmuje następującą formę:

(a-c)-di

Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważnego operatora.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Wartość złożona do odejmowania (odjemna).</param>
        <param name="right">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemnik).</param>
        <summary>Odejmuje jedną liczbę rzeczywistą podwójnej precyzji od liczby zespolonej i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Odejmowanie liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) z liczby zespolonej (a i analizy biznesowej):

(a-c) + BI

Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważnego operatora.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość do odejmowania (odjemna).</param>
        <param name="right">Wartość do odejmowania (odjemnik).</param>
        <summary>Odejmuje jedną liczbę zespoloną od innej i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> od <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Odejmowanie liczby zespolonej, c + di z innej liczby zespolonej, a bi, ma następującą formę:

(a-c) + (b-d) i

Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważnego operatora.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca tangens podanej liczby zespolonej.</summary>
        <returns>Tangens <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Tan%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Tan%2A>  
  
 Metoda używa następującej formuły, aby obliczyć tangens liczby `value`zespolonej: <xref:System.Numerics.Complex.Tan%2A>  
  
 <xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Numerics.Complex.Tan%2A> metodę. Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożona.</param>
        <summary>Zwraca tangens hiperboliczny dla podanej liczby zespolonej.</summary>
        <returns>Tangens hiperboliczny <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dla liczb zespolonych odpowiada <xref:System.Math.Tanh%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Tanh%2A>  
  
 Metoda używa następującej formuły, aby obliczyć tangens hiperboliczny liczby `value`zespolonej: <xref:System.Numerics.Complex.Tanh%2A>  
  
 <xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczby zespolonej na jej równoważną reprezentację w postaci ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w formie kartezjańskiego.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna reprezentacja `(`liczby zespolonej wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, a *b* jest jej części urojonej. Zarówno ** a, jak i *b* są formatowane przy użyciu specyfikatora formatu ogólnego ("G") i Konwencji bieżącej kultury systemowej.  
  
   
  
## Examples  
 Poniższy przykład Wyświetla reprezentację ciągu kilku liczb zespolonych. Dane wyjściowe używają Konwencji formatowania kultury angielskiej Stany Zjednoczone ("en-US"), która w tym przypadku jest bieżącą kulturą systemu.  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w postaci kartezjańskiego przy użyciu określonych informacji o formatowaniu specyficznych dla kultury.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego, określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg reprezentujący liczbę zespoloną zwracaną przez tę metodę wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w `(`formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, i *b* jest jej częścią urojoną. Zarówno ** a, jak i *b* są formatowane przy użyciu specyfikatora formatu ogólnego ("G") oraz Konwencji kultury zdefiniowanej `provider`przez.  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza specyficzne dla kultury informacje o formacie liczb rzeczywistych i urojonych w zwracanym ciągu. Jeśli `provider` jest `null`, zwracany<xref:System.Globalization.NumberFormatInfo> ciąg jest formatowany przy użyciu obiektu bieżącej kultury.  
  
 `provider` Parametr może mieć jedną z następujących wartości:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.  
  
-   Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider> interfejs. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu.  
  
   
  
## Examples  
 Poniższy przykład Wyświetla reprezentację ciągu kilku liczb zespolonych. W wyniku są stosowane konwencje formatowania angielskiej Stany Zjednoczone ("en-US") i francuski — Francja ("fr-FR").  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w postaci kartezjańskiego przy użyciu określonego formatu dla jego części rzeczywistych i urojonych.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg reprezentujący liczbę zespoloną zwracaną przez tę metodę wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w `(`formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, i *b* jest jej częścią urojoną. Zarówno ** a, jak i *b* są formatowane przy użyciu ciągu `format`formatu określonego przez. `format` Parametr może być dowolnym prawidłowym specyfikatorem standardowego formatu liczbowego lub dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego. Jeśli `format` jest `null`równe lub is, rzeczywiste i urojone części liczby zespolonej są formatowane przy użyciu specyfikatora formatu ogólnego ("G"). <xref:System.String.Empty?displayProperty=nameWithType> Jeśli `format` jest dowolną inną wartością, Metoda <xref:System.FormatException>zgłasza.  
  
 .NET Framework zapewnia rozbudowaną obsługę formatowania, co opisano szczegółowo w następujących tematach:  
  
-   Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów](~/docs/standard/base-types/custom-numeric-format-strings.md)liczbowych.  
  
-   Aby uzyskać więcej informacji na temat formatowania w .NET Framework, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Format zwracanego ciągu jest określany przez <xref:System.Globalization.NumberFormatInfo> obiekt dla bieżącej kultury. W zależności `format` od parametru ten obiekt kontroluje symbole, takie jak znak minus, separator grupy i symbol separatora dziesiętnego w ciągu danych wyjściowych. Aby zapewnić informacje o formatowaniu dla kultur innych niż bieżąca kultura, wywołaj <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> Przeciążenie.  
  
   
  
## Examples  
 Poniższy przykład inicjuje liczbę zespoloną i wyświetla ją przy użyciu kilku ciągów formatu standardowego.  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />nie jest prawidłowym ciągiem formatu.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w postaci kartezjańskiego przy użyciu określonego formatu i informacji o formacie specyficznym dla kultury dla jego części rzeczywistych i urojonych.</summary>
        <returns>Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego, zgodnie <paramref name="format" /> z parametrami i. <paramref name="provider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg reprezentujący liczbę zespoloną zwracaną przez tę metodę wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w `(`formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, i *b* jest jej częścią urojoną. Zarówno ** a, jak i *b* są formatowane przy użyciu ciągu `format`formatu określonego przez. `format` Parametr może być dowolnym prawidłowym specyfikatorem standardowego formatu liczbowego lub dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego. Jeśli `format` jest `null`równe lub is, rzeczywiste i urojone części liczby zespolonej są formatowane przy użyciu specyfikatora formatu ogólnego ("G"). <xref:System.String.Empty?displayProperty=nameWithType> Jeśli `format` jest dowolną inną wartością, Metoda <xref:System.FormatException>zgłasza.  
  
 .NET Framework zapewnia rozbudowaną obsługę formatowania, co opisano szczegółowo w następujących tematach:  
  
-   Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów](~/docs/standard/base-types/custom-numeric-format-strings.md)liczbowych.  
  
-   Aby uzyskać więcej informacji na temat formatowania w .NET Framework, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Parametr<xref:System.IFormatProvider> jest implementacją. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza specyficzne dla kultury informacje o formacie liczb rzeczywistych i urojonych w zwracanym ciągu. W zależności `format` od parametru ten obiekt kontroluje symbole, takie jak znak minus, separator grupy i symbol separatora dziesiętnego w ciągu danych wyjściowych. Jeśli `provider` jest `null`, zwracany<xref:System.Globalization.NumberFormatInfo> ciąg jest formatowany przy użyciu obiektu bieżącej kultury.  
  
 `provider` Parametr może mieć jedną z następujących wartości:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.  
  
-   Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider> interfejs. Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę liczb zespolonych i wyświetla każdą z nich przy użyciu kilku ciągów <xref:System.Globalization.CultureInfo> formatu standardowego oraz obiektów, które reprezentują kultury Stany Zjednoczone w języku angielskim ("en-us") i francuski — Francja ("fr-fr").  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />nie jest prawidłowym ciągiem formatu.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowe <see cref="T:System.Numerics.Complex" /> wystąpienie o liczbie rzeczywistej równej zero i liczbie urojonej równej zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest najczęściej używana do <xref:System.Numerics.Complex> porównywania wartości z zerem. <xref:System.Numerics.Complex.Zero>  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości przy <xref:System.Numerics.Complex.Zero> użyciu właściwości. Następnie porównuje tę wartość z inną wartością, która jest tworzona przez wywołanie <xref:System.Numerics.Complex> konstruktora z częścią rzeczywistą równą zero i części urojonej równej zero. Ponieważ dane wyjściowe z przykładu są wyświetlane, te dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>

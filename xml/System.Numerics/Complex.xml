<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1adbe02d035bfc5cd2896e8b0e40079375718a5e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30561796" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje liczbą.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba złożonych jest liczba, która składa się z liczbą rzeczywistą i zespoloną numer. Z liczby złożonej są zwykle zapisywane w postaci z = x + yi, gdzie *x* i *y* są liczbami rzeczywistą i *i* to jednostka zespoloną, który ma właściwość *i* <sup>2</sup> = -1. Część rzeczywista liczby złożonej jest reprezentowana przez *x*, odwołuje się wyrażenie Liczba_zespolona część liczby złożonej *y*.  
  
 <xref:System.Numerics.Complex> Kartezjański układ współrzędnych (prawdziwe, zespoloną) używa typu podczas tworzenia wystąpienia i operowanie nimi liczby złożone. Liczbą może być reprezentowany jako punktu dwuwymiarowa układ współrzędnych, znany jako płaszczyzny złożone. Część rzeczywista liczby złożonej znajduje się na osi x (osi poziomej), a część urojony znajduje się na osi y (osi pionowej).  
  
 Można również wyrażane dowolnego punktu w płaszczyźnie złożone na podstawie jego wartość bezwzględna polar współrzędnych., w Współrzędne biegunowe, punkt charakteryzuje się dwie liczb:  
  
-   Jego rozmiar, który jest odległość punktu ze źródła (to znaczy 0,0 lub punktu osi x i y przecięcia).  
  
-   Jego fazy, czyli kąta między rzeczywistych osi i linią ze źródła do punktu.  
  
## <a name="instantiating-a-complex-number"></a>Utworzenie wystąpienia liczby zespolonej  
 Można przypisać wartość liczbą w jednym z następujących sposobów:  
  
-   Przez przekazanie dwa <xref:System.Double> wartości dla jego konstruktora. Pierwsza wartość reprezentuje część rzeczywista liczby złożonej, a druga wartość reprezentuje jego urojony części. Te wartości oznaczają pozycja liczby złożonej w dwuwymiarowa kartezjański układ współrzędnych.  
  
-   Wywołując statycznych (`Shared` w języku Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> metodę w celu utworzenia jego Współrzędne biegunowe liczbą.  
  
-   Przypisując <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, lub <xref:System.Double> do wartości <xref:System.Numerics.Complex> obiektu. Wartość staje się część rzeczywista liczby złożonej, a jego urojony części jest równe 0.  
  
-   Rzutowanie (w języku C#) lub konwertowanie (w języku Visual Basic) <xref:System.Decimal> lub <xref:System.Numerics.BigInteger> do wartości <xref:System.Numerics.Complex> obiektu. Wartość staje się część rzeczywista liczby złożonej, a jego urojony części jest równe 0.  
  
-   Przypisując liczby złożonej, który jest zwracany przez metodę lub operator może <xref:System.Numerics.Complex> obiektu. Na przykład <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> jest statyczną metodę, która zwraca wartość liczby złożonej, który jest sumą dwóch liczb zespolonych i <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator dodaje dwie liczby złożone i zwraca wynik.  
  
 W poniższym przykładzie pokazano każdego z tych sposobów pięć przypisywanie wartości do liczbą.  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a>Operacje na liczbach zespolonych  
 <xref:System.Numerics.Complex> Struktury w programie .NET Framework zawiera elementy, które zapewniają następujące funkcje:  
  
-   Metody do porównania dwóch liczb zespolonych, aby sprawdzić, czy są równe.  
  
-   Operatory do wykonania operacji arytmetycznych na liczbach złożone. <xref:System.Numerics.Complex> Operatory umożliwiają wykonywanie Dodawanie, odejmowanie, mnożenie, dzielenie i negacji jednoargumentowe z liczby złożone.  
  
-   Metody wykonywania innych operacji wartości liczbowych na liczby złożone. Oprócz cztery podstawowe operacje arytmetyczne Zgłoś liczbą do określonej potęgi, Znajdź pierwiastek kwadratowy z liczby złożonej, a wartość bezwzględną liczby złożone.  
  
-   Metody wykonywania trygonometryczne operacji na liczbach złożone. Na przykład można obliczyć tangens kąta reprezentowany przez liczbą.  
  
 Należy zauważyć, że ponieważ <xref:System.Numerics.Complex.Real%2A> i <xref:System.Numerics.Complex.Imaginary%2A> właściwości są tylko do odczytu, nie można zmodyfikować wartości istniejącej <xref:System.Numerics.Complex> obiektu.  Wszystkie metody, które w trakcie operacji na <xref:System.Numerics.Complex> number, jeśli ich wartość zwracana jest typu <xref:System.Numerics.Complex>, zwraca nową <xref:System.Numerics.Complex> numer.  
  
## <a name="precision-and-complex-numbers"></a>Precyzja i liczby zespolone  
 Rzeczywiste i urojony części liczbą są reprezentowane przez dwie wartości zmiennoprzecinkowej podwójnej precyzji. Oznacza to, że <xref:System.Numerics.Complex> wartości, takie jak wartości zmiennoprzecinkowe podwójnej precyzji, mogą tracić dokładność wyniku operacji wartości liczbowych. Oznacza to, że strict porównania równości dwóch <xref:System.Numerics.Complex> wartości może się nie powieść, nawet jeśli jest to różnica między dwiema wartościami z powodu utraty dokładności. Aby uzyskać więcej informacji, zobacz <xref:System.Double>.  
  
 Na przykład przeprowadzenie potęgowania na obliczony logarytm naturalny liczby powinien zwrócić oryginalny numer. W niektórych przypadkach utrata dokładności wartości zmiennoprzecinkowych może jednak spowodować niewielkich różnic między dwiema wartościami, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 Podobnie poniższy przykład, który oblicza pierwiastek kwadratowy liczby <xref:System.Numerics.Complex> cyfry, i tworzy nieco inne wyniki na 32-bitowe i IA64 wersje programu .NET Framework.  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a>Liczby zespolone, nieskończoność i NaN  
 Rzeczywiste i urojony części liczbą są reprezentowane przez <xref:System.Double> wartości. Oprócz od <xref:System.Double.MinValue?displayProperty=nameWithType> do <xref:System.Double.MaxValue?displayProperty=nameWithType>, rzeczywisty lub urojony część liczbą może mieć wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType>. <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Double.NaN?displayProperty=nameWithType> wszystkie propagację w żadnej operacji arytmetycznych lub trygonometryczne.  
  
 W poniższym przykładzie dzielenie przez <xref:System.Numerics.Complex.Zero> tworzy liczby złożonej, w których części rzeczywistą i urojony są <xref:System.Double.NaN?displayProperty=nameWithType>. W związku z tym również wykonywania mnożenia o tej wartości powoduje liczby złożonej, w których części rzeczywistą i urojony są <xref:System.Double.NaN?displayProperty=nameWithType>. Podobnie, wykonywanie mnożenia, który przelewa zakres <xref:System.Double> typu tworzy liczbą których część rzeczywista jest <xref:System.Double.NaN?displayProperty=nameWithType> i których część urojony jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Następnie wykonywania dzielenia o tym numerze złożone zwraca liczby złożonej, w których część rzeczywista jest <xref:System.Double.NaN?displayProperty=nameWithType> i których część urojony jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 Operacji matematycznych z liczby złożone, które są nieprawidłowe lub który przepełnienie <xref:System.Double> — typ danych zgłosiła wyjątek. Zamiast tego, że oba operatory zwracają <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> w następujących warunkach:  
  
-   Dzielenia przez zero zwraca liczby dodatniej <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
-   Wszelkie operacje, które przepełnienie, górna granica <xref:System.Double> zwraca typ danych <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.  
  
-   Dzielenie przez zero zwraca liczby ujemnej <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
-   Wszelkie operacje, który przelewa dolna granica <xref:System.Double> zwraca typ danych <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
-   Zwraca dzielenia 0 przez zero <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
-   Wszelkie operacje, które jest przeprowadzane w wypadku argumentów operacji o wartości <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType>, w zależności od określonej operacji.  
  
 Należy pamiętać, że dotyczy to wszelkie pośrednie obliczenia wykonywane przez metodę. Na przykład iloczyn `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` używa formuły (ac - bd) + (ad + bc) i. Obliczanie rzeczywistych składnik, który jest wynikiem mnożenia ocenia 9e308 wyrażenie * 2,5 - 9e308 * 3.5. Zwraca poszczególnych pośrednia mnożenia w tym wyrażeniu <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>i podjęcie próby odjąć <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> z <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
## <a name="formatting-a-complex-number"></a>Formatowanie liczby zespolonej  
 Domyślnie reprezentację ciągu liczbą ma postać `(` *rzeczywistych* `,` *urojony*`)`, gdzie *rzeczywistych* i *urojony* są reprezentacji ciągu <xref:System.Double> wartości, które tworzą liczby złożonej rzeczywistą i urojony składników. Niektóre przeciążeń <xref:System.Numerics.Complex.ToString%2A> metody można dostosowywać reprezentacji ciągu tych <xref:System.Double> wartości, aby odzwierciedlić Konwencji formatowania określonej kultury lub pojawią się w określonym formacie zdefiniowane przez liczbowe standardowych lub niestandardowych Ciąg formatu. (Aby uzyskać więcej informacji, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
 Jednym ze sposobów częściej wyrażenia reprezentację ciągu liczbą ma postać + analizy biznesowej, gdzie jest składnikiem rzeczywistej liczby złożonej i serwer b jest składnik urojony liczby złożonej. W inżynierii electrical liczbą najczęściej jest wyrażony jako + bj. Reprezentacja ciągu z liczbą może zwrócić w jednej z tych dwóch form. Aby to zrobić, należy zdefiniować dostawcy formatu niestandardowego zaimplementowanie <xref:System.ICustomFormatter> i <xref:System.IFormatProvider> interfejsów, a następnie wywołania <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metody.  
  
 W poniższym przykładzie zdefiniowano `ComplexFormatter` klasa, która reprezentuje liczbą jako ciągu w postaci + analizy biznesowej lub + bj.  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 W poniższym przykładzie użyto następnie ten niestandardowy element formatujący, aby wyświetlić reprezentację ciągu liczbą.  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">Część rzeczywista liczby złożonej.</param>
        <param name="imaginary">Wyrażenie Liczba_zespolona część liczby złożonej.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.Complex" /> struktury przy użyciu określonych wartości rzeczywistych i urojony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `real` Lub `imaginary` argumenty mogą tracić dokładność, jeśli są typy danych, które wymaga jawnego rzutowania do <xref:System.Double>.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwie liczb zespolonych, a następnie użycie ich w operacji dodawania, odejmowania, mnożenia i dzielenia.  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Pobiera wartość bezwzględna (lub wielkości) liczbą.</summary>
        <returns>Wartość bezwzględna <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość bezwzględna liczby złożonej jest odpowiednikiem jego <xref:System.Numerics.Complex.Magnitude%2A> właściwości. Wartość bezwzględna liczby rzeczywistych + bi jest obliczana w następujący sposób:  
  
-   Jeśli b = 0, wynikiem jest 0.  
  
-   Jeśli > b, wynikiem jest *<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).  
  
-   Jeśli b >, wynikiem jest b * <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 +<sup>2</sup>/b<sup>2</sup>).  
  
 Jeśli obliczanie wartości bezwzględnych powoduje przepełnienie, metoda zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Jeśli dowolny <xref:System.Numerics.Complex.Real%2A> lub <xref:System.Numerics.Complex.Imaginary%2A> właściwość jest <xref:System.Double.NaN?displayProperty=nameWithType> i inne właściwości nie jest ani <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ani <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Oblicza wartość bezwzględna liczby złożonej, pokazuje, że jest odpowiednikiem wartości w następującym przykładzie <xref:System.Numerics.Complex.Magnitude%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych, która reprezentuje cosinus.</param>
        <summary>Zwraca kąt, będącą arcus cosinus określonej liczby złożonej.</summary>
        <returns>Kąt, mierzony w radianach, który jest arcus cosinus z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Acos%2A> Odpowiada metoda liczby złożone <xref:System.Math.Acos%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Acos%2A> Metoda używa następującej formuły:  
  
 (-<xref:System.Numerics.Complex.ImaginaryOne>) * <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` * `value`)))    
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Acos%2A> metody. Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy liczby złożonej do dodania.</param>
        <param name="right">Druga liczba złożone do dodania.</param>
        <summary>Dodaje dwie liczby złożone i zwraca wynik.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodanie złożony number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:  
  
 (+ c) + (b + d) i.  
  
 Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Można używać języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.Complex.Add%2A> metodę w celu dodania numerami złożone.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dodawania przy liczby złożone.  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca kąt, będącą arcus sinus określonej liczby złożonej.</summary>
        <returns>Czyli arcus sinus kąta z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Asin%2A> Odpowiada metoda liczby złożone <xref:System.Math.Asin%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Asin%2A> Metoda używa następującej formuły:  
  
 -<xref:System.Numerics.Complex.ImaginaryOne> * <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> * wartość + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -wartość * wartość))    
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Asin%2A> metody. Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca kąt, będącą arcus tangens określonej liczby złożonej.</summary>
        <returns>Będący arcus tangens kąta <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Atan%2A> Odpowiada metoda liczby złożone <xref:System.Math.Atan%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Atan%2A> Metoda używa następującej formuły:  
  
 <xref:System.Numerics.Complex.ImaginaryOne> / Nowy złożonych (2.0, 0,0)) * (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> * wartość)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne * wartość)   
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Atan%2A> metody. Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Oblicza sprzężenie liczbą i zwraca wynik.</summary>
        <returns>Sprzężenie z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprzężenie liczbą odwraca znak urojony składników; oznacza to, że dotyczy ona negacji jednoargumentowy urojony składnika. Jeśli + bi jest liczbą, jest jego sprzężenie - analizy biznesowej.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sprzężenie dwóch liczb złożone.  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca cosinus określonej liczby złożonej.</summary>
        <returns>Cosinus <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Cos%2A> Odpowiada metoda liczby złożone <xref:System.Math.Cos%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Cos%2A> Metoda używa następującej formuły można obliczyć cosinus liczby złożonej + analizy biznesowej:  
  
 (<xref:System.Math.Cos%2A>() * <xref:System.Math.Cosh%2A>(b)-(<xref:System.Math.Sin%2A>() * <xref:System.Math.Sinh%2A>(b)))  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Acos%2A> metody. Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca cosinus hiperboliczny dla określonej liczby złożonej.</summary>
        <returns>Cosinus hiperboliczny liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Cosh%2A> Odpowiada metoda liczby złożone <xref:System.Math.Cosh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Cosh%2A> Metoda używa następującej formuły można obliczyć cosinus hiperboliczny dla liczby złożonej + analizy biznesowej:  
  
 (<xref:System.Math.Cosh%2A>() * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>() * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">Liczba złożonych podział.</param>
        <param name="divisor">Liczby złożonej do dzielenia przez.</param>
        <summary>Dzieli jedną liczbę złożone przez inną i zwraca wynik.</summary>
        <returns>Iloraz z dzielenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzielenie liczby zespolonej + bi przez druga liczba złożony, liczbę, c + podpisane, ma następującą postać:  
  
 ((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i  
  
 Jeśli wyniki działania iloraz nastąpiło przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 <xref:System.Numerics.Complex.Divide%2A> Metody mogą być używane przez języki, które nie obsługują niestandardowych operatorów. Jego zachowanie jest identyczne dzielenia przy użyciu operatora dzielenia.  
  
   
  
## Examples  
 Poniższy przykład dzieli liczbą przez każdy element tablicy liczby złożone.  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwie liczb zespolonych są takie same.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczby złożonej do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określonej liczby złożonej mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli ta liczba złożone i <paramref name="value" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda zapewnia <xref:System.IEquatable%601> implementację <xref:System.Numerics.Complex> struktury. Wykonuje nieco lepszym rozwiązaniem niż <xref:System.Numerics.Complex.Equals%28System.Object%29> metody, ponieważ nie trzeba przekonwertować jej parametr liczbą.  
  
 Dwie liczb zespolonych są takie same, jeśli ich rzeczywistym części są takie same i ich urojony części są takie same. <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda jest odpowiednikiem następującego wyrażenia:  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Użyj <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metody ostrożnie, ponieważ dwie wartości, które są równoważne najwyraźniej jest uznawana za nierówne z powodu różnych precyzji ich rzeczywiste i urojony składników. Poniższy przykład zgłasza, że <c>(3.33333, 0.142857)</c> i <c>(10/3, 1/7)</c> nie są takie same.  
  
 [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)]
 [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  
  
 Jeden zalecane technika jest określenie dopuszczalne margines różnicę między dwiema wartościami (takich jak. 01% jeden ze składników wartości rzeczywistych i urojony) zamiast porównanie wartości pod kątem równości. Jeśli wartość bezwzględna różnicy między dwiema wartościami jest mniejsza niż lub równa tej margines, różnica polega na tym prawdopodobnie z powodu różnic w dokładność i, w związku z tym wartości są mogą być takie same. W poniższym przykładzie użyto tej metody do porównywania dwóch wartości złożonych, które można nierówne w poprzednim przykładzie kodu. Znajdzie dwie liczb zespolonych równe.  
  
 [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> parametr jest <see cref="T:System.Numerics.Complex" /> obiektu lub funkcją niejawnej konwersji na typ <see cref="T:System.Numerics.Complex" /> obiekt i jego wartość jest równa bieżącej <see cref="T:System.Numerics.Complex" /> obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwie liczb zespolonych są takie same, jeśli ich rzeczywistym części są takie same i ich urojony części są takie same. <xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda jest odpowiednikiem następującego wyrażenia:  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 Jeśli `obj` parametr nie jest <xref:System.Numerics.Complex> obiekt, ale jest typu danych, dla którego zdefiniowano niejawna konwersja, <xref:System.Numerics.Complex.Equals%28System.Object%29> metoda konwertuje `obj` do <xref:System.Numerics.Complex> obiektu, w których część rzeczywista jest równa wartości `obj`i której część urojony jest równa zero, przed rozpoczęciem porównania. Poniższy przykład przedstawia to znajdując liczbą i wartość zmiennoprzecinkową podwójnej precyzji są takie same.  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Użyj <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metody ostrożnie, ponieważ dwie wartości, które są równoważne najwyraźniej jest uznawana za nierówne z powodu różnych precyzji ich rzeczywiste i urojony składników. Problem może być accentuated, jeśli <paramref name="obj" /> muszą zostać skonwertowane do <see cref="T:System.Double" /> przed wykonaniem operacji porównania. Poniższy przykład porównuje liczbą którego rzeczywistych składnika wydaje się być taka sama jak <see cref="T:System.Single" /> wartości z tym <see cref="T:System.Single" /> wartość. Jak pokazano na dane wyjściowe, zwraca porównania równości <see langword="False" />.  
  
 [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)]
 [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  
  
 Jeden zalecane technika jest określenie dopuszczalne margines różnicę między dwiema wartościami (takich jak. 01% jeden ze składników wartości rzeczywistych i urojony) zamiast porównanie wartości pod kątem równości. Jeśli wartość bezwzględna różnicy między dwiema wartościami jest mniejsza niż lub równa tej margines, różnica jest prawdopodobnie z powodu różnic w dokładność i w związku z tym są mogą być takie same wartości. W poniższym przykładzie użyto tej metody do porównywania dwóch wartości, które można nierówne w poprzednim przykładzie kodu. Teraz znajdzie się być takie same.  
  
 [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)]
 [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych, określająca potęgi.</param>
        <summary>Zwraca <see langword="e" /> podniesionej do potęgi określonej przez liczbą.</summary>
        <returns>Liczba <see langword="e" /> podniesionej do potęgi <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Numerics.Complex.Pow%2A> metodę obliczania uprawnień innych typów podstawowych.  
  
 <xref:System.Numerics.Complex.Exp%2A> Odpowiada metoda liczby złożone <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych. <xref:System.Numerics.Complex.Exp%2A> jest odwrotność <xref:System.Numerics.Complex.Log%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Exp%2A> metody. Pokazuje, z niektórych dozwolony dla braku dokładność <xref:System.Double> typu danych, przekazując wartość zwrócona przez <xref:System.Numerics.Complex.Log%2A> metodę <xref:System.Numerics.Complex.Exp%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">Wielkość, który jest odległość ze źródła (przecięcia osi x i y), do liczby całkowitej.</param>
        <param name="phase">Fazy, to kąt, w wierszu do osi poziomej, mierzony w radianach.</param>
        <summary>Tworzy złożone z Współrzędne biegunowe punktu.</summary>
        <returns>Liczba złożonych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Metoda tworzy liczbą oparte na jego Współrzędne biegunowe.  
  
 Ponieważ istnieje wiele reprezentacje punktu na płaszczyźnie złożone, zwracana wartość <xref:System.Numerics.Complex.FromPolarCoordinates%2A> są znormalizowane metody. Wielkość jest znormalizowane do liczbą dodatnią, a fazy jest znormalizowane do wartości z zakresu od -<xref:System.Math.PI> do <xref:System.Math.PI>. W wyniku wartości <xref:System.Numerics.Complex.Phase%2A> i <xref:System.Numerics.Complex.Magnitude%2A> właściwości wynikowa liczba złożone nie mogą równa oryginalnej wartości `magnitude` i `phase` parametrów.  
  
 Można przekonwertować wartości w stopniach na wartość w radianach do `phase` parametru mnożenie jej  <xref:System.Math.PI?displayProperty=nameWithType> /180.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody tworzenia wystąpienia liczbą oparte na jego Współrzędne biegunowe, a następnie wyświetla wartość jego <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik urojony bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <value>Wyrażenie Liczba_zespolona składnik liczbą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podany numer złożone + analizy biznesowej, <xref:System.Numerics.Complex.Imaginary%2A> właściwość zwraca wartość b.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.Complex> obiekty i wyświetla rzeczywiste i urojony składniki każdej z nich w formularzu + analizy biznesowej.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienia z liczbą rzeczywistą równa zero i liczbę zespoloną równa jeden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Numerics.Complex> wartość przy użyciu <xref:System.Numerics.Complex.ImaginaryOne> właściwości. Następnie porównuje tę wartość na inną wartość, która zostanie uruchomiony przez wywołanie metody <xref:System.Numerics.Complex> konstruktora z rzeczywistą równa zero i część dotyczącą urojony równa jeden. Jak pokazano na dane wyjściowe z przykładu, dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca logarytm liczbą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca fizyczna (podstawowy <see langword="e" />) logarytm o podstawie określonej liczby złożone.</summary>
        <returns>Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> Odpowiada metoda liczby złożone <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Log%2A> metody. Pokazuje, z niektórych dozwolony dla braku dokładność <xref:System.Double> typu danych, przekazując wartość zwrócona przez <xref:System.Numerics.Complex.Log%2A> metodę <xref:System.Numerics.Complex.Exp%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <param name="baseValue">Podstawa logarytmu.</param>
        <summary>Zwraca logarytm o określonej liczby złożonej w określonej podstawy.</summary>
        <returns>Logarytmu <paramref name="value" /> w podstawowym <paramref name="baseValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> Odpowiada metoda liczby złożone <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca logarytm base 10 podanej liczby złożone.</summary>
        <returns>10 podstawa logarytmu <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Log10%2A> Odpowiada metoda liczby złożone <xref:System.Math.Log10%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość (lub wartość bezwzględna) liczbą.</summary>
        <value>Wartość bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Magnitude%2A> Jest odpowiednikiem wartość bezwzględna liczby złożonej właściwości. Określa odległość ze źródła (przecięcia osi x i y w układzie współrzędnych kartezjański) w punkcie dwuwymiarowa reprezentowany przez liczbą. Wartość bezwzględna jest obliczana w następujący sposób:  
  
 &#124;+ analizy biznesowej &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(* + b * b)  
  
 Jeśli obliczanie wartości bezwzględnych powoduje przepełnienie, ta właściwość zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości definiują położenie punktu, który reprezentuje liczbą w systemie biegunowe.  
  
 Można utworzyć wystąpienia liczbą oparte na jego Współrzędne biegunowe, zamiast współrzędnych kartezjańskimi przez wywołanie metody <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody.  
  
   
  
## Examples  
 Oblicza wartość bezwzględna liczby złożonej, pokazuje, że jest odpowiednikiem wartości w następującym przykładzie <xref:System.Numerics.Complex.Magnitude%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy złożone liczbę Aby pomnożyć.</param>
        <param name="right">Druga liczba złożone do wielokrotnie.</param>
        <summary>Zwraca iloczyn dwóch liczb złożone.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mnożenia złożonego number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:  
  
 (ac - bd) + (ad + bc) i  
  
 Jeśli mnożenia powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 <xref:System.Numerics.Complex.Multiply%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów. Jego zachowanie jest identyczne mnożenia przy użyciu operatora mnożenia.  
  
   
  
## Examples  
 Poniższy przykład wielokrotności liczbę złożone przez każdy element tablicy liczby złożone.  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca odwrotność dodatku określonej liczby złożonej.</summary>
        <returns>Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki <paramref name="value" /> parametru pomnożona przez wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odwrotność dodatku liczbą jest liczbą tworzącego wartość <xref:System.Numerics.Complex> po dodaniu do oryginalnego liczby złożonej. Ta metoda zwraca liczby złożonej, w którym składniki rzeczywistych i urojony oryginalna liczba złożone są pomnożona przez wartość -1.  
  
 <xref:System.Numerics.Complex.Negate%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów. Jego zachowanie jest takie same jak negacji przy użyciu Jednoargumentowy operator negacji <xref:System.Numerics.Complex.op_UnaryNegation%2A>.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje odwrotność dodatku każdego elementu w tablicy liczby złożone.  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienia z liczbą rzeczywistą równą jeden numer zespoloną równa zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Numerics.Complex> wartość przy użyciu <xref:System.Numerics.Complex.One> właściwości. Następnie porównuje tę wartość na inną wartość, która zostanie uruchomiony przez wywołanie metody <xref:System.Numerics.Complex> konstruktora z rzeczywistą równa jeden i część dotyczącą urojony równa zero. Jak pokazano na dane wyjściowe z przykładu, dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do dodania.</param>
        <param name="right">Druga wartość do dodania.</param>
        <summary>Dodaje dwie liczby złożone.</summary>
        <returns>Suma <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Addition%2A> Metoda definiuje operacji dodawania dla liczby złożone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 Dodanie złożony number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:  
  
 (a + c) + (b + d)i  
  
 Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Add%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład przedstawia dodawania przy liczby złożone.  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość podział.</param>
        <param name="right">Wartość do dzielenia przez.</param>
        <summary>Dzieli określonej liczby złożonej innego określoną liczbę złożone.</summary>
        <returns>Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Division%2A> Metoda definiuje operacji dzielenia liczby złożone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 Podział złożony number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:  
  
 ((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i  
  
 Jeśli podział powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.Numerics.Complex.Divide%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy liczby złożonej do porównania.</param>
        <param name="right">Druga liczba złożone do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie liczb zespolonych są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.Complex> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody zamiast tego.  
  
 Dwie liczb zespolonych są takie same, jeśli ich rzeczywistym części są takie same i ich urojony części są takie same. <xref:System.Numerics.Complex.op_Equality%2A> Metoda jest odpowiednikiem następującego wyrażenia:  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 Należy pamiętać, że z powodu różnic w dokładność, dwóch liczb zespolonych, które są równoważne najwyraźniej jest uznawana za nierówne. Więcej informacji oraz możliwe rozwiązania, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje jawnej konwersji między <see cref="T:System.Numerics.Complex" /> obiektu i innego typu.</summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Decimal" /> wartość liczbą.</summary>
        <returns>Liczbę złożone z rzeczywistą składnik równy <paramref name="value" /> i składnika urojony równa zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operatory jawnej konwersji Definiowanie typów, które mogą być konwertowane na <xref:System.Numerics.Complex> obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.

 Konwersja typu <xref:System.Decimal> wartości rzeczywistych część liczbą może spowodować zmniejszenie precyzji, ponieważ <xref:System.Double>, który jest typem liczby złożonej <xref:System.Numerics.Complex.Real%2A> właściwość ma mniejszą liczbę cyfr znaczących niż <xref:System.Decimal>.



## Examples
 Poniższy przykład przedstawia jawna konwersja <xref:System.Decimal> wartości do <xref:System.Numerics.Complex> wartości.

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> wartość liczbą.</summary>
        <returns>Liczbę złożone z rzeczywistą składnik równy <paramref name="value" /> i składnika urojony równa zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operatory jawnej konwersji Definiowanie typów, które mogą być konwertowane na <xref:System.Numerics.Complex> obiektu. Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych. Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany. W przeciwnym razie wystąpi błąd kompilatora wyświetlane.

 Konwersja typu <xref:System.Numerics.BigInteger> wartości rzeczywistych część liczbą może spowodować zmniejszenie precyzji, ponieważ <xref:System.Double>, który jest typem liczby złożonej <xref:System.Numerics.Complex.Real%2A> właściwość ma mniejszą liczbę cyfr znaczących niż <xref:System.Numerics.BigInteger>.

 Jeśli nie powiedzie się konwersji ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> typ operacji nie zgłasza <xref:System.OverflowException>. Zamiast tego Jeśli `value` jest mniejsza niż <xref:System.Double.MinValue>, wyniku jest liczbą zawierający <xref:System.Numerics.Complex.Real%2A> wartość właściwości jest równa <xref:System.Double.NegativeInfinity>. Jeśli `value` jest większa niż <xref:System.Double.MaxValue>, wyniku jest liczbą zawierający <xref:System.Numerics.Complex.Real%2A> wartość właściwości jest równa <xref:System.Double.PositiveInfinity>.



## Examples
 Poniższy przykład przedstawia jawna konwersja <xref:System.Numerics.BigInteger> wartości do <xref:System.Numerics.Complex> wartości.

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niejawna konwersja między <see cref="T:System.Numerics.Complex" /> obiektu i innego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawnej konwersji wartości bajtu bez znaku.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Byte> wartość liczby złożonej, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest równa <xref:System.Byte> wartość i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawna konwersja liczby zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Double> wartość liczby złożonej, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest równa <xref:System.Double> wartość i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawnej konwersji wartości 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z 16-bitową liczbę całkowitą ze znakiem liczbą, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista wynosi 16-bitową liczbę całkowitą ze znakiem i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje niejawna konwersja całkowita 32-bitowej liczby złożonej.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z całkowita 32-bitowa liczbą, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, jak całkowita 32-bitowa i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje niejawna konwersja 64-bitowej podpisanej liczby całkowitej liczby złożonej.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z całkowita 64-bitowa liczbą, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, jak całkowita 64-bitowa i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawnej konwersji wartości bajtu ze znakiem.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z bajtu ze znakiem liczbą, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, jak podpisem bajt i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje niejawna konwersja z liczby zmiennoprzecinkowej pojedynczej precyzji liczbą.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Single> wartość liczby złożonej, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest równa <xref:System.Single> wartość i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawnej konwersji wartości 16-bitową liczbę całkowitą bez znaku.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z liczbą całkowitą bez znaku 16-bitową liczbą, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, liczbę całkowitą bez znaku 16-bitowych i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawna konwersja z 32-bitowej liczby całkowitej bez znaku.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z liczbą całkowitą bez znaku 32-bitowe liczby złożonej, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, liczbę całkowitą bez znaku 32-bitowe i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do przekonwertowania na liczbę złożone.</param>
        <summary>Definiuje liczbą niejawna konwersja 64-bitowej liczby całkowitej bez znaku.   
           
Ten interfejs API nie jest zgodny ze specyfikacją CLS.</summary>
        <returns>Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.

 To przeciążenie umożliwia kompilatora obsługi konwersje z liczbą całkowitą bez znaku 64-bitowe liczby złożonej, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, liczbę całkowitą bez znaku 64-bitowe i których część urojony jest równa zero.

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwie liczb zespolonych nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje działania operator nierówności dla liczby złożone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 Języki, które nie obsługują niestandardowych operatory można sprawdzić nierówności, wywołując <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> — metoda i jego wartość cofania.  
  
 Należy pamiętać, że z powodu różnic w dokładność, dwóch liczb zespolonych, które są równoważne najwyraźniej jest uznawana za nierówne. Jednym możliwym obejściem jest implementacja metody porównania, która zwraca `true` tylko wtedy, gdy jest to różnica między dwoma częściami rzeczywistą i urojony liczby złożone przekroczy określony próg (np. 01% wartości rzeczywistych lub urojony składnika jeden z liczby złożone). Aby uzyskać więcej informacji, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość wielokrotnie.</param>
        <param name="right">Druga wartość używana w wielokrotnie.</param>
        <summary>Mnoży dwie określonej liczby złożone.</summary>
        <returns>Iloczyn <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Multiply%2A> Metoda definiuje działania operator mnożenia dla liczby złożone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 Mnożenia złożonego number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:  
  
 (ac - bd) + (ad + bc) i  
  
 Jeśli mnożenia powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Multiply%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość, którą chcesz odjąć od (minuend).</param>
        <param name="right">Wartość do odejmowania (subtrahend).</param>
        <summary>Odejmuje liczbą od drugiej złożone.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_Subtraction%2A> Metoda definiuje działania operator odejmowania dla liczby złożone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Odejmowanie liczby złożonej, c + podpisane z innej liczby złożonej, + analizy biznesowej, ma następującą postać:  
  
 (- c) + (b - d) i  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Subtract%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do wskazania ujemnej.</param>
        <summary>Zwraca odwrotność dodatku określonej liczby złożonej.</summary>
        <returns>Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki <paramref name="value" /> parametru pomnożona przez wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.op_UnaryNegation%2A> Metoda definiuje działania Jednoargumentowy operator negacji (dodatku odwrotność) dla liczby złożone. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 Wynikowa liczba zespolona daje wartość <xref:System.Numerics.Complex> 0 (zero), gdy jest ona dodawana do oryginalnego liczby złożonej. Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Negate%2A> metody zamiast tego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera fazy liczbą.</summary>
        <value>Faza liczby złożonej, w radianach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla liczbą + analizy biznesowej, fazę jest obliczana jako <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b).  
  
 Można zidentyfikować liczbą współrzędnych kartezjańskimi na płaszczyźnie złożone lub jego Współrzędne biegunowe. Fazy (argumentów) liczbą ma punkt o liczby złożonej kąt, do rzeczywistych osi linią z punktu pochodzenia (przecięcia osi x i y). Wielkość (reprezentowane przez <xref:System.Numerics.Complex.Magnitude%2A> właściwości) jest odległość między punkt początkowy punkt, który jest reprezentowana przez liczbę złożone.  
  
 Można utworzyć wystąpienia liczbą oparte na jego Współrzędne biegunowe, zamiast współrzędnych kartezjańskimi przez wywołanie metody <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody.  
  
 Aby przekonwertować fazy z radianów stopni, należy pomnożyć go przez 180 /<xref:System.Math.PI?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody tworzenia wystąpienia liczbą oparte na jego Współrzędne biegunowe, a następnie wyświetla wartość jego <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości.  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca określoną liczbę złożone podniesione do określonej potęgi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Liczby złożonej do podniesione do potęgi.</param>
        <param name="power">Liczba zmiennoprzecinkowe podwójnej precyzji, która określa potęgi.</param>
        <summary>Zwraca określoną liczbę złożone podniesionej do potęgi określonej przez liczbie zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Liczby złożone <paramref name="value" /> podniesionej do potęgi <paramref name="power" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>. Dla innych wartości Jeśli `power` ma wartość 0, metoda zwraca <xref:System.Numerics.Complex.One?displayProperty=nameWithType>i w razie `power` ma wartość 1, funkcja zwraca `value`.  
  
 Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia potęgowania przy użyciu liczbą i wykładnik, którego wartość może się wahać od -1 do 10.  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczby złożonej do podniesione do potęgi.</param>
        <param name="power">Liczba złożonych, określająca potęgi.</param>
        <summary>Zwraca określoną liczbę złożone podniesionej do potęgi określonej przez liczbą.</summary>
        <returns>Liczby złożone <paramref name="value" /> podniesionej do potęgi <paramref name="power" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik rzeczywistych bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</summary>
        <value>Rzeczywiste składnik liczbą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podany numer złożone + analizy biznesowej, <xref:System.Numerics.Complex.Real%2A> właściwość zwraca wartość.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Numerics.Complex> obiekty i wyświetla rzeczywiste i urojony składniki każdej z nich w formularzu + analizy biznesowej.  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca odwrotność multiplicative liczbą.</summary>
        <returns>Odwrotność <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wzajemne lub multiplicative odwrotność liczbą *x* jest liczbą *y* gdzie *x* pomnożona przez *y* daje 1. Liczby złożonej, której wynikiem jest odwrotność liczbą <xref:System.Numerics.Complex.One?displayProperty=nameWithType> kiedy są mnożone dwóch liczb. Jeśli liczbą jest reprezentowana przez + analizy biznesowej, jego odwrotność jest reprezentowana przez wyrażenie / (<sup>2</sup>+ b<sup>2</sup>) + -b / (<sup>2</sup> + b<sup>2</sup>).  
  
 Jeśli wartość jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>. W przeciwnym razie zwraca wynik wyrażenia <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Numerics.Complex.Reciprocal%2A> metodę obliczania wzajemnego wartości wielu kodów zespolonych. Również pokazuje, że wynik mnożenia liczbą przez jego odwrotność jest <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca sinus określonej liczby złożonej.</summary>
        <returns>Sinus <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Sin%2A> Odpowiada metoda liczby złożone <xref:System.Math.Sin%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Sin%2A> Metoda używa następującej formuły można obliczyć sinus liczby złożonej + analizy biznesowej:  
  
 (<xref:System.Math.Sin%2A>() * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>() * <xref:System.Math.Sinh%2A>(b))  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Sin%2A> metody. Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca sinus hiperboliczny liczby określonej liczby złożonej.</summary>
        <returns>Sinus hiperboliczny <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Sinh%2A> Odpowiada metoda liczby złożone <xref:System.Math.Sinh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Sinh%2A> Metoda używa następującej formuły można obliczyć sinus hiperboliczny liczby złożonej + analizy biznesowej:  
  
 (<xref:System.Math.Sinh%2A>() * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>() * <xref:System.Math.Sin%2A>(b))  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca pierwiastek kwadratowy z podanej liczby złożone.</summary>
        <returns>Pierwiastek kwadratowy liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwiastek kwadratowy z liczby złożonej `value` jest obliczana przy użyciu następującej formuły:  
  
 <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)   
  
 <xref:System.Numerics.Complex.Sqrt%2A> Odpowiada metoda liczby złożone <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">Wartość, którą chcesz odjąć od (minuend).</param>
        <param name="right">Wartość do odejmowania (subtrahend).</param>
        <summary>Odejmuje jedną liczbę złożone z innego i zwraca wynik.</summary>
        <returns>Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odejmowanie liczby złożonej, c + podpisane z innej liczby złożonej, + analizy biznesowej, ma następującą postać:  
  
 (- c) + (b - d) i  
  
 Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.  
  
 Można używać języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.Complex.Subtract%2A> metodę w celu odejmowania za pomocą liczby złożone.  
  
   
  
## Examples  
 Poniższy przykład odejmuje każdej liczby złożonej w tablicy z liczbą.  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca tangens określonej liczby złożonej.</summary>
        <returns>Tangens <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Tan%2A> Odpowiada metoda liczby złożone <xref:System.Math.Tan%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Tan%2A> Metoda używa następującej formuły można obliczyć tangens liczby złożonej `value`:  
  
 <xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)  
  
   
  
## Examples  
 Poniższy przykład przedstawia <xref:System.Numerics.Complex.Tan%2A> metody. Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">Liczba złożonych.</param>
        <summary>Zwraca tangens hiperboliczny dla określonej liczby złożonej.</summary>
        <returns>Tangens hiperboliczny liczby <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Tanh%2A> Odpowiada metoda liczby złożone <xref:System.Math.Tanh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.  
  
 <xref:System.Numerics.Complex.Tanh%2A> Metoda używa następującej formuły można obliczyć tangens hiperboliczny dla liczby złożonej `value`:  
  
 <xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość liczby złożonej do reprezentacji ciągu równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi.</summary>
        <returns>Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne reprezentację liczby złożonej Wyświetla liczbę przy użyciu współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony. Zarówno ** i *b* są sformatowane przy użyciu specyfikatora formatu Ogólne ("G") i konwencje związane z bieżącego ustawienia kulturowego systemu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono kilka liczby złożone reprezentację ciągu. Dane wyjściowe używa konwencji formatowania języka angielskiego - kultury Stanów Zjednoczonych ("pl pl"), który w tym przypadku jest bieżącego ustawienia kulturowego systemu.  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi przy użyciu określonego formatowania informacje specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi określony przez <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja ciągu liczby złożonej zwracane przez tę metodę. Wyświetla liczbę za pomocą współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony. Zarówno ** i *b* sformatowane przy użyciu specyfikatora formatu Ogólne ("G") i konwencje kultury zdefiniowane przez `provider`.  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie rzeczywistą i zespoloną liczb w zwracany ciąg. Jeśli `provider` jest `null`, zwracany ciąg sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.  
  
 `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiektu, który dostarcza informacje dotyczące formatowania.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje dotyczące formatowania.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono kilka liczby złożone reprezentację ciągu. Wynik używa konwencji formatowania Polish - poland ("pl pl") i francuskim - kultur Francja (fr-FR").  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <summary>Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi przy użyciu określonego formatu dla jego rzeczywistego i urojony części.</summary>
        <returns>Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja ciągu liczby złożonej zwracane przez tę metodę. Wyświetla liczbę za pomocą współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony. Zarówno ** i *b* są sformatowane przy użyciu określonej przez ciąg formatu `format`. `format` Parametr może być specyfikator wszystkie prawidłowe standardowego formatu liczbowego lub dowolną kombinację specyfikatory niestandardowego formatu liczbowego. Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, rzeczywiste i urojony części liczby złożonej są sformatowane specyfikator formatu Ogólne ("G"). Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.  
  
 .NET Framework zapewnia szeroką gamę formatowania, opisany bardziej szczegółowo w następujących tematach:  
  
-   Aby uzyskać więcej informacji na temat ciągi formatujące liczb, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 Format zwrócony ciąg jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury. W zależności od `format` parametr, ten obiekt określa symbole, takie jak znaku minus, separatora grupy i symbol punktu dziesiętnego w ciągu wyjściowego. Aby podać informacje dotyczące formatowania dla kultury niż bieżącej kultury, wywołaj <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.  
  
   
  
## Examples  
 Poniższy przykład inicjuje liczbą i wyświetla je przy użyciu kilku standardowe ciągi formatujące.  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest prawidłowym ciągiem formatu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Standardowy lub niestandardowy ciąg formatu liczbowego.</param>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi przy użyciu określonego formatu i informacji o formacie specyficzne dla kultury dla jego rzeczywistego i urojony części.</summary>
        <returns>Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi określony przez <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentacja ciągu liczby złożonej zwracane przez tę metodę. Wyświetla liczbę za pomocą współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony. Zarówno ** i *b* są sformatowane przy użyciu określonej przez ciąg formatu `format`. `format` Parametr może być specyfikator wszystkie prawidłowe standardowego formatu liczbowego lub dowolną kombinację specyfikatory niestandardowego formatu liczbowego. Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, rzeczywiste i urojony części liczby złożonej są sformatowane specyfikator formatu Ogólne ("G"). Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.  
  
 .NET Framework zapewnia szeroką gamę formatowania, opisany bardziej szczegółowo w następujących tematach:  
  
-   Aby uzyskać więcej informacji na temat ciągi formatujące liczb, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Aby uzyskać więcej informacji na temat formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Parametr jest <xref:System.IFormatProvider> implementacji. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie rzeczywistą i zespoloną liczb w zwracany ciąg. W zależności od `format` parametr, ten obiekt określa symbole, takie jak znaku minus, separatora grupy i symbol punktu dziesiętnego w ciągu wyjściowego. Jeśli `provider` jest `null`, zwracany ciąg sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.  
  
 `provider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania  
  
-   <xref:System.Globalization.NumberFormatInfo> Obiektu, który dostarcza informacje dotyczące formatowania.  
  
-   Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu. Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje dotyczące formatowania.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę liczby złożone i są wyświetlane wszystkie przy użyciu kilku standardowe ciągi formatujące oraz <xref:System.Globalization.CultureInfo> obiekty reprezentujące kultur angielskiego — Stany Zjednoczone ("pl pl") i francuskim - Francja (fr-FR").  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> nie jest prawidłowym ciągiem formatu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienia z liczbą rzeczywistą równa zero i liczbę zespoloną równa zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Complex.Zero> Jest najczęściej używana do porównania <xref:System.Numerics.Complex> wartość zero.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Numerics.Complex> wartość przy użyciu <xref:System.Numerics.Complex.Zero> właściwości. Następnie porównuje tę wartość na inną wartość, która zostanie uruchomiony przez wywołanie metody <xref:System.Numerics.Complex> konstruktora z rzeczywistą równa zero i część dotyczącą urojony równa zero. Jak pokazano na dane wyjściowe z przykładu, dwie wartości są równe.  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Complex" FullName="System.Numerics.Complex">
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a9f0e-101">Reprezentuje liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-102">Liczba zespolona to liczba, która składa się z części liczby rzeczywistej i części urojonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="a9f0e-103">Liczba złożona z jest zwykle zapisywana w postaci z = x + yi, gdzie *x* i *y* są liczbami rzeczywistymi, a *jestem* jednostką urojoną, która ma właściwość *i*<sup>2</sup> =-1.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="a9f0e-104">Rzeczywista część liczby zespolonej jest reprezentowana przez *x*, a część urojona liczby zespolonej jest reprezentowana przez *y*.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="a9f0e-105"><xref:System.Numerics.Complex> Typ używa układu współrzędnych kartezjańskiego (rzeczywistą, urojoną) podczas tworzenia wystąpienia i manipulowania liczbami złożonymi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="a9f0e-106">Liczba zespolona może być reprezentowana jako punkt w dwuwymiarowym układzie współrzędnych, który jest znany jako Płaszczyzna złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="a9f0e-107">Rzeczywista część liczby zespolonej jest umieszczana na osi x (osi poziomej), a część urojona jest umieszczana na osi y (oś pionowa).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="a9f0e-108">Każdy punkt w płaszczyźnie złożonej może być również wyrażony na podstawie jego wartości bezwzględnej przy użyciu układu współrzędnych biegunowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="a9f0e-109">We współrzędnych polarnych punkt jest scharakteryzowany przez dwie liczby:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="a9f0e-110">Jego wielkość, czyli odległość punktu od początku (to jest, 0, 0, lub punkt, w którym oś x i oś y przecinają).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="a9f0e-111">Jej faza, która jest kątem między osią rzeczywistą i linią pochodzącą od początku do punktu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="a9f0e-112">Utworzenie wystąpienia liczby zespolonej</span><span class="sxs-lookup"><span data-stu-id="a9f0e-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="a9f0e-113">Można przypisać wartość do liczby zespolonej w jeden z następujących sposobów:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="a9f0e-114">Przekazując dwie <xref:System.Double> wartości do jego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="a9f0e-115">Pierwsza wartość reprezentuje rzeczywistą część liczby zespolonej, a druga wartość reprezentuje jej część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="a9f0e-116">Te wartości reprezentują pozycję liczby zespolonej w dwuwymiarowym układzie współrzędnych kartezjańskiego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="a9f0e-117">Wywołując metodę static (`Shared` w Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> , aby utworzyć liczbę zespoloną na podstawie współrzędnych biegunowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="a9f0e-118"><xref:System.Byte>Przypisanie, ,,<xref:System.UInt64> ,,<xref:System.Numerics.Complex> ,,,, lub doobiektu.<xref:System.Double> <xref:System.UInt16> <xref:System.Int32> <xref:System.UInt32> <xref:System.Int16> <xref:System.SByte> <xref:System.Int64> <xref:System.Single></span><span class="sxs-lookup"><span data-stu-id="a9f0e-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="a9f0e-119">Wartość jest rzeczywistą częścią liczby zespolonej, a jej część urojona jest równa 0.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="a9f0e-120">Przez rzutowanie ( C#in) lub konwertowanie (w Visual Basic) <xref:System.Decimal> a <xref:System.Numerics.BigInteger> <xref:System.Numerics.Complex> lub wartości do obiektu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="a9f0e-121">Wartość jest rzeczywistą częścią liczby zespolonej, a jej część urojona jest równa 0.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="a9f0e-122">Przypisanie liczby zespolonej zwracanej przez metodę lub operator do <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="a9f0e-123">Na przykład <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> jest metodą statyczną zwracającą liczbę zespoloną, która jest sumą dwóch liczb zespolonych, <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> a operator dodaje dwie liczby zespolone i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="a9f0e-124">Poniższy przykład ilustruje każdy z tych pięciu sposobów przypisywania wartości do liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="a9f0e-125">Operacje na liczbach zespolonych</span><span class="sxs-lookup"><span data-stu-id="a9f0e-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="a9f0e-126"><xref:System.Numerics.Complex> Struktura w .NET Framework zawiera elementy członkowskie, które zapewniają następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="a9f0e-127">Metody porównywania dwóch liczb zespolonych, aby określić, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="a9f0e-128">Operatory wykonywania operacji arytmetycznych na liczbach złożonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="a9f0e-129"><xref:System.Numerics.Complex>Operatory umożliwiają dodawanie, odejmowanie, mnożenie, dzielenie i jednoargumentowe negację z liczbami złożonymi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="a9f0e-130">Metody wykonywania innych operacji numerycznych na liczbach zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="a9f0e-131">Oprócz czterech podstawowych operacji arytmetycznych można podnieść liczbę zespoloną do określonej potęgi, znaleźć pierwiastek kwadratowy liczby zespolonej i uzyskać wartość bezwzględną liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="a9f0e-132">Metody wykonywania operacji trygonometrycznych na liczbach zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="a9f0e-133">Na przykład można obliczyć tangens kąta reprezentowanego przez liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="a9f0e-134">Należy zauważyć, że ponieważ <xref:System.Numerics.Complex.Real%2A> właściwości <xref:System.Numerics.Complex.Imaginary%2A> i są tylko do odczytu, nie można zmodyfikować wartości istniejącego <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="a9f0e-135">Wszystkie metody, które wykonują operacje na <xref:System.Numerics.Complex> liczbie, jeśli ich wartość zwracana jest typu <xref:System.Numerics.Complex>, zwracają nowy <xref:System.Numerics.Complex> numer.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="a9f0e-136">Precyzja i liczby zespolone</span><span class="sxs-lookup"><span data-stu-id="a9f0e-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="a9f0e-137">Rzeczywiste i urojone części liczby zespolonej są reprezentowane przez dwie wartości zmiennoprzecinkowe podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="a9f0e-138">Oznacza to, <xref:System.Numerics.Complex> że wartości, takie jak wartości zmiennoprzecinkowe podwójnej precyzji, mogą utracić dokładność w wyniku operacji numerycznych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="a9f0e-139">Oznacza to, że ścisłe porównania dla równości <xref:System.Numerics.Complex> dwóch wartości mogą zakończyć się niepowodzeniem, nawet jeśli różnica między tymi dwiema wartościami jest spowodowana utratą precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="a9f0e-140">Aby uzyskać więcej informacji, zobacz <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="a9f0e-141">Na przykład wykonywanie potęgowania na logarytmie liczby powinno zwracać pierwotną liczbę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="a9f0e-142">Jednak w niektórych przypadkach utrata dokładności wartości zmiennoprzecinkowych może spowodować niewielkie różnice między tymi dwiema wartościami, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="a9f0e-143">Podobnie Poniższy przykład, który oblicza pierwiastek kwadratowy <xref:System.Numerics.Complex> liczby, tworzy nieco inne wyniki na 32-bitowej i ia64 wersjach .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="a9f0e-144">Liczby zespolone, nieskończoność i NaN</span><span class="sxs-lookup"><span data-stu-id="a9f0e-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="a9f0e-145">Rzeczywiste i urojone części liczby zespolonej są reprezentowane przez <xref:System.Double> wartości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="a9f0e-146">Oprócz <xref:System.Double.MinValue?displayProperty=nameWithType> zakresu od <xref:System.Double.NaN?displayProperty=nameWithType>do <xref:System.Double.MaxValue?displayProperty=nameWithType>, rzeczywista lub urojona część liczby zespolonej <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>może mieć wartość, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> i<xref:System.Double.NaN?displayProperty=nameWithType> wszystkie są propagowane w każdej operacji arytmetycznej lub trygonometrycznej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="a9f0e-148">W poniższym przykładzie dzielenie przez <xref:System.Numerics.Complex.Zero> tworzy liczbę zespoloną, której elementy rzeczywiste i urojone są oba. <xref:System.Double.NaN?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-149">W efekcie wykonywanie mnożenia z tą wartością również daje liczbę zespoloną, której części rzeczywiste i urojone są <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-150">Podobnie wykonywanie operacji mnożenia, która przepełni zakres <xref:System.Double> typu, daje liczbę zespoloną, której część rzeczywista jest <xref:System.Double.NaN?displayProperty=nameWithType> i której części urojonej jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-151">Następnie wykonanie dzielenia przy użyciu tej liczby zespolonej zwraca liczbę zespoloną, której <xref:System.Double.NaN?displayProperty=nameWithType> część rzeczywista jest i której <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>części urojonej jest.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="a9f0e-152">Operacje matematyczne ze złożonymi liczbami, które są nieprawidłowe lub które przepełnią zakres <xref:System.Double> typu danych, nie generują wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="a9f0e-153">Zamiast tego zwracają <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>lub <xref:System.Double.NaN?displayProperty=nameWithType> w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="a9f0e-154">Dzielenie liczby dodatniej przez zero zwraca wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a9f0e-155">Każda operacja, która przepełni górną granicę <xref:System.Double> zwracanego <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>typu danych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a9f0e-156">Dzielenie ujemnej liczby przez zero zwraca wartość <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a9f0e-157">Każda operacja, która przepełniła dolną granicę <xref:System.Double> zwracanego <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>typu danych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a9f0e-158">Podział wartości zerowej przez zero zwraca wartość <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a9f0e-159">Każda operacja wykonywana w przypadku operandów, których wartości to <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>lub <xref:System.Double.NaN?displayProperty=nameWithType>, w zależności od określonej operacji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="a9f0e-160">Należy zauważyć, że dotyczy to wszelkich obliczeń pośrednich wykonanych przez metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="a9f0e-161">Na przykład mnożenia `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` używa formuły (AC-BD) + (AD + BC) i.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="a9f0e-162">Obliczenie składnika rzeczywistego, który powstał w wyniku mnożenia, oblicza wyrażenie 9e308 \* 2,5-9e308 \* 3,5.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="a9f0e-163"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>Każde pośrednie mnożenie w tym wyrażeniu zwraca i próba odejmowania <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> od <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Return. <xref:System.Double.NaN?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="a9f0e-164">Formatowanie liczby zespolonej</span><span class="sxs-lookup"><span data-stu-id="a9f0e-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="a9f0e-165">`(`Domyślnie ciąg reprezentujący liczbę zespoloną przyjmuje postać`)` *rzeczywistej* `,` <xref:System.Double> *urojonej*, gdzie *rzeczywiste* i urojone są \*\* reprezentacjami ciągu wartości, które tworzą rzeczywiste i urojone składniki liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="a9f0e-166">Niektóre przeciążenia <xref:System.Numerics.Complex.ToString%2A> metody umożliwiają dostosowanie ciągu reprezentacji tych <xref:System.Double> wartości w celu odzwierciedlenia Konwencji formatowania określonej kultury lub wyświetlania w określonym formacie zdefiniowanym przez standardową lub niestandardową wartość ciąg formatu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="a9f0e-167">(Aby uzyskać więcej informacji, zobacz [Standardowe ciągi formatujące numeryczne](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatu niestandardowego](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="a9f0e-167">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="a9f0e-168">Jednym z najpopularniejszych sposobów wyrażania ciągu reprezentującego liczbę zespoloną jest forma a + bi, gdzie a to prawdziwy składnik liczby zespolonej, a b to składnik urojony liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="a9f0e-169">W inżynierii elektrycznej liczba złożona jest najczęściej wyrażona jako + BJ.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="a9f0e-170">Można zwrócić ciąg reprezentujący liczbę zespoloną w jednej z tych dwóch form.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="a9f0e-171">Aby to zrobić, zdefiniuj niestandardowego dostawcę formatowania <xref:System.ICustomFormatter> <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> , implementując interfejsy i <xref:System.IFormatProvider> , a następnie Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a9f0e-172">W poniższym przykładzie zdefiniowano `ComplexFormatter` klasę, która reprezentuje liczbę zespoloną jako ciąg w postaci a + bi lub + BJ.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="a9f0e-173">Poniższy przykład używa tego niestandardowego programu formatującego do wyświetlania ciągu reprezentującego liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="a9f0e-174">Rzeczywista część liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="a9f0e-175">Część urojona liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-176">Inicjuje nowe wystąpienie <see cref="T:System.Numerics.Complex" /> struktury przy użyciu określonych wartości rzeczywistych i urojonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-177">Argumenty `real` <xref:System.Double>lub `imaginary` mogą utracić precyzję, jeśli są typami danych, które wymagają jawnego rzutowania do.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-178">Poniższy przykład tworzy wystąpienie dwóch liczb zespolonych, a następnie używa ich w operacjach dodawania, odejmowania, mnożenia i dzielenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-179">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-180">Pobiera wartość bezwzględną (lub wielkości) liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-181">Wartość bezwzględna <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-182">Wartość bezwzględna liczby zespolonej jest równoważna z <xref:System.Numerics.Complex.Magnitude%2A> jej właściwością.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="a9f0e-183">Wartość bezwzględna liczby rzeczywistej a + bi jest obliczana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-183">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="a9f0e-184">Jeśli b = 0, wynik wynosi 0.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-184">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="a9f0e-185">Jeśli > b, wynikiem jest \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-185">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="a9f0e-186">Jeśli b > a, wynikiem jest b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="a9f0e-187">Jeśli Obliczanie wartości bezwzględnej powoduje przepełnienie, metoda zwraca albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-188"><xref:System.Numerics.Complex.Imaginary%2A> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType>Jeśli właściwość <xref:System.Numerics.Complex.Real%2A> or ma<xref:System.Double.NaN?displayProperty=nameWithType> wartość, a druga właściwość nie jest ani ani, metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-189">Poniższy przykład oblicza wartość bezwzględną liczby zespolonej i pokazuje, że jest ona równoważna z wartością <xref:System.Numerics.Complex.Magnitude%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-190">Liczba zespolona reprezentująca cosinus.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="a9f0e-191">Zwraca kąt, który jest cosinusem łuku określonego numeru zespolonego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-192">Kąt mierzony w radianach, który jest cosinusem <paramref name="value" />łuku.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-193">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Acos%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Acos%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-194"><xref:System.Numerics.Complex.Acos%2A> Metoda używa następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="a9f0e-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-196">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Acos%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="a9f0e-197">Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <Docs>
        <summary><span data-ttu-id="a9f0e-198">Dodaje określoną liczbę do innej określonej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-198">Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <span data-ttu-id="a9f0e-199"><xref:System.Numerics.Complex.Add%2A> Metody umożliwiają wykonywanie operacji dodawania, które obejmują liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-199">The <xref:System.Numerics.Complex.Add%2A> methods allow performing addition operations that involve complex numbers.</span></span> 
  
 <span data-ttu-id="a9f0e-200">Jeśli metoda wywołuje wyniki w przepełnieniu w składniku rzeczywistym lub urojonym, wartość składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-200">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a9f0e-201">W językach, które nie obsługują niestandardowych operatorów, <xref:System.Numerics.Complex.Add%2A> można używać metody do dodawania liczb złożonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-201">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  

 <span data-ttu-id="a9f0e-202"><xref:System.Numerics.Complex.Add%2A> Metody, które odbierają jeden podwójnie są wydajniejsze niż metody, które odbierają dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-202">The <xref:System.Numerics.Complex.Add%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.</span></span>
  
## Examples  

 <span data-ttu-id="a9f0e-203">Poniższy przykład ilustruje Dodawanie liczb złożonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-203">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-204">Wartość rzeczywista podwójnej precyzji do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-204">The double-precision real value to add.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-205">Wartość złożona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-205">The complex value to add.</span></span></param>
        <summary><span data-ttu-id="a9f0e-206">Dodaje liczbę rzeczywistą o podwójnej precyzji do liczby zespolonej i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-206">Adds a double-precision real number to a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-207">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-207">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="a9f0e-208">Dodanie liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczby zespolonej (c + di) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-208">The addition of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="a9f0e-209">(a + c) + di</span><span class="sxs-lookup"><span data-stu-id="a9f0e-209">(a + c) + di</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-210">Wartość złożona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-210">The complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-211">Wartość rzeczywista podwójnej precyzji do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-211">The double-precision real value to add.</span></span></param>
        <summary><span data-ttu-id="a9f0e-212">Dodaje liczbę zespoloną do liczby rzeczywistej o podwójnej precyzji i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-212">Adds a complex number to a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-213">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-213">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="a9f0e-214">Dodanie liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-214">The addition of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-215">(a + c) + BI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-215">(a + c) + bi</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-216">Pierwsza liczba zespolona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-216">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-217">Druga liczba zespolona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-217">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="a9f0e-218">Dodaje dwie liczby zespolone i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-218">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-219">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-219">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-220">Dodanie liczby zespolonej, a + bi i drugiej liczby zespolonej, c + di, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-220">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="a9f0e-221">(a + c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-221">(a + c) + (b + d)i.</span></span>  

  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-222">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-222">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-223">Zwraca kąt, który jest sinusem łuku określonego numeru zespolonego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-223">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-224">Kąt, który jest sinusem <paramref name="value" />łuku.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-224">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-225">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Asin%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Asin%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-225">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-226"><xref:System.Numerics.Complex.Asin%2A> Metoda używa następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-226">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="a9f0e-227">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* wartość + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -Value \* wartość))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-227">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-228">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Asin%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-228">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="a9f0e-229">Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-229">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-230">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-230">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-231">Zwraca kąt, który jest tangens łuku określonego numeru zespolonego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-231">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-232">Kąt, który jest tangens <paramref name="value" />łuku.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-232">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-233">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Atan%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Atan%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-233">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-234"><xref:System.Numerics.Complex.Atan%2A> Metoda używa następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-234">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="a9f0e-235">(<xref:System.Numerics.Complex.ImaginaryOne> /New Complex (2.0, 0,0)) \* (<xref:System.Numerics.Complex.Log%2A><xref:System.Numerics.Complex.ImaginaryOne> (<xref:System.Numerics.Complex.One>  -  \* wartość)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* Value))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-235">(<xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value))</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-236">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Atan%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-236">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="a9f0e-237">Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-237">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-238">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-238">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-239">Oblicza sprzężenie liczby zespolonej i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-239">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-240">Sprzężenie <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-240">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-241">Sprzężenie liczby zespolonej odwraca znak części urojonej; oznacza to, że stosuje jednoargumentowe negację do części urojonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-241">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="a9f0e-242">Jeśli program + BI jest liczbą zespoloną, jej sprzężenie jest typu-BI.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-242">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-243">Poniższy przykład wyświetla sprzężenie dwóch liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-243">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-244">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-244">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-245">Zwraca cosinus podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-245">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-246">Cosinus <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-246">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-247">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Cos%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Cos%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-247">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-248"><xref:System.Numerics.Complex.Cos%2A> Metoda używa następującej formuły, aby obliczyć cosinus liczby zespolonej a + bi:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-248">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="a9f0e-249">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-249">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-250">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Acos%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-250">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="a9f0e-251">Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-251">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-252">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-252">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-253">Zwraca cosinus hiperboliczny podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-253">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-254">Cosinus hiperboliczny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-254">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-255">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Cosh%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Cosh%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-255">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-256"><xref:System.Numerics.Complex.Cosh%2A> Metoda używa następującej formuły, aby obliczyć cosinus hiperboliczny liczby zespolonej a + bi:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-256">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="a9f0e-257">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-257">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <Docs>
        <summary><span data-ttu-id="a9f0e-258">Dzieli określoną liczbę przez inny określony numer, gdzie co najmniej jeden z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-258">Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <span data-ttu-id="a9f0e-259"><xref:System.Numerics.Complex.Divide%2A> Metody umożliwiają wykonywanie operacji dzielenia, które obejmują liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-259">The <xref:System.Numerics.Complex.Divide%2A> methods allow performing division operations that involve complex numbers.</span></span> 
  
 <span data-ttu-id="a9f0e-260">Jeśli obliczenie ilorazu spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-260">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a9f0e-261"><xref:System.Numerics.Complex.Divide%2A> Metoda może być używana przez Języki, które nie obsługują operatorów niestandardowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-261">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="a9f0e-262">Zachowanie jest takie samo jak w przypadku dzielenia przy użyciu operatora dzielenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-262">Its behavior is identical to division using the division operator.</span></span>  

 <span data-ttu-id="a9f0e-263"><xref:System.Numerics.Complex.Divide%2A> Metody, które odbierają jeden podwójnie są wydajniejsze niż metody, które odbierają dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-263">The <xref:System.Numerics.Complex.Divide%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.</span></span>

## Examples  
 <span data-ttu-id="a9f0e-264">Poniższy przykład dzieli liczbę zespoloną przez każdy element w tablicy liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-264">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
   
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (double dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(float64 dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Double, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(double dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="a9f0e-265">Liczba rzeczywista podwójnej precyzji, która ma zostać podzielona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-265">The double-precision real number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="a9f0e-266">Liczba złożona do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-266">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="a9f0e-267">Dzieli jedną liczbę rzeczywistą o podwójnej precyzji przez liczbę zespoloną i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-267">Divides one double-precision real number by a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-268">Iloraz dzielenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-268">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="a9f0e-269">Podział liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-269">The division of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

 <span data-ttu-id="a9f0e-270">(AC/(c<sup>2</sup> + d<sup>2</sup>)) + (AD/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-270">(ac / (c<sup>2</sup> + d<sup>2</sup>)) + (ad / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, double divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, float64 divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, double divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="divisor" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="a9f0e-271">Liczba zespolona, która ma zostać podzielona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-271">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="a9f0e-272">Liczba rzeczywista podwójnej precyzji do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-272">The double-precision real number to divide by.</span></span></param>
        <summary><span data-ttu-id="a9f0e-273">Dzieli jedną liczbę zespoloną przez liczbę rzeczywistą o podwójnej precyzji i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-273">Divides one complex number by a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-274">Iloraz dzielenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-274">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="a9f0e-275">Podział liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-275">The division of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

 <span data-ttu-id="a9f0e-276">(AC/c<sup>2</sup>) + (BC/c<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-276">(ac / c<sup>2</sup>) + (bc / c<sup>2</sup>)i</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="a9f0e-277">Liczba zespolona, która ma zostać podzielona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-277">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="a9f0e-278">Liczba złożona do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-278">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="a9f0e-279">Dzieli jedną liczbę zespoloną przez inną i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-279">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-280">Iloraz dzielenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-280">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-281">Dzielenie liczby zespolonej z + BI, przez drugą liczbę zespoloną, Number, c + di, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-281">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="a9f0e-282">((AC + BD)/(c<sup>2</sup> + d<sup>2</sup>)) + ((BC-AD)/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-282">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
    
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a9f0e-283">Zwraca wartość wskazującą, czy dwie liczby zespolone są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-283">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-284">Liczba zespolona do porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-284">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="a9f0e-285">Zwraca wartość wskazującą, czy bieżące wystąpienie i określona liczba złożona mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-285">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-286"><see langword="true" />Jeśli ta liczba złożona i <paramref name="value" /> ma tę samą wartość; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-286"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-287">Metoda zapewnia implementację <xref:System.Numerics.Complex>struktury. <xref:System.IEquatable%601> <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29></span><span class="sxs-lookup"><span data-stu-id="a9f0e-287">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="a9f0e-288">Jest wykonywane nieco lepiej niż <xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda, ponieważ nie musi skonwertować jej parametru na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-288">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="a9f0e-289">Dwie liczby zespolone są równe, jeśli ich rzeczywiste części są równe, a ich części urojone są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-289">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="a9f0e-290"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda jest równoważna z następującym wyrażeniem:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-290">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="a9f0e-291"><see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> Użyj metody z zachowaniem ostrożności, ponieważ dwie wartości, które są uważane za równoważne mogą być uznawane za nierówne ze względu na zróżnicowaną precyzję ich rzeczywistych i urojonych składników.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-291">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="a9f0e-292">Następujące przykładowe raporty <c>(3,33333, 0,142857)</c> i <c>(10/3, 1/7)</c> nie są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-292">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="a9f0e-293">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="a9f0e-293">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="a9f0e-294">Jedną z zalecanych technik jest zdefiniowanie akceptowalnego marginesu różnicy między tymi dwiema wartościami (na przykład .01% jednego z wartości rzeczywistych i urojonych) zamiast porównywania wartości dla równości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-294">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="a9f0e-295">Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza lub równa marginesowi, różnica jest prawdopodobnie spowodowana różnicą precyzji i dlatego wartości mogą być równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-295">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="a9f0e-296">Poniższy przykład korzysta z tej techniki, aby porównać dwie wartości złożone, których poprzedni przykład kodu nie jest równy.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-296">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="a9f0e-297">Znaleziono dwie liczby zespolone jako równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-297">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="a9f0e-298">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="a9f0e-298">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a9f0e-299">Obiekt do porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-299">The object to compare.</span></span></param>
        <summary><span data-ttu-id="a9f0e-300">Zwraca wartość wskazującą, czy bieżące wystąpienie i określony obiekt mają tę samą wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-300">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-301"><see langword="true" /><see langword="false" /> <see cref="T:System.Numerics.Complex" /> <see cref="T:System.Numerics.Complex" /> Jeśli parametr jest obiektem lub typem umożliwiającym niejawną konwersję do obiektu, a jego wartość jest równa bieżącemu obiektowi; w przeciwnym razie,. <see cref="T:System.Numerics.Complex" /> <paramref name="obj" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-301"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-302">Dwie liczby zespolone są równe, jeśli ich rzeczywiste części są równe, a ich części urojone są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-302">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="a9f0e-303"><xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda jest równoważna z następującym wyrażeniem:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-303">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="a9f0e-304"><xref:System.Numerics.Complex> <xref:System.Numerics.Complex.Equals%28System.Object%29> `obj` Jeśli parametr nie jest obiektem,alejesttypemdanych,dlaktóregozdefiniowanoniejawnąkonwersję,Metodakonwertujedoobiektu,któregoczęśćrzeczywistajestrównawartości<xref:System.Numerics.Complex> `obj` `obj`i których część urojona jest równa zero przed przeprowadzeniem porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-304">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="a9f0e-305">Poniższy przykład ilustruje to poprzez znalezienie, że liczba zespolona i wartość zmiennoprzecinkową o podwójnej precyzji są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-305">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="a9f0e-306"><see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> Użyj metody z zachowaniem ostrożności, ponieważ dwie wartości, które są uważane za równoważne mogą być uznawane za nierówne ze względu na zróżnicowaną precyzję ich rzeczywistych i urojonych składników.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-306">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="a9f0e-307">Problem może być accentuated, jeśli <paramref name="obj" /> musi zostać przekonwertowany na <see cref="T:System.Double" /> a przed przeprowadzeniem porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-307">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="a9f0e-308">Poniższy przykład porównuje liczbę zespoloną, której prawdziwy składnik wydaje się być równy <see cref="T:System.Single" /> wartości tej <see cref="T:System.Single" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-308">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="a9f0e-309">Jak widać, porównanie dla zwracanych <see langword="False" />danych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-309">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="a9f0e-310">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="a9f0e-310">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="a9f0e-311">Jedną z zalecanych technik jest zdefiniowanie akceptowalnego marginesu różnicy między tymi dwiema wartościami (na przykład .01% jednego z wartości rzeczywistych i urojonych) zamiast porównywania wartości dla równości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-311">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="a9f0e-312">Jeśli wartość bezwzględna różnicy między dwoma wartościami jest mniejsza lub równa marginesowi, różnica jest prawdopodobnie spowodowana różnicą precyzji i dlatego wartości mogą być równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-312">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="a9f0e-313">Poniższy przykład korzysta z tej techniki, aby porównać dwie wartości, które nie zostały odnalezione przez poprzedni przykład kodu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-313">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="a9f0e-314">Teraz znajdzie je na równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-314">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="a9f0e-315">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="a9f0e-315">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-316">Liczba złożona, która określa potęgę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-316">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="a9f0e-317">Zwraca <see langword="e" /> wartość podniesioną do potęgi określonej przez liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-317">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-318">Liczba <see langword="e" /> podniesiona do potęgi <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-318">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-319"><xref:System.Numerics.Complex.Pow%2A> Użyj metody, aby obliczyć uprawnienia innych baz.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-319">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="a9f0e-320">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Exp%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Exp%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-320">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="a9f0e-321"><xref:System.Numerics.Complex.Exp%2A>jest odwrotnością <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-321"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-322">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Exp%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-322">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="a9f0e-323">Pokazuje to <xref:System.Double> , że z pewnym <xref:System.Numerics.Complex.Log%2A> wpływem na brak dokładności typu danych, przekazując wartość zwróconą przez metodę do <xref:System.Numerics.Complex.Exp%2A> metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-323">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="a9f0e-324">Wartość, czyli odległość od początku (część wspólna osi x i oś y) do liczby.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-324">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="a9f0e-325">Faza, która jest kątem od linii do osi poziomej, mierzona w radianach.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-325">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="a9f0e-326">Tworzy liczbę zespoloną na podstawie współrzędnych bieguna punktu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-326">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-327">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-327">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-328"><xref:System.Numerics.Complex.FromPolarCoordinates%2A> Metoda tworzy wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-328">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="a9f0e-329">Ponieważ istnieje wiele reprezentacji punktu na złożonej płaszczyźnie, wartość <xref:System.Numerics.Complex.FromPolarCoordinates%2A> zwracana metody jest znormalizowana.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-329">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="a9f0e-330">Wartość jest znormalizowana na liczbę dodatnią, a faza jest znormalizowana do wartości z zakresu od<xref:System.Math.PI> do. <xref:System.Math.PI></span><span class="sxs-lookup"><span data-stu-id="a9f0e-330">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="a9f0e-331">W związku z tym <xref:System.Numerics.Complex.Phase%2A> wartości i <xref:System.Numerics.Complex.Magnitude%2A> właściwości wynikowej liczby zespolonej nie mogą być równe oryginalnymi wartościom `magnitude` parametrów i `phase` .</span><span class="sxs-lookup"><span data-stu-id="a9f0e-331">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="a9f0e-332">Aby przekonwertować wartość z stopni na radiany dla `phase` parametru, pomnóż ją przez <xref:System.Math.PI?displayProperty=nameWithType>/180.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-332">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-333">W poniższym przykładzie zastosowano <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodę w celu utworzenia wystąpienia liczby zespolonej na podstawie współrzędnych bieguna, a następnie <xref:System.Numerics.Complex.Magnitude%2A> wyświetlenia <xref:System.Numerics.Complex.Phase%2A> wartości właściwości i.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-333">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a9f0e-334">Zwraca kod skrótu dla bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-334">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-335">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-335">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-336">Pobiera składnik urojony bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-336">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="a9f0e-337">Składnik urojony liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-337">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-338">Uwzględniając liczbę zespoloną a + bi, <xref:System.Numerics.Complex.Imaginary%2A> Właściwość zwraca wartość b.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-338">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-339">Poniższy przykład tworzy wystąpienie tablicy <xref:System.Numerics.Complex> obiektów i wyświetla rzeczywiste i urojone składniki każdego z nich w formie a + bi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-339">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-340">Zwraca nowe <see cref="T:System.Numerics.Complex" /> wystąpienie o liczbie rzeczywistej równej zero i liczbie urojonej równej jednemu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-340">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a9f0e-341">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości przy <xref:System.Numerics.Complex.ImaginaryOne> użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-341">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="a9f0e-342">Następnie porównuje tę wartość z inną wartością, która jest tworzona przez wywołanie <xref:System.Numerics.Complex> konstruktora z częścią rzeczywistą równą zero i części urojonej równej jednej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-342">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="a9f0e-343">Ponieważ dane wyjściowe z przykładu są wyświetlane, te dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-343">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Infinity" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Infinity As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Infinity;" />
      <MemberSignature Language="F#" Value=" staticval mutable Infinity : System.Numerics.Complex" Usage="System.Numerics.Complex.Infinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-344">Reprezentuje nieskończoność jako liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-344">Represents infinity as a complex number.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsFinite(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsFinite : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsFinite value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-345">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-345">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-346">Określa, czy określony numer złożony jest skończona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-346">Determines whether the specified complex number is finite.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-347"><see langword="true" />Jeśli obie wartości, rzeczywiste i urojone części są ograniczone (zero, subnormal lub Normal); w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-347"><see langword="true" /> if both, the real and imaginary parts are finite (zero, subnormal or normal); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInfinity value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-348">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-348">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-349">Zwraca wartość wskazującą, czy określona liczba złożona ma być wartością nieskończoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-349">Returns a value indicating whether the specified complex number evaluates to infinity.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-350"><see langword="true"/>w przypadku obu, części rzeczywistej lub urojonej <see cref="F:System.Double.PositiveInfinity" /> są <see cref="F:System.Double.NegativeInfinity" />lub; w <see langword="false"/>przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-350"><see langword="true"/> if either, the real or imaginary part are <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />; otherwise, <see langword="false"/>.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNaN(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsNaN : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNaN value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-351">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-351">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-352">Zwraca wartość wskazującą, czy określone wystąpienie złożone nie jest liczbą (NaN).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-352">Returns a value that indicates whether the specified complex instance is not a number (NaN).</span></span></summary>
        <returns><span data-ttu-id="a9f0e-353"><see langword="true"/>Jeśli określona wartość nie jest skończona ani nieskończona; w przeciwnym razie. <see langword="false"/></span><span class="sxs-lookup"><span data-stu-id="a9f0e-353"><see langword="true"/> if the specified value is not finite nor infinite; otherwise, <see langword="false"/>.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a9f0e-354">Zwraca logarytm liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-354">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-355">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-355">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-356">Zwraca logarytm naturalny (podstawowy <see langword="e" />) podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-356">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-357">Logarytm naturalny (podstawowy <see langword="e" />) elementu. <paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-357">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-358">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29></span><span class="sxs-lookup"><span data-stu-id="a9f0e-358">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-359">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Log%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-359">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="a9f0e-360">Pokazuje to <xref:System.Double> , że z pewnym <xref:System.Numerics.Complex.Log%2A> wpływem na brak dokładności typu danych, przekazując wartość zwróconą przez metodę do <xref:System.Numerics.Complex.Exp%2A> metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-360">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-361">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-361">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="a9f0e-362">Podstawa logarytmu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-362">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="a9f0e-363">Zwraca logarytm o określonej liczbie zespolonej w określonej bazie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-363">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-364">LOGARYTM <paramref name="value" /> w elemencie Base <paramref name="baseValue" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-364">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-365">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29></span><span class="sxs-lookup"><span data-stu-id="a9f0e-365">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-366">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-366">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-367">Zwraca logarytm dziesiętny dla podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-367">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-368">Logarytm dziesiętny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-368">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-369">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Log10%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-369">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-370">Pobiera wartość (lub bezwzględną) liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-370">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="a9f0e-371">Wielkość bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-371">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-372"><xref:System.Numerics.Complex.Magnitude%2A> Właściwość jest równoważna z wartością bezwzględną liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-372">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="a9f0e-373">Określa odległość od początku (część wspólna osi x i oś y w układzie współrzędnych kartezjańskiego) do dwuwymiarowego punktu reprezentowanego przez liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-373">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="a9f0e-374">Wartość bezwzględna jest obliczana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-374">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="a9f0e-375">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span><span class="sxs-lookup"><span data-stu-id="a9f0e-375">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="a9f0e-376">Jeśli Obliczanie wartości bezwzględnej spowoduje przepełnienie, ta właściwość zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> albo lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-376">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a9f0e-377"><xref:System.Numerics.Complex.Magnitude%2A> Iwłaściwościdefiniująpozycjępunktu,któryreprezentujeliczbęzespolonąwukładziewspółrzędnych<xref:System.Numerics.Complex.Phase%2A> biegunowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-377">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="a9f0e-378">Można utworzyć wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych zamiast jej współrzędnych kartezjańskiego <xref:System.Numerics.Complex.FromPolarCoordinates%2A> przez wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-378">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-379">Poniższy przykład oblicza wartość bezwzględną liczby zespolonej i pokazuje, że jest ona równoważna z wartością <xref:System.Numerics.Complex.Magnitude%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-379">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary><span data-ttu-id="a9f0e-380">Mnoży określoną liczbę przez inny określony numer, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-380">Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

 <span data-ttu-id="a9f0e-381"><xref:System.Numerics.Complex.Multiply%2A> Metody umożliwiają wykonywanie operacji mnożenia obejmujących liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-381">The <xref:System.Numerics.Complex.Multiply%2A> methods allow performing multiplication operations that involve complex numbers.</span></span>

 <span data-ttu-id="a9f0e-382">Jeśli mnożenie spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-382">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
 
 <span data-ttu-id="a9f0e-383"><xref:System.Numerics.Complex.Multiply%2A> Metoda jest implementowana dla języków, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-383">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="a9f0e-384">Zachowanie jest takie samo jak mnożenie przy użyciu operatora mnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-384">Its behavior is identical to multiplication using the multiplication operator.</span></span>  

  
## Examples  
 <span data-ttu-id="a9f0e-385">Poniższy przykład tworzy wiele liczb zespolonych przez każdy element w tablicy liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-385">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-386">Liczba rzeczywista podwójnej precyzji do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-386">The double-precision real number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-387">Liczba zespolona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-387">The complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="a9f0e-388">Zwraca iloczyn liczby rzeczywistej o podwójnej precyzji i liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-388">Returns the product of a double-precision real number and a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-389">Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</span><span class="sxs-lookup"><span data-stu-id="a9f0e-389">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="a9f0e-390">Liczebność liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-390">The multiplication of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>
 
 <span data-ttu-id="a9f0e-391">AC + ADI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-391">ac + adi</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-392">Liczba zespolona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-392">The complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-393">Liczba rzeczywista podwójnej precyzji do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-393">The double-precision real number to multiply.</span></span></param>
        <summary><span data-ttu-id="a9f0e-394">Zwraca iloczyn liczby zespolonej i liczby rzeczywistej o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-394">Returns the product of a complex number and a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-395">Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</span><span class="sxs-lookup"><span data-stu-id="a9f0e-395">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-396">Iloczyn liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-396">The multiplication of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-397">AC + BCI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-397">ac + bci</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-398">Pierwsza liczba zespolona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-398">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-399">Druga liczba zespolona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-399">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="a9f0e-400">Zwraca iloczyn dwóch liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-400">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-401">Iloczyn <paramref name="left" /> parametrów i <paramref name="right" /> .</span><span class="sxs-lookup"><span data-stu-id="a9f0e-401">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-402">Mnożenie liczby zespolonej, analizy biznesowej i drugiej liczby zespolonej, c + di, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-402">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="a9f0e-403">(AC-BD) + (AD + BC) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-403">(ac - bd) + (ad + bc)i</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex NaN" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NaN As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex NaN;" />
      <MemberSignature Language="F#" Value=" staticval mutable NaN : System.Numerics.Complex" Usage="System.Numerics.Complex.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-404">Reprezentuje wystąpienie złożone, które nie jest liczbą (NaN).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-404">Represents a complex instance that is not a number (NaN).</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-405">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-405">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-406">Zwraca wartość z przewidzianą przez funkcję odwrotną do określonej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-406">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-407">Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki parametrupomnożoneprzez-1.<paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-407">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-408">Dodatek odwrotny do liczby zespolonej jest liczbą zespoloną, która tworzy wartość <xref:System.Numerics.Complex> , gdy zostanie dodana do oryginalnej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-408">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="a9f0e-409">Ta metoda zwraca liczbę zespoloną, w której rzeczywiste i urojone składniki oryginalnej liczby zespolonej są mnożone przez-1.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-409">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="a9f0e-410"><xref:System.Numerics.Complex.Negate%2A> Metoda jest implementowana dla języków, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-410">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="a9f0e-411">Zachowanie jest takie samo jak Negacja przy użyciu jednoargumentowego operatora <xref:System.Numerics.Complex.op_UnaryNegation%2A>negacji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-411">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-412">Poniższy przykład uzyskuje dodatkową funkcję odwrotną dla każdego elementu w tablicy liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-412">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-413">Zwraca nowe <see cref="T:System.Numerics.Complex" /> wystąpienie o liczbie rzeczywistej równej jednej i liczbie urojonej równej zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-413">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a9f0e-414">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości przy <xref:System.Numerics.Complex.One> użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-414">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="a9f0e-415">Następnie porównuje tę wartość z inną wartością, która jest tworzona przez wywołanie <xref:System.Numerics.Complex> konstruktora z częścią rzeczywistą równą jednej i części urojonej równej zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-415">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="a9f0e-416">Ponieważ dane wyjściowe z przykładu są wyświetlane, te dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-416">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <Docs>
        <summary><span data-ttu-id="a9f0e-417">Dodaje określoną liczbę do innej określonej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-417">Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<span data-ttu-id="a9f0e-418"><xref:System.Numerics.Complex.op_Addition%2A> Operator umożliwia wykonywanie operacji dodawania, które obejmują liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-418">The <xref:System.Numerics.Complex.op_Addition%2A> operator allows performing addition operations that involve complex numbers.</span></span> <span data-ttu-id="a9f0e-419">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-419">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
[!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]

<span data-ttu-id="a9f0e-420">Jeśli dodanie spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-420">If the addition results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a9f0e-421">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%2A> równoważną grupę metod.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-421">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="a9f0e-422"><xref:System.Numerics.Complex.op_Addition%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-422">The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

## Examples

<span data-ttu-id="a9f0e-423">Poniższy przykład ilustruje Dodawanie liczb złożonych:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-423">The following example illustrates addition with complex numbers:</span></span>

[!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
[!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-424">Wartość rzeczywista podwójnej precyzji do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-424">The double-precision real value to add.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-425">Wartość złożona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-425">The complex value to add.</span></span></param>
        <summary><span data-ttu-id="a9f0e-426">Dodaje liczbę rzeczywistą o podwójnej precyzji do liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-426">Adds a double-precision real number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-427">Suma <paramref name="left" /> i<paramref name="right" /> jako liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-427">The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-428">Dodanie liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczby zespolonej (c + di) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-428">The addition of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="a9f0e-429">(a + c) + di</span><span class="sxs-lookup"><span data-stu-id="a9f0e-429">(a + c) + di</span></span>

<span data-ttu-id="a9f0e-430">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-430">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-431">Wartość złożona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-431">The complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-432">Wartość rzeczywista podwójnej precyzji do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-432">The double-precision real value to add.</span></span></param>
        <summary><span data-ttu-id="a9f0e-433">Dodaje liczbę zespoloną do liczby rzeczywistej o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-433">Adds a complex number to a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-434">Suma <paramref name="left" /> i<paramref name="right" /> jako liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-434">The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-435">Dodanie liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-435">The addition of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-436">(a + c) + BI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-436">(a + c) + bi</span></span>

<span data-ttu-id="a9f0e-437">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-437">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-438">Pierwsza wartość złożona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-438">The first complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-439">Druga wartość złożona do dodania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-439">The second complex value to add.</span></span></param>
        <summary><span data-ttu-id="a9f0e-440">Dodaje dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-440">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-441">Suma <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-441">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-442">Dodanie liczby zespolonej, a + bi i drugiej liczby zespolonej, c + di, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-442">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="a9f0e-443">(a + c) + (b + d)i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-443">(a + c) + (b + d)i</span></span>

<span data-ttu-id="a9f0e-444">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-444">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Division">
      <Docs>
        <summary><span data-ttu-id="a9f0e-445">Dzieli określoną liczbę przez inny określony numer, gdzie co najmniej jeden z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-445">Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<span data-ttu-id="a9f0e-446"><xref:System.Numerics.Complex.op_Division%2A> Operator umożliwia wykonywanie operacji dzielenia, które obejmują liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-446">The <xref:System.Numerics.Complex.op_Division%2A> operator allows performing division operations that involve complex numbers.</span></span> <span data-ttu-id="a9f0e-447">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-447">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
[!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]

<span data-ttu-id="a9f0e-448">Jeśli podział powoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-448">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a9f0e-449">Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%2A> równoważną grupę metod.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-449">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> equivalent group of method instead.</span></span>

<span data-ttu-id="a9f0e-450"><xref:System.Numerics.Complex.op_Division%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-450">The <xref:System.Numerics.Complex.op_Division%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-451">Wartość rzeczywista podwójnej precyzji, która ma zostać podzielona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-451">The double-precision real value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-452">Wartość złożona do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-452">The complex value to divide by.</span></span></param>
        <summary><span data-ttu-id="a9f0e-453">Dzieli określoną liczbę rzeczywistą o podwójnej precyzji o określoną liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-453">Divides a specified double-precision real number by a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-454">Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />, jako liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-454">The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-455">Podział liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-455">The division of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="a9f0e-456">(AC/(c<sup>2</sup> + d<sup>2</sup>)) + (AD/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-456">(ac / (c<sup>2</sup> + d<sup>2</sup>)) + (ad / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

<span data-ttu-id="a9f0e-457">Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-457">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-458">Wartość złożona, która ma zostać podzielona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-458">The complex value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-459">Wartość rzeczywista podwójnej precyzji, która ma zostać podzielona przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-459">The double-precision real value to divide by.</span></span></param>
        <summary><span data-ttu-id="a9f0e-460">Dzieli określoną liczbę zespoloną przez określoną liczbę rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-460">Divides a specified complex number by a specified double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-461">Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />, jako liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-461">The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-462">Podział liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-462">The division of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-463">(AC/c<sup>2</sup>) + (BC/c<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-463">(ac / c<sup>2</sup>) + (bc / c<sup>2</sup>)i</span></span>

<span data-ttu-id="a9f0e-464">Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-464">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-465">Wartość złożona, która ma zostać podzielona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-465">The complex value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-466">Wartość złożona do podzielenia przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-466">The complex value to divide by.</span></span></param>
        <summary><span data-ttu-id="a9f0e-467">Dzieli określoną liczbę zespoloną przez inną określoną liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-467">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-468">Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-468">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-469">Podział liczby zespolonej, analizy biznesowej i drugiej liczby zespolonej, c + di, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-469">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="a9f0e-470">((AC + BD)/(c<sup>2</sup> + d<sup>2</sup>)) + ((BC-AD)/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-470">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

<span data-ttu-id="a9f0e-471">Języki nieobsługujące niestandardowych operatorów i przeciążania operatora mogą wywołać <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-471">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-472">Pierwsza liczba zespolona do porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-472">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-473">Druga liczba zespolona do porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-473">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="a9f0e-474">Zwraca wartość wskazującą, czy dwie liczby zespolone są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-474">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-475"><see langword="true" />Jeśli parametry <paramref name="right" /> <see langword="false" />i mają tę samą wartość; w przeciwnym razie. <paramref name="left" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-475"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-476">Metoda definiuje operację operatora równości dla <xref:System.Numerics.Complex> wartości. <xref:System.Numerics.Complex.op_Equality%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-476">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="a9f0e-477">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-477">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="a9f0e-478">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodę zamiast.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-478">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="a9f0e-479">Dwie liczby zespolone są równe, jeśli ich rzeczywiste części są równe, a ich części urojone są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-479">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="a9f0e-480"><xref:System.Numerics.Complex.op_Equality%2A> Metoda jest równoważna z następującym wyrażeniem:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-480">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="a9f0e-481">Należy zauważyć, że ze względu na różnice, dwie złożone liczby, które są równie równoważne mogą być uznawane za nierówne.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-481">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="a9f0e-482">Aby uzyskać więcej informacji i możliwe obejście, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-482">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="a9f0e-483">Równoważna Metoda dla tego operatora to<xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-483">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a9f0e-484">Definiuje jawną konwersję między <see cref="T:System.Numerics.Complex" /> obiektem a innym typem.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-484">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-485">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-485">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-486">Definiuje jawną konwersję <see cref="T:System.Decimal" /> wartości na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-486">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-487">Liczba zespolona, która ma prawdziwy składnik równy <paramref name="value" /> i składnik urojony równy zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-487">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-488">Operatory jawnej konwersji definiują typy, które można przekonwertować <xref:System.Numerics.Complex> na obiekt.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-488">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="a9f0e-489">Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-489">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="a9f0e-490">Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-490">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="a9f0e-491">W przeciwnym razie wyświetla błąd kompilatora.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-491">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="a9f0e-492">Konwersja <xref:System.Decimal> wartości do rzeczywistej części liczby zespolonej może spowodować utratę precyzji <xref:System.Double>, ponieważ typ, który jest typem <xref:System.Numerics.Complex.Real%2A> <xref:System.Decimal>właściwości zespolonej, ma mniejszą liczbę cyfr znaczących niż.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-492">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="a9f0e-493">Poniższy przykład ilustruje jawną konwersję <xref:System.Decimal> wartości na <xref:System.Numerics.Complex> wartości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-493">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-494">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-494">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-495">Definiuje jawną konwersję <see cref="T:System.Numerics.BigInteger" /> wartości na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-495">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-496">Liczba zespolona, która ma prawdziwy składnik równy <paramref name="value" /> i składnik urojony równy zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-496">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-497">Operatory jawnej konwersji definiują typy, które można przekonwertować <xref:System.Numerics.Complex> na obiekt.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-497">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="a9f0e-498">Kompilatory języka nie wykonują tej konwersji automatycznie, ponieważ mogą one zawierać utratę danych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-498">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="a9f0e-499">Zamiast tego wykonuje konwersję tylko wtedy, gdy jest używany operator rzutowania (in C#) lub funkcja konwersji ( `CType` na przykład w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-499">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="a9f0e-500">W przeciwnym razie wyświetla błąd kompilatora.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-500">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="a9f0e-501">Konwersja <xref:System.Numerics.BigInteger> wartości do rzeczywistej części liczby zespolonej może spowodować utratę precyzji <xref:System.Double>, ponieważ typ, który jest typem <xref:System.Numerics.Complex.Real%2A> <xref:System.Numerics.BigInteger>właściwości zespolonej, ma mniejszą liczbę cyfr znaczących niż.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-501">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="a9f0e-502">Jeśli konwersja nie powiedzie się, ponieważ <xref:System.Numerics.BigInteger> wartość znajduje się poza zakresem <xref:System.Double> typu, operacja nie generuje elementu <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-502">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="a9f0e-503">Zamiast tego, `value` jeśli jest mniejsza <xref:System.Double.MinValue>niż, wynik jest liczbą <xref:System.Numerics.Complex.Real%2A> zespoloną, która ma wartość właściwości równą <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-503">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="a9f0e-504">Jeśli `value` jest większa niż <xref:System.Double.MaxValue>, wynik jest liczbą <xref:System.Numerics.Complex.Real%2A> zespoloną, która ma wartość właściwości równą <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-504">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="a9f0e-505">Poniższy przykład ilustruje jawną konwersję <xref:System.Numerics.BigInteger> wartości na <xref:System.Numerics.Complex> wartości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-505">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a9f0e-506">Definiuje niejawną konwersję <see cref="T:System.Numerics.Complex" /> między obiektem a innym typem.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-506">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-507">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-507">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-508">Definiuje niejawną konwersję niepodpisanego bajtu na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-508">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-509">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-509">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-510">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-510">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-511">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-511">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-512">To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Byte> wartości na liczbę zespoloną, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-512">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-513">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa <xref:System.Byte> wartości i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-513">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-514">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-514">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-515">Definiuje niejawną konwersję liczby zmiennoprzecinkowej o podwójnej precyzji na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-515">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-516">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-516">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-517">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-517">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-518">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-518">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-519">To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Double> wartości na liczbę zespoloną, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-519">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-520">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa <xref:System.Double> wartości i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-520">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-521">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-521">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-522">Definiuje niejawną konwersję 16-bitowej podpisanej liczby całkowitej na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-522">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-523">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-523">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-524">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-524">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-525">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-525">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-526">Dzięki temu przeciążeniu można przeprowadzić konwersję na podstawie 16-bitowej liczby całkowitej ze znakiem na liczbę zespoloną, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-526">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-527">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa podpisanej 16-bitowej liczbie całkowitej, a której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-527">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-528">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-528">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-529">Definiuje niejawną konwersję 32-bitowej podpisanej liczby całkowitej na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-529">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-530">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-530">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-531">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-531">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-532">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-532">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-533">Dzięki temu przeciążeniu można przeprowadzić konwersję dojścia kompilatora ze podpisanej 32-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-533">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-534">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa podpisanej 32-bitowej liczbie całkowitej i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-534">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-535">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-535">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-536">Definiuje niejawną konwersję 64-bitowej podpisanej liczby całkowitej na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-536">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-537">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-537">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-538">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-538">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-539">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-539">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-540">Dzięki temu przeciążeniu można przeprowadzić konwersję dojścia kompilatora ze podpisanej 64-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-540">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-541">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa podpisanej 64-bitowej liczbie całkowitej i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-541">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-542">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-542">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-543">Definiuje niejawną konwersję podpisanego bajtu na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-543">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="a9f0e-544">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-544">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-545">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-545">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-546">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-546">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-547">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-547">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-548">To przeciążenie umożliwia kompilatorowi obsługę konwersji z podpisanego bajtu na liczbę zespoloną, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-548">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-549">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa bajtowi podpisanemu i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-549">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-550">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-550">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-551">Definiuje niejawną konwersję liczby zmiennoprzecinkowej o pojedynczej precyzji na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-551">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-552">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-552">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-553">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-553">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-554">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-554">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-555">To przeciążenie umożliwia kompilatorowi obsługę konwersji z <xref:System.Single> wartości na liczbę zespoloną, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-555">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-556">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa <xref:System.Single> wartości i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-556">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-557">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-557">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-558">Definiuje niejawną konwersję 16-bitowej liczby całkowitej bez znaku na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-558">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="a9f0e-559">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-559">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-560">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-560">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-561">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-561">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-562">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-562">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-563">Dzięki temu przeciążeniu można przeprowadzić konwersje z niepodpisanej 16-bitową liczbą całkowitą do liczby zespolonej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-563">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-564">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa 16-bitowej liczbie całkowitej bez znaku i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-564">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-565">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-565">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-566">Definiuje niejawną konwersję 32-bitowej liczby całkowitej bez znaku na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-566">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="a9f0e-567">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-567">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-568">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-568">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-569">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-569">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-570">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-570">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-571">Dzięki temu przeciążeniu kompilator obsługuje konwersje z niepodpisanej 32-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-571">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-572">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa niepodpisanej 32-bitowej liczbie całkowitej i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-572">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-573">Wartość do przekonwertowania na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-573">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-574">Definiuje niejawną konwersję 64-bitowej liczby całkowitej bez znaku na liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-574">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="a9f0e-575">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-575">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-576">Obiekt, który zawiera wartość <paramref name="value" /> parametru jako jego część rzeczywistą i zero jako część urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-576">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-577">Przeciążenia <xref:System.Numerics.Complex.op_Implicit%2A> operatora definiują typy, z których kompilator może automatycznie <xref:System.Numerics.Complex> skonwertować obiekt bez jawnego operatora rzutowania (in C#) lub wywołania funkcji konwersji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-577">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="a9f0e-578">Są to rozszerzające konwersje, które nie obejmują utraty danych i nie generują <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-578">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="a9f0e-579">Dzięki temu przeciążeniu kompilator obsługuje konwersje z niepodpisanej 64-bitowej liczby całkowitej do liczby zespolonej, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-579">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="a9f0e-580">Należy zauważyć, że wynik konwersji jest liczbą zespoloną, której część rzeczywista jest równa niepodpisanej 64-bitowej liczbie całkowitej i której część urojona jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-580">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-581">Pierwsza wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-581">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-582">Druga wartość do porównania.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-582">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="a9f0e-583">Zwraca wartość wskazującą, czy dwie liczby zespolone nie są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-583">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-584"><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-584"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-585"><xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje operacje operatora nierówności dla liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-585">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="a9f0e-586">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-586">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="a9f0e-587">Języki nieobsługujące niestandardowych operatorów mogą testować pod kątem nierówności przez wywołanie <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody i odwrócenie jej wartości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-587">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="a9f0e-588">Należy zauważyć, że ze względu na różnice, dwie złożone liczby, które są równie równoważne mogą być uznawane za nierówne.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-588">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="a9f0e-589">Jednym z możliwych obejść jest zaimplementowanie metody porównania `true` , która zwraca tylko wtedy, gdy różnica między dwoma rzeczywistą i urojoną częścią liczb złożonych przekracza określony próg (na przykład .01% wartości rzeczywistego lub urojonego składnika Jedna z liczb zespolonych).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-589">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="a9f0e-590">Aby uzyskać więcej informacji, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-590">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary><span data-ttu-id="a9f0e-591">Mnoży określoną liczbę przez inny określony numer, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-591">Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<span data-ttu-id="a9f0e-592"><xref:System.Numerics.Complex.op_Multiply%2A> Operator umożliwia wykonywanie operacji mnożenia obejmujących liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-592">The <xref:System.Numerics.Complex.op_Multiply%2A> operator allows performing multiplication operations that involve complex numbers.</span></span> <span data-ttu-id="a9f0e-593">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-593">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
[!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]

<span data-ttu-id="a9f0e-594">Jeśli mnożenie spowoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-594">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a9f0e-595">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%2A> równoważną grupę metod.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-595">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="a9f0e-596"><xref:System.Numerics.Complex.op_Multiply%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-596">The <xref:System.Numerics.Complex.op_Multiply%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-597">Wartość rzeczywista podwójnej precyzji do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-597">The double-precision real value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-598">Wartość złożona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-598">The complex value to multiply.</span></span></param>
        <summary><span data-ttu-id="a9f0e-599">Mnoży określoną liczbę rzeczywistą o podwójnej precyzji przez określoną liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-599">Multiplies a specified double-precision real number by a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-600">Iloczyn <paramref name="left" /> i<paramref name="right" />, jako liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-600">The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-601">Liczebność liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) i liczba złożona (c + di) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-601">The multiplication of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="a9f0e-602">AC + ADI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-602">ac + adi</span></span>

<span data-ttu-id="a9f0e-603">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-603">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>


          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-604">Wartość złożona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-604">The complex value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-605">Wartość rzeczywista podwójnej precyzji do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-605">The double-precision real value to multiply.</span></span></param>
        <summary><span data-ttu-id="a9f0e-606">Mnoży określoną liczbę zespoloną przez określoną liczbę rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-606">Multiplies the specified complex number by a specified double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-607">Iloczyn <paramref name="left" /> i<paramref name="right" />, jako liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-607">The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-608">Iloczyn liczby zespolonej (a + bi) i liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-608">The multiplication of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-609">AC + BCI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-609">ac + bci</span></span>

<span data-ttu-id="a9f0e-610">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-610">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-611">Pierwsza złożona wartość do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-611">The first complex value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-612">Druga wartość złożona do pomnożenia.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-612">The second complex value to multiply.</span></span></param>
        <summary><span data-ttu-id="a9f0e-613">Mnoży dwa określone liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-613">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-614">Produkt <paramref name="left" /> i <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-614">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-615">Mnożenie liczby zespolonej, analizy biznesowej i drugiej liczby zespolonej, c + di, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-615">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="a9f0e-616">(AC-BD) + (AD + BC) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-616">(ac - bd) + (ad + bc)i</span></span>

<span data-ttu-id="a9f0e-617">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważną metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-617">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <Docs>
        <summary><span data-ttu-id="a9f0e-618">Odejmuje określoną liczbę od innej podanej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-618">Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<span data-ttu-id="a9f0e-619"><xref:System.Numerics.Complex.op_Subtraction%2A> Operator umożliwia wykonywanie operacji odejmowania obejmujących liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-619">The <xref:System.Numerics.Complex.op_Subtraction%2A> operator allows performing subtraction operations that involve complex numbers.</span></span> <span data-ttu-id="a9f0e-620">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-620">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
[!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]

<span data-ttu-id="a9f0e-621">Jeśli odejmowanie powoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-621">If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a9f0e-622">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%2A> równoważną grupę metod.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-622">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="a9f0e-623"><xref:System.Numerics.Complex.op_Addition%2A> Operatory, które odbierają jeden Double, są bardziej wydajne niż operatory, które odbierają dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-623">The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-624">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemna).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-624">The double-precision real value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-625">Wartość złożona do odejmowania (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-625">The complex value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="a9f0e-626">Odejmuje liczbę zespoloną od liczby rzeczywistej o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-626">Subtracts a complex number from a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-627">Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-627">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-628">Odejmowanie liczby zespolonej (c + di) z liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-628">The subtraction of a complex number (c + di) from a real number (which can be regarded as the complex number a + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-629">(a-c)-di</span><span class="sxs-lookup"><span data-stu-id="a9f0e-629">(a - c) - di</span></span>

<span data-ttu-id="a9f0e-630">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> metodę zamiast.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-630">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-631">Wartość złożona do odejmowania (odjemna).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-631">The complex value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-632">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-632">The double-precision real value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="a9f0e-633">Odejmuje liczbę rzeczywistą o podwójnej precyzji od liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-633">Subtracts a double-precision real number from a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-634">Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-634">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-635">Odejmowanie liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) z liczby zespolonej (a i analizy biznesowej):</span><span class="sxs-lookup"><span data-stu-id="a9f0e-635">The subtraction of a real number (which can be regarded as the complex number c + 0i) from a complex number (a + bi) takes the following form:</span></span>

<span data-ttu-id="a9f0e-636">(a-c) + BI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-636">(a - c) + bi</span></span>

<span data-ttu-id="a9f0e-637">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> metodę zamiast.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-637">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-638">Wartość do odejmowania (odjemna).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-638">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-639">Wartość do odejmowania (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-639">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="a9f0e-640">Odejmuje liczbę zespoloną od innego numeru zespolonego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-640">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-641">Wynik odejmowania <paramref name="right" /> od <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-641">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-642">Odejmowanie liczby zespolonej, c + di z innej liczby zespolonej, a bi, ma następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-642">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>

<span data-ttu-id="a9f0e-643">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-643">(a - c) + (b - d)i</span></span>

<span data-ttu-id="a9f0e-644">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> metodę zamiast.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-644">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-645">Wartość do wskazania ujemnej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-645">The value to negate.</span></span></param>
        <summary><span data-ttu-id="a9f0e-646">Zwraca wartość z przewidzianą przez funkcję odwrotną do określonej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-646">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-647">Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki parametrupomnożoneprzez-1.<paramref name="value" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-647">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-648"><xref:System.Numerics.Complex.op_UnaryNegation%2A> Metoda definiuje operacje operatora jednoargumentowego negacji (addytywne) dla liczb złożonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-648">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="a9f0e-649">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-649">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="a9f0e-650">Wynikowa liczba złożona daje wartość <xref:System.Numerics.Complex> 0 (zero), gdy zostanie dodana do oryginalnej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-650">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="a9f0e-651">Języki nieobsługujące niestandardowych operatorów mogą wywołać <xref:System.Numerics.Complex.Negate%2A> metodę zamiast.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-651">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="a9f0e-652">Równoważna Metoda dla tego operatora to<xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-652">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-653">Pobiera fazę liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-653">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="a9f0e-654">Faza liczby zespolonej w radianach.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-654">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-655">W przypadku liczby zespolonej a + bi faza jest obliczana jako <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-655">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="a9f0e-656">Można zidentyfikować liczbę zespoloną przez współrzędne kartezjańskiego na płaszczyźnie złożonej lub przez współrzędne biegunowe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-656">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="a9f0e-657">Faza (argument) liczby zespolonej to kąt do osi rzeczywistej linii rysowanej od punktu początkowego (część wspólna osi x i oś y) do punktu reprezentowanego przez liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-657">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="a9f0e-658">Wartość (reprezentowana przez <xref:System.Numerics.Complex.Magnitude%2A> Właściwość) to odległość od punktu początkowego do punktu, który jest reprezentowany przez liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-658">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="a9f0e-659">Można utworzyć wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych zamiast jej współrzędnych kartezjańskiego <xref:System.Numerics.Complex.FromPolarCoordinates%2A> przez wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-659">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="a9f0e-660">Aby przekonwertować fazę z radianów na stopnie, pomnóż ją przez 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-660">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-661">W poniższym przykładzie zastosowano <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodę, aby utworzyć wystąpienie liczby zespolonej na podstawie współrzędnych biegunowych, a następnie wyświetlić <xref:System.Numerics.Complex.Magnitude%2A> wartość <xref:System.Numerics.Complex.Phase%2A> właściwości i.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-661">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a9f0e-662">Zwraca określoną liczbę zespoloną podniesioną do określonej potęgi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-662">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-663">Liczba złożona, która zostanie podniesiona do potęgi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-663">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="a9f0e-664">Liczba zmiennoprzecinkowa podwójnej precyzji, która określa potęgę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-664">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="a9f0e-665">Zwraca określoną liczbę zespoloną podniesioną do potęgi określonej przez liczbę zmiennoprzecinkową o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-665">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-666">Liczba <paramref name="value" /> złożona przyniesiona do potęgi <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-666">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-667">Jeśli `value` <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-667">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-668">W przypadku innych wartości, `power` jeśli jest równa 0, <xref:System.Numerics.Complex.One?displayProperty=nameWithType>Metoda zwraca wartość `power` , a jeśli jest 1 `value`, zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-668">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="a9f0e-669">Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodzie dla pierwotnych typów liczbowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-669">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-670">Poniższy przykład ilustruje potęgowanie przy użyciu liczby zespolonej i wykładnika, której wartość należy do zakresu od-1 do 10.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-670">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-671">Liczba złożona, która zostanie podniesiona do potęgi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-671">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="a9f0e-672">Liczba złożona, która określa potęgę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-672">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="a9f0e-673">Zwraca określoną liczbę zespoloną podniesioną do potęgi określonej przez liczbę zespoloną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-673">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-674">Liczba <paramref name="value" /> złożona przyniesiona do potęgi <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-674">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-675">Pobiera prawdziwy składnik bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-675">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="a9f0e-676">Prawdziwy składnik liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-676">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-677">Uwzględniając liczbę zespoloną a + bi, <xref:System.Numerics.Complex.Real%2A> Właściwość zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-677">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-678">Poniższy przykład tworzy wystąpienie tablicy <xref:System.Numerics.Complex> obiektów i wyświetla rzeczywiste i urojone składniki każdego z nich w formie a + bi.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-678">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-679">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-679">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-680">Zwraca mnożenia odwrotności liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-680">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-681">Odwrotność <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-681">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-682">Funkcja odwrotna lub mnożenia odwracania od liczby *x* jest liczbą *y* , gdzie *x* pomnożona przez *y* daje 1.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-682">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="a9f0e-683">Odwrotność liczby zespolonej to liczba złożona, która powstaje <xref:System.Numerics.Complex.One?displayProperty=nameWithType> , gdy dwie liczby są mnożone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-683">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="a9f0e-684">Jeśli liczba złożona jest reprezentowana przez + BI, jego wzajemna wartość jest reprezentowana przez wyrażenie a/(a<sup>2</sup>+ b<sup>2</sup>) +-b/(a<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-684">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="a9f0e-685">Jeśli wartość jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca. <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-685">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a9f0e-686">W przeciwnym razie zwraca wynik wyrażenia <xref:System.Numerics.Complex.One?displayProperty=nameWithType>. / `value`</span><span class="sxs-lookup"><span data-stu-id="a9f0e-686">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-687">W poniższym przykładzie zastosowano <xref:System.Numerics.Complex.Reciprocal%2A> metodę, aby obliczyć wzajemne wartości kilku liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-687">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="a9f0e-688">Pokazuje również, że wynik mnożenia liczby zespolonej przez jej wzajemny wpływ wynosi <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-688">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-689">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-689">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-690">Zwraca sinus określonego numeru złożonego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-690">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-691">Sinus <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-691">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-692">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Sin%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Sin%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-692">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-693"><xref:System.Numerics.Complex.Sin%2A> Metoda używa następującej formuły, aby obliczyć sinus liczby zespolonej a + bi:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-693">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="a9f0e-694">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-694">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-695">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Sin%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-695">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="a9f0e-696">Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-696">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-697">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-697">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-698">Zwraca sinus hiperboliczny podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-698">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-699">Sinus hiperboliczny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-699">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-700">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Sinh%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Sinh%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-700">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-701"><xref:System.Numerics.Complex.Sinh%2A> Metoda używa następującej formuły, aby obliczyć sinus hiperboliczny liczby zespolonej a + bi:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-701">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="a9f0e-702">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="a9f0e-702">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-703">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-703">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-704">Zwraca pierwiastek kwadratowy z podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-704">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-705">Pierwiastek kwadratowy <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-705">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-706">Pierwiastek kwadratowy liczby `value` zespolonej jest obliczany przy użyciu następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-706">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="a9f0e-707"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> /2,0)</span><span class="sxs-lookup"><span data-stu-id="a9f0e-707"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="a9f0e-708">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Sqrt%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-708">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <Docs>
        <summary><span data-ttu-id="a9f0e-709">Odejmuje określoną liczbę od innej podanej liczby, gdzie co najmniej jedna z nich jest liczbą zespoloną, a druga może być liczbą rzeczywistą o podwójnej precyzji i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-709">Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number, and returns the result.</span></span></summary>
        <remarks>
          <format type="text/markdown">
  <![CDA

## Remarks

<span data-ttu-id="a9f0e-710">Metoda <xref:System.Numerics.Complex.Subtract%2A> zezwala na operacje odejmowania, które obejmują liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-710">The <xref:System.Numerics.Complex.Subtract%2A> method allows subtraction operations that involve complex numbers.</span></span>

<span data-ttu-id="a9f0e-711">Jeśli odejmowanie powoduje przepełnienie w składniku rzeczywistym lub urojonym, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-711">If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a9f0e-712">Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%2A> równoważnej grupy operatorów.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-712">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%2A> equivalent group of operators too.</span></span>

<span data-ttu-id="a9f0e-713"><xref:System.Numerics.Complex.Subtract%2A> Metody, które odbierają jeden podwójnie są wydajniejsze niż metoda, która otrzymuje dwie liczby zespolone.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-713">The <xref:System.Numerics.Complex.Subtract%2A> methods that receive one double are more efficient than the method that receive two Complex numbers.</span></span>

## Examples

<span data-ttu-id="a9f0e-714">Poniższy przykład odejmuje każdą liczbę zespoloną w tablicy od liczby zespolonej:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-714">The following example subtracts each complex number in an array from a complex number:</span></span>

[!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
[!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-715">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemna).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-715">The double-precision real value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-716">Wartość złożona do odejmowania (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-716">The complex value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="a9f0e-717">Odejmuje jedną liczbę zespoloną od liczby rzeczywistej o podwójnej precyzji i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-717">Subtracts one complex number from a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-718">Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-718">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-719">Odejmowanie liczby zespolonej (c + di) z liczby rzeczywistej (która może być traktowana jako liczba złożona a + 0i) przyjmuje następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-719">The subtraction of a complex number (c + di) from a real number (which can be regarded as the complex number a + 0i) takes the following form:</span></span>

<span data-ttu-id="a9f0e-720">(a-c)-di</span><span class="sxs-lookup"><span data-stu-id="a9f0e-720">(a - c) - di</span></span>

<span data-ttu-id="a9f0e-721">Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważnego operatora.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-721">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-722">Wartość złożona do odejmowania (odjemna).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-722">The complex value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-723">Wartość rzeczywista podwójnej precyzji do odejmowania (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-723">The double-precision real value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="a9f0e-724">Odejmuje jedną liczbę rzeczywistą podwójnej precyzji od liczby zespolonej i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-724">Subtracts one double-precision real number from a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-725">Wynik odejmowania <paramref name="right" /> od <paramref name="left" />, jako liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-725">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-726">Odejmowanie liczby rzeczywistej (która może być traktowana jako liczba złożona c + 0i) z liczby zespolonej (a i analizy biznesowej):</span><span class="sxs-lookup"><span data-stu-id="a9f0e-726">The subtraction of a real number (which can be regarded as the complex number c + 0i) from a complex number (a + bi) takes the following form:</span></span>

<span data-ttu-id="a9f0e-727">(a-c) + BI</span><span class="sxs-lookup"><span data-stu-id="a9f0e-727">(a - c) + bi</span></span>

<span data-ttu-id="a9f0e-728">Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> równoważnego operatora.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-728">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a9f0e-729">Wartość do odejmowania (odjemna).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-729">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="a9f0e-730">Wartość do odejmowania (odjemnik).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-730">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="a9f0e-731">Odejmuje jedną liczbę zespoloną od innej i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-731">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-732">Wynik odejmowania <paramref name="right" /> od <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-732">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a9f0e-733">Odejmowanie liczby zespolonej, c + di z innej liczby zespolonej, a bi, ma następującą formę:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-733">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>

<span data-ttu-id="a9f0e-734">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="a9f0e-734">(a - c) + (b - d)i</span></span>

<span data-ttu-id="a9f0e-735">Języki obsługujące operatory niestandardowe mogą również używać <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> równoważnego operatora.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-735">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-736">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-736">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-737">Zwraca tangens podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-737">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-738">Tangens <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-738">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-739">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Tan%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Tan%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-739">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-740">Metoda używa następującej formuły, aby obliczyć tangens liczby `value`zespolonej: <xref:System.Numerics.Complex.Tan%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-740">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="a9f0e-741"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="a9f0e-741"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-742">Poniższy przykład ilustruje <xref:System.Numerics.Complex.Tan%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-742">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="a9f0e-743">Pokazuje, że przekazywanie wartości zwracanej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> do metody zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-743">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a9f0e-744">Liczba złożona.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-744">A complex number.</span></span></param>
        <summary><span data-ttu-id="a9f0e-745">Zwraca tangens hiperboliczny dla podanej liczby zespolonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-745">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-746">Tangens hiperboliczny <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-746">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-747">Metoda dla liczb zespolonych odpowiada <xref:System.Math.Tanh%2A?displayProperty=nameWithType> metodzie liczb rzeczywistych. <xref:System.Numerics.Complex.Tanh%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-747">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="a9f0e-748">Metoda używa następującej formuły, aby obliczyć tangens hiperboliczny liczby `value`zespolonej: <xref:System.Numerics.Complex.Tanh%2A></span><span class="sxs-lookup"><span data-stu-id="a9f0e-748">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="a9f0e-749"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="a9f0e-749"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a9f0e-750">Konwertuje wartość liczby zespolonej na jej równoważną reprezentację w postaci ciągu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-750">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a9f0e-751">Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w formie kartezjańskiego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-751">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-752">Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-752">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-753">Domyślna reprezentacja `(`liczby zespolonej wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, a *b* jest jej części urojonej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-753">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="a9f0e-754">Zarówno \*\* a, jak i *b* są formatowane przy użyciu specyfikatora formatu ogólnego ("G") i Konwencji bieżącej kultury systemowej.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-754">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-755">Poniższy przykład Wyświetla reprezentację ciągu kilku liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-755">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="a9f0e-756">Dane wyjściowe używają Konwencji formatowania kultury angielskiej Stany Zjednoczone ("en-US"), która w tym przypadku jest bieżącą kulturą systemu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-756">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="a9f0e-757">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-757">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="a9f0e-758">Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w postaci kartezjańskiego przy użyciu określonych informacji o formatowaniu specyficznych dla kultury.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-758">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-759">Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego, określony przez <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-759">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-760">Ciąg reprezentujący liczbę zespoloną zwracaną przez tę metodę wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w `(`formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, i *b* jest jej częścią urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-760">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="a9f0e-761">Zarówno \*\* a, jak i *b* są formatowane przy użyciu specyfikatora formatu ogólnego ("G") oraz Konwencji kultury zdefiniowanej `provider`przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-761">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="a9f0e-762">`provider` Parametr<xref:System.IFormatProvider> jest implementacją.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-762">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="a9f0e-763">Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza specyficzne dla kultury informacje o formacie liczb rzeczywistych i urojonych w zwracanym ciągu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-763">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="a9f0e-764">Jeśli `provider` jest `null`, zwracany<xref:System.Globalization.NumberFormatInfo> ciąg jest formatowany przy użyciu obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-764">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="a9f0e-765">`provider` Parametr może mieć jedną z następujących wartości:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-765">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="a9f0e-766"><xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu</span><span class="sxs-lookup"><span data-stu-id="a9f0e-766">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="a9f0e-767"><xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-767">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="a9f0e-768">Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider> interfejs.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-768">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="a9f0e-769">Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-769">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-770">Poniższy przykład Wyświetla reprezentację ciągu kilku liczb zespolonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-770">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="a9f0e-771">W wyniku są stosowane konwencje formatowania angielskiej Stany Zjednoczone ("en-US") i francuski — Francja ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="a9f0e-771">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="a9f0e-772">Standardowy lub niestandardowy ciąg formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-772">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="a9f0e-773">Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w postaci kartezjańskiego przy użyciu określonego formatu dla jego części rzeczywistych i urojonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-773">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-774">Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-774">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-775">Ciąg reprezentujący liczbę zespoloną zwracaną przez tę metodę wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w `(`formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, i *b* jest jej częścią urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-775">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="a9f0e-776">Zarówno \*\* a, jak i *b* są formatowane przy użyciu ciągu `format`formatu określonego przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-776">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="a9f0e-777">`format` Parametr może być dowolnym prawidłowym specyfikatorem standardowego formatu liczbowego lub dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-777">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="a9f0e-778">Jeśli `format` jest `null`równe lub is, rzeczywiste i urojone części liczby zespolonej są formatowane przy użyciu specyfikatora formatu ogólnego ("G"). <xref:System.String.Empty?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-778">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="a9f0e-779">Jeśli `format` jest dowolną inną wartością, Metoda <xref:System.FormatException>zgłasza.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-779">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="a9f0e-780">.NET Framework zapewnia rozbudowaną obsługę formatowania, co opisano szczegółowo w następujących tematach:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-780">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="a9f0e-781">Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów](~/docs/standard/base-types/custom-numeric-format-strings.md)liczbowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-781">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="a9f0e-782">Aby uzyskać więcej informacji na temat formatowania w .NET Framework, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-782">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="a9f0e-783">Format zwracanego ciągu jest określany przez <xref:System.Globalization.NumberFormatInfo> obiekt dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-783">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="a9f0e-784">W zależności `format` od parametru ten obiekt kontroluje symbole, takie jak znak minus, separator grupy i symbol separatora dziesiętnego w ciągu danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-784">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="a9f0e-785">Aby zapewnić informacje o formatowaniu dla kultur innych niż bieżąca kultura, wywołaj <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> Przeciążenie.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-785">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-786">Poniższy przykład inicjuje liczbę zespoloną i wyświetla ją przy użyciu kilku ciągów formatu standardowego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-786">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="a9f0e-787"><paramref name="format" />nie jest prawidłowym ciągiem formatu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-787"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="a9f0e-788">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="a9f0e-788">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="a9f0e-789">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="a9f0e-789">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="a9f0e-790">Standardowy lub niestandardowy ciąg formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-790">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="a9f0e-791">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-791">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="a9f0e-792">Konwertuje wartość bieżącej liczby zespolonej na jej równoważną reprezentację w postaci ciągu w postaci kartezjańskiego przy użyciu określonego formatu i informacji o formacie specyficznym dla kultury dla jego części rzeczywistych i urojonych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-792">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="a9f0e-793">Ciąg reprezentujący bieżące wystąpienie w formularzu kartezjańskiego, zgodnie <paramref name="format" /> z parametrami i. <paramref name="provider" /></span><span class="sxs-lookup"><span data-stu-id="a9f0e-793">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-794">Ciąg reprezentujący liczbę zespoloną zwracaną przez tę metodę wyświetla liczbę przy użyciu jej współrzędnych kartezjańskiego w `(`formie *a* `,` *b*`)`, gdzie *a* jest rzeczywistą częścią liczby zespolonej, i *b* jest jej częścią urojoną.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-794">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="a9f0e-795">Zarówno \*\* a, jak i *b* są formatowane przy użyciu ciągu `format`formatu określonego przez.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-795">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="a9f0e-796">`format` Parametr może być dowolnym prawidłowym specyfikatorem standardowego formatu liczbowego lub dowolną kombinacją niestandardowych specyfikatorów formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-796">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="a9f0e-797">Jeśli `format` jest `null`równe lub is, rzeczywiste i urojone części liczby zespolonej są formatowane przy użyciu specyfikatora formatu ogólnego ("G"). <xref:System.String.Empty?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a9f0e-797">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="a9f0e-798">Jeśli `format` jest dowolną inną wartością, Metoda <xref:System.FormatException>zgłasza.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-798">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="a9f0e-799">.NET Framework zapewnia rozbudowaną obsługę formatowania, co opisano szczegółowo w następujących tematach:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-799">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="a9f0e-800">Aby uzyskać więcej informacji na temat ciągów formatu liczbowego, zobacz [Standardowe ciągi formatujące](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatów](~/docs/standard/base-types/custom-numeric-format-strings.md)liczbowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-800">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="a9f0e-801">Aby uzyskać więcej informacji na temat formatowania w .NET Framework, zobacz [Typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="a9f0e-801">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="a9f0e-802">`provider` Parametr<xref:System.IFormatProvider> jest implementacją.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-802">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="a9f0e-803">Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza specyficzne dla kultury informacje o formacie liczb rzeczywistych i urojonych w zwracanym ciągu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-803">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="a9f0e-804">W zależności `format` od parametru ten obiekt kontroluje symbole, takie jak znak minus, separator grupy i symbol separatora dziesiętnego w ciągu danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-804">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="a9f0e-805">Jeśli `provider` jest `null`, zwracany<xref:System.Globalization.NumberFormatInfo> ciąg jest formatowany przy użyciu obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-805">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="a9f0e-806">`provider` Parametr może mieć jedną z następujących wartości:</span><span class="sxs-lookup"><span data-stu-id="a9f0e-806">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="a9f0e-807"><xref:System.Globalization.CultureInfo> Obiekt, który reprezentuje kulturę dostarczającą informacje o formatowaniu</span><span class="sxs-lookup"><span data-stu-id="a9f0e-807">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="a9f0e-808"><xref:System.Globalization.NumberFormatInfo> Obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-808">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="a9f0e-809">Obiekt niestandardowy, który implementuje <xref:System.IFormatProvider> interfejs.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-809">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="a9f0e-810">Jego <xref:System.IFormatProvider.GetFormat%2A> Metoda<xref:System.Globalization.NumberFormatInfo> zwraca obiekt, który dostarcza informacje o formatowaniu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-810">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-811">Poniższy przykład tworzy tablicę liczb zespolonych i wyświetla każdą z nich przy użyciu kilku ciągów <xref:System.Globalization.CultureInfo> formatu standardowego oraz obiektów, które reprezentują kultury Stany Zjednoczone w języku angielskim ("en-us") i francuski — Francja ("fr-fr").</span><span class="sxs-lookup"><span data-stu-id="a9f0e-811">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="a9f0e-812"><paramref name="format" />nie jest prawidłowym ciągiem formatu.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-812"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="a9f0e-813">Standardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="a9f0e-813">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="a9f0e-814">Niestandardowe ciągi formatujące liczby</span><span class="sxs-lookup"><span data-stu-id="a9f0e-814">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a9f0e-815">Zwraca nowe <see cref="T:System.Numerics.Complex" /> wystąpienie o liczbie rzeczywistej równej zero i liczbie urojonej równej zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-815">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9f0e-816">Właściwość jest najczęściej używana do <xref:System.Numerics.Complex> porównywania wartości z zerem. <xref:System.Numerics.Complex.Zero></span><span class="sxs-lookup"><span data-stu-id="a9f0e-816">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9f0e-817">Poniższy przykład tworzy wystąpienie <xref:System.Numerics.Complex> wartości przy <xref:System.Numerics.Complex.Zero> użyciu właściwości.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-817">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="a9f0e-818">Następnie porównuje tę wartość z inną wartością, która jest tworzona przez wywołanie <xref:System.Numerics.Complex> konstruktora z częścią rzeczywistą równą zero i części urojonej równej zero.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-818">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="a9f0e-819">Ponieważ dane wyjściowe z przykładu są wyświetlane, te dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="a9f0e-819">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1adbe02d035bfc5cd2896e8b0e40079375718a5e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="3a7aa-101">Reprezentuje liczbą.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3a7aa-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-102">Liczba złożonych jest liczba, która składa się z liczbą rzeczywistą i zespoloną numer.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="3a7aa-103">Z liczby złożonej są zwykle zapisywane w postaci z = x + yi, gdzie *x* i *y* są liczbami rzeczywistą i *i* to jednostka zespoloną, który ma właściwość *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="3a7aa-104">Część rzeczywista liczby złożonej jest reprezentowana przez *x*, odwołuje się wyrażenie Liczba_zespolona część liczby złożonej *y*.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="3a7aa-105"><xref:System.Numerics.Complex> Kartezjański układ współrzędnych (prawdziwe, zespoloną) używa typu podczas tworzenia wystąpienia i operowanie nimi liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="3a7aa-106">Liczbą może być reprezentowany jako punktu dwuwymiarowa układ współrzędnych, znany jako płaszczyzny złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="3a7aa-107">Część rzeczywista liczby złożonej znajduje się na osi x (osi poziomej), a część urojony znajduje się na osi y (osi pionowej).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="3a7aa-108">Można również wyrażane dowolnego punktu w płaszczyźnie złożone na podstawie jego wartość bezwzględna polar współrzędnych., w Współrzędne biegunowe, punkt charakteryzuje się dwie liczb:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="3a7aa-109">Jego rozmiar, który jest odległość punktu ze źródła (to znaczy 0,0 lub punktu osi x i y przecięcia).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="3a7aa-110">Jego fazy, czyli kąta między rzeczywistych osi i linią ze źródła do punktu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="3a7aa-111">Utworzenie wystąpienia liczby zespolonej</span><span class="sxs-lookup"><span data-stu-id="3a7aa-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="3a7aa-112">Można przypisać wartość liczbą w jednym z następujących sposobów:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="3a7aa-113">Przez przekazanie dwa <xref:System.Double> wartości dla jego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="3a7aa-114">Pierwsza wartość reprezentuje część rzeczywista liczby złożonej, a druga wartość reprezentuje jego urojony części.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="3a7aa-115">Te wartości oznaczają pozycja liczby złożonej w dwuwymiarowa kartezjański układ współrzędnych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="3a7aa-116">Wywołując statycznych (`Shared` w języku Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> metodę w celu utworzenia jego Współrzędne biegunowe liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="3a7aa-117">Przypisując <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, lub <xref:System.Double> do wartości <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3a7aa-118">Wartość staje się część rzeczywista liczby złożonej, a jego urojony części jest równe 0.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="3a7aa-119">Rzutowanie (w języku C#) lub konwertowanie (w języku Visual Basic) <xref:System.Decimal> lub <xref:System.Numerics.BigInteger> do wartości <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3a7aa-120">Wartość staje się część rzeczywista liczby złożonej, a jego urojony części jest równe 0.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="3a7aa-121">Przypisując liczby złożonej, który jest zwracany przez metodę lub operator może <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3a7aa-122">Na przykład <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> jest statyczną metodę, która zwraca wartość liczby złożonej, który jest sumą dwóch liczb zespolonych i <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator dodaje dwie liczby złożone i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="3a7aa-123">W poniższym przykładzie pokazano każdego z tych sposobów pięć przypisywanie wartości do liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="3a7aa-124">Operacje na liczbach zespolonych</span><span class="sxs-lookup"><span data-stu-id="3a7aa-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="3a7aa-125"><xref:System.Numerics.Complex> Struktury w programie .NET Framework zawiera elementy, które zapewniają następujące funkcje:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="3a7aa-126">Metody do porównania dwóch liczb zespolonych, aby sprawdzić, czy są równe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="3a7aa-127">Operatory do wykonania operacji arytmetycznych na liczbach złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="3a7aa-128"><xref:System.Numerics.Complex> Operatory umożliwiają wykonywanie Dodawanie, odejmowanie, mnożenie, dzielenie i negacji jednoargumentowe z liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="3a7aa-129">Metody wykonywania innych operacji wartości liczbowych na liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="3a7aa-130">Oprócz cztery podstawowe operacje arytmetyczne Zgłoś liczbą do określonej potęgi, Znajdź pierwiastek kwadratowy z liczby złożonej, a wartość bezwzględną liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="3a7aa-131">Metody wykonywania trygonometryczne operacji na liczbach złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="3a7aa-132">Na przykład można obliczyć tangens kąta reprezentowany przez liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="3a7aa-133">Należy zauważyć, że ponieważ <xref:System.Numerics.Complex.Real%2A> i <xref:System.Numerics.Complex.Imaginary%2A> właściwości są tylko do odczytu, nie można zmodyfikować wartości istniejącej <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="3a7aa-134">Wszystkie metody, które w trakcie operacji na <xref:System.Numerics.Complex> number, jeśli ich wartość zwracana jest typu <xref:System.Numerics.Complex>, zwraca nową <xref:System.Numerics.Complex> numer.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="3a7aa-135">Precyzja i liczby zespolone</span><span class="sxs-lookup"><span data-stu-id="3a7aa-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="3a7aa-136">Rzeczywiste i urojony części liczbą są reprezentowane przez dwie wartości zmiennoprzecinkowej podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="3a7aa-137">Oznacza to, że <xref:System.Numerics.Complex> wartości, takie jak wartości zmiennoprzecinkowe podwójnej precyzji, mogą tracić dokładność wyniku operacji wartości liczbowych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="3a7aa-138">Oznacza to, że strict porównania równości dwóch <xref:System.Numerics.Complex> wartości może się nie powieść, nawet jeśli jest to różnica między dwiema wartościami z powodu utraty dokładności.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="3a7aa-139">Aby uzyskać więcej informacji, zobacz <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="3a7aa-140">Na przykład przeprowadzenie potęgowania na obliczony logarytm naturalny liczby powinien zwrócić oryginalny numer.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="3a7aa-141">W niektórych przypadkach utrata dokładności wartości zmiennoprzecinkowych może jednak spowodować niewielkich różnic między dwiema wartościami, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="3a7aa-142">Podobnie poniższy przykład, który oblicza pierwiastek kwadratowy liczby <xref:System.Numerics.Complex> cyfry, i tworzy nieco inne wyniki na 32-bitowe i IA64 wersje programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="3a7aa-143">Liczby zespolone, nieskończoność i NaN</span><span class="sxs-lookup"><span data-stu-id="3a7aa-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="3a7aa-144">Rzeczywiste i urojony części liczbą są reprezentowane przez <xref:System.Double> wartości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="3a7aa-145">Oprócz od <xref:System.Double.MinValue?displayProperty=nameWithType> do <xref:System.Double.MaxValue?displayProperty=nameWithType>, rzeczywisty lub urojony część liczbą może mieć wartość <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, i <xref:System.Double.NaN?displayProperty=nameWithType> wszystkie propagację w żadnej operacji arytmetycznych lub trygonometryczne.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="3a7aa-147">W poniższym przykładzie dzielenie przez <xref:System.Numerics.Complex.Zero> tworzy liczby złożonej, w których części rzeczywistą i urojony są <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-148">W związku z tym również wykonywania mnożenia o tej wartości powoduje liczby złożonej, w których części rzeczywistą i urojony są <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-149">Podobnie, wykonywanie mnożenia, który przelewa zakres <xref:System.Double> typu tworzy liczbą których część rzeczywista jest <xref:System.Double.NaN?displayProperty=nameWithType> i których część urojony jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-150">Następnie wykonywania dzielenia o tym numerze złożone zwraca liczby złożonej, w których część rzeczywista jest <xref:System.Double.NaN?displayProperty=nameWithType> i których część urojony jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="3a7aa-151">Operacji matematycznych z liczby złożone, które są nieprawidłowe lub który przepełnienie <xref:System.Double> — typ danych zgłosiła wyjątek.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="3a7aa-152">Zamiast tego, że oba operatory zwracają <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> w następujących warunkach:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="3a7aa-153">Dzielenia przez zero zwraca liczby dodatniej <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3a7aa-154">Wszelkie operacje, które przepełnienie, górna granica <xref:System.Double> zwraca typ danych <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3a7aa-155">Dzielenie przez zero zwraca liczby ujemnej <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3a7aa-156">Wszelkie operacje, który przelewa dolna granica <xref:System.Double> zwraca typ danych <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3a7aa-157">Zwraca dzielenia 0 przez zero <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3a7aa-158">Wszelkie operacje, które jest przeprowadzane w wypadku argumentów operacji o wartości <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType> zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, lub <xref:System.Double.NaN?displayProperty=nameWithType>, w zależności od określonej operacji.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="3a7aa-159">Należy pamiętać, że dotyczy to wszelkie pośrednie obliczenia wykonywane przez metodę.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="3a7aa-160">Na przykład iloczyn `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` używa formuły (ac - bd) + (ad + bc) i.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="3a7aa-161">Obliczanie rzeczywistych składnik, który jest wynikiem mnożenia ocenia 9e308 wyrażenie * 2,5 - 9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="3a7aa-162">Zwraca poszczególnych pośrednia mnożenia w tym wyrażeniu <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>i podjęcie próby odjąć <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> z <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="3a7aa-163">Formatowanie liczby zespolonej</span><span class="sxs-lookup"><span data-stu-id="3a7aa-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="3a7aa-164">Domyślnie reprezentację ciągu liczbą ma postać `(` *rzeczywistych* `,` *urojony*`)`, gdzie *rzeczywistych* i *urojony* są reprezentacji ciągu <xref:System.Double> wartości, które tworzą liczby złożonej rzeczywistą i urojony składników.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="3a7aa-165">Niektóre przeciążeń <xref:System.Numerics.Complex.ToString%2A> metody można dostosowywać reprezentacji ciągu tych <xref:System.Double> wartości, aby odzwierciedlić Konwencji formatowania określonej kultury lub pojawią się w określonym formacie zdefiniowane przez liczbowe standardowych lub niestandardowych Ciąg formatu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="3a7aa-166">(Aby uzyskać więcej informacji, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="3a7aa-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="3a7aa-167">Jednym ze sposobów częściej wyrażenia reprezentację ciągu liczbą ma postać + analizy biznesowej, gdzie jest składnikiem rzeczywistej liczby złożonej i serwer b jest składnik urojony liczby złożonej.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="3a7aa-168">W inżynierii electrical liczbą najczęściej jest wyrażony jako + bj.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="3a7aa-169">Reprezentacja ciągu z liczbą może zwrócić w jednej z tych dwóch form.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="3a7aa-170">Aby to zrobić, należy zdefiniować dostawcy formatu niestandardowego zaimplementowanie <xref:System.ICustomFormatter> i <xref:System.IFormatProvider> interfejsów, a następnie wywołania <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3a7aa-171">W poniższym przykładzie zdefiniowano `ComplexFormatter` klasa, która reprezentuje liczbą jako ciągu w postaci + analizy biznesowej lub + bj.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="3a7aa-172">W poniższym przykładzie użyto następnie ten niestandardowy element formatujący, aby wyświetlić reprezentację ciągu liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="3a7aa-173">Część rzeczywista liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="3a7aa-174">Wyrażenie Liczba_zespolona część liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-175">Inicjuje nowe wystąpienie klasy <see cref="T:System.Numerics.Complex" /> struktury przy użyciu określonych wartości rzeczywistych i urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-176">`real` Lub `imaginary` argumenty mogą tracić dokładność, jeśli są typy danych, które wymaga jawnego rzutowania do <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-177">Poniższy przykład tworzy dwie liczb zespolonych, a następnie użycie ich w operacji dodawania, odejmowania, mnożenia i dzielenia.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-178">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-179">Pobiera wartość bezwzględna (lub wielkości) liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-180">Wartość bezwzględna <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-181">Wartość bezwzględna liczby złożonej jest odpowiednikiem jego <xref:System.Numerics.Complex.Magnitude%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="3a7aa-182">Wartość bezwzględna liczby rzeczywistych + bi jest obliczana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="3a7aa-183">Jeśli b = 0, wynikiem jest 0.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="3a7aa-184">Jeśli > b, wynikiem jest \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="3a7aa-185">Jeśli b >, wynikiem jest b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 +<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="3a7aa-186">Jeśli obliczanie wartości bezwzględnych powoduje przepełnienie, metoda zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-187">Jeśli dowolny <xref:System.Numerics.Complex.Real%2A> lub <xref:System.Numerics.Complex.Imaginary%2A> właściwość jest <xref:System.Double.NaN?displayProperty=nameWithType> i inne właściwości nie jest ani <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ani <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, metoda zwraca <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-188">Oblicza wartość bezwzględna liczby złożonej, pokazuje, że jest odpowiednikiem wartości w następującym przykładzie <xref:System.Numerics.Complex.Magnitude%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-189">Liczba złożonych, która reprezentuje cosinus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-190">Zwraca kąt, będącą arcus cosinus określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-191">Kąt, mierzony w radianach, który jest arcus cosinus z <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-192"><xref:System.Numerics.Complex.Acos%2A> Odpowiada metoda liczby złożone <xref:System.Math.Acos%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-193"><xref:System.Numerics.Complex.Acos%2A> Metoda używa następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="3a7aa-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="3a7aa-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-195">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Acos%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="3a7aa-196">Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-197">Pierwszy liczby złożonej do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-198">Druga liczba złożone do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-199">Dodaje dwie liczby złożone i zwraca wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-200">Suma <paramref name="left" /> i <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-201">Dodanie złożony number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-202">(+ c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="3a7aa-203">Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-204">Można używać języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.Complex.Add%2A> metodę w celu dodania numerami złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-205">Poniższy przykład przedstawia dodawania przy liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-206">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-207">Zwraca kąt, będącą arcus sinus określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-208">Czyli arcus sinus kąta z <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-209"><xref:System.Numerics.Complex.Asin%2A> Odpowiada metoda liczby złożone <xref:System.Math.Asin%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-210"><xref:System.Numerics.Complex.Asin%2A> Metoda używa następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="3a7aa-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* wartość + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -wartość \* wartość))</span><span class="sxs-lookup"><span data-stu-id="3a7aa-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-212">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Asin%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="3a7aa-213">Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-214">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-215">Zwraca kąt, będącą arcus tangens określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-216">Będący arcus tangens kąta <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-217"><xref:System.Numerics.Complex.Atan%2A> Odpowiada metoda liczby złożone <xref:System.Math.Atan%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-218"><xref:System.Numerics.Complex.Atan%2A> Metoda używa następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="3a7aa-219"><xref:System.Numerics.Complex.ImaginaryOne> / Nowy złożonych (2.0, 0,0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* wartość)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* wartość)</span><span class="sxs-lookup"><span data-stu-id="3a7aa-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-220">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Atan%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="3a7aa-221">Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-222">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-223">Oblicza sprzężenie liczbą i zwraca wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-224">Sprzężenie z <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-225">Sprzężenie liczbą odwraca znak urojony składników; oznacza to, że dotyczy ona negacji jednoargumentowy urojony składnika.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="3a7aa-226">Jeśli + bi jest liczbą, jest jego sprzężenie - analizy biznesowej.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-227">W poniższym przykładzie przedstawiono sprzężenie dwóch liczb złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-228">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-229">Zwraca cosinus określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-230">Cosinus <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-231"><xref:System.Numerics.Complex.Cos%2A> Odpowiada metoda liczby złożone <xref:System.Math.Cos%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-232"><xref:System.Numerics.Complex.Cos%2A> Metoda używa następującej formuły można obliczyć cosinus liczby złożonej + analizy biznesowej:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3a7aa-233">(<xref:System.Math.Cos%2A>() * <xref:System.Math.Cosh%2A>(b)-(<xref:System.Math.Sin%2A>() * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="3a7aa-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-234">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Acos%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="3a7aa-235">Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Acos%2A> metodę <xref:System.Numerics.Complex.Cos%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-236">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-237">Zwraca cosinus hiperboliczny dla określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-238">Cosinus hiperboliczny liczby <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-239"><xref:System.Numerics.Complex.Cosh%2A> Odpowiada metoda liczby złożone <xref:System.Math.Cosh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-240"><xref:System.Numerics.Complex.Cosh%2A> Metoda używa następującej formuły można obliczyć cosinus hiperboliczny dla liczby złożonej + analizy biznesowej:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3a7aa-241">(<xref:System.Math.Cosh%2A>() * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>() * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="3a7aa-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="3a7aa-242">Liczba złożonych podział.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="3a7aa-243">Liczby złożonej do dzielenia przez.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-244">Dzieli jedną liczbę złożone przez inną i zwraca wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-245">Iloraz z dzielenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-246">Dzielenie liczby zespolonej + bi przez druga liczba złożony, liczbę, c + podpisane, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-247">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="3a7aa-248">Jeśli wyniki działania iloraz nastąpiło przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-249"><xref:System.Numerics.Complex.Divide%2A> Metody mogą być używane przez języki, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="3a7aa-250">Jego zachowanie jest identyczne dzielenia przy użyciu operatora dzielenia.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-251">Poniższy przykład dzieli liczbą przez każdy element tablicy liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-252">Zwraca wartość wskazującą, czy dwie liczb zespolonych są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-253">Liczby złożonej do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-254">Zwraca wartość wskazującą, czy bieżące wystąpienie i określonej liczby złożonej mają taką samą wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-255">
            <see langword="true" /> Jeśli ta liczba złożone i <paramref name="value" /> mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-256"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda zapewnia <xref:System.IEquatable%601> implementację <xref:System.Numerics.Complex> struktury.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="3a7aa-257">Wykonuje nieco lepszym rozwiązaniem niż <xref:System.Numerics.Complex.Equals%28System.Object%29> metody, ponieważ nie trzeba przekonwertować jej parametr liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="3a7aa-258">Dwie liczb zespolonych są takie same, jeśli ich rzeczywistym części są takie same i ich urojony części są takie same.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="3a7aa-259"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Metoda jest odpowiednikiem następującego wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="3a7aa-260">Użyj <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metody ostrożnie, ponieważ dwie wartości, które są równoważne najwyraźniej jest uznawana za nierówne z powodu różnych precyzji ich rzeczywiste i urojony składników.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3a7aa-260">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span>
            </span>
            <span data-ttu-id="3a7aa-261">Poniższy przykład zgłasza, że <c>(3.33333, 0.142857)</c> i <c>(10/3, 1/7)</c> nie są takie same.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3a7aa-261">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span>
            </span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)]
 [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  
  
 <span data-ttu-id="3a7aa-262">Jeden zalecane technika jest określenie dopuszczalne margines różnicę między dwiema wartościami (takich jak. 01% jeden ze składników wartości rzeczywistych i urojony) zamiast porównanie wartości pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-262">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span><span data-ttu-id="3a7aa-263">Jeśli wartość bezwzględna różnicy między dwiema wartościami jest mniejsza niż lub równa tej margines, różnica polega na tym prawdopodobnie z powodu różnic w dokładność i, w związku z tym wartości są mogą być takie same.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-263">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span><span data-ttu-id="3a7aa-264">W poniższym przykładzie użyto tej metody do porównywania dwóch wartości złożonych, które można nierówne w poprzednim przykładzie kodu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-264">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span><span data-ttu-id="3a7aa-265">Znajdzie dwie liczb zespolonych równe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-265">It finds the two complex numbers to be equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="3a7aa-266">Obiekt do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-266">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-267">Zwraca wartość wskazującą, czy bieżące wystąpienie oraz określony obiekt mają taką samą wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-267">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-268">
            <see langword="true" /> Jeśli <paramref name="obj" /> parametr jest <see cref="T:System.Numerics.Complex" /> obiektu lub funkcją niejawnej konwersji na typ <see cref="T:System.Numerics.Complex" /> obiekt i jego wartość jest równa bieżącej <see cref="T:System.Numerics.Complex" /> obiektu; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-268">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-269">Dwie liczb zespolonych są takie same, jeśli ich rzeczywistym części są takie same i ich urojony części są takie same.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-269">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="3a7aa-270"><xref:System.Numerics.Complex.Equals%28System.Object%29> Metoda jest odpowiednikiem następującego wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-270">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="3a7aa-271">Jeśli `obj` parametr nie jest <xref:System.Numerics.Complex> obiekt, ale jest typu danych, dla którego zdefiniowano niejawna konwersja, <xref:System.Numerics.Complex.Equals%28System.Object%29> metoda konwertuje `obj` do <xref:System.Numerics.Complex> obiektu, w których część rzeczywista jest równa wartości `obj`i której część urojony jest równa zero, przed rozpoczęciem porównania.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-271">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="3a7aa-272">Poniższy przykład przedstawia to znajdując liczbą i wartość zmiennoprzecinkową podwójnej precyzji są takie same.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-272">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="3a7aa-273">Użyj <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metody ostrożnie, ponieważ dwie wartości, które są równoważne najwyraźniej jest uznawana za nierówne z powodu różnych precyzji ich rzeczywiste i urojony składników.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3a7aa-273">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span>
            </span>
            <span data-ttu-id="3a7aa-274">Problem może być accentuated, jeśli <paramref name="obj" /> muszą zostać skonwertowane do <see cref="T:System.Double" /> przed wykonaniem operacji porównania.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3a7aa-274">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span>
            </span>
            <span data-ttu-id="3a7aa-275">Poniższy przykład porównuje liczbą którego rzeczywistych składnika wydaje się być taka sama jak <see cref="T:System.Single" /> wartości z tym <see cref="T:System.Single" /> wartość.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3a7aa-275">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span>
            </span>
            <span data-ttu-id="3a7aa-276">Jak pokazano na dane wyjściowe, zwraca porównania równości <see langword="False" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="3a7aa-276">As the output shows, the comparison for equality returns <see langword="False" />.</span>
            </span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)]
 [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  
  
 <span data-ttu-id="3a7aa-277">Jeden zalecane technika jest określenie dopuszczalne margines różnicę między dwiema wartościami (takich jak. 01% jeden ze składników wartości rzeczywistych i urojony) zamiast porównanie wartości pod kątem równości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-277">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span><span data-ttu-id="3a7aa-278">Jeśli wartość bezwzględna różnicy między dwiema wartościami jest mniejsza niż lub równa tej margines, różnica jest prawdopodobnie z powodu różnic w dokładność i w związku z tym są mogą być takie same wartości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-278">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span><span data-ttu-id="3a7aa-279">W poniższym przykładzie użyto tej metody do porównywania dwóch wartości, które można nierówne w poprzednim przykładzie kodu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-279">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span><span data-ttu-id="3a7aa-280">Teraz znajdzie się być takie same.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-280">It now finds them to be equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)]
 [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-281">Liczba złożonych, określająca potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-281">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-282">Zwraca <see langword="e" /> podniesionej do potęgi określonej przez liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-282">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-283">Liczba <see langword="e" /> podniesionej do potęgi <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-283">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-284">Użyj <xref:System.Numerics.Complex.Pow%2A> metodę obliczania uprawnień innych typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-284">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="3a7aa-285"><xref:System.Numerics.Complex.Exp%2A> Odpowiada metoda liczby złożone <xref:System.Math.Exp%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-285">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="3a7aa-286"><xref:System.Numerics.Complex.Exp%2A> jest odwrotność <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-286"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-287">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Exp%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-287">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="3a7aa-288">Pokazuje, z niektórych dozwolony dla braku dokładność <xref:System.Double> typu danych, przekazując wartość zwrócona przez <xref:System.Numerics.Complex.Log%2A> metodę <xref:System.Numerics.Complex.Exp%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-288">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="3a7aa-289">Wielkość, który jest odległość ze źródła (przecięcia osi x i y), do liczby całkowitej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-289">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="3a7aa-290">Fazy, to kąt, w wierszu do osi poziomej, mierzony w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-290">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-291">Tworzy złożone z Współrzędne biegunowe punktu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-291">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-292">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-292">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-293"><xref:System.Numerics.Complex.FromPolarCoordinates%2A> Metoda tworzy liczbą oparte na jego Współrzędne biegunowe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-293">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="3a7aa-294">Ponieważ istnieje wiele reprezentacje punktu na płaszczyźnie złożone, zwracana wartość <xref:System.Numerics.Complex.FromPolarCoordinates%2A> są znormalizowane metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-294">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="3a7aa-295">Wielkość jest znormalizowane do liczbą dodatnią, a fazy jest znormalizowane do wartości z zakresu od -<xref:System.Math.PI> do <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-295">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="3a7aa-296">W wyniku wartości <xref:System.Numerics.Complex.Phase%2A> i <xref:System.Numerics.Complex.Magnitude%2A> właściwości wynikowa liczba złożone nie mogą równa oryginalnej wartości `magnitude` i `phase` parametrów.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-296">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="3a7aa-297">Można przekonwertować wartości w stopniach na wartość w radianach do `phase` parametru mnożenie jej  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-297">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-298">W poniższym przykładzie użyto <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody tworzenia wystąpienia liczbą oparte na jego Współrzędne biegunowe, a następnie wyświetla wartość jego <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-298">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-299">Zwraca wartość skrótu dla bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-299">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-300">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-300">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-301">Pobiera składnik urojony bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-301">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a7aa-302">Wyrażenie Liczba_zespolona składnik liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-302">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-303">Podany numer złożone + analizy biznesowej, <xref:System.Numerics.Complex.Imaginary%2A> właściwość zwraca wartość b.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-303">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-304">Poniższy przykład tworzy tablicę <xref:System.Numerics.Complex> obiekty i wyświetla rzeczywiste i urojony składniki każdej z nich w formularzu + analizy biznesowej.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-304">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-305">Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienia z liczbą rzeczywistą równa zero i liczbę zespoloną równa jeden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-305">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3a7aa-306">Poniższy przykład tworzy <xref:System.Numerics.Complex> wartość przy użyciu <xref:System.Numerics.Complex.ImaginaryOne> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-306">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="3a7aa-307">Następnie porównuje tę wartość na inną wartość, która zostanie uruchomiony przez wywołanie metody <xref:System.Numerics.Complex> konstruktora z rzeczywistą równa zero i część dotyczącą urojony równa jeden.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-307">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="3a7aa-308">Jak pokazano na dane wyjściowe z przykładu, dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-308">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-309">Zwraca logarytm liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-309">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-310">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-310">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-311">Zwraca fizyczna (podstawowy <see langword="e" />) logarytm o podstawie określonej liczby złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-311">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-312">Fizyczna (podstawowy <see langword="e" />) logarytm <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-312">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-313"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> Odpowiada metoda liczby złożone <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-313">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-314">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Log%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-314">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="3a7aa-315">Pokazuje, z niektórych dozwolony dla braku dokładność <xref:System.Double> typu danych, przekazując wartość zwrócona przez <xref:System.Numerics.Complex.Log%2A> metodę <xref:System.Numerics.Complex.Exp%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-315">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-316">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-316">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="3a7aa-317">Podstawa logarytmu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-317">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-318">Zwraca logarytm o określonej liczby złożonej w określonej podstawy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-318">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-319">Logarytmu <paramref name="value" /> w podstawowym <paramref name="baseValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-319">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-320"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> Odpowiada metoda liczby złożone <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-320">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-321">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-321">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-322">Zwraca logarytm base 10 podanej liczby złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-322">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-323">10 podstawa logarytmu <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-323">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-324"><xref:System.Numerics.Complex.Log10%2A> Odpowiada metoda liczby złożone <xref:System.Math.Log10%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-324">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-325">Pobiera wartość (lub wartość bezwzględna) liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-325">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a7aa-326">Wartość bieżącego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-326">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-327"><xref:System.Numerics.Complex.Magnitude%2A> Jest odpowiednikiem wartość bezwzględna liczby złożonej właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-327">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="3a7aa-328">Określa odległość ze źródła (przecięcia osi x i y w układzie współrzędnych kartezjański) w punkcie dwuwymiarowa reprezentowany przez liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-328">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="3a7aa-329">Wartość bezwzględna jest obliczana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-329">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="3a7aa-330">&#124;+ analizy biznesowej &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(* + b * b)</span><span class="sxs-lookup"><span data-stu-id="3a7aa-330">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="3a7aa-331">Jeśli obliczanie wartości bezwzględnych powoduje przepełnienie, ta właściwość zwraca <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-331">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-332"><xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości definiują położenie punktu, który reprezentuje liczbą w systemie biegunowe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-332">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="3a7aa-333">Można utworzyć wystąpienia liczbą oparte na jego Współrzędne biegunowe, zamiast współrzędnych kartezjańskimi przez wywołanie metody <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-333">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-334">Oblicza wartość bezwzględna liczby złożonej, pokazuje, że jest odpowiednikiem wartości w następującym przykładzie <xref:System.Numerics.Complex.Magnitude%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-334">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-335">Pierwszy złożone liczbę Aby pomnożyć.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-335">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-336">Druga liczba złożone do wielokrotnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-336">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-337">Zwraca iloczyn dwóch liczb złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-337">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-338">Iloczyn <paramref name="left" /> i <paramref name="right" /> parametrów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-338">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-339">Mnożenia złożonego number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-339">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-340">(ac - bd) + (ad + bc) i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-340">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="3a7aa-341">Jeśli mnożenia powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-341">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-342"><xref:System.Numerics.Complex.Multiply%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-342">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="3a7aa-343">Jego zachowanie jest identyczne mnożenia przy użyciu operatora mnożenia.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-343">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-344">Poniższy przykład wielokrotności liczbę złożone przez każdy element tablicy liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-344">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-345">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-345">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-346">Zwraca odwrotność dodatku określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-346">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-347">Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki <paramref name="value" /> parametru pomnożona przez wartość -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-347">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-348">Odwrotność dodatku liczbą jest liczbą tworzącego wartość <xref:System.Numerics.Complex> po dodaniu do oryginalnego liczby złożonej.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-348">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="3a7aa-349">Ta metoda zwraca liczby złożonej, w którym składniki rzeczywistych i urojony oryginalna liczba złożone są pomnożona przez wartość -1.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-349">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="3a7aa-350"><xref:System.Numerics.Complex.Negate%2A> Metoda została zaimplementowana dla języków, które nie obsługują niestandardowych operatorów.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-350">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="3a7aa-351">Jego zachowanie jest takie same jak negacji przy użyciu Jednoargumentowy operator negacji <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-351">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-352">Poniższy przykład uzyskuje odwrotność dodatku każdego elementu w tablicy liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-352">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-353">Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienia z liczbą rzeczywistą równą jeden numer zespoloną równa zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-353">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3a7aa-354">Poniższy przykład tworzy <xref:System.Numerics.Complex> wartość przy użyciu <xref:System.Numerics.Complex.One> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-354">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="3a7aa-355">Następnie porównuje tę wartość na inną wartość, która zostanie uruchomiony przez wywołanie metody <xref:System.Numerics.Complex> konstruktora z rzeczywistą równa jeden i część dotyczącą urojony równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-355">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="3a7aa-356">Jak pokazano na dane wyjściowe z przykładu, dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-356">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-357">Pierwsza wartość do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-357">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-358">Druga wartość do dodania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-358">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-359">Dodaje dwie liczby złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-359">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-360">Suma <paramref name="left" /> i <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-360">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-361"><xref:System.Numerics.Complex.op_Addition%2A> Metoda definiuje operacji dodawania dla liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-361">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="3a7aa-362">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="3a7aa-363">Dodanie złożony number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-363">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-364">(a + c) + (b + d)i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-364">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="3a7aa-365">Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-365">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-366">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Add%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-366">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="3a7aa-367">Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a7aa-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="3a7aa-368">Poniższy przykład przedstawia dodawania przy liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-368">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-369">Wartość podział.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-369">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-370">Wartość do dzielenia przez.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-370">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-371">Dzieli określonej liczby złożonej innego określoną liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-371">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-372">Wynik dzielenia <paramref name="left" /> przez <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-372">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-373"><xref:System.Numerics.Complex.op_Division%2A> Metoda definiuje operacji dzielenia liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-373">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="3a7aa-374">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-374">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="3a7aa-375">Podział złożony number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-375">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-376">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-376">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="3a7aa-377">Jeśli podział powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-377">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-378">Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.Numerics.Complex.Divide%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-378">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="3a7aa-379">Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a7aa-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-380">Pierwszy liczby złożonej do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-380">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-381">Druga liczba złożone do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-381">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-382">Zwraca wartość wskazującą, czy dwie liczb zespolonych są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-382">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-383">
            <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> parametry mają taką samą wartość; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-383">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-384"><xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje operacji operatora równości dla <xref:System.Numerics.Complex> wartości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-384">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="3a7aa-385">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-385">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="3a7aa-386">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-386">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="3a7aa-387">Dwie liczb zespolonych są takie same, jeśli ich rzeczywistym części są takie same i ich urojony części są takie same.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-387">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="3a7aa-388"><xref:System.Numerics.Complex.op_Equality%2A> Metoda jest odpowiednikiem następującego wyrażenia:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-388">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="3a7aa-389">Należy pamiętać, że z powodu różnic w dokładność, dwóch liczb zespolonych, które są równoważne najwyraźniej jest uznawana za nierówne.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-389">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="3a7aa-390">Więcej informacji oraz możliwe rozwiązania, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-390">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="3a7aa-391">Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a7aa-391">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-392">Definiuje jawnej konwersji między <see cref="T:System.Numerics.Complex" /> obiektu i innego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-392">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-393">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-393">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-394">Definiuje jawna konwersja <see cref="T:System.Decimal" /> wartość liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-394">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-395">Liczbę złożone z rzeczywistą składnik równy <paramref name="value" /> i składnika urojony równa zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-395">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-396">Operatory jawnej konwersji Definiowanie typów, które mogą być konwertowane na <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-396">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3a7aa-397">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-397">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="3a7aa-398">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-398">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="3a7aa-399">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-399">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="3a7aa-400">Konwersja typu <xref:System.Decimal> wartości rzeczywistych część liczbą może spowodować zmniejszenie precyzji, ponieważ <xref:System.Double>, który jest typem liczby złożonej <xref:System.Numerics.Complex.Real%2A> właściwość ma mniejszą liczbę cyfr znaczących niż <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-400">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="3a7aa-401">Poniższy przykład przedstawia jawna konwersja <xref:System.Decimal> wartości do <xref:System.Numerics.Complex> wartości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-401">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-402">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-402">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-403">Definiuje jawna konwersja <see cref="T:System.Numerics.BigInteger" /> wartość liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-403">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-404">Liczbę złożone z rzeczywistą składnik równy <paramref name="value" /> i składnika urojony równa zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-404">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-405">Operatory jawnej konwersji Definiowanie typów, które mogą być konwertowane na <xref:System.Numerics.Complex> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-405">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3a7aa-406">Kompilatory języka nie wykonaj tę konwersję automatycznie, ponieważ może obejmować utraty danych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-406">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="3a7aa-407">Zamiast tego wykonują konwersji tylko wtedy, gdy operator rzutowania (w języku C#) lub funkcji konwersji (takich jak `CType` w języku Visual Basic) jest używany.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-407">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="3a7aa-408">W przeciwnym razie wystąpi błąd kompilatora wyświetlane.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-408">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="3a7aa-409">Konwersja typu <xref:System.Numerics.BigInteger> wartości rzeczywistych część liczbą może spowodować zmniejszenie precyzji, ponieważ <xref:System.Double>, który jest typem liczby złożonej <xref:System.Numerics.Complex.Real%2A> właściwość ma mniejszą liczbę cyfr znaczących niż <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-409">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="3a7aa-410">Jeśli nie powiedzie się konwersji ponieważ <xref:System.Numerics.BigInteger> wartość jest poza zakresem <xref:System.Double> typ operacji nie zgłasza <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-410">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="3a7aa-411">Zamiast tego Jeśli `value` jest mniejsza niż <xref:System.Double.MinValue>, wyniku jest liczbą zawierający <xref:System.Numerics.Complex.Real%2A> wartość właściwości jest równa <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-411">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="3a7aa-412">Jeśli `value` jest większa niż <xref:System.Double.MaxValue>, wyniku jest liczbą zawierający <xref:System.Numerics.Complex.Real%2A> wartość właściwości jest równa <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-412">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="3a7aa-413">Poniższy przykład przedstawia jawna konwersja <xref:System.Numerics.BigInteger> wartości do <xref:System.Numerics.Complex> wartości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-413">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-414">Definiuje niejawna konwersja między <see cref="T:System.Numerics.Complex" /> obiektu i innego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-414">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-415">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-415">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-416">Definiuje liczbą niejawnej konwersji wartości bajtu bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-416">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-417">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-417">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-418">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-418">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-419">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-419">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-420">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Byte> wartość liczby złożonej, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-420">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-421">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest równa <xref:System.Byte> wartość i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-421">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-422">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-422">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-423">Definiuje liczbą niejawna konwersja liczby zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-423">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-424">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-424">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-425">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-425">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-426">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-426">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-427">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Double> wartość liczby złożonej, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-427">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-428">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest równa <xref:System.Double> wartość i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-428">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-429">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-429">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-430">Definiuje liczbą niejawnej konwersji wartości 16-bitową liczbę całkowitą ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-430">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-431">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-431">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-432">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-432">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-433">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-433">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-434">To przeciążenie umożliwia kompilatora obsługi konwersje z 16-bitową liczbę całkowitą ze znakiem liczbą, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-434">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-435">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista wynosi 16-bitową liczbę całkowitą ze znakiem i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-435">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-436">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-436">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-437">Definiuje niejawna konwersja całkowita 32-bitowej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-437">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-438">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-438">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-439">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-439">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-440">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-440">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-441">To przeciążenie umożliwia kompilatora obsługi konwersje z całkowita 32-bitowa liczbą, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-441">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-442">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, jak całkowita 32-bitowa i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-442">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-443">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-443">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-444">Definiuje niejawna konwersja 64-bitowej podpisanej liczby całkowitej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-444">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-445">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-445">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-446">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-446">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-447">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-447">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-448">To przeciążenie umożliwia kompilatora obsługi konwersje z całkowita 64-bitowa liczbą, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-448">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-449">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, jak całkowita 64-bitowa i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-449">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-450">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-450">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-451">Definiuje liczbą niejawnej konwersji wartości bajtu ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-451">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="3a7aa-452">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-452">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-453">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-453">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-454">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-454">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-455">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-455">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-456">To przeciążenie umożliwia kompilatora obsługi konwersje z bajtu ze znakiem liczbą, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-456">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-457">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, jak podpisem bajt i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-457">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-458">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-458">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-459">Definiuje niejawna konwersja z liczby zmiennoprzecinkowej pojedynczej precyzji liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-459">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-460">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-460">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-461">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-461">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-462">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-462">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-463">To przeciążenie umożliwia kompilatora obsługiwać konwersję z <xref:System.Single> wartość liczby złożonej, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-463">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-464">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest równa <xref:System.Single> wartość i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-464">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-465">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-465">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-466">Definiuje liczbą niejawnej konwersji wartości 16-bitową liczbę całkowitą bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-466">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="3a7aa-467">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-467">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-468">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-468">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-469">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-469">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-470">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-470">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-471">To przeciążenie umożliwia kompilatora obsługi konwersje z liczbą całkowitą bez znaku 16-bitową liczbą, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-471">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-472">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, liczbę całkowitą bez znaku 16-bitowych i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-472">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-473">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-473">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-474">Definiuje liczbą niejawna konwersja z 32-bitowej liczby całkowitej bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-474">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="3a7aa-475">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-475">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-476">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-476">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-477">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-477">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-478">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-478">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-479">To przeciążenie umożliwia kompilatora obsługi konwersje z liczbą całkowitą bez znaku 32-bitowe liczby złożonej, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-479">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-480">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, liczbę całkowitą bez znaku 32-bitowe i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-480">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-481">Wartość do przekonwertowania na liczbę złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-481">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-482">Definiuje liczbą niejawna konwersja 64-bitowej liczby całkowitej bez znaku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-482">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="3a7aa-483">Ten interfejs API nie jest zgodny ze specyfikacją CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-483">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-484">Obiekt zawierający wartości <paramref name="value" /> parametr jako jego część rzeczywista oraz zero w jej ramach urojony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-484">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-485">Przeciążeń <xref:System.Numerics.Complex.op_Implicit%2A> operator Definiowanie typów, z których może automatycznie przekonwertować kompilatora <xref:System.Numerics.Complex> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-485">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3a7aa-486">Są one rozszerzanie konwersji, nie obejmują utraty danych, które nie zgłaszają <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-486">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3a7aa-487">To przeciążenie umożliwia kompilatora obsługi konwersje z liczbą całkowitą bez znaku 64-bitowe liczby złożonej, jak przedstawiono na poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-487">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3a7aa-488">Należy pamiętać, że wynik konwersji liczbą których część rzeczywista jest taki sam, liczbę całkowitą bez znaku 64-bitowe i których część urojony jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-488">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-489">Pierwsza wartość do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-489">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-490">Druga wartość do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-490">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-491">Zwraca wartość wskazującą, czy dwie liczb zespolonych nie są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-491">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-492">
            <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-492">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-493"><xref:System.Numerics.Complex.op_Equality%2A> Metoda definiuje działania operator nierówności dla liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-493">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="3a7aa-494">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-494">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="3a7aa-495">Języki, które nie obsługują niestandardowych operatory można sprawdzić nierówności, wywołując <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> — metoda i jego wartość cofania.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-495">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="3a7aa-496">Należy pamiętać, że z powodu różnic w dokładność, dwóch liczb zespolonych, które są równoważne najwyraźniej jest uznawana za nierówne.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-496">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="3a7aa-497">Jednym możliwym obejściem jest implementacja metody porównania, która zwraca `true` tylko wtedy, gdy jest to różnica między dwoma częściami rzeczywistą i urojony liczby złożone przekroczy określony próg (np. 01% wartości rzeczywistych lub urojony składnika jeden z liczby złożone).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-497">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="3a7aa-498">Aby uzyskać więcej informacji, zobacz <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-498">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-499">Pierwsza wartość wielokrotnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-499">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-500">Druga wartość używana w wielokrotnie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-500">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-501">Mnoży dwie określonej liczby złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-501">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-502">Iloczyn <paramref name="left" /> i <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-502">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-503"><xref:System.Numerics.Complex.op_Multiply%2A> Metoda definiuje działania operator mnożenia dla liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-503">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="3a7aa-504">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-504">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="3a7aa-505">Mnożenia złożonego number + analizy biznesowej, a druga liczba złożone, c + podpisane, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-505">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-506">(ac - bd) + (ad + bc) i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-506">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="3a7aa-507">Jeśli mnożenia powoduje przepełnienie w czasie rzeczywistym lub urojony składnika, wartość tego składnika jest <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-507">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-508">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Multiply%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-508">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="3a7aa-509">Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a7aa-509">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-510">Wartość, którą chcesz odjąć od (minuend).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-510">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-511">Wartość do odejmowania (subtrahend).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-511">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-512">Odejmuje liczbą od drugiej złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-512">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-513">Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-513">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-514"><xref:System.Numerics.Complex.op_Subtraction%2A> Metoda definiuje działania operator odejmowania dla liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-514">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="3a7aa-515">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-515">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="3a7aa-516">Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-516">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-517">Odejmowanie liczby złożonej, c + podpisane z innej liczby złożonej, + analizy biznesowej, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-517">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-518">(- c) + (b - d) i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-518">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="3a7aa-519">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Subtract%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-519">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="3a7aa-520">Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a7aa-520">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-521">Wartość do wskazania ujemnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-521">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-522">Zwraca odwrotność dodatku określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-522">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-523">Wynik <see cref="P:System.Numerics.Complex.Real" /> i <see cref="P:System.Numerics.Complex.Imaginary" /> składniki <paramref name="value" /> parametru pomnożona przez wartość -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-523">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-524"><xref:System.Numerics.Complex.op_UnaryNegation%2A> Metoda definiuje działania Jednoargumentowy operator negacji (dodatku odwrotność) dla liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-524">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="3a7aa-525">Umożliwia stosowanie kodu takiego jak następujący:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-525">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="3a7aa-526">Wynikowa liczba zespolona daje wartość <xref:System.Numerics.Complex> 0 (zero), gdy jest ona dodawana do oryginalnego liczby złożonej.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-526">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="3a7aa-527">Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.Numerics.Complex.Negate%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-527">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="3a7aa-528">Jest równoważne metodę dla tego operatora <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a7aa-528">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-529">Pobiera fazy liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-529">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a7aa-530">Faza liczby złożonej, w radianach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-530">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-531">Dla liczbą + analizy biznesowej, fazę jest obliczana jako <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-531">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="3a7aa-532">Można zidentyfikować liczbą współrzędnych kartezjańskimi na płaszczyźnie złożone lub jego Współrzędne biegunowe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-532">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="3a7aa-533">Fazy (argumentów) liczbą ma punkt o liczby złożonej kąt, do rzeczywistych osi linią z punktu pochodzenia (przecięcia osi x i y).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-533">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="3a7aa-534">Wielkość (reprezentowane przez <xref:System.Numerics.Complex.Magnitude%2A> właściwości) jest odległość między punkt początkowy punkt, który jest reprezentowana przez liczbę złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-534">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="3a7aa-535">Można utworzyć wystąpienia liczbą oparte na jego Współrzędne biegunowe, zamiast współrzędnych kartezjańskimi przez wywołanie metody <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-535">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="3a7aa-536">Aby przekonwertować fazy z radianów stopni, należy pomnożyć go przez 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-536">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-537">W poniższym przykładzie użyto <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metody tworzenia wystąpienia liczbą oparte na jego Współrzędne biegunowe, a następnie wyświetla wartość jego <xref:System.Numerics.Complex.Magnitude%2A> i <xref:System.Numerics.Complex.Phase%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-537">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-538">Zwraca określoną liczbę złożone podniesione do określonej potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-538">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-539">Liczby złożonej do podniesione do potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-539">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="3a7aa-540">Liczba zmiennoprzecinkowe podwójnej precyzji, która określa potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-540">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-541">Zwraca określoną liczbę złożone podniesionej do potęgi określonej przez liczbie zmiennoprzecinkowej podwójnej precyzji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-541">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-542">Liczby złożone <paramref name="value" /> podniesionej do potęgi <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-542">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-543">Jeśli `value` jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-543">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-544">Dla innych wartości Jeśli `power` ma wartość 0, metoda zwraca <xref:System.Numerics.Complex.One?displayProperty=nameWithType>i w razie `power` ma wartość 1, funkcja zwraca `value`.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-544">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="3a7aa-545">Ta metoda odpowiada <xref:System.Math.Pow%2A?displayProperty=nameWithType> metody dla typów pierwotnych liczbowych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-545">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-546">Poniższy przykład przedstawia potęgowania przy użyciu liczbą i wykładnik, którego wartość może się wahać od -1 do 10.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-546">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-547">Liczby złożonej do podniesione do potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-547">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="3a7aa-548">Liczba złożonych, określająca potęgi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-548">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-549">Zwraca określoną liczbę złożone podniesionej do potęgi określonej przez liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-549">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-550">Liczby złożone <paramref name="value" /> podniesionej do potęgi <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-550">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-551">Pobiera składnik rzeczywistych bieżącego <see cref="T:System.Numerics.Complex" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-551">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a7aa-552">Rzeczywiste składnik liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-552">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-553">Podany numer złożone + analizy biznesowej, <xref:System.Numerics.Complex.Real%2A> właściwość zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-553">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-554">Poniższy przykład tworzy tablicę <xref:System.Numerics.Complex> obiekty i wyświetla rzeczywiste i urojony składniki każdej z nich w formularzu + analizy biznesowej.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-554">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-555">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-555">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-556">Zwraca odwrotność multiplicative liczbą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-556">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-557">Odwrotność <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-557">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-558">Wzajemne lub multiplicative odwrotność liczbą *x* jest liczbą *y* gdzie *x* pomnożona przez *y* daje 1.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-558">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="3a7aa-559">Liczby złożonej, której wynikiem jest odwrotność liczbą <xref:System.Numerics.Complex.One?displayProperty=nameWithType> kiedy są mnożone dwóch liczb.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-559">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="3a7aa-560">Jeśli liczbą jest reprezentowana przez + analizy biznesowej, jego odwrotność jest reprezentowana przez wyrażenie / (<sup>2</sup>+ b<sup>2</sup>) + -b / (<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-560">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="3a7aa-561">Jeśli wartość jest <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, metoda zwraca <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-561">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a7aa-562">W przeciwnym razie zwraca wynik wyrażenia <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-562">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-563">W poniższym przykładzie użyto <xref:System.Numerics.Complex.Reciprocal%2A> metodę obliczania wzajemnego wartości wielu kodów zespolonych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-563">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="3a7aa-564">Również pokazuje, że wynik mnożenia liczbą przez jego odwrotność jest <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-564">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-565">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-565">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-566">Zwraca sinus określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-566">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-567">Sinus <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-567">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-568"><xref:System.Numerics.Complex.Sin%2A> Odpowiada metoda liczby złożone <xref:System.Math.Sin%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-568">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-569"><xref:System.Numerics.Complex.Sin%2A> Metoda używa następującej formuły można obliczyć sinus liczby złożonej + analizy biznesowej:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-569">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3a7aa-570">(<xref:System.Math.Sin%2A>() * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>() * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="3a7aa-570">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-571">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Sin%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-571">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="3a7aa-572">Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Asin%2A> metodę <xref:System.Numerics.Complex.Sin%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-572">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-573">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-573">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-574">Zwraca sinus hiperboliczny liczby określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-574">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-575">Sinus hiperboliczny <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-575">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-576"><xref:System.Numerics.Complex.Sinh%2A> Odpowiada metoda liczby złożone <xref:System.Math.Sinh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-576">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-577"><xref:System.Numerics.Complex.Sinh%2A> Metoda używa następującej formuły można obliczyć sinus hiperboliczny liczby złożonej + analizy biznesowej:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-577">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3a7aa-578">(<xref:System.Math.Sinh%2A>() * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>() * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="3a7aa-578">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-579">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-579">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-580">Zwraca pierwiastek kwadratowy z podanej liczby złożone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-580">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-581">Pierwiastek kwadratowy liczby <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-581">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-582">Pierwiastek kwadratowy z liczby złożonej `value` jest obliczana przy użyciu następującej formuły:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-582">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="3a7aa-583"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span><span class="sxs-lookup"><span data-stu-id="3a7aa-583"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="3a7aa-584"><xref:System.Numerics.Complex.Sqrt%2A> Odpowiada metoda liczby złożone <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-584">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3a7aa-585">Wartość, którą chcesz odjąć od (minuend).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-585">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3a7aa-586">Wartość do odejmowania (subtrahend).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-586">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-587">Odejmuje jedną liczbę złożone z innego i zwraca wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-587">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-588">Wynik odejmowania <paramref name="right" /> z <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-588">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-589">Odejmowanie liczby złożonej, c + podpisane z innej liczby złożonej, + analizy biznesowej, ma następującą postać:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-589">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="3a7aa-590">(- c) + (b - d) i</span><span class="sxs-lookup"><span data-stu-id="3a7aa-590">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="3a7aa-591">Jeśli metoda wyniki wywołania nastąpiło przepełnienie w jeden składnik rzeczywisty lub urojony, wartość tego składnika jest albo <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> lub <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-591">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3a7aa-592">Można używać języków, które nie obsługują niestandardowych operatory <xref:System.Numerics.Complex.Subtract%2A> metodę w celu odejmowania za pomocą liczby złożone.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-592">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-593">Poniższy przykład odejmuje każdej liczby złożonej w tablicy z liczbą.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-593">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-594">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-594">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-595">Zwraca tangens określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-595">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-596">Tangens <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-596">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-597"><xref:System.Numerics.Complex.Tan%2A> Odpowiada metoda liczby złożone <xref:System.Math.Tan%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-597">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-598"><xref:System.Numerics.Complex.Tan%2A> Metoda używa następującej formuły można obliczyć tangens liczby złożonej `value`:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-598">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="3a7aa-599"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="3a7aa-599"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-600">Poniższy przykład przedstawia <xref:System.Numerics.Complex.Tan%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-600">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="3a7aa-601">Widoczny jest przekazanie wartości zwróconej przez <xref:System.Numerics.Complex.Atan%2A> metodę <xref:System.Numerics.Complex.Tan%2A> metoda zwraca oryginalną <xref:System.Numerics.Complex> wartość.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-601">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3a7aa-602">Liczba złożonych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-602">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-603">Zwraca tangens hiperboliczny dla określonej liczby złożonej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-603">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-604">Tangens hiperboliczny liczby <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-604">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-605"><xref:System.Numerics.Complex.Tanh%2A> Odpowiada metoda liczby złożone <xref:System.Math.Tanh%2A?displayProperty=nameWithType> metody dla liczb rzeczywistych.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-605">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3a7aa-606"><xref:System.Numerics.Complex.Tanh%2A> Metoda używa następującej formuły można obliczyć tangens hiperboliczny dla liczby złożonej `value`:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-606">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="3a7aa-607"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="3a7aa-607"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-608">Konwertuje wartość liczby złożonej do reprezentacji ciągu równoważne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-608">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-609">Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-609">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-610">Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-610">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-611">Domyślne reprezentację liczby złożonej Wyświetla liczbę przy użyciu współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-611">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3a7aa-612">Zarówno ** i *b* są sformatowane przy użyciu specyfikatora formatu Ogólne ("G") i konwencje związane z bieżącego ustawienia kulturowego systemu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-612">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-613">W poniższym przykładzie przedstawiono kilka liczby złożone reprezentację ciągu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-613">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="3a7aa-614">Dane wyjściowe używa konwencji formatowania języka angielskiego - kultury Stanów Zjednoczonych ("pl pl"), który w tym przypadku jest bieżącego ustawienia kulturowego systemu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-614">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="3a7aa-615">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-615">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-616">Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi przy użyciu określonego formatowania informacje specyficzne dla kultury.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-616">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-617">Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi określony przez <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-617">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-618">Reprezentacja ciągu liczby złożonej zwracane przez tę metodę. Wyświetla liczbę za pomocą współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-618">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3a7aa-619">Zarówno ** i *b* sformatowane przy użyciu specyfikatora formatu Ogólne ("G") i konwencje kultury zdefiniowane przez `provider`.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-619">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="3a7aa-620">`provider` Parametr jest <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-620">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="3a7aa-621">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie rzeczywistą i zespoloną liczb w zwracany ciąg.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-621">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="3a7aa-622">Jeśli `provider` jest `null`, zwracany ciąg sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-622">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="3a7aa-623">`provider` Parametr może być jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-623">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="3a7aa-624">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania</span><span class="sxs-lookup"><span data-stu-id="3a7aa-624">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="3a7aa-625"><xref:System.Globalization.NumberFormatInfo> Obiektu, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-625">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="3a7aa-626">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-626">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="3a7aa-627">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-627">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-628">W poniższym przykładzie przedstawiono kilka liczby złożone reprezentację ciągu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-628">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="3a7aa-629">Wynik używa konwencji formatowania Polish - poland ("pl pl") i francuskim - kultur Francja (fr-FR").</span><span class="sxs-lookup"><span data-stu-id="3a7aa-629">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="3a7aa-630">Standardowy lub niestandardowy ciąg formatu liczbowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-630">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-631">Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi przy użyciu określonego formatu dla jego rzeczywistego i urojony części.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-631">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-632">Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-632">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-633">Reprezentacja ciągu liczby złożonej zwracane przez tę metodę. Wyświetla liczbę za pomocą współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-633">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3a7aa-634">Zarówno ** i *b* są sformatowane przy użyciu określonej przez ciąg formatu `format`.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-634">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="3a7aa-635">`format` Parametr może być specyfikator wszystkie prawidłowe standardowego formatu liczbowego lub dowolną kombinację specyfikatory niestandardowego formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-635">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="3a7aa-636">Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, rzeczywiste i urojony części liczby złożonej są sformatowane specyfikator formatu Ogólne ("G").</span><span class="sxs-lookup"><span data-stu-id="3a7aa-636">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="3a7aa-637">Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-637">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="3a7aa-638">.NET Framework zapewnia szeroką gamę formatowania, opisany bardziej szczegółowo w następujących tematach:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-638">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="3a7aa-639">Aby uzyskać więcej informacji na temat ciągi formatujące liczb, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-639">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="3a7aa-640">Aby uzyskać więcej informacji na temat formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-640">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="3a7aa-641">Format zwrócony ciąg jest określany przez <xref:System.Globalization.NumberFormatInfo> obiektu dla bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-641">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="3a7aa-642">W zależności od `format` parametr, ten obiekt określa symbole, takie jak znaku minus, separatora grupy i symbol punktu dziesiętnego w ciągu wyjściowego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-642">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="3a7aa-643">Aby podać informacje dotyczące formatowania dla kultury niż bieżącej kultury, wywołaj <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-643">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-644">Poniższy przykład inicjuje liczbą i wyświetla je przy użyciu kilku standardowe ciągi formatujące.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-644">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="3a7aa-645">
            <paramref name="format" /> nie jest prawidłowym ciągiem formatu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-645">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="3a7aa-646">Standardowy lub niestandardowy ciąg formatu liczbowego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-646">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="3a7aa-647">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-647">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a7aa-648">Konwertuje wartość bieżącej liczby złożonej do reprezentacji ciągu odpowiednik w postaci kartezjańskimi przy użyciu określonego formatu i informacji o formacie specyficzne dla kultury dla jego rzeczywistego i urojony części.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-648">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3a7aa-649">Reprezentacja ciągu bieżącego wystąpienia w formularzu kartezjańskimi określony przez <paramref name="format" /> i <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-649">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-650">Reprezentacja ciągu liczby złożonej zwracane przez tę metodę. Wyświetla liczbę za pomocą współrzędnych kartezjańskimi w formie `(` ** `,` *b*`)`, gdzie ** jest część rzeczywista liczba złożone i *b* jest jego częścią urojony.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-650">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3a7aa-651">Zarówno ** i *b* są sformatowane przy użyciu określonej przez ciąg formatu `format`.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-651">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="3a7aa-652">`format` Parametr może być specyfikator wszystkie prawidłowe standardowego formatu liczbowego lub dowolną kombinację specyfikatory niestandardowego formatu liczbowego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-652">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="3a7aa-653">Jeśli `format` jest równa <xref:System.String.Empty?displayProperty=nameWithType> lub `null`, rzeczywiste i urojony części liczby złożonej są sformatowane specyfikator formatu Ogólne ("G").</span><span class="sxs-lookup"><span data-stu-id="3a7aa-653">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="3a7aa-654">Jeśli `format` jest wszelkie inne wartości, metoda zgłasza <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-654">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="3a7aa-655">.NET Framework zapewnia szeroką gamę formatowania, opisany bardziej szczegółowo w następujących tematach:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-655">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="3a7aa-656">Aby uzyskać więcej informacji na temat ciągi formatujące liczb, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowe ciągi formatów liczbowych](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-656">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="3a7aa-657">Aby uzyskać więcej informacji na temat formatowania w programie .NET Framework, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="3a7aa-657">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="3a7aa-658">`provider` Parametr jest <xref:System.IFormatProvider> implementacji.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-658">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="3a7aa-659">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje specyficzne dla kultury o formacie rzeczywistą i zespoloną liczb w zwracany ciąg.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-659">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="3a7aa-660">W zależności od `format` parametr, ten obiekt określa symbole, takie jak znaku minus, separatora grupy i symbol punktu dziesiętnego w ciągu wyjściowego.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-660">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="3a7aa-661">Jeśli `provider` jest `null`, zwracany ciąg sformatowany przy użyciu <xref:System.Globalization.NumberFormatInfo> obiektu bieżącej kultury.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-661">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="3a7aa-662">`provider` Parametr może być jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="3a7aa-662">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="3a7aa-663">A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, który dostarcza informacje dotyczące formatowania</span><span class="sxs-lookup"><span data-stu-id="3a7aa-663">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="3a7aa-664"><xref:System.Globalization.NumberFormatInfo> Obiektu, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-664">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="3a7aa-665">Niestandardowy obiekt, który implementuje <xref:System.IFormatProvider> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-665">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="3a7aa-666">Jego <xref:System.IFormatProvider.GetFormat%2A> metoda zwraca <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza informacje dotyczące formatowania.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-667">Poniższy przykład tworzy tablicę liczby złożone i są wyświetlane wszystkie przy użyciu kilku standardowe ciągi formatujące oraz <xref:System.Globalization.CultureInfo> obiekty reprezentujące kultur angielskiego — Stany Zjednoczone ("pl pl") i francuskim - Francja (fr-FR").</span><span class="sxs-lookup"><span data-stu-id="3a7aa-667">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="3a7aa-668">
            <paramref name="format" /> nie jest prawidłowym ciągiem formatu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-668">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a7aa-669">Zwraca nowy <see cref="T:System.Numerics.Complex" /> wystąpienia z liczbą rzeczywistą równa zero i liczbę zespoloną równa zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a7aa-669">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a7aa-670"><xref:System.Numerics.Complex.Zero> Jest najczęściej używana do porównania <xref:System.Numerics.Complex> wartość zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-670">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a7aa-671">Poniższy przykład tworzy <xref:System.Numerics.Complex> wartość przy użyciu <xref:System.Numerics.Complex.Zero> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-671">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="3a7aa-672">Następnie porównuje tę wartość na inną wartość, która zostanie uruchomiony przez wywołanie metody <xref:System.Numerics.Complex> konstruktora z rzeczywistą równa zero i część dotyczącą urojony równa zero.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-672">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="3a7aa-673">Jak pokazano na dane wyjściowe z przykładu, dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="3a7aa-673">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>
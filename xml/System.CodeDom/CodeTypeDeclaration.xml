<Type Name="CodeTypeDeclaration" FullName="System.CodeDom.CodeTypeDeclaration">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ada939b11aca74ba85b3b6dd8b46aedfae2d91a5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36645958" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CodeTypeDeclaration : System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CodeTypeDeclaration extends System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.CodeTypeDeclaration" />
  <TypeSignature Language="VB.NET" Value="Public Class CodeTypeDeclaration&#xA;Inherits CodeTypeMember" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeTypeDeclaration : System::CodeDom::CodeTypeMember" />
  <TypeSignature Language="F#" Value="type CodeTypeDeclaration = class&#xA;    inherit CodeTypeMember" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.CodeDom.CodeTypeMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje deklaracji typu klasy, struktury, interfejsu lub wyliczenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.CodeTypeDeclaration> może być używana do reprezentowania kodu, który deklaruje klasy, struktury, interfejsu lub wyliczenia. <xref:System.CodeDom.CodeTypeDeclaration> można zadeklarować typu, który jest zagnieżdżony w ramach innego typu.  
  
 <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> Właściwość określa typ podstawowy lub typy podstawowe typu został zadeklarowany. <xref:System.CodeDom.CodeTypeDeclaration.Members%2A> Właściwość zawiera elementy członkowskie typu, które mogą obejmować metody, pola, właściwości, komentarze i innych typów. <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> Właściwość wskazuje <xref:System.Reflection.TypeAttributes> dla deklaracji typu wartości, które wskazują kategorii typu typu. <xref:System.CodeDom.CodeTypeDeclaration.IsClass%2A>, <xref:System.CodeDom.CodeTypeDeclaration.IsStruct%2A>, <xref:System.CodeDom.CodeTypeDeclaration.IsEnum%2A>, I <xref:System.CodeDom.CodeTypeDeclaration.IsInterface%2A> metody informujące o powodzeniu typu klasy, struktury, wyliczenia lub typu interfejsu, odpowiednio.  
  
> [!NOTE]
>  Niektóre języki programowania obsługuje tylko deklaracji typów referencyjnych i klas. Aby sprawdzić generator kodu CodeDOM specyficzny dla języka dla pomocy technicznej deklarowania interfejsy, wyliczenia lub typu wartości, należy wywołać <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> metody do testowania dla odpowiedniej <xref:System.CodeDom.Compiler.GeneratorSupport> flagi. <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareInterfaces> Wskazuje obsługę interfejsów, <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareEnums> wskazuje obsługę wyliczenia, i <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareValueTypes> wskazuje pomocy technicznej dla typów wartości, takich jak struktury.  
  
 Tworzenie klasy lub struktury implementacji w jednej deklaracji pełną lub ich rozmieszczenie do wykonania wielu deklaracji. <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Właściwość wskazuje, czy deklaracja typu jest pełną lub częściową. Nie wszystkie generatory kodu obsługuje deklaracji typu częściowego, dlatego należy przetestować obsługę wywołując <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> metody z flagą <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>.  
  
   
  
## Examples  
 W tym przykładzie pokazano, przy użyciu <xref:System.CodeDom.CodeTypeDeclaration> Aby zadeklarować typu.  
  
 [!code-cpp[CodeTypeDeclarationExample#2](~/samples/snippets/cpp/VS_Snippets_CLR/CodeTypeDeclarationExample/CPP/codetypedeclarationexample.cpp#2)]
 [!code-csharp[CodeTypeDeclarationExample#2](~/samples/snippets/csharp/VS_Snippets_CLR/CodeTypeDeclarationExample/CS/codetypedeclarationexample.cs#2)]
 [!code-vb[CodeTypeDeclarationExample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeTypeDeclarationExample/VB/codetypedeclarationexample.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.CodeDom.CodeTypeDeclarationCollection" />
    <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.CodeTypeDeclaration" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.CodeTypeDeclaration" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.CodeTypeDeclaration : string -&gt; System.CodeDom.CodeTypeDeclaration" Usage="new System.CodeDom.CodeTypeDeclaration name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nowego typu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.CodeTypeDeclaration" /> klasy o określonej nazwie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseTypes">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReferenceCollection BaseTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeReferenceCollection BaseTypes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseTypes As CodeTypeReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeReferenceCollection ^ BaseTypes { System::CodeDom::CodeTypeReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseTypes : System.CodeDom.CodeTypeReferenceCollection" Usage="System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy podstawowe typu.</summary>
        <value>A <see cref="T:System.CodeDom.CodeTypeReferenceCollection" /> obiekt, który wskazuje typy podstawowe typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wygenerować klasy w Visual Basic, który nie dziedziczy z typu podstawowego, ale który implementuje jeden lub więcej interfejsów, należy uwzględnić <xref:System.Object> jako pierwszy element <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> kolekcji.  
  
> [!NOTE]
>  W programie .NET Framework w wersji 2.0, nie trzeba <xref:System.CodeDom.CodeTypeReference> dla <xref:System.Object> Jeśli interfejsu w przypadku wdrażania już istnieje i odwołujące się do niego według typu. Na przykład w przypadku wdrażania <xref:System.Collections.ICollection> interfejsu i dodaj go do kolekcji z tej instrukcji `ctd.BaseTypes.Add(New CodeTypeReference(typeof(ICollection)))`, nie trzeba poprzedniego `ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))` instrukcji.  
  
 Poniższy kod ilustruje dodanie <xref:System.CodeDom.CodeTypeReference> do kolekcji, która odwołuje się do <xref:System.Object>.  
  
```vb  
Dim ctd As New CodeTypeDeclaration("Class1")  
ctd.IsClass = True  
ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))  
ctd.BaseTypes.Add(New CodeTypeReference("Interface1"))  
```  
  
```csharp  
CodeTypeDeclaration ctd = new CodeTypeDeclaration("Class1");  
ctd.IsClass = true;  
ctd.BaseTypes.Add(new CodeTypeReference(typeof(Object)));  
ctd.BaseTypes.Add(new CodeTypeReference("Interface1"));  
```  
  
 Poprzedni kod generuje odpowiednikiem następującego kodu języka Visual Basic.  
  
```vb  
Public Class Class1  
Implements Interface1  
```  
  
 Kod Visual Basic faktycznie generowany jest jednak poniżej.  
  
```vb  
Public Class Class1  
Inherits Object  
Implements Interface1  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeReferenceCollection" />
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy typ jest typem klasy lub odwołanie.</summary>
        <value>
          <see langword="true" /> Jeśli typ jest typem klasy lub odwołania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy typ jest wyliczeniem.</summary>
        <value>
          <see langword="true" /> Jeśli typ jest wyliczeniem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy typ jest interfejsem.</summary>
        <value>
          <see langword="true" /> Jeśli typ jest interfejsem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPartial">
      <MemberSignature Language="C#" Value="public bool IsPartial { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPartial" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPartial As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPartial { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPartial : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy deklaracja typu jest pełną lub częściową.</summary>
        <value>
          <see langword="true" /> w przypadku deklaracji klasy lub struktury reprezentację częściowa implementacja; <see langword="false" /> czy deklaracja jest pełna implementacja klasy lub struktury. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzenie klasy lub struktury implementacji w jednej deklaracji pełną lub ich rozmieszczenie do wykonania wielu deklaracji. Implementacje często są określane w deklaracji typu pełną. W takim przypadku należy ustawić deklaracji typu <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> właściwości `false`, co oznacza, że Deklaracja typu reprezentuje wszystkie szczegóły implementacji klasy lub struktury.  
  
 Deklaracja typu częściowego ułatwia tworzenie różnych części implementacji klasy lub struktury w różnych modułach aplikacji. Deklaracje typu częściowego mogą być przechowywane w jednym pliku źródłowego lub rozłożyć na wiele plików źródłowych kompilowanych ostatecznie razem do utworzenia implementacji typu połączonych.  
  
 W języku C# obsługuje typ częściowe deklaracje klas i struktur za pomocą `partial` — słowo kluczowe. Visual Basic obsługuje typ częściowe deklaracje klas i struktur z `Partial` — słowo kluczowe. Nie wszystkie generatory kodu obsługuje deklaracji typu częściowego, dlatego należy przetestować obsługę wywołując <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> metody z flagą <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>.  
  
> [!NOTE]
>  Deklaracje typu częściowego są obsługiwane dla klas i struktur. Jeśli określisz deklaracji typu częściowego, wyliczenie lub interfejs wygenerowany kod tworzy błędy kompilatora.  
  
 Ustaw dostarczając implementację klasy lub struktury w wielu deklaracjach <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> właściwości `true` początkowej deklaracji i wszystkie dodatkowe deklaracje. Początkowej deklaracji pełni określić typ podpisu, takich jak modyfikatory dostępu dziedziczone typy i zaimplementowane interfejsy. Dodatkowe deklaracje nie trzeba ponownie Określ podpis typu. Błąd kompilatora zwykle powoduje podczas zmiany definicji podpis typu w deklaracji dodatkowych.  
  
 Visual Studio 2005 używa typów częściowych do oddzielania kod wygenerowany przez użytkownika z projektanta kodu. W projektach Visual Basic aplikacji systemu Windows, kod użytkownika znajduje się w klasie częściowej, który nie jest kwalifikowana przez `Partial` — słowo kluczowe; podane projektanta kod pojawia się w częściowej klasy, która ma `Partial` — słowo kluczowe. W języku C#, zarówno kod użytkownika i kodu projektanta wyświetlane w częściowej klasy oznaczona `partial` — słowo kluczowe.  
  
   
  
## Examples  
 W tym przykładzie pokazano, przy użyciu <xref:System.CodeDom.CodeTypeDeclaration> dostarczyć implementację klasy w wielu deklaracjach. Przykład kompilacje instrukcji deklaracji klasy początkowej i ustawia <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> właściwości `true`.  
  
 [!code-cpp[CodeDomPartialTypeExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomPartialTypeExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#3)]
 [!code-vb[CodeDomPartialTypeExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#3)]  
  
 Inna metoda w tym przykładzie rozszerza implementacji klasy. Ta metoda tworzy nowy instrukcji deklaracji typu dla istniejącej klasy i zestawów <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> właściwości `true`. Kompilator łączy dwie deklaracje typu częściowego ze sobą w celu wykonania pełnej klasy.  
  
 [!code-cpp[CodeDomPartialTypeExample#7](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#7)]
 [!code-csharp[CodeDomPartialTypeExample#7](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#7)]
 [!code-vb[CodeDomPartialTypeExample#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.CodeDom.Compiler.GeneratorSupport.PartialTypes" />
      </Docs>
    </Member>
    <Member MemberName="IsStruct">
      <MemberSignature Language="C#" Value="public bool IsStruct { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStruct" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberSignature Language="VB.NET" Value="Public Property IsStruct As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStruct { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsStruct : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy typ jest typem wartości (struktury).</summary>
        <value>
          <see langword="true" /> Jeśli typem jest typ wartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Members">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeMemberCollection Members { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeMemberCollection Members" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Members As CodeTypeMemberCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeMemberCollection ^ Members { System::CodeDom::CodeTypeMemberCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Members : System.CodeDom.CodeTypeMemberCollection" Usage="System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeMemberCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję elementów członkowskich klasy dla typu reprezentowanego.</summary>
        <value>A <see cref="T:System.CodeDom.CodeTypeMemberCollection" /> obiekt, który wskazuje elementów członkowskich klasy.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.CodeDom.CodeTypeMemberCollection" />
      </Docs>
    </Member>
    <Member MemberName="PopulateBaseTypes">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateBaseTypes;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateBaseTypes" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateBaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateBaseTypes As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateBaseTypes;" />
      <MemberSignature Language="F#" Value="member this.PopulateBaseTypes : EventHandler " Usage="member this.PopulateBaseTypes : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" /> kolekcji jest dostępny po raz pierwszy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateMembers">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateMembers;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateMembers" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateMembers" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateMembers As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateMembers;" />
      <MemberSignature Language="F#" Value="member this.PopulateMembers : EventHandler " Usage="member this.PopulateMembers : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.CodeDom.CodeTypeDeclaration.Members" /> kolekcji jest dostępny po raz pierwszy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAttributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes TypeAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes TypeAttributes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeAttributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes TypeAttributes { System::Reflection::TypeAttributes get(); void set(System::Reflection::TypeAttributes value); };" />
      <MemberSignature Language="F#" Value="member this.TypeAttributes : System.Reflection.TypeAttributes with get, set" Usage="System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia atrybuty typu.</summary>
        <value>A <see cref="T:System.Reflection.TypeAttributes" /> obiekt, który określa atrybuty typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes> Właściwość zawiera ten sam typ wartości używane przez <xref:System.Reflection> podczas badania typu w czasie wykonywania. Wiele z tych flag nie odpowiadają Składnia deklaracji typu w przypadku niektórych języków. W związku z tym tylko następujące flagi są istotne dla <xref:System.CodeDom.CodeTypeDeclaration> : <xref:System.Reflection.TypeAttributes.Class>, <xref:System.Reflection.TypeAttributes.Interface>, <xref:System.Reflection.TypeAttributes.Abstract>, <xref:System.Reflection.TypeAttributes.Sealed>, <xref:System.Reflection.TypeAttributes.Public>, <xref:System.Reflection.TypeAttributes.NotPublic>, <xref:System.Reflection.TypeAttributes.NestedPublic>, i <xref:System.Reflection.TypeAttributes.NestedPrivate>.  
  
> [!NOTE]
>  Niektórych flag, takich jak <xref:System.Reflection.TypeAttributes.Abstract> nakłada się znaczenie flagi w <xref:System.CodeDom.CodeTypeMember.Attributes%2A> właściwość <xref:System.CodeDom.CodeTypeDeclaration> który odziedziczone <xref:System.CodeDom.CodeTypeMember>. <xref:System.CodeDom.CodeTypeMember.Attributes%2A> Właściwość jest efektem ubocznym <xref:System.CodeDom.CodeTypeDeclaration> dziedziczenia z klasy <xref:System.CodeDom.CodeTypeMember> , dzięki czemu mogą być zagnieżdżane klasy. Flagi w <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> właściwość powinna być używana zamiast flagi w <xref:System.CodeDom.CodeTypeMember.Attributes%2A> właściwości.  
  
> [!NOTE]
>  Wzorzec do ustawiania flagi widoczności (flagi zawierające słowa `Public` lub `Nested`) jest zamaskowanie widoczność wszystkie flagi przy użyciu <xref:System.Reflection.TypeAttributes.VisibilityMask> , a następnie ustaw wartość flagi widoczności żądany. Na przykład C# instrukcja kodu do identyfikowania <xref:System.CodeDom.CodeTypeDeclaration> (o nazwie `cd`) jest klasą wewnętrzną `cd.TypeAttributes = (cd.TypeAttributes & ~TypeAttributes.VisibilityMask) | TypeAttributes.NotPublic;`.  Kod, aby ustawić tę samą wartość w języku Visual Basic `cd.TypeAttributes = (cd.TypeAttributes And (TypeAttributes.VisibilityMask Xor -1)) Or TypeAttributes.NotPublic`. Ustawienie <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> właściwości bezpośrednio do flaga widoczności (`cd.TypeAttributes = TypeAttributes.NotPublic;`) powoduje usunięcie wszystkich flag, które mogą być ustawione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="TypeParameters">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeParameterCollection TypeParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeParameterCollection TypeParameters" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeParameters As CodeTypeParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeParameterCollection ^ TypeParameters { System::CodeDom::CodeTypeParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeParameters : System.CodeDom.CodeTypeParameterCollection" Usage="System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera parametry typu dla deklaracji typu.</summary>
        <value>A <see cref="T:System.CodeDom.CodeTypeParameterCollection" /> zawiera parametry typu dla deklaracji typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deklaracja typu ogólnego zawiera jeden lub kilka nieokreślonych typy znane jako parametrów typu. Nazwa parametru typu oznacza typu w treści deklaracja ogólna. Na przykład deklaracja ogólna dla <xref:System.Collections.Generic.List%601> klasa zawiera parametr typu `T`.  
  
 Aby uzyskać więcej informacji dotyczących typów ogólnych, zobacz [typy ogólne w bibliotece klas programu .NET Framework](~/docs/csharp/programming-guide/generics/generics-in-the-net-framework-class-library.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeParameterCollection" />
        <altmember cref="T:System.CodeDom.CodeTypeParameter" />
      </Docs>
    </Member>
  </Members>
</Type>
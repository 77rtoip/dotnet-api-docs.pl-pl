<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c701543cf78be82eeaa3f9705791e280a033479a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36507817" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje powiązanie między <see cref="T:System.Windows.Input.InputGesture" /> i polecenia. To polecenie jest potencjalnie <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić, czy dane wejściowe użytkownika wywołuje polecenia, tworząc <xref:System.Windows.Input.InputBinding>. Gdy użytkownik wykonuje określone dane wejściowe <xref:System.Windows.Input.ICommand> który ustawiono <xref:System.Windows.Input.InputBinding.Command%2A> właściwości jest wykonywana.  
  
 Można określić, że <xref:System.Windows.Input.InputBinding> wywołuje polecenie, które jest zdefiniowany w obiekcie przez utworzenie powiązania na <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, i <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwości. Dzięki temu można zdefiniować polecenia niestandardowych i skojarzyć go z danych wejściowych użytkownika. Aby uzyskać więcej informacji zobacz drugi przykład w sekcji przykładów.  
  
 <xref:System.Windows.Input.InputBinding> Można zdefiniować określonego obiektu lub na poziomie klasy rejestrując <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> z <xref:System.Windows.Input.CommandManager>.  
  
 <xref:System.Windows.Input.InputBinding> Sama klasa nie obsługuje użycia XAML, ponieważ nie ujawnia publicznego konstruktora domyślnego (Brak domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą uwidaczniać konstruktora publicznego i w związku z tym można ustawić właściwości w klasie pochodnej, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem języka XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding>-klasy pochodnej, można wdrożyć w języku XAML, które można ustawić właściwości w języku XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>. Typowe właściwości w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] programowania, który jest ustawiony w kodzie XAML i ma co najmniej jeden <xref:System.Windows.Input.InputBinding> obiekty jako wartości jest <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> właściwości.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Użycie elementu obiektu języka XAML  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodnej z <xref:System.Windows.Input.InputBinding> składni elementu obiektu, który obsługuje takie jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Input.KeyBinding> powiązać <xref:System.Windows.Input.KeyGesture> do <xref:System.Windows.Input.ApplicationCommands.Open%2A> polecenia. Po wykonaniu klucza gestu polecenia Otwórz jest wywoływany.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Poniższe przykłady pokazują, jak można powiązać polecenia niestandardowych <xref:System.Windows.Input.InputBinding> obiektów. Te przykłady tworzenia aplikacji, która umożliwia użytkownikowi zmianę koloru tła, wykonując jedną z następujących czynności:  
  
-   Kliknięcie przycisku.  
  
-   Naciśnięcie klawiszy CTRL + C.  
  
-   Prawym przyciskiem myszy <xref:System.Windows.Controls.StackPanel> (poza <xref:System.Windows.Controls.ListBox>).  
  
 W pierwszym przykładzie jest tworzony klasę o nazwie `SimpleDelegateCommand`. Ta klasa akceptuje delegata tak, aby obiekt Tworzenie polecenia można określić akcję, która występuje, gdy polecenie zostanie wykonane. `SimpleDelegateCommand` definiuje również właściwości, które określają, jakie klucza i myszy dane wejściowe wywołuje polecenie. `GestureKey` i `GestureModifier` Określ klawiatury; `MouseGesture` wejście myszy.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 Poniższy przykład tworzy i inicjuje `ColorChangeCommand`, która jest `SimpleDelegateCommand`. W przykładzie zdefiniowano także metodę, która wykonuje się, gdy polecenie jest wywoływany i ustawia `GestureKey`, `GestureModifier`, i `MouseGesture` właściwości. Aplikacja może wywołać `InitializeCommand` metody, gdy rozpocznie się program, taki jak konstruktora <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Poniższy przykład tworzy koniec interfejsu użytkownika. W przykładzie dodano <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding> do <xref:System.Windows.Controls.StackPanel> zawierający <xref:System.Windows.Controls.Button> i <xref:System.Windows.Controls.ListBox>. Użytkownik wybrał element <xref:System.Windows.Controls.ListBox>, użytkownik może zmienić kolor tła wybranego koloru. W każdym przypadku `CommandParameter` właściwość jest powiązana z wybranego elementu w <xref:System.Windows.Controls.ListBox>i `Command` właściwość jest powiązana z `ColorChangeCommand`. <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, I <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> właściwości powiązanych z odpowiednich właściwości `SimpleDelegateCommand` klasy.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Input.InputBinding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Zapewnia podstawowe inicjowania klasy wyprowadzone z <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> nie jest technicznie klasą abstrakcyjną, ale domyślny konstruktor jest celowo chronione dostępu. Powoduje to przekształcenie <xref:System.Windows.Input.InputBinding> "abstract" klasy dla języka XAML. Istnieją istniejącej właściwości w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] użycia XAML, które oczekują obiektów tego typu, która ma <xref:System.Windows.Input.InputBinding>, ale nie można określić <xref:System.Windows.Input.InputBinding> wystąpienia w języku XAML. Zamiast tego można określić jeden z konkretnym urządzeniu <xref:System.Windows.Input.InputBinding> klas pochodnych jako wartości, na przykład <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku zastosowania niestandardowego <see cref="T:System.Windows.Input.InputBinding" /> obsługującej użycie języka XAML, użyj tego konstruktora podstawowego inicjowania.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Polecenie, aby skojarzyć z <c>gestu</c>.</param>
        <param name="gesture">Wejściowy gestu do skojarzenia z <c>polecenia</c>.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Input.InputBinding" /> z określonego polecenia i wejściowych gestu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jesteś deweloperem oprogramowania przy użyciu istniejących danych wejściowych powiązanie klasy na zazwyczaj nie będzie używać tego konstruktora, nawet jeśli definiujesz polecenia niestandardowych. Zamiast tego należy albo użyje konstruktory klas pochodnych (<xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>), lub jako podstawowej podczas tworzenia wystąpienia klasy niestandardowej użyjesz tego konstruktora. Mimo że <xref:System.Windows.Input.InputBinding> klasa obsługuje różne urządzenia wejściowego w zasadzie, w praktyce należy wybrać urządzenia, które będą stanowiły powiązania wejściowego. Można tylko ustawić tylko jeden <xref:System.Windows.Input.InputBinding.Gesture%2A> wartość powiązania wejściowego i gestów są specyficzne dla urządzenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tego konstruktora do skojarzenia <xref:System.Windows.Input.KeyGesture> z <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcomand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcomand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="command" /> lub <paramref name="gesture" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Kopiuje podstawowej (z systemem innym niż animowane) wartości właściwości określonego obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Kopiuje bieżące wartości właściwości określonego obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Input.ICommand" /> skojarzony z tym powiązaniem wejściowego.</summary>
        <value>Polecenie skojarzone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> Klasa nie obsługuje użycia XAML, ponieważ nie ujawnia publicznego konstruktora domyślnego (ma domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą uwidaczniać konstruktora publicznego i w związku z tym można używać właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding>. Dwa istniejące <xref:System.Windows.Input.InputBinding> klasy pochodnej, można wdrożyć w języku XAML, które można ustawić właściwości z użycia języka XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> odwołuje się do konwerter typu, który umożliwia niektóre istniejące wcześniej <xref:System.Windows.Input.ICommand> implementacji, aby określić wartości w postaci ciągu. To zachowanie konwersji typu Ustawia atrybut formularza wartość tej właściwości. Może także powiązać <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, i <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwości <xref:System.Windows.Input.ICommand> określony dla obiektu. Dzięki temu można zdefiniować polecenia niestandardowych i skojarzyć go z danych wejściowych użytkownika. Aby uzyskać więcej informacji, zobacz drugi przykład w <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 <`inputBindingDerivedClass` `Command`= "<xref:System.Windows.Input.ICommand>" / >  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodnej z <xref:System.Windows.Input.InputBinding> składni elementu obiektu, który obsługuje takie jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `iCommandImplementation`  
 Implementacja obiektu <xref:System.Windows.Input.ICommand> obsługującej składni elementu obiektu (nie ma publicznego konstruktora domyślnego).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Input.KeyBinding> powiązać <xref:System.Windows.Input.KeyGesture> do <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> polecenia. Po wykonaniu klucza gestu polecenia Otwórz jest wywoływany.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Input.InputBinding.Command" /> Wartość jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dane specyficzne dla polecenia dla określonego polecenia.</summary>
        <value>Dane specyficzne dla danego polecenia. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding.CommandParameter%2A> Właściwość jest używana do przekazywania określonych informacji do polecenia podczas jej wykonywania. Typ danych jest zdefiniowany przez polecenie. Wiele poleceń nie oczekuje parametry polecenia; dla tych poleceń wszystkie parametry polecenia przekazany zostanie zignorowany.  
  
 Jeśli polecenie skojarzonego z powiązania wejściowego jest <xref:System.Windows.Input.RoutedCommand>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A> powiązania wejściowego jest przekazywana do <xref:System.Windows.Input.RoutedCommand> obsługi za pomocą <xref:System.Windows.Input.ExecutedRoutedEventArgs> i <xref:System.Windows.Input.CanExecuteRoutedEventArgs> dane zdarzenia podczas przetwarzania polecenia.  
  
 Typ danych i cel parametr polecenia są zdefiniowane inaczej dla każdego polecenia i może być `null`. Możesz powiązać <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, i <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwości <xref:System.Windows.Input.ICommand> określony dla obiektu. Dzięki temu można zdefiniować polecenia niestandardowych i skojarzyć go z danych wejściowych użytkownika. Aby uzyskać więcej informacji, zobacz drugi przykład w <xref:System.Windows.Input.InputBinding>.  
  
 <xref:System.Windows.Input.InputBinding> Klasa nie obsługuje użycia XAML, ponieważ nie ujawnia publicznego konstruktora domyślnego (ma domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą uwidaczniać konstruktora publicznego i w związku z tym można ustawić właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem języka XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding> klasy pochodnej, można wdrożyć w języku XAML, które można ustawić właściwości w języku XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodnej z <xref:System.Windows.Input.InputBinding> składni elementu obiektu, który obsługuje takie jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `commandParameterString`  
 Ciąg, który jest przetwarzany przez konkretnego polecenia. Ciągi to wspólny typ używane dla parametrów polecenia, ponieważ może być łatwo ustawiony w języku XAML. Oczekiwano ciągu formatu i jej celem w dokumentacji konkretnego polecenia skojarzonego z powiązania wejściowego. Wiele poleceń nie oczekuje parametrów.  
  
 `commandParameterObject`  
 Obiekt, który jest przetwarzany przez konkretnego polecenia. Wszystkie istniejące [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] polecenia, użyj parametrów. W związku z tym tej składni elementu właściwości ma zastosowanie tylko w scenariuszach poleceń niestandardowych. Aby zapewnić obsługę tej składni `commandParameterObject` obiektu muszą również obsługiwać składni elementu obiektu (musi mieć publicznego konstruktora domyślnego).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Input.InputBinding.CommandParameter" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Input.InputBinding.Command" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element docelowy polecenia.</summary>
        <value>Element docelowy polecenia. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W Windows Presentation Foundation droższe systemu <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwość <xref:System.Windows.Input.ICommandSource> obiekt jest stosowane tylko wtedy, gdy <xref:System.Windows.Input.ICommand> jest <xref:System.Windows.Input.RoutedCommand>. Jeśli <xref:System.Windows.Input.InputBinding.CommandTarget%2A> jest ustawiona na <xref:System.Windows.Input.ICommandSource> i odpowiadające jej polecenie nie jest <xref:System.Windows.Input.RoutedCommand>, element docelowy polecenia jest ignorowana.  
  
 W przypadku użycia z <xref:System.Windows.Input.RoutedCommand>, obiektu, na którym jest element docelowy polecenia <xref:System.Windows.Input.CommandManager.Executed> i <xref:System.Windows.Input.CommandManager.CanExecute> pojawienia się zdarzenia. Jeśli <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwość nie jest ustawiona, element z fokusem klawiatury jest używany jako element docelowy.  
  
 <xref:System.Windows.Input.InputBinding> Sama klasa nie obsługuje użycia XAML, ponieważ nie ujawnia publicznego konstruktora domyślnego (Brak domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą uwidaczniać konstruktora publicznego i w związku z tym można ustawić właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem języka XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding> klasy pochodnej, można wdrożyć w języku XAML, które można ustawić właściwości w języku XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodnej z <xref:System.Windows.Input.InputBinding> składni elementu obiektu, który obsługuje takie jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `bindingToTarget`  
 Ciąg, który korzysta z typu powiązania składnię, która może zwracać odwołanie do obiektu do istniejącej nazwy elementu. Zobacz uwagi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Input.InputBinding.CommandTarget" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Input.InputGesture" /> skojarzony z tym powiązaniem wejściowego.</summary>
        <value>Gest skojarzone. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gest wejściowy jest akcja, która wywołuje polecenie. Przykłady wejściowych gestów w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] są <xref:System.Windows.Input.KeyGesture> i <xref:System.Windows.Input.MouseGesture>. A <xref:System.Windows.Input.KeyGesture> jest kombinacją <xref:System.Windows.Input.Key> i zestaw <xref:System.Windows.Input.ModifierKeys>. A <xref:System.Windows.Input.MouseGesture> jest kombinacją <xref:System.Windows.Input.MouseAction> i zestaw <xref:System.Windows.Input.ModifierKeys>.  
  
 <xref:System.Windows.Input.InputBinding> Sama klasa nie obsługuje użycia XAML, ponieważ nie ujawnia publicznego konstruktora domyślnego (Brak domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą uwidaczniać konstruktora publicznego i w związku z tym można ustawić właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem języka XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding> klasy pochodnej, można wdrożyć w języku XAML, które można ustawić właściwości w języku XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`= "<xref:System.Windows.Input.KeyGesture>" / >  
  
 \- lub -  
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`= "<xref:System.Windows.Input.MouseGesture>" / >  
  
 \- lub -  
  
 <`inputBindingDerivedClass` `Gesture`= "<xref:System.Windows.Input.InputGesture>" / >  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodnej z <xref:System.Windows.Input.InputBinding> składni elementu obiektu, który obsługuje takie jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `inputGestureImplementation`  
 Klasy pochodnej niestandardowego <xref:System.Windows.Input.InputGesture> obsługującej składni elementu obiekt.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Input.KeyBinding> powiązać <xref:System.Windows.Input.KeyGesture> do <xref:System.Windows.Input.RoutedCommand>. Gdy <xref:System.Windows.Input.KeyGesture> wciśnięto ALT + L, <xref:System.Windows.Input.ApplicationCommands.Close%2A> polecenia jest wywoływany.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że wystąpienie zablokowane klonowania określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej właściwości (z systemem innym niż animowane).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że bieżące wystąpienie zablokowane klonowania określonego <see cref="T:System.Windows.Freezable" />. Jeśli obiekt ma właściwości zależności animowany, ich bieżącymi wartościami animowany są kopiowane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
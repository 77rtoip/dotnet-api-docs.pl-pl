<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="afed80ac748380a5fef227ddfb0f18272d0bef07" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53483748" /></Metadata><TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje powiązanie między <see cref="T:System.Windows.Input.InputGesture" /> i polecenia. To polecenie jest potencjalnie <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić, że dane wejściowe użytkownika wywołuje polecenie tworząc <xref:System.Windows.Input.InputBinding>. Gdy użytkownik wykonuje określone dane wejściowe <xref:System.Windows.Input.ICommand> który jest skonfigurowany do <xref:System.Windows.Input.InputBinding.Command%2A> właściwości jest wykonywany.  
  
 Można określić, że <xref:System.Windows.Input.InputBinding> wywołuje polecenie, która jest zdefiniowana na obiekt, tworząc powiązanie na <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, i <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwości. Dzięki temu można zdefiniować niestandardowe polecenie i skojarzyć ją z danymi wejściowymi użytkownika. Aby uzyskać więcej informacji zobacz drugi przykład w sekcji przykładów.  
  
 <xref:System.Windows.Input.InputBinding> Można zdefiniować określonego obiektu lub na poziomie klasy, rejestrując <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> z <xref:System.Windows.Input.CommandManager>.  
  
 <xref:System.Windows.Input.InputBinding> Sama klasa nie obsługuje użycia XAML, ponieważ nie uwidacznia publicznego konstruktora domyślnego (Brak domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą ujawniać Konstruktor publiczny i w związku z tym można ustawić właściwości w klasie pochodnej, która są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding>-klasy pochodne, które mogą być utworzone w XAML i właściwości można ustawić w XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>. Typowe właściwości w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] programowania, to znaczy w ustawach XAML i ma co najmniej jeden <xref:System.Windows.Input.InputBinding> obiektów jako wartości jest <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> właściwości.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Użycie elementu obiektu języka XAML  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodne <xref:System.Windows.Input.InputBinding> , która obsługuje składnię obiektów, takich jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Input.KeyBinding> powiązać <xref:System.Windows.Input.KeyGesture> do <xref:System.Windows.Input.ApplicationCommands.Open%2A> polecenia. Podczas wykonywania kluczowych gestu polecenie Otwórz, zostanie wywołana.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 W poniższych przykładach pokazano, jak powiązać polecenia niestandardowego do <xref:System.Windows.Input.InputBinding> obiektów. Te przykłady tworzenia aplikacji, która umożliwia użytkownikowi zmianę koloru tła, wykonując jedną z następujących czynności:  
  
-   Kliknięcie przycisku.  
  
-   Naciskając klawisze CTRL + C.  
  
-   Kliknij prawym przyciskiem myszy <xref:System.Windows.Controls.StackPanel> (poza <xref:System.Windows.Controls.ListBox>).  
  
 Pierwszy przykład tworzy klasę o nazwie `SimpleDelegateCommand`. Ta klasa akceptuje delegata, tak, aby obiekt Tworzenie polecenia można określić akcję, która występuje, gdy polecenie zostanie wykonane. `SimpleDelegateCommand` definiuje również właściwości, które określają, jakie klucza i myszy dane wejściowe wywołuje polecenie. `GestureKey` i `GestureModifier` Określ klawiatury; `MouseGesture` określono wejście myszy.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 Poniższy przykład tworzy i inicjuje `ColorChangeCommand`, czyli `SimpleDelegateCommand`. W przykładzie zdefiniowano też metodę, która wykonuje, gdy polecenie jest wywoływany i ustawia `GestureKey`, `GestureModifier`, i `MouseGesture` właściwości. Aplikacja może wywołać `InitializeCommand` metody, gdy rozpoczyna się program, takich jak Konstruktor <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Na koniec poniższy przykład tworzy interfejs użytkownika. W przykładzie dodano <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding> do <xref:System.Windows.Controls.StackPanel> zawierający <xref:System.Windows.Controls.Button> i <xref:System.Windows.Controls.ListBox>. Gdy użytkownik wybierze element <xref:System.Windows.Controls.ListBox>, użytkownik można zmienić kolor tła wybranego koloru. W każdym przypadku `CommandParameter` właściwość jest powiązana z wybranym elemencie <xref:System.Windows.Controls.ListBox>i `Command` właściwość jest powiązana z `ColorChangeCommand`. <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, I <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> właściwości są powiązane z odpowiednich właściwości `SimpleDelegateCommand` klasy.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Input.InputBinding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Udostępnia inicjowania podstawowa dla klasy pochodne <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> nie jest technicznie klasę abstrakcyjną, ale domyślny konstruktor jest celowo chronionego dostępu. Ma to wpływ podejmowanie <xref:System.Windows.Input.InputBinding> klasę "abstrakcyjnego" dla XAML. Istnieją istniejących właściwości w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] użycia XAML, które oczekują obiektów tego typu, które mają <xref:System.Windows.Input.InputBinding>, ale nie można określić <xref:System.Windows.Input.InputBinding> wystąpienia w XAML. Zamiast tego można określić jeden z określonych urządzeń <xref:System.Windows.Input.InputBinding> klasy pochodne jako wartości, na przykład <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W przypadku zaimplementowania niestandardowego <see cref="T:System.Windows.Input.InputBinding" /> użycia XAML, która obsługuje, należy użyć tego konstruktora podstawowego inicjowania.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Polecenie, aby skojarzyć z <paramref name="gesture" />.</param>
        <param name="gesture">Wejściowy gestu do skojarzenia z <paramref name="command" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Input.InputBinding" /> klasy przy użyciu określonego polecenia i zdecydować danych wejściowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jesteś programistą przy użyciu istniejących danych wejściowych wiązania klasy, na ogólnie nie będzie używać tego konstruktora, nawet jeśli są Definiowanie niestandardowych poleceń. Zamiast tego albo użyje konstruktory klas pochodnych (<xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>), lub jako podstawowego podczas tworzenia wystąpienia klasy niestandardowej będzie użyć tego konstruktora. Mimo że <xref:System.Windows.Input.InputBinding> klasy obsługuje różne urządzenia wejściowego w zasadzie w praktyce należy wybrać urządzenia, które będzie reprezentować powiązania danych wejściowych. Tylko można ustawić tylko jeden <xref:System.Windows.Input.InputBinding.Gesture%2A> wartość powiązania danych wejściowych i gestów są specyficzne dla urządzenia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć tego konstruktora, aby skojarzyć <xref:System.Windows.Input.KeyGesture> z <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcomand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcomand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" /> lub <paramref name="gesture" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Kopiuje podstawowej (bez animowane) wartości właściwości określonego obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Kopiuje bieżące wartości właściwości określonego obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Input.ICommand" /> skojarzony z tym powiązaniem danych wejściowych.</summary>
        <value>Polecenie skojarzone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> Klasa nie obsługuje użycia XAML, ponieważ nie uwidacznia publicznego konstruktora domyślnego (ma domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą ujawniać Konstruktor publiczny i w związku z tym, można użyć właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding>. Dwa istniejące <xref:System.Windows.Input.InputBinding> klasy pochodne mogą być utworzone w XAML, które można ustawić właściwości z użycia XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> odwołuje się do konwerter typu, który umożliwia pewne istniejący wcześniej <xref:System.Windows.Input.ICommand> implementacji, aby określić wartości w postaci ciągu. To zachowanie konwersji typu Ustawia atrybut formularza wartość tej właściwości. Możesz również powiązać <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, i <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwości <xref:System.Windows.Input.ICommand> zdefiniowanego w obiekcie. Dzięki temu można zdefiniować niestandardowe polecenie i skojarzyć ją z danymi wejściowymi użytkownika. Aby uzyskać więcej informacji, zobacz drugi przykład w <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 <`inputBindingDerivedClass` `Command`= "<xref:System.Windows.Input.ICommand>" / >  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodne <xref:System.Windows.Input.InputBinding> , która obsługuje składnię obiektów, takich jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `iCommandImplementation`  
 Implementacja obiektu <xref:System.Windows.Input.ICommand> , która obsługuje składnia elementu obiektu (nie ma publicznego konstruktora domyślnego).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Input.KeyBinding> powiązać <xref:System.Windows.Input.KeyGesture> do <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> polecenia. Podczas wykonywania kluczowych gestu polecenie Otwórz, zostanie wywołana.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Input.InputBinding.Command" /> Wartość <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dane specyficzne dla polecenia dotyczącą danego polecenia.</summary>
        <value>Dane specyficzne dla danego polecenia. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding.CommandParameter%2A> Właściwość jest używana do przekazania do polecenia szczegółowe informacje, gdy jest wykonywany. Typ danych jest definiowany przez polecenie. Wiele poleceń nie oczekuje parametrów polecenia; dla tych poleceń wszystkie parametry polecenia przekazywane będą ignorowane.  
  
 Czy polecenie, które powiązania danych wejściowych usługi skojarzono z <xref:System.Windows.Input.RoutedCommand>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A> powiązania danych wejściowych jest przekazywany do <xref:System.Windows.Input.RoutedCommand> obsługi za pomocą <xref:System.Windows.Input.ExecutedRoutedEventArgs> i <xref:System.Windows.Input.CanExecuteRoutedEventArgs> danych zdarzenia podczas przetwarzania polecenia.  
  
 Typ danych i celem parametr polecenia są zdefiniowane w różny sposób dla każdego polecenia i może być `null`. Możesz powiązać <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, i <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwości <xref:System.Windows.Input.ICommand> zdefiniowanego w obiekcie. Dzięki temu można zdefiniować niestandardowe polecenie i skojarzyć ją z danymi wejściowymi użytkownika. Aby uzyskać więcej informacji, zobacz drugi przykład w <xref:System.Windows.Input.InputBinding>.  
  
 <xref:System.Windows.Input.InputBinding> Klasa nie obsługuje użycia XAML, ponieważ nie uwidacznia publicznego konstruktora domyślnego (ma domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą ujawniać Konstruktor publiczny i w związku z tym, można ustawić właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding> klas pochodnych, które mogą być utworzone w XAML i właściwości można ustawić w XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodne <xref:System.Windows.Input.InputBinding> , która obsługuje składnię obiektów, takich jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `commandParameterString`  
 Ciąg, który jest przetwarzany przez określonego polecenia. Ciągi są wspólny typ używany do parametrów polecenia, ponieważ można je łatwo skonfigurować w XAML. Dla formatu oczekiwany ciąg i jego przeznaczenie zobacz dokumentację dla określonego polecenia, które powiązania danych wejściowych jest skojarzona z. Wiele poleceń nie powinna mieć parametrów.  
  
 `commandParameterObject`  
 Obiekt, który jest przetwarzany przez określonego polecenia. Wszystkie istniejące [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] polecenia użyć ciągów. W związku z tym ta składnia elementu właściwości ma zastosowanie tylko w scenariuszach polecenie niestandardowe. Aby można było obsługuje tej składni `commandParameterObject` obiektu również musi obsługiwać składnia elementu obiektu (musi mieć publicznego konstruktora domyślnego).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Input.InputBinding.CommandParameter" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Input.InputBinding.Command" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element docelowy polecenia.</summary>
        <value>Obiekt docelowy polecenia. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie Windows Presentation Foundation, polecenia systemowe <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwość <xref:System.Windows.Input.ICommandSource> obiekt jest stosowane tylko wtedy, gdy <xref:System.Windows.Input.ICommand> jest <xref:System.Windows.Input.RoutedCommand>. Jeśli <xref:System.Windows.Input.InputBinding.CommandTarget%2A> jest ustawiona na <xref:System.Windows.Input.ICommandSource> i odpowiednie polecenie nie jest <xref:System.Windows.Input.RoutedCommand>, jest ignorowana w elemencie docelowym polecenia.  
  
 Gdy jest używane z <xref:System.Windows.Input.RoutedCommand>, element docelowy polecenia jest obiekt, dla którego <xref:System.Windows.Input.CommandManager.Executed> i <xref:System.Windows.Input.CommandManager.CanExecute> zdarzenia są wywoływane. Jeśli <xref:System.Windows.Input.InputBinding.CommandTarget%2A> właściwość nie jest ustawiona, element z fokusem klawiatury jest używany jako element docelowy.  
  
 <xref:System.Windows.Input.InputBinding> Sama klasa nie obsługuje użycia XAML, ponieważ nie uwidacznia publicznego konstruktora domyślnego (Brak domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą ujawniać Konstruktor publiczny i w związku z tym można ustawić właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding> klas pochodnych, które mogą być utworzone w XAML i właściwości można ustawić w XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodne <xref:System.Windows.Input.InputBinding> , która obsługuje składnię obiektów, takich jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `bindingToTarget`  
 Ciąg, który korzysta z typu składnia powiązania, który może zwrócić odwołanie do obiektu do istniejącej nazwy elementu. Zobacz uwagi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Input.InputBinding.CommandTarget" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <returns>Nowy obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Input.InputGesture" /> skojarzony z tym powiązaniem danych wejściowych.</summary>
        <value>Gest skojarzone. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gest danych wejściowych jest akcja, która wywołuje polecenie. Przykłady danych wejściowych gestów w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] są <xref:System.Windows.Input.KeyGesture> i <xref:System.Windows.Input.MouseGesture>. A <xref:System.Windows.Input.KeyGesture> jest kombinacją <xref:System.Windows.Input.Key> oraz zestaw <xref:System.Windows.Input.ModifierKeys>. A <xref:System.Windows.Input.MouseGesture> jest kombinacją <xref:System.Windows.Input.MouseAction> oraz zestaw <xref:System.Windows.Input.ModifierKeys>.  
  
 <xref:System.Windows.Input.InputBinding> Sama klasa nie obsługuje użycia XAML, ponieważ nie uwidacznia publicznego konstruktora domyślnego (Brak domyślnego konstruktora, ale jest on chroniony). Jednak klasy pochodne mogą ujawniać Konstruktor publiczny i związku z tym można ustawić właściwości, które są dziedziczone z <xref:System.Windows.Input.InputBinding> z użyciem XAML. Dwa istniejące <xref:System.Windows.Input.InputBinding> klas pochodnych, które mogą być utworzone w XAML i właściwości można ustawić w XAML są <xref:System.Windows.Input.KeyBinding> i <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`= "<xref:System.Windows.Input.KeyGesture>" / >  
  
—lub—
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`= "<xref:System.Windows.Input.MouseGesture>" / >  
  
—lub—
  
 <`inputBindingDerivedClass` `Gesture`= "<xref:System.Windows.Input.InputGesture>" / >  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 `inputBindingDerivedClass`  
 Klasy pochodne <xref:System.Windows.Input.InputBinding> , która obsługuje składnię obiektów, takich jak <xref:System.Windows.Input.KeyBinding> lub <xref:System.Windows.Input.MouseBinding>. Zobacz uwagi.  
  
 `inputGestureImplementation`  
 Niestandardowy pochodne klasy <xref:System.Windows.Input.InputGesture> , która obsługuje składnię obiektów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Input.KeyBinding> powiązać <xref:System.Windows.Input.KeyGesture> do <xref:System.Windows.Input.RoutedCommand>. Gdy <xref:System.Windows.Input.KeyGesture> wciśnięto ALT + L, <xref:System.Windows.Input.ApplicationCommands.Close%2A> wywoływania polecenia.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" /> przy użyciu wartości podstawowej (bez animowane) właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Obiekt do klonowania.</param>
        <summary>Sprawia, że bieżące wystąpienie zamrożone klonowania określonego <see cref="T:System.Windows.Freezable" />. Jeśli obiekt ma właściwości animowany zależności, są kopiowane ich bieżącymi wartościami animowany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
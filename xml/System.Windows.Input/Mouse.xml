<Type Name="Mouse" FullName="System.Windows.Input.Mouse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ec3e1064dcc20597ae43c5eaa793a33bb0a8161" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39877757" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Mouse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Mouse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Mouse" />
  <TypeSignature Language="VB.NET" Value="Public Class Mouse" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mouse abstract sealed" />
  <TypeSignature Language="F#" Value="type Mouse = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje urządzenie myszy do określonego wątku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.Mouse> Klasa udostępnia myszy zdarzenia związane z, metody i właściwości, które zawierają informacje dotyczące stanu myszy.  
  
 Każde zdarzenie, <xref:System.Windows.Input.Mouse> definiuje jako dołączone zdarzenie jest również ponownie narażona jest klasy bazowej elementów <xref:System.Windows.UIElement> i <xref:System.Windows.ContentElement> jako nowe zdarzenia trasowanego. Ogólnie rzecz biorąc, jest bardziej wygodne do obsługi zdarzeń myszy dla aplikacji na <xref:System.Windows.UIElement> i <xref:System.Windows.ContentElement>, zamiast używania <xref:System.Windows.Input.Mouse> zdarzenia. Aby uzyskać więcej informacji, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Statyczne elementy członkowskie <xref:System.Windows.Input.Mouse> klasy delegata do podstawowej <xref:System.Windows.Input.MouseDevice> Menedżera danych wejściowych wątku wywołującego.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.MouseDown" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.MouseMove" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.MouseUp" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void AddQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Dodaje program obsługi <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Capture">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przechwytuje dane wejściowe myszy określony element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wejście myszy czy kursor znajduje się w jego granicach.  
  
 Jeśli <xref:System.Windows.Input.CaptureMode> nie zostanie określony, domyślnie <xref:System.Windows.Input.CaptureMode> jest <xref:System.Windows.Input.CaptureMode.Element>.  
  
 Aby zwolnić przechwytywanie myszy, należy wywołać <xref:System.Windows.Input.Mouse.Capture%2A> przekazywanie `null` jako element do przechwytywania.  
  
 Jeśli przycisk myszy jest przechwytywane podczas <xref:System.Windows.Input.Mouse.MouseDown> lub <xref:System.Windows.Input.Mouse.MouseUp> zdarzenie jest zgłaszane i nie ma danych wejściowych do elementu poniżej mysz, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> i <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> są inicjowane jako pierwsze.  Dzięki temu przechwyconych element szansę, aby zwolnić Przechwytywanie przed <xref:System.Windows.Input.Mouse.MouseDown> i <xref:System.Windows.Input.Mouse.MouseUp> są kierowane zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement -&gt; bool" Usage="System.Windows.Input.Mouse.Capture element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Element do przechwytywania myszą.</param>
        <summary>Przechwytuje dane wejściowe myszy określony element.</summary>
        <returns>
          <see langword="true" /> Jeśli element był w stanie przechwytywania myszy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wejście myszy czy kursor znajduje się w jego granicach.  
  
 Jeśli <xref:System.Windows.Input.CaptureMode> nie zostanie określony, domyślnie <xref:System.Windows.Input.CaptureMode> jest <xref:System.Windows.Input.CaptureMode.Element>.  
  
 Aby zwolnić przechwytywanie myszy, należy wywołać <xref:System.Windows.Input.Mouse.Capture%2A> przekazywanie `null` jako element do przechwytywania.  
  
 Jeśli przycisk myszy jest przechwytywane podczas <xref:System.Windows.Input.Mouse.MouseDown> lub <xref:System.Windows.Input.Mouse.MouseUp> zdarzenie jest zgłaszane i nie ma danych wejściowych do elementu poniżej mysz, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> i <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> są inicjowane jako pierwsze.  Dzięki temu przechwyconych element szansę, aby zwolnić Przechwytywanie przed <xref:System.Windows.Input.Mouse.MouseDown> i <xref:System.Windows.Input.Mouse.MouseUp> są kierowane zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przechwytywanie myszy do określonego elementu za pomocą <xref:System.Windows.Input.Mouse.Capture%2A> metody.  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element, System.Windows.Input.CaptureMode captureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element, valuetype System.Windows.Input.CaptureMode captureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement,System.Windows.Input.CaptureMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element, System::Windows::Input::CaptureMode captureMode);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement * System.Windows.Input.CaptureMode -&gt; bool" Usage="System.Windows.Input.Mouse.Capture (element, captureMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="captureMode" Type="System.Windows.Input.CaptureMode" />
      </Parameters>
      <Docs>
        <param name="element">Element do przechwytywania myszą.</param>
        <param name="captureMode">Zasady przechwytywania do użycia.</param>
        <summary>Przechwytuje dane wejściowe myszy określony element przy użyciu określonego <see cref="T:System.Windows.Input.CaptureMode" />.</summary>
        <returns>
          <see langword="true" /> Jeśli element był w stanie przechwytywania myszy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wejście myszy czy kursor znajduje się w jego granicach.  
  
 Aby zwolnić przechwytywanie myszy, należy wywołać <xref:System.Windows.Input.Mouse.Capture%2A> przekazywanie `null` jako element do przechwytywania.  
  
 Jeśli przycisk myszy jest przechwytywane podczas <xref:System.Windows.Input.Mouse.MouseDown> lub <xref:System.Windows.Input.Mouse.MouseUp> zdarzenie jest zgłaszane i nie ma danych wejściowych do elementu poniżej mysz, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> i <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> są inicjowane jako pierwsze.  Dzięki temu przechwyconych element szansę, aby zwolnić Przechwytywanie przed <xref:System.Windows.Input.Mouse.MouseDown> i <xref:System.Windows.Input.Mouse.MouseUp> są kierowane zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przechwytywanie myszy do określonego elementu za pomocą <xref:System.Windows.Input.Mouse.Capture%2A> metody.  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Captured">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Captured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement Captured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.Captured" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Captured As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ Captured { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Captured : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.Captured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, który został przechwycony myszy.</summary>
        <value>Element przechwycone przy użyciu myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wejście myszy czy kursor znajduje się w jego granicach. Mysz są zazwyczaj przechwytywane w ten sposób tylko podczas operacji przeciągania i upuszczania oraz zachowuje przechwytywania, dopóki nie wystąpi akcja upuszczania operacji przeciągania i upuszczania.  
  
   
  
## Examples  
 W przykładzie poniżej pokazano, jak można uzyskać elementu, który ma przechwytywanie myszy.  
  
 [!code-csharp[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecapturemousecaptured)]
 [!code-vb[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecapturemousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyOver">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement DirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement DirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.DirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DirectlyOver As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ DirectlyOver { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectlyOver : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.DirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, którego wskaźnik myszy znajduje się bezpośrednio za pośrednictwem.</summary>
        <value>Element wskaźnik myszy znajduje się nad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formanty może składać się z wielu elementów. <xref:System.Windows.Input.Mouse.DirectlyOver%2A> Raporty określonego elementu złożonego formantu, który znajduje się wskaźnik myszy nad i nie formantu. Na przykład, w zależności od część <xref:System.Windows.Controls.Button> wskaźnik znajduje się nad, <xref:System.Windows.Input.Mouse.DirectlyOver%2A> właściwości można raportować <xref:System.Windows.Controls.TextBox> z <xref:System.Windows.Controls.ContentControl.Content%2A> właściwości lub <xref:Microsoft.Windows.Themes.ButtonChrome>.  
  
 Użyj <xref:System.Windows.IInputElement.IsMouseOver%2A> właściwość <xref:System.Windows.UIElement> i <xref:System.Windows.ContentElement> ustalić, czy wskaźnik myszy nad elementem, w tym jego elementy podrzędne visual lub kontroluje elementy, składania.  
  
 Jeśli element ma przechwytywanie myszy, wskaźnik myszy jest uważany za bezpośrednio nad elementem niezależnie od tego, gdzie jest wskaźnikiem myszy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseOver" />
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="GetIntermediatePoints">
      <MemberSignature Language="C#" Value="public static int GetIntermediatePoints (System.Windows.IInputElement relativeTo, System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetIntermediatePoints(class System.Windows.IInputElement relativeTo, valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetIntermediatePoints(System.Windows.IInputElement,System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIntermediatePoints (relativeTo As IInputElement, points As Point()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetIntermediatePoints(System::Windows::IInputElement ^ relativeTo, cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="static member GetIntermediatePoints : System.Windows.IInputElement * System.Windows.Point[] -&gt; int" Usage="System.Windows.Input.Mouse.GetIntermediatePoints (relativeTo, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Elementy <c>punktów</c> są w odniesieniu do.</param>
        <param name="points">Tablica obiektów.</param>
        <summary>Pobiera maksymalnie 64 poprzedniego współrzędne wskaźnika myszy od czasu ostatniego myszy przesuń zdarzeń.</summary>
        <returns>Liczba punktów jest zwracana.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point GetPosition (System.Windows.IInputElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point GetPosition(class System.Windows.IInputElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetPosition(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPosition (relativeTo As IInputElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point GetPosition(System::Windows::IInputElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="static member GetPosition : System.Windows.IInputElement -&gt; System.Windows.Point" Usage="System.Windows.Input.Mouse.GetPosition relativeTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Przestrzeni współrzędnych, którego chcesz obliczyć położenie kursora myszy.</param>
        <summary>Pobiera położenie kursora myszy względem określonego elementu.</summary>
        <returns>Położenie kursora myszy względem parametru <paramref name="relativeTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja wskaźnik myszy jest obliczana względem określonego elementu za pomocą lewego górnego rogu elementu jest punkt początkowy, od 0,0.  
  
 Podczas operacji przeciągania i upuszczania, położenie kursora myszy nie można niezawodnie ustalić za pośrednictwem <xref:System.Windows.Input.Mouse.GetPosition%2A>. Jest to spowodowane kontrolę nad myszy (ewentualnie w tym przechwytywania) są przechowywane przez element źródłowy przeciągania, aż do zakończenia listy o wiele zachowanie kontrolowane przez bazowe [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] wywołania. Zamiast tego spróbuj następujących metod:  
  
-   Wywołaj <xref:System.Windows.DragEventArgs.GetPosition%2A> metody <xref:System.Windows.DragEventArgs> przekazana do zdarzenia przeciągania (<xref:System.Windows.ContentElement.DragEnter>, <xref:System.Windows.ContentElement.DragOver>, <xref:System.Windows.ContentElement.DragLeave>).  
  
-   Wywołaj [GetCursorPos](http://msdn.microsoft.com/library/default.asp?url=/library/winui/winui/windowsuserinterface/resources/cursors/cursorreference/cursorfunctions/getcursorpos.asp), przy użyciu metody P/Invoke.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Input.Mouse.GetPosition%2A> do określenia pozycji wskaźnika myszy.  Pozycja wskaźnik myszy znajduje się w <xref:System.Windows.Point> struktury.  <xref:System.Windows.Point.X%2A> i <xref:System.Windows.Point.Y%2A> wartości <xref:System.Windows.Point> obiektu są wyświetlane w <xref:System.Windows.Controls.TextBox>.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetspositionmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetspositionmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.MouseEventArgs.GetPosition(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" Usage="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy element przechwytuje mysz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wejście myszy czy kursor znajduje się w jego granicach.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Ze względu na propagacji routingu rzeczywisty element, który ma przechwytywania może być elementu podrzędnego, nie musi to być element, gdzie program obsługi zdarzeń jest faktycznie dołączony. Sprawdź <xref:System.Windows.RoutedEventArgs.Source%2A> w przypadku przechwytywania argumenty, aby określić rzeczywisty element, który ma myszy.  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.GotMouseCaptureEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Nie ma żadnego zdefiniowanych odpowiednie zdarzenia tunelowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState LeftButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState LeftButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.LeftButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LeftButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState LeftButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.LeftButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.LeftButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan lewego przycisku myszy.</summary>
        <value>Stan lewego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy lewy przycisk myszy jest wciśnięty przez sprawdzenie, czy stan <xref:System.Windows.Input.Mouse.LeftButton%2A> jest równa <xref:System.Windows.Input.MouseButtonState> wartość wyliczenia <xref:System.Windows.Input.MouseButtonState.Pressed>.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, które aktualizacje są wyświetlane elementy w próbce.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" Usage="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po utracie przechwycenia myszy przez element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wejście myszy czy kursor znajduje się w jego granicach. T  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Ze względu na propagacji routingu rzeczywiste element, który utraty przechwytywania może być elementu podrzędnego, nie musi to być element, gdzie program obsługi zdarzeń jest faktycznie dołączony. Sprawdź <xref:System.Windows.RoutedEventArgs.Source%2A> argumenty zdarzeń, aby określić rzeczywisty element, który utraty przechwytywania.  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.LostMouseCaptureEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Nie ma żadnego zdefiniowanych odpowiednie zdarzenia tunelowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MiddleButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState MiddleButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState MiddleButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.MiddleButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MiddleButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState MiddleButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.MiddleButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.MiddleButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan środkowy przycisk myszy.</summary>
        <value>Stan środkowego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy środkowy przycisk myszy jest wciśnięty przez sprawdzenie, czy stan <xref:System.Windows.Input.Mouse.MiddleButton%2A> jest równa <xref:System.Windows.Input.MouseButtonState> wartość wyliczenia <xref:System.Windows.Input.MouseButtonState.Pressed>.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, które aktualizacje są wyświetlane elementy w próbce.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetmiddlebuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetmiddlebuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" Usage="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy dowolnego przycisku myszy jest wciśnięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, które przycisk myszy został wciśnięty, należy sprawdzić <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A> właściwość <xref:System.Windows.Input.MouseButtonEventArgs> przekazane do narzędzia obsługi.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework opiera się na tym dołączone zdarzenie, dzięki czemu są ujawniane ją jako dwa różne [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] zdarzenia <xref:System.Windows.UIElement> i <xref:System.Windows.ContentElement>: <xref:System.Windows.UIElement.MouseLeftButtonDown> i <xref:System.Windows.UIElement.MouseRightButtonDown>. Tych implementacji obsługi podstawowych <xref:System.Windows.Input.Mouse.MouseDown> zdarzeń i przeczytać argumenty zdarzenia w celu określenia, czy przycisk myszy w lewo lub w prawo brał udział. Myszy trzy przyciski Brak obsługi zdarzeń na poziomie struktury dla środkowy przycisk. Należy używać <xref:System.Windows.Input.Mouse.MouseDown> zdarzeń i sprawdź <xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A> stanie w przypadku argumentów.  
  
> [!IMPORTANT]
>  Kilka <xref:System.Windows.ContentElement> pochodnych klas, które mają podobne do kontroli zachowania, na przykład <xref:System.Windows.Documents.Hyperlink>, może być zarezerwowanymi obsługę klasy dla zdarzenia przycisku myszy. Lewy przycisk myszy wciśnięty zdarzeń jest najbardziej prawdopodobne zdarzenie, aby mieć klasę, obsługa w formancie. Klasy obsługi często oznacza bazowego <xref:System.Windows.Input.Mouse> zdarzenia klasy jako obsługiwane. Gdy zdarzenie jest oznaczony jako obsługiwany, innych programów obsługi wystąpienia, które są dołączone do tego elementu nie są zwykle zgłaszane. Wszystkie inne klasy lub wystąpienia programów obsługi, które są dołączone do elementów w propagacji kierunku ku główny w drzewie interfejsu użytkownika również nie zazwyczaj są wywoływane.  
  
 Możesz rozwiązać ten problem, który jest opisany w poprzednim ważna uwaga i nadal otrzymywać <xref:System.Windows.UIElement.MouseDown> zdarzeń związanych z lewego przycisku myszy w dół do zdarzenia w klasie pochodnej, która ma klasę obsługi przy użyciu jednej z tych rozwiązań:  
  
-   Dołącz programy obsługi dla <xref:System.Windows.UIElement.PreviewMouseDown> zdarzenie, które nie jest oznaczony jako obsługiwane przez formanty. Zwróć uwagę, że ponieważ jest to zdarzenie (wersja zapoznawcza), trasy rozpoczyna się w katalogu głównym i tunele do formantu.  
  
-   Rejestrowanie programu obsługi w kontrolce proceduralnie przez wywołanie metody <xref:System.Windows.UIElement.AddHandler%2A> i wybranie opcji podpisu, która umożliwia obsługi do nasłuchiwania zdarzeń nawet wtedy, gdy są one już oznaczone jako obsługiwane w danych zdarzenia trasowanego.  
  
 Dla zdarzenia trasowane, które odnoszą się do przycisku myszy należy zachować ostrożność sposób lub czas oznaczeniu ich obsługi. Trudności w podejmowaniu właściwych wyborów dotyczących tego, czy elementy nadrzędne powinien również zostać poinformowany o podanej akcji myszy jest w rzeczywistości Dlaczego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework wybrany model o bazowe zdarzenie myszy kierowane być udostępniane jako [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia wzdłuż trasy. Istnieją podobne problemy z tunelowaniem zdarzeń myszy.  Należy można obsłużyć zdarzenie, jak i jest realizowany przez dodatkowe elementy podrzędne w kierunku źródła i jak będzie tym składania mogą wpłynąć na kontrolkę, której elementy składania może oczekiwać myszy zachowania?  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseDownEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Odpowiednie zdarzenie tunelowania jest <xref:System.Windows.Input.Mouse.PreviewMouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.MouseDown" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="F#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" Usage="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po wejściu wskaźnika myszy w granice tego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie używa bezpośredniej obsługi strategii routingu zdarzeń. Zdarzenia trasowane bezpośrednie nie są zgłaszane wraz trasę (są tylko obsługiwane w przypadku tego samego elementu, na którym są one inicjowane).  Pozwalają natomiast inne aspekty zdarzenia trasowanego zachowań, takich jak wyzwalacze zdarzeń w stylach.  
  
 Mimo że to zdarzenie służy do śledzenia gdy wskaźnik myszy zostanie przesunięty elementu, jest także raportowanie <xref:System.Windows.UIElement.IsMouseOver%2A> właściwości została zmieniona z `false` do `true` w tym elemencie.  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseEnterEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" Usage="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po opuszczeniu granic elementu przez wskaźnik myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie używa bezpośredniej obsługi strategii routingu zdarzeń. Zdarzenia trasowane bezpośrednie nie wykonuj trasę (są tylko obsługiwane w przypadku tego samego elementu, na którym są one inicjowane).  Pozwalają natomiast inne aspekty zdarzenia trasowanego zachowań, takich jak wyzwalacze zdarzeń w stylach.  
  
 Mimo że to zdarzenie jest używane do śledzenia, gdy wskaźnik myszy opuszcza elementu, również zgłaszane jest który <xref:System.Windows.UIElement.IsMouseOver%2A> wartość właściwości została zmieniona z `true` do `false` w tym elemencie.  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseLeaveEvent>|  
|Strategii routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" Usage="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po przemieszczeniu wskaźnika myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseMoveEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Odpowiednie zdarzenie tunelowania jest <xref:System.Windows.Input.Mouse.PreviewMouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.MouseMove" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" Usage="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po zwolnieniu dowolnego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przycisk myszy, która została wydana jest określany przez sprawdzenie argumenty zdarzenia.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework opiera się na tym dołączone zdarzenie, dzięki czemu są ujawniane ją jako dwa różne [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] zdarzenia <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.MouseLeftButtonUp> i <xref:System.Windows.UIElement.MouseRightButtonUp>. Tych implementacji obsługi podstawowych <xref:System.Windows.Input.Mouse.MouseUp> zdarzeń i przeczytać argumenty zdarzenia w celu określenia, czy przycisk myszy w lewo lub w prawo brał udział. Dla trzy przyciski to Brak obsługi zdarzeń na poziomie struktury środkowy przycisk i należy używać <xref:System.Windows.Input.Mouse.MouseUp> zdarzeń i wyszukaj środkowy przycisk warunku w przypadku argumentów.  
  
 Dla zdarzenia trasowane, które odnoszą się do przycisku myszy należy zachować ostrożność sposób lub czas oznaczeniu ich obsługi. Trudności w podejmowaniu właściwych wyborów dotyczących tego, czy elementy nadrzędne powinien również zostać poinformowany o podanej akcji myszy jest w rzeczywistości Dlaczego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework wybrany model mających podstawowe <xref:System.Windows.Input.Mouse> udostępnić zdarzenia trasowanego jako [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia całego trasy.  
  
 Istnieją podobne problemy z tunelowaniem zdarzeń myszy.  Powinien się obsługi zdarzeń ma on zostać obsłużone przez elementy podrzędne w dalszych kierunku źródła i jak będzie tym składania wpływ w kontrolce, gdzie może oczekiwać elementy składania myszy zachowania?  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseUpEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 Odpowiednie zdarzenie tunelowania jest <xref:System.Windows.Input.Mouse.PreviewMouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.MouseUp" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" Usage="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy jest obracana kółka myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zespół lub myszy przechwytywania pierwszeństwo gdy wskaźnik myszy znajduje się.  Jeśli pojawi się to zdarzenie od elementu wąsko zdefiniowany lub przechwycone, wskaźnik myszy w rzeczywistości może być za pośrednictwem innego elementu w czasie.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseWheelEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Odpowiednie zdarzenie tunelowania jest <xref:System.Windows.Input.Mouse.PreviewMouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelDeltaForOneLine">
      <MemberSignature Language="C#" Value="public const int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MouseWheelDeltaForOneLine = (120)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberSignature Language="VB.NET" Value="Public Const MouseWheelDeltaForOneLine As Integer  = 120" />
      <MemberSignature Language="C++ CLI" Value="public: int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="F#" Value="val mutable MouseWheelDeltaForOneLine : int" Usage="System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>120</MemberValue>
      <Docs>
        <summary>Reprezentuje liczbę jednostek obraca się obrót kółkiem myszy do przewijania jeden wiersz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W bieżącym [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)], wartość tego pola to 120. Ujawnienia pola jest umożliwienie dostawcom do tworzenia bardziej precyzyjną rozpoznawania myszy z kółkiem w przyszłości, które może dołączyć za darmo rotacji kółka bez pozycje. Oczekuje się, że takie urządzenie prześle więcej wiadomości na rotacji, ale z mniejszą wartość w każdej wiadomości. Aby zapewnić obsługę tej możliwości, należy albo dodać wartości delta przychodzących do momentu <xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine> osiągnięciu kwotę (dzięki czemu możesz uzyskać tę samą odpowiedź rotację delta) lub przewiń częściowe wierszy w odpowiedzi na komunikaty częściej. Można również wybrać własne szczegółowości przewijania i kumulują się różnic, wybranej przez użytkownika, dopóki tej różnicowej zostanie osiągnięty, lub być może odwoływać się do kontrolowania użytkownika systemu parametrów czułości myszy i ekstrapolację tych progów delta kółka myszy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseWheelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideCursor">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.Cursor OverrideCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.Cursor OverrideCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.OverrideCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OverrideCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::Cursor ^ OverrideCursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OverrideCursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.Input.Mouse.OverrideCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor dla całej aplikacji.</summary>
        <value>Kursor zastąpienia lub <see langword="null" /> Jeśli <see cref="P:System.Windows.Input.Mouse.OverrideCursor" /> nie jest ustawiona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.Cursor> , <xref:System.Windows.Input.Mouse.OverrideCursor%2A> Jest ustawiona na będą stosowane do całej aplikacji.  
  
 Aby wyczyścić zastąpienie <xref:System.Windows.Input.Cursor>ustaw <xref:System.Windows.Input.Mouse.OverrideCursor%2A> do `null`.  
  
 Ustawienie <xref:System.Windows.Input.Mouse.OverrideCursor%2A> do <xref:System.Windows.Input.Cursors.None%2A> wymusi kursora myszy, które nie mają być wyświetlane, ale zdarzenia myszy są nadal przetwarzane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano program obsługi zdarzeń dla <xref:System.Windows.Controls.RadioButton> umożliwiający przełączanie zakres zmianę kursora między pojedynczego elementu i całej aplikacji.  Jeśli formant, który podniósł zdarzenie jest `rbScopeElement` <xref:System.Windows.Controls.RadioButton>, jest ustawiona flaga, która oznacza zakresu zmian kursora i <xref:System.Windows.Input.Mouse.OverrideCursor%2A> ustawiono `null`.  Jeśli formant, który podniósł zdarzenie jest `rbScopeApplication` <xref:System.Windows.Controls.RadioButton>, jest ustawiona flaga, która oznacza zakresu zmian kursora i <xref:System.Windows.Input.Mouse.OverrideCursor%2A> ustawiono <xref:System.Windows.FrameworkElement.Cursor%2A> właściwość <xref:System.Windows.Controls.Border> formantu o nazwie `DisplayArea`.  
  
 [!code-csharp[cursors#CursorsSampleOverrideCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#cursorssampleoverridecursor)]
 [!code-vb[cursors#CursorsSampleOverrideCursor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#cursorssampleoverridecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" Usage="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy dowolnego przycisku myszy jest wciśnięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przycisk myszy, który został wciśnięty jest określany przez sprawdzenie argumenty zdarzenia. Jest to dołączone zdarzenie (przy użyciu tunelowania strategii routingu) zamierzony za pomocą składni dołączone zdarzenie być przywoływane przez istniejące [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementy, które pobierać dane wejściowe.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework opiera się na tym dołączone zdarzenie, dzięki czemu są ujawniane ją jako dwa różne [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] zdarzenia <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> i <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>. Tych implementacji obsługi podstawowych <xref:System.Windows.Input.Mouse.PreviewMouseDown> zdarzeń i przeczytać argumenty zdarzenia w celu określenia, czy przycisk myszy w lewo lub w prawo brał udział. Dla trzy przyciski to Brak obsługi zdarzeń na poziomie struktury środkowy przycisk i należy używać <xref:System.Windows.Input.Mouse.PreviewMouseDown> zdarzeń i wyszukaj środkowy przycisk warunku w przypadku argumentów.  
  
 Dla zdarzenia trasowane, które odnoszą się do przycisku myszy należy zachować ostrożność sposób lub czas oznaczeniu ich obsługi. Obsługa zdarzeń w folderze głównym i obsługiwania go przez element podrzędny, dodatkowo do źródła może nie być odpowiednie dla formanty złożone, gdzie elementy składania może mieć spodziewanych zachowań myszy. Trudności w podejmowaniu właściwych wyborów dotyczących tego, czy inne elementy powinien również zostać poinformowany o podanej akcji myszy jest w rzeczywistości Dlaczego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework wybrany model mających podstawowe <xref:System.Windows.Input.Mouse> udostępnić zdarzenia trasowanego jako [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia wzdłuż trasy.  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseDownEvent>|  
|Strategii routingu|Tunelowanie|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   To odpowiednie zdarzenie propagacji <xref:System.Windows.Input.Mouse.MouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" Usage="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy główny przycisk myszy jest wciśnięty poza elementem, który jest Przechwytywanie zdarzeń myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie nie jest resurfaced podstawowych elementów. Jest to głównie dotyczą autorom kontroli, próbujących w taki sposób, aby uzgodnić przechwytywanie myszy i wprowadzanie w ramach ich składania sterowania za pomocą myszy.  
  
<a name="routedEventInfo_PreviewMouseDownOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent>|  
|Strategii routingu|Tunelowanie|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" Usage="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy nad elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje zarówno w przypadku nowo przesunięciu wskaźnika myszy w granice elementu, a także gdy wskaźnik myszy porusza się nadal zachowując granice elementu jednocześnie.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseMoveEvent>|  
|Strategii routingu|Tunelowanie|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   To odpowiednie zdarzenie propagacji <xref:System.Windows.Input.Mouse.MouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" Usage="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po zwolnieniu dowolnego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przycisk myszy, która została wydana jest określany przez sprawdzenie argumenty zdarzenia.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework opiera się na tym dołączone zdarzenie, dzięki czemu są ujawniane ją jako dwa różne [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] zdarzenia <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> i <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>. Tych implementacji obsługi podstawowych <xref:System.Windows.Input.Mouse.PreviewMouseUp> zdarzeń i przeczytać argumenty zdarzenia w celu określenia, czy przycisk myszy w lewo lub w prawo brał udział. Dla trzy przyciski to Brak obsługi zdarzeń na poziomie struktury środkowy przycisk i należy używać <xref:System.Windows.Input.Mouse.PreviewMouseUp> zdarzeń i wyszukaj środkowy przycisk warunku w przypadku argumentów.  
  
 Dla zdarzenia trasowane, które odnoszą się do przycisku myszy należy zachować ostrożność sposób lub czas oznaczeniu ich obsługi. Obsługa zdarzeń w katalogu głównym i braku obsługi przez element podrzędny dalsze kierunku źródła może nie być odpowiednie dla formanty złożone, gdzie elementy składania może mieć spodziewanych zachowań myszy. Trudności w podejmowaniu właściwych wyborów dotyczących tego, czy inne elementy powinien również zostać poinformowany o podanej akcji myszy jest w rzeczywistości Dlaczego [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework wybrany model mających podstawowe <xref:System.Windows.Input.Mouse> udostępnić zdarzenia trasowanego jako [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia wzdłuż trasy.  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseUpEvent>|  
|Strategii routingu|Tunelowanie|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   To odpowiednie zdarzenie propagacji <xref:System.Windows.Input.Mouse.MouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" Usage="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po zwolnieniu przycisku myszy głównej poza elementem, który jest Przechwytywanie zdarzeń myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie nie jest resurfaced podstawowych elementów. Jest to głównie dotyczą autorom kontroli, próbujących w taki sposób, aby uzgodnić przechwytywanie myszy i wprowadzanie w ramach ich składania sterowania za pomocą myszy.  
  
<a name="routedEventInfo_PreviewMouseUpOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent>|  
|Strategii routingu|Tunelowanie|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Nie ma żadnego odpowiedniego zdarzenia propagacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" Usage="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy obraca kółko myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zespół lub myszy przechwytywania pierwszeństwo gdy wskaźnik myszy znajduje się; w związku z tym jeśli zostanie wyświetlony to zdarzenie od elementu wąsko zdefiniowany lub przechwycone, wskaźnik myszy może w rzeczywistości to za pośrednictwem innego elementu w czasie.  
  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseWheelEvent>|  
|Strategii routingu|Tunelowanie|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   To odpowiednie zdarzenie propagacji <xref:System.Windows.Input.Mouse.MouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.MouseDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As MouseDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseDevice ^ PrimaryDevice { System::Windows::Input::MouseDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.MouseDevice" Usage="System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera urządzeniem podstawowym.</summary>
        <value>Urządzenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość obsługuje infrastrukturę programu Windows Presentation Foundation i nie jest przeznaczona do użycia bezpośrednio w kodzie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="ILAsm" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="F#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" Usage="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy element, który wysyła zapytanie o bieżący kursor myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementuje zdarzeń jest dołączonych jako zdarzenia trasowane. Dołączone zdarzenia są całkowicie [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcji języka do odwoływania się do zdarzenia, które mogą być obsługiwane na obiektach, które nie określają tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerza włączając zdarzeń na przechodzenie przez trasę. Zdarzenia dołączone ma składni bezpośredniej obsługi w kodzie Aby dołączyć programy obsługi dla zdarzenia trasowanego w kodzie, należy użyć wyznaczonym Dodaj * metodę procedury obsługi. Aby uzyskać więcej informacji, zobacz [Przegląd zdarzeń dołączonych](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_Querycursor"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.QueryCursorEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
 Nie ma żadnego zdefiniowanych odpowiednie zdarzenia tunelowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia trasowanego identyfikatory są tworzone zdarzenia trasowane są rejestrowane, gdy wynik jest przechowywany jako pole w klasie, która rejestruje zdarzenie trasowane. Identyfikatory te zawierają nazwę identyfikującą typ właściciela, typ procedury obsługi, strategii routingu i narzędzie metoda dodawania właścicieli dla zdarzenia. Często używają tych identyfikatorów jako parametry do metod system zdarzeń, aby zidentyfikować konkretne zdarzenie trasowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseDown" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseMove" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseUp" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void RemoveQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.UIElement" /> Lub <see cref="T:System.Windows.ContentElement" /> nasłuchuje tego zdarzenia.</param>
        <param name="handler">Program obsługi zdarzeń.</param>
        <summary>Usuwa obsługi dla <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> dołączone zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState RightButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState RightButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.RightButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RightButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState RightButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.RightButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.RightButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan przycisku po prawej.</summary>
        <value>Stan prawego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy prawy przycisk myszy jest wciśnięty przez sprawdzenie, czy stan <xref:System.Windows.Input.Mouse.RightButton%2A> jest równa <xref:System.Windows.Input.MouseButtonState> wartość wyliczenia <xref:System.Windows.Input.MouseButtonState.Pressed>.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, które aktualizacje są wyświetlane elementy w próbce.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetrightbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetrightbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public static bool SetCursor (System.Windows.Input.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetCursor(class System.Windows.Input.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.SetCursor(System.Windows.Input.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetCursor(System::Windows::Input::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="static member SetCursor : System.Windows.Input.Cursor -&gt; bool" Usage="System.Windows.Input.Mouse.SetCursor cursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cursor" Type="System.Windows.Input.Cursor" />
      </Parameters>
      <Docs>
        <param name="cursor">Kursora, aby ustawić wskaźnik myszy.</param>
        <summary>Ustawia wskaźnik myszy na określonym <see cref="T:System.Windows.Input.Cursor" />.</summary>
        <returns>
          <see langword="true" />, jeśli ustawiono kursora; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor zostanie ustawiony nie dotyczy to jeden z elementów, ale raczej ma zastosowanie do całej aplikacji.  Tak Jeśli po ustawieniu kursora, który wskaźnik myszy porusza się nad obiektem, który ustawia kursor, kursor zmieni się ponownie.  
  
 Aby wymusić wskaźnik myszy na konkretnym <xref:System.Windows.Input.Cursor> i wymusić wykonanie tej <xref:System.Windows.Input.Cursor> na wszystkie elementy, ustaw <xref:System.Windows.Input.Mouse.OverrideCursor%2A> właściwości.  
  
 Aby ustawić kursor na określony element, należy użyć <xref:System.Windows.FrameworkElement.Cursor%2A> właściwość albo <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>.  Aby uzyskać więcej informacji na temat podstawowych elementów, zobacz [Przegląd elementów podstawowych](~/docs/framework/wpf/advanced/base-elements-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursors" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="Synchronize">
      <MemberSignature Language="C#" Value="public static void Synchronize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Synchronize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Synchronize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Synchronize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Synchronize();" />
      <MemberSignature Language="F#" Value="static member Synchronize : unit -&gt; unit" Usage="System.Windows.Input.Mouse.Synchronize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza myszą, aby ponownie zsynchronizować.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
        <altmember cref="M:System.Windows.Input.Mouse.Synchronize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateCursor">
      <MemberSignature Language="C#" Value="public static void UpdateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.UpdateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UpdateCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateCursor();" />
      <MemberSignature Language="F#" Value="static member UpdateCursor : unit -&gt; unit" Usage="System.Windows.Input.Mouse.UpdateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza kursora myszy do zaktualizowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XButton1">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton1 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton1 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton1 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan pierwszy przycisk rozszerzonej.</summary>
        <value>Stan pierwszej przycisku myszy rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy pierwszy przycisk rozszerzonej myszy jest wciśnięty przez sprawdzenie, czy stan <xref:System.Windows.Input.Mouse.XButton1%2A> jest równa <xref:System.Windows.Input.MouseButtonState> wartość wyliczenia <xref:System.Windows.Input.MouseButtonState.Pressed>.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, które aktualizacje są wyświetlane elementy w próbce.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx1buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx1buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="XButton2">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton2" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton2 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton2 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton2 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan drugi przycisk rozszerzonej.</summary>
        <value>Stan drugi przycisk myszy rozszerzonej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy drugi przycisk rozszerzonej myszy jest wciśnięty przez sprawdzenie, czy stan <xref:System.Windows.Input.Mouse.XButton2%2A> jest równa <xref:System.Windows.Input.MouseButtonState> wartość wyliczenia <xref:System.Windows.Input.MouseButtonState.Pressed>.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, które aktualizacje są wyświetlane elementy w próbce.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx2buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx2buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
  </Members>
</Type>
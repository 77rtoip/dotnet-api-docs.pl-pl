<Type Name="Mouse" FullName="System.Windows.Input.Mouse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2ec29fdc352c03282bddfca91b02b0b0b0d7ce66" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69170831" /></Metadata><TypeSignature Language="C#" Value="public static class Mouse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Mouse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Mouse" />
  <TypeSignature Language="VB.NET" Value="Public Class Mouse" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mouse abstract sealed" />
  <TypeSignature Language="F#" Value="type Mouse = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje urządzenie myszy do określonego wątku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.Mouse> Klasa zawiera zdarzenia dotyczące myszy, metody i właściwości, które zawierają informacje dotyczące stanu myszy.  
  
 Każde zdarzenie, <xref:System.Windows.Input.Mouse> które definiuje jako dołączone zdarzenie, jest również ponownie uwidaczniane przez klasy <xref:System.Windows.UIElement> elementów podstawowych i <xref:System.Windows.ContentElement> jako nowe zdarzenie kierowane. Ogólnie rzecz biorąc, wygodniejsze jest obsłużenie zdarzeń myszy dla aplikacji <xref:System.Windows.UIElement> <xref:System.Windows.Input.Mouse> , <xref:System.Windows.ContentElement>a nie przy użyciu zdarzeń. Aby uzyskać szczegółowe informacje, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Statyczny element członkowski <xref:System.Windows.Input.Mouse> klasy delegowany do podstawowego <xref:System.Windows.Input.MouseDevice> Menedżera wejściowego wątku wywołującego.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseDown" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseMove" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseUp" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void AddQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Dodaje procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Capture">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przechwytuje dane wejściowe myszy do określonego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wskaźnik myszy, niezależnie od tego, czy kursor znajduje się w jego granicach.  
  
 Jeśli nie <xref:System.Windows.Input.CaptureMode> <xref:System.Windows.Input.CaptureMode.Element>jest określony, wartość domyślna to. <xref:System.Windows.Input.CaptureMode>  
  
 Aby zwolnić funkcję przechwytywania myszy, <xref:System.Windows.Input.Mouse.Capture%2A> Wywołaj przekazywanie `null` jako element do przechwycenia.  
  
 Jeśli wskaźnik myszy jest przechwytywany, <xref:System.Windows.Input.Mouse.MouseDown> gdy <xref:System.Windows.Input.Mouse.MouseUp> zdarzenie lub zostanie wywołane, a dane wejściowe nie przechodzą do <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> elementu pod myszą <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> i są wywoływane jako pierwsze.  Dzięki temu przechwyconemu elementowi można zwolnić przechwycenie przed <xref:System.Windows.Input.Mouse.MouseDown> rozpoczęciem routingu i <xref:System.Windows.Input.Mouse.MouseUp> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement -&gt; bool" Usage="System.Windows.Input.Mouse.Capture element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Element, aby przechwycić mysz.</param>
        <summary>Przechwytuje dane wejściowe myszy do określonego elementu.</summary>
        <returns><see langword="true" />Jeśli element był w stanie przechwycić mysz; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wskaźnik myszy, niezależnie od tego, czy kursor znajduje się w jego granicach.  
  
 Jeśli nie <xref:System.Windows.Input.CaptureMode> <xref:System.Windows.Input.CaptureMode.Element>jest określony, wartość domyślna to. <xref:System.Windows.Input.CaptureMode>  
  
 Aby zwolnić funkcję przechwytywania myszy, <xref:System.Windows.Input.Mouse.Capture%2A> Wywołaj przekazywanie `null` jako element do przechwycenia.  
  
 Jeśli wskaźnik myszy jest przechwytywany, <xref:System.Windows.Input.Mouse.MouseDown> gdy <xref:System.Windows.Input.Mouse.MouseUp> zdarzenie lub zostanie wywołane, a dane wejściowe nie przechodzą do <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> elementu pod myszą <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> i są wywoływane jako pierwsze.  Dzięki temu przechwyconemu elementowi można zwolnić przechwycenie przed <xref:System.Windows.Input.Mouse.MouseDown> rozpoczęciem routingu i <xref:System.Windows.Input.Mouse.MouseUp> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przechwycić mysz do określonego elementu przy użyciu <xref:System.Windows.Input.Mouse.Capture%2A> metody.  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element, System.Windows.Input.CaptureMode captureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element, valuetype System.Windows.Input.CaptureMode captureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement,System.Windows.Input.CaptureMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element, System::Windows::Input::CaptureMode captureMode);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement * System.Windows.Input.CaptureMode -&gt; bool" Usage="System.Windows.Input.Mouse.Capture (element, captureMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="captureMode" Type="System.Windows.Input.CaptureMode" />
      </Parameters>
      <Docs>
        <param name="element">Element, aby przechwycić mysz.</param>
        <param name="captureMode">Zasady przechwytywania do użycia.</param>
        <summary>Przechwytuje dane wejściowe myszy do określonego elementu przy <see cref="T:System.Windows.Input.CaptureMode" />użyciu określonego.</summary>
        <returns><see langword="true" />Jeśli element był w stanie przechwycić mysz; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wskaźnik myszy, czy kursor znajduje się w jego granicach.  
  
 Aby zwolnić funkcję przechwytywania myszy, <xref:System.Windows.Input.Mouse.Capture%2A> Wywołaj przekazywanie `null` jako element do przechwycenia.  
  
 Jeśli wskaźnik myszy jest przechwytywany, <xref:System.Windows.Input.Mouse.MouseDown> gdy <xref:System.Windows.Input.Mouse.MouseUp> zdarzenie lub zostanie wywołane, a dane wejściowe nie przechodzą do <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> elementu pod myszą <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> i są wywoływane jako pierwsze.  Dzięki temu przechwyconemu elementowi można zwolnić przechwycenie przed <xref:System.Windows.Input.Mouse.MouseDown> rozpoczęciem routingu i <xref:System.Windows.Input.Mouse.MouseUp> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przechwycić mysz do określonego elementu przy użyciu <xref:System.Windows.Input.Mouse.Capture%2A> metody.  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Captured">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Captured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement Captured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.Captured" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Captured As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ Captured { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Captured : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.Captured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, który przechwytuje mysz.</summary>
        <value>Element przechwycony przez mysz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wskaźnik myszy, niezależnie od tego, czy kursor znajduje się w jego granicach. Mysz jest zwykle przechwytywana w ten sposób tylko podczas operacji przeciągania i upuszczania oraz zachowuje przechwytywanie do momentu wystąpienia akcji przeciągania i upuszczania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak uzyskać element, który ma przechwycenie myszy.  
  
 [!code-csharp[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecapturemousecaptured)]
 [!code-vb[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecapturemousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyOver">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement DirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement DirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.DirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DirectlyOver As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ DirectlyOver { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectlyOver : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.DirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, którego wskaźnik myszy jest przełączany bezpośrednio.</summary>
        <value>Element, nad którym znajduje się wskaźnik myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolki mogą składać się z wielu elementów. <xref:System.Windows.Input.Mouse.DirectlyOver%2A>raportuje określony element w kontrolce złożonej, wskaźnik myszy znajduje się nad, a nie sam formantem. Na przykład, w zależności od tego, która część <xref:System.Windows.Controls.Button> wskaźnika znajduje się nad <xref:System.Windows.Input.Mouse.DirectlyOver%2A> , właściwość <xref:System.Windows.Controls.ContentControl.Content%2A> może zgłosić <xref:System.Windows.Controls.TextBox> właściwość lub <xref:Microsoft.Windows.Themes.ButtonChrome>.  
  
 Użyj właściwości w <xref:System.Windows.UIElement> i<xref:System.Windows.ContentElement> , aby określić, czy wskaźnik myszy znajduje się nad elementem, który obejmuje jego elementy potomne wizualizacji lub elementy kompozycji formantów. <xref:System.Windows.IInputElement.IsMouseOver%2A>  
  
 Jeśli element ma przechwycenie myszy, wskaźnik myszy jest uznawany za bezpośrednio nad elementem, bez względu na to, gdzie znajduje się wskaźnik myszy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseOver" />
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="GetIntermediatePoints">
      <MemberSignature Language="C#" Value="public static int GetIntermediatePoints (System.Windows.IInputElement relativeTo, System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetIntermediatePoints(class System.Windows.IInputElement relativeTo, valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetIntermediatePoints(System.Windows.IInputElement,System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIntermediatePoints (relativeTo As IInputElement, points As Point()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetIntermediatePoints(System::Windows::IInputElement ^ relativeTo, cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="static member GetIntermediatePoints : System.Windows.IInputElement * System.Windows.Point[] -&gt; int" Usage="System.Windows.Input.Mouse.GetIntermediatePoints (relativeTo, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Elementy <paramref name="points" /> znajdują się w odniesieniu do.</param>
        <param name="points">Tablica obiektów.</param>
        <summary>Pobiera do 64 poprzednich współrzędnych wskaźnika myszy od momentu ostatniego przejścia kursora myszy.</summary>
        <returns>Liczba zwróconych punktów.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point GetPosition (System.Windows.IInputElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point GetPosition(class System.Windows.IInputElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetPosition(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPosition (relativeTo As IInputElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point GetPosition(System::Windows::IInputElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="static member GetPosition : System.Windows.IInputElement -&gt; System.Windows.Point" Usage="System.Windows.Input.Mouse.GetPosition relativeTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Przestrzeń współrzędnych, w której ma zostać obliczona pozycja myszy.</param>
        <summary>Pobiera pozycję myszy względem określonego elementu.</summary>
        <returns>Pozycja myszy względem parametru <paramref name="relativeTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja wskaźnika myszy jest obliczana względem określonego elementu w lewym górnym rogu elementu, który jest punktem początkowym, 0, 0.  
  
 Podczas operacji przeciągania i upuszczania pozycja myszy nie może być niezawodnie określana za pomocą <xref:System.Windows.Input.Mouse.GetPosition%2A>. Wynika to z faktu, że kontrola nad myszą (może także dotyczyć przechwytywania) jest utrzymywana przez element inicjujący przeciągania do momentu ukończenia upuszczania, z dużą ilością zachowania [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] sterowanego przez wywołania bazowe. Zamiast tego spróbuj użyć następujących metod:  
  
-   <xref:System.Windows.ContentElement.DragEnter> <xref:System.Windows.ContentElement.DragLeave> <xref:System.Windows.ContentElement.DragOver>Wywołaj <xref:System.Windows.DragEventArgs> metodę, która jest przenoszona do zdarzeń przeciągania (,,). <xref:System.Windows.DragEventArgs.GetPosition%2A>  
  
-   Wywołaj [GetCursorPos](https://msdn.microsoft.com/library/default.asp?url=/library/winui/winui/windowsuserinterface/resources/cursors/cursorreference/cursorfunctions/getcursorpos.asp), używając metody P/Invoke.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Input.Mouse.GetPosition%2A> do określenia pozycji wskaźnika myszy.  Położenie wskaźnika myszy jest przechowywane w <xref:System.Windows.Point> strukturze.  Wartości <xref:System.Windows.Point.X%2A> i<xref:System.Windows.Point.Y%2A> obiektu są wyświetlane w <xref:System.Windows.Controls.TextBox>. <xref:System.Windows.Point>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetspositionmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetspositionmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.MouseEventArgs.GetPosition(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" Usage="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy element przechwytuje mysz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wskaźnik myszy, niezależnie od tego, czy kursor znajduje się w jego granicach.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Ze względu na propagację routingu, rzeczywisty element, który ma przechwycenie, może być elementem podrzędnym, niekoniecznie do elementu, w którym program obsługi zdarzeń jest rzeczywiście dołączony. <xref:System.Windows.RoutedEventArgs.Source%2A> Sprawdź w argumentach zdarzeń, aby określić rzeczywisty element, który ma przechwycenie myszą.  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.GotMouseCaptureEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Nie zdefiniowano odpowiedniego zdarzenia tunelowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState LeftButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState LeftButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.LeftButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LeftButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState LeftButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.LeftButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.LeftButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan lewego przycisku myszy.</summary>
        <value>Stan lewego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy lewy przycisk myszy jest wciśnięty, sprawdzając, czy stan <xref:System.Windows.Input.Mouse.LeftButton%2A> jest równy <xref:System.Windows.Input.MouseButtonState> wartości <xref:System.Windows.Input.MouseButtonState.Pressed>wyliczenia.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, która aktualizuje elementy w przykładzie.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" Usage="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy element utraci przechwytywanie myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element przechwytuje mysz, otrzymuje wskaźnik myszy, niezależnie od tego, czy kursor znajduje się w jego granicach. T  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Ze względu na propagację routingu, rzeczywisty element, który utracił przechwytywanie, może być elementem podrzędnym, niekoniecznie jest to element, w którym program obsługi zdarzeń jest rzeczywiście dołączony. <xref:System.Windows.RoutedEventArgs.Source%2A> Sprawdź w argumentach zdarzeń, aby określić rzeczywisty element, który utracił przechwytywanie.  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.LostMouseCaptureEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Nie zdefiniowano odpowiedniego zdarzenia tunelowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MiddleButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState MiddleButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState MiddleButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.MiddleButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MiddleButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState MiddleButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.MiddleButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.MiddleButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan środkowego przycisku myszy.</summary>
        <value>Stan środkowego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy środkowy przycisk myszy jest wciśnięty, sprawdzając, czy stan <xref:System.Windows.Input.Mouse.MiddleButton%2A> jest równy <xref:System.Windows.Input.MouseButtonState> wartości <xref:System.Windows.Input.MouseButtonState.Pressed>wyliczenia.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, która aktualizuje elementy w przykładzie.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetmiddlebuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetmiddlebuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" Usage="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po naciśnięciu dowolnego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, który przycisk myszy został rozciśnięty, sprawdź <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A> Właściwość <xref:System.Windows.Input.MouseButtonEventArgs> w przekazaniu do procedury obsługi.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 Struktura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] jest oparta na tym załączonym zdarzeniu przez przełączenie go <xref:System.Windows.UIElement> na <xref:System.Windows.ContentElement>dwa <xref:System.Windows.UIElement.MouseLeftButtonDown> różne <xref:System.Windows.UIElement.MouseRightButtonDown> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] zdarzenia w systemach i: i. Te implementacje obsługują zdarzenie <xref:System.Windows.Input.Mouse.MouseDown> podstawowe i odczytują argumenty zdarzenia, aby określić, czy pozostały lewy lub prawy przycisk myszy. W przypadku myszy z trzema przyciskami nie ma obsługi zdarzeń na poziomie platformy dla przycisku centrum. Należy użyć <xref:System.Windows.Input.Mouse.MouseDown> zdarzenia i <xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A> sprawdzić stan w argumentach zdarzeń.  
  
> [!IMPORTANT]
>  Kilka <xref:System.Windows.ContentElement> klas pochodnych, które mają zachowanie podobne do kontrolki, na <xref:System.Windows.Documents.Hyperlink>przykład, może mieć nieodłączną obsługę klas dla zdarzeń przycisków myszy. Lewe zdarzenie myszy w dół jest najbardziej prawdopodobną przyczyną obsługi klas w formancie. Obsługa klasy często oznacza zdarzenia klasy bazowej <xref:System.Windows.Input.Mouse> jako obsługiwane. Gdy zdarzenie zostanie oznaczone jako obsługiwane, inne programy obsługi wystąpienia dołączone do tego elementu nie są zwykle zgłaszane. Wszystkie inne procedury obsługi klasy lub wystąpienia, które są dołączone do elementów w kierunku propagacji do korzenia w drzewie interfejsu użytkownika, również nie są zwykle zgłaszane.  
  
 Można rozwiązać problem opisany w powyższej ważnej notatce i nadal otrzymywać <xref:System.Windows.UIElement.MouseDown> zdarzenia dla lewego przycisku myszy zdarzenia w klasie pochodnej, która ma obsługę klasy, przy użyciu jednego z następujących rozwiązań:  
  
-   Dołącz programy obsługi dla <xref:System.Windows.UIElement.PreviewMouseDown> zdarzenia, które nie jest oznaczone jako obsługiwane przez kontrolki. Zwróć uwagę, że ponieważ jest to zdarzenie w wersji zapoznawczej, trasa zaczyna się od elementu głównego i tuneluje do formantu.  
  
-   Zarejestrowanie procedury obsługi na formancie w sposób proceduralny przez <xref:System.Windows.UIElement.AddHandler%2A> wywołanie i wybranie opcji podpisu, która umożliwia programom obsługi nasłuchiwanie zdarzeń nawet wtedy, gdy są one już oznaczone jako obsługiwane w danych zdarzenia kierowanego.  
  
 W przypadku zdarzeń kierowanych odnoszących się do myszy należy zachować ostrożność w przypadku, gdy są one oznaczane jako obsługiwane. Trudności w podejmowaniu odpowiednich wyborów dotyczących tego, czy elementy nadrzędne powinny być również poinformowane o każdej akcji myszy, dlatego, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] że struktura zdecydowała się na modelu, że dla danego zdarzenia kierowana myszą [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] jest przypadane jako zdarzenia na trasie. Podobne problemy występują w przypadku tunelowania zdarzeń myszy.  Należy obsłużyć zdarzenie, które nie powinno być obsługiwane przez dalsze elementy podrzędne w kierunku źródła i jak miałoby to wpływ na tworzenie kontrolki, w której elementy kompozycji mogą mieć oczekiwane zachowania myszy?  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseDownEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Odpowiednie zdarzenie tunelowania to <xref:System.Windows.Input.Mouse.PreviewMouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.MouseDown" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="F#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" Usage="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy zostanie przesunięty w granice elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie używa strategii routingu dotyczącej bezpośredniego obsługi zdarzeń. Zdarzenia kierowane bezpośrednio nie są zgłaszane na trasie (są obsługiwane tylko w tym samym elemencie, w którym są wywoływane).  Można jednak włączyć inne aspekty zachowań zdarzeń kierowanych, takich jak wyzwalacze zdarzeń w stylach.  
  
 Chociaż to zdarzenie jest używane do śledzenia, gdy wskaźnik myszy zostanie przesunięty do elementu, jest <xref:System.Windows.UIElement.IsMouseOver%2A> również raportowany, `false` że `true` właściwość została zmieniona z na na dla tego elementu.  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseEnterEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.MouseEnter" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" Usage="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy opuszcza granice elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie używa strategii routingu dotyczącej bezpośredniego obsługi zdarzeń. Zdarzenia kierowane bezpośrednio nie są zgodne z trasą (są obsługiwane tylko w tym samym elemencie, w którym zostały zgłoszone).  Można jednak włączyć inne aspekty zachowań zdarzeń kierowanych, takich jak wyzwalacze zdarzeń w stylach.  
  
 Chociaż to zdarzenie jest używane do śledzenia, gdy wskaźnik myszy opuszcza element, jest również raportowany, że <xref:System.Windows.UIElement.IsMouseOver%2A> wartość właściwości została zmieniona z `true` na `false` na w tym elemencie.  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseLeaveEvent>|  
|Strategia routingu|Bezpośrednie|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.MouseLeave" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" Usage="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po przesunięciu wskaźnika myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseMoveEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Odpowiednie zdarzenie tunelowania to <xref:System.Windows.Input.Mouse.PreviewMouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.MouseMove" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" Usage="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po wydaniu dowolnego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Który przycisk myszy został wyznaczony, jest określany przez sprawdzanie argumentów zdarzenia.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] <xref:System.Windows.UIElement.MouseRightButtonUp> <xref:System.Windows.UIElement.MouseLeftButtonUp> Platforma kompiluje na tym załączonym zdarzeniu, umieszczając je w postaci dwóch różnych zdarzeń w: i. [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Te implementacje obsługują zdarzenie <xref:System.Windows.Input.Mouse.MouseUp> podstawowe i odczytują argumenty zdarzenia, aby określić, czy pozostały lewy lub prawy przycisk myszy. W przypadku trzech przycisków nie ma obsługi zdarzeń na poziomie platformy dla przycisku centrum. należy użyć <xref:System.Windows.Input.Mouse.MouseUp> zdarzenia i sprawdzić warunek środkowy przycisku w argumentach zdarzeń.  
  
 W przypadku zdarzeń kierowanych odnoszących się do myszy należy zachować ostrożność w przypadku, gdy są one oznaczane jako obsługiwane. Trudności w podejmowaniu odpowiednich wyborów dotyczących tego, czy elementy nadrzędne powinny być również poinformowane o każdej akcji myszy, dlatego, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] że struktura zdecydowała się na modelu, <xref:System.Windows.Input.Mouse> że dane zdarzenie powiązanezkierowana[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia wszystkie wzdłuż trasy.  
  
 Podobne problemy występują w przypadku tunelowania zdarzeń myszy.  Należy obsłużyć zdarzenie i nie powinno być obsługiwane przez elementy podrzędne w celu dalszej części źródła i jak miałoby to wpływ na składanie w formancie, w którym elementy kompozycji mogą mieć oczekiwane zachowania myszy?  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseUpEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 Odpowiednie zdarzenie tunelowania to <xref:System.Windows.Input.Mouse.PreviewMouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.MouseUp" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" Usage="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po obróceniu kółka myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja skupienie lub Funkcja przechwytywania myszy ma pierwszeństwo przed miejscem, w którym znajduje się wskaźnik myszy.  Jeśli otrzymasz to zdarzenie z elementu skoncentrowanego lub przechwyconego, wskaźnik myszy może znajdować się nad innym elementem w danym momencie.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.MouseWheelEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Odpowiednie zdarzenie tunelowania to <xref:System.Windows.Input.Mouse.PreviewMouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelDeltaForOneLine">
      <MemberSignature Language="C#" Value="public const int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MouseWheelDeltaForOneLine = (120)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberSignature Language="VB.NET" Value="Public Const MouseWheelDeltaForOneLine As Integer  = 120" />
      <MemberSignature Language="C++ CLI" Value="public: int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="F#" Value="val mutable MouseWheelDeltaForOneLine : int" Usage="System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>120</MemberValue>
      <Docs>
        <summary>Przedstawia liczbę jednostek obróconych kółkiem myszy w jeden wiersz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W bieżącej [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]wartości tego pola jest 120. Zamiarem ekspozycji pola jest umożliwienie dostawcom kompilowania kółk myszy o większej rozdzielczości w przyszłości, co może obejmować swobodne kółko bez nacięcia. Oczekuje się, że takie urządzenie wyśle więcej komunikatów na obrót, ale z mniejszą wartością w każdym komunikacie. Aby zapewnić obsługę tej możliwości, należy dodać przychodzące wartości przyrostu do momentu <xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine> osiągnięcia kwoty (dlatego w przypadku rotacji różnicowej uzyskuje taką samą odpowiedź) lub przewijać częściowe wiersze w odpowiedzi na częstsze komunikaty. Możesz również wybrać własny poziom szczegółowości przewijania i rozrastać własne różnice, aż do osiągnięcia tego delty, lub być może odwoływać się do kontrolowanych przez użytkownika parametrów systemu pod kątem czułości myszy i ekstrapolacji ich na progi różnic kółka myszy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseWheelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.MouseWheel" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideCursor">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.Cursor OverrideCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.Cursor OverrideCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.OverrideCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OverrideCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::Cursor ^ OverrideCursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OverrideCursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.Input.Mouse.OverrideCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor dla całej aplikacji.</summary>
        <value>Przesłonięcie kursora <see langword="null" /> lub <see cref="P:System.Windows.Input.Mouse.OverrideCursor" /> Jeśli nie jest ustawiona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.Cursor> Toustawieniezostanie<xref:System.Windows.Input.Mouse.OverrideCursor%2A> zastosowane do całej aplikacji.  
  
 Aby wyczyścić przesłonięcie <xref:System.Windows.Input.Cursor>, <xref:System.Windows.Input.Mouse.OverrideCursor%2A> `null`ustaw wartość.  
  
 Ustawienie opcji <xref:System.Windows.Input.Mouse.OverrideCursor%2A>spowodujewymuszenie wyświetlania kursora myszy, ale zdarzenia myszy są nadal przetwarzane. <xref:System.Windows.Input.Cursors.None%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje procedurę obsługi <xref:System.Windows.Controls.RadioButton> zdarzeń, która jest używana do przełączania zakresu zmiany kursora między pojedynczym elementem a całą aplikacją.  Jeśli formant, który `rbScopeElement`wywołał zdarzenie <xref:System.Windows.Controls.RadioButton>, jest flagą, która określa zakres zmiany kursora jest ustawiony i <xref:System.Windows.Input.Mouse.OverrideCursor%2A> jest ustawiony na `null`.  Jeśli formant, który wywołał zdarzenie `rbScopeApplication` <xref:System.Windows.Controls.RadioButton>, jest flagą, która określa zakres zmiany kursora jest ustawiony <xref:System.Windows.FrameworkElement.Cursor%2A> i <xref:System.Windows.Input.Mouse.OverrideCursor%2A> jest ustawiony na Właściwość <xref:System.Windows.Controls.Border> formantu o nazwie `DisplayArea`.  
  
 [!code-csharp[cursors#CursorsSampleOverrideCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#cursorssampleoverridecursor)]
 [!code-vb[cursors#CursorsSampleOverrideCursor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#cursorssampleoverridecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" Usage="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po naciśnięciu dowolnego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Który przycisk myszy został rozciśnięty jest określany przez sprawdzanie argumentów zdarzenia. Jest to dołączone zdarzenie (przy użyciu strategii routingu tunelowania), które jest przeznaczone do odwoływania się do wszystkich istniejących [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementów, które pobierają dane wejściowe.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Platforma kompiluje na tym załączonym zdarzeniu, umieszczając je w postaci dwóch różnych zdarzeń w: i. [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Te implementacje obsługują zdarzenie <xref:System.Windows.Input.Mouse.PreviewMouseDown> podstawowe i odczytują argumenty zdarzenia, aby określić, czy pozostały lewy lub prawy przycisk myszy. W przypadku trzech przycisków nie ma obsługi zdarzeń na poziomie platformy dla przycisku centrum. należy użyć <xref:System.Windows.Input.Mouse.PreviewMouseDown> zdarzenia i sprawdzić warunek środkowy przycisku w argumentach zdarzeń.  
  
 W przypadku zdarzeń kierowanych odnoszących się do myszy należy zachować ostrożność w przypadku, gdy są one oznaczane jako obsługiwane. Obsługa zdarzenia w sąsiedztwie katalogu głównego i obsłudze go przez dziecko w dalszej części źródła może nie być odpowiednia dla kontrolek złożonych, gdzie elementy złożone mogą mieć oczekiwane zachowania myszy. Trudności w podejmowaniu odpowiednich wyborów dotyczących tego, czy inne elementy powinny być również poinformowane o każdej akcji myszy, dlatego, że [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] struktura wybiera model, który jest powiązany <xref:System.Windows.Input.Mouse> ze zdarzeniem kierowanym.[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia na trasie.  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseDownEvent>|  
|Strategia routingu|Tunelowania|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Odpowiednie zdarzenie propagacji to <xref:System.Windows.Input.Mouse.MouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" Usage="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po naciśnięciu podstawowego przycisku myszy poza elementem, który przechwytuje zdarzenia myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie nie jest zmieniane na elementy podstawowe. Polega głównie na kontroli autorów, którzy próbują uzgodnić przechwycenie myszy i dane wejściowe myszy w ramach ich składania.  
  
<a name="routedEventInfo_PreviewMouseDownOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent>|  
|Strategia routingu|Tunelowania|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" Usage="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy zostanie przesunięty nad element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje, gdy wskaźnik myszy jest nowo przenoszony w granicach elementów, a także gdy wskaźnik myszy jest przenoszony, gdy nadal pozostaje w granicach elementów.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseMoveEvent>|  
|Strategia routingu|Tunelowania|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Odpowiednie zdarzenie propagacji to <xref:System.Windows.Input.Mouse.MouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" Usage="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po wydaniu dowolnego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Który przycisk myszy został wyznaczony, jest określany przez sprawdzanie argumentów zdarzenia.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> Platforma kompiluje na tym załączonym zdarzeniu, umieszczając je w postaci dwóch różnych zdarzeń w: i. [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Te implementacje obsługują zdarzenie <xref:System.Windows.Input.Mouse.PreviewMouseUp> podstawowe i odczytują argumenty zdarzenia, aby określić, czy pozostały lewy lub prawy przycisk myszy. W przypadku trzech przycisków nie ma obsługi zdarzeń na poziomie platformy dla przycisku centrum. należy użyć <xref:System.Windows.Input.Mouse.PreviewMouseUp> zdarzenia i sprawdzić warunek środkowy przycisku w argumentach zdarzeń.  
  
 W przypadku zdarzeń kierowanych odnoszących się do myszy należy zachować ostrożność w przypadku, gdy są one oznaczane jako obsługiwane. Obsługa zdarzenia w sąsiedztwie katalogu głównego i nieobsługiwanego przez dziecko w dalszej części źródła może nie być odpowiednia dla kontrolek złożonych, gdzie elementy złożone mogą mieć oczekiwane zachowania myszy. Trudności w podejmowaniu odpowiednich wyborów dotyczących tego, czy inne elementy powinny być również poinformowane o każdej akcji myszy, dlatego, że [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] struktura wybiera model, który jest powiązany <xref:System.Windows.Input.Mouse> ze zdarzeniem kierowanym.[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] zdarzenia na trasie.  
  
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseUpEvent>|  
|Strategia routingu|Tunelowania|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Odpowiednie zdarzenie propagacji to <xref:System.Windows.Input.Mouse.MouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" Usage="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy podstawowy przycisk myszy zostanie wyprowadzony poza elementem, który przechwytuje zdarzenia myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
 To zdarzenie nie jest zmieniane na elementy podstawowe. Polega głównie na kontroli autorów, którzy próbują uzgodnić przechwycenie myszy i dane wejściowe myszy w ramach ich składania.  
  
<a name="routedEventInfo_PreviewMouseUpOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent>|  
|Strategia routingu|Tunelowania|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Nie ma odpowiedniego zdarzenia propagacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" Usage="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje po obróceniu kółka myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przechwycenie fokusu lub myszy ma pierwszeństwo przed miejscem, gdzie wskaźnik myszy jest; w związku z tym, jeśli otrzymasz to zdarzenie z elementu skoncentrowanego lub przechwyconego, wskaźnik myszy może znajdować się nad innym elementem w danym momencie.  
  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.PreviewMouseWheelEvent>|  
|Strategia routingu|Tunelowania|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Odpowiednie zdarzenie propagacji to <xref:System.Windows.Input.Mouse.MouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.MouseDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As MouseDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseDevice ^ PrimaryDevice { System::Windows::Input::MouseDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.MouseDevice" Usage="System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowe urządzenie myszy.</summary>
        <value>Urządzenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość obsługuje infrastrukturę Windows Presentation Foundation i nie jest przeznaczona do użycia bezpośrednio w kodzie.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="ILAsm" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="F#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" Usage="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Występuje, gdy element szuka bieżącego kursora myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest dołączone zdarzenie. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]implementuje dołączone zdarzenia jako zdarzenia kierowane. Dołączone zdarzenia są zasadniczo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] koncepcją języka dla odwołujących się zdarzeń, które mogą być obsługiwane na obiektach, które nie definiują tego zdarzenia, które [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] rozszerzają się, a także włączając zdarzenie przechodzące do trasy. Dołączone zdarzenia nie mają bezpośredniej składni obsługi w kodzie; Aby dołączyć procedury obsługi dla zdarzenia kierowanego w kodzie, należy użyć wskazanej metody dodawania * procedury obsługi. Aby uzyskać szczegółowe informacje, zobacz [Omówienie załączonych zdarzeń](~/docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="routedEventInfo_Querycursor"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Input.Mouse.QueryCursorEvent>|  
|Strategia routingu|Propagacja|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
 Nie zdefiniowano odpowiedniego zdarzenia tunelowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Input.Mouse.QueryCursor" /> Identyfikuje dołączone zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zdarzeń kierowanych są tworzone po zarejestrowaniu zdarzeń kierowanych, a wynik jest zapisywany jako pole w klasie, która rejestruje rozesłane zdarzenie. Identyfikatory te zawierają nazwę identyfikującą, typ właściciela, typ procedury obsługi, strategię routingu oraz metodę narzędzia do dodawania właścicieli dla zdarzenia. Te identyfikatory są często używane jako parametry do metod systemu zdarzeń, aby identyfikować konkretne zdarzenie kierowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseDown" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseMove" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseUp" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void RemoveQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Windows.UIElement" /> Lub<see cref="T:System.Windows.ContentElement" /> który nasłuchuje na tym zdarzeniu.</param>
        <param name="handler">Procedura obsługi zdarzeń.</param>
        <summary>Usuwa procedurę obsługi dla <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> dołączonego zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState RightButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState RightButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.RightButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RightButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState RightButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.RightButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.RightButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan przycisku po prawej stronie.</summary>
        <value>Stan prawego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy prawy przycisk myszy jest wciśnięty, sprawdzając, czy stan <xref:System.Windows.Input.Mouse.RightButton%2A> jest równy <xref:System.Windows.Input.MouseButtonState> wartości <xref:System.Windows.Input.MouseButtonState.Pressed>wyliczenia.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, która aktualizuje elementy w przykładzie.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetrightbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetrightbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public static bool SetCursor (System.Windows.Input.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetCursor(class System.Windows.Input.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.SetCursor(System.Windows.Input.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetCursor(System::Windows::Input::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="static member SetCursor : System.Windows.Input.Cursor -&gt; bool" Usage="System.Windows.Input.Mouse.SetCursor cursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cursor" Type="System.Windows.Input.Cursor" />
      </Parameters>
      <Docs>
        <param name="cursor">Kursor, dla którego ma zostać ustawiony wskaźnik myszy.</param>
        <summary>Ustawia wskaźnik myszy na określony <see cref="T:System.Windows.Input.Cursor" />.</summary>
        <returns><see langword="true" />, jeśli kursor został ustawiony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawiany kursor nie ma zastosowania do żadnego konkretnego elementu, ale nie dotyczy całej aplikacji.  Tak więc, jeśli po ustawieniu kursora wskaźnik myszy przesuwa się nad obiektem, który ustawia kursor, kursor zostanie ponownie zmieniony.  
  
 Aby wymusić wskaźnik myszy do określonego <xref:System.Windows.Input.Cursor> i wymusić <xref:System.Windows.Input.Cursor> ten element dla <xref:System.Windows.Input.Mouse.OverrideCursor%2A> wszystkich elementów, ustaw właściwość.  
  
 Aby ustawić kursor dla określonego elementu, użyj <xref:System.Windows.FrameworkElement.Cursor%2A> właściwości <xref:System.Windows.FrameworkElement> z lub <xref:System.Windows.FrameworkContentElement>.  Aby uzyskać więcej informacji na temat elementów podstawowych, zobacz [Omówienie elementów podstawowych](~/docs/framework/wpf/advanced/base-elements-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursors" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="Synchronize">
      <MemberSignature Language="C#" Value="public static void Synchronize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Synchronize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Synchronize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Synchronize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Synchronize();" />
      <MemberSignature Language="F#" Value="static member Synchronize : unit -&gt; unit" Usage="System.Windows.Input.Mouse.Synchronize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza ponowną synchronizację myszy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
        <altmember cref="M:System.Windows.Input.Mouse.Synchronize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateCursor">
      <MemberSignature Language="C#" Value="public static void UpdateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.UpdateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UpdateCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateCursor();" />
      <MemberSignature Language="F#" Value="static member UpdateCursor : unit -&gt; unit" Usage="System.Windows.Input.Mouse.UpdateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza aktualizację kursora myszy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XButton1">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton1 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton1 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton1 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan pierwszego rozszerzonego przycisku.</summary>
        <value>Stan pierwszego rozszerzonego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy pierwszy rozszerzony przycisk myszy jest wciśnięty, sprawdzając, czy stan <xref:System.Windows.Input.Mouse.XButton1%2A> jest równa <xref:System.Windows.Input.MouseButtonState> wartości <xref:System.Windows.Input.MouseButtonState.Pressed>wyliczenia.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, która aktualizuje elementy w przykładzie.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx1buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx1buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="XButton2">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton2" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton2 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton2 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton2 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan drugiego przycisku rozszerzonego.</summary>
        <value>Stan drugiego rozszerzonego przycisku myszy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak ustalić, czy drugi rozszerzony przycisk myszy jest wciśnięty, sprawdzając, czy stan <xref:System.Windows.Input.Mouse.XButton2%2A> jest równy <xref:System.Windows.Input.MouseButtonState> wartości <xref:System.Windows.Input.MouseButtonState.Pressed>wyliczenia.  Jeśli przycisk jest wciśnięty, metoda jest wywoływana, która aktualizuje elementy w przykładzie.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx2buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx2buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
  </Members>
</Type>

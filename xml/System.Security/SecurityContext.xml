<Type Name="SecurityContext" FullName="System.Security.SecurityContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="deede5f5711f0e5c6d55042cdaff686a30670c86" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36424000" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SecurityContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SecurityContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SecurityContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityContext sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type SecurityContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje i propaguje wszystkie dane związane z zabezpieczeniami dla kontekstów wykonanie przenoszone między wątkami. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Security.SecurityContext> obiektu przechwytuje wszystkie informacje związane z zabezpieczeniami dla logicznego wątku, w tym informacje zawarte w <xref:System.Security.Principal.WindowsIdentity> i <xref:System.Threading.CompressedStack> obiektów.  Taka konfiguracja pozwala tożsamości systemu Windows i elementy zabezpieczeń na stosie propagację automatycznie po <xref:System.Security.SecurityContext> jest kopiowany i transferowane za pośrednictwem asynchronicznych wątków.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego (CLR) jest świadome personifikacji operacje wykonywane przy użyciu tylko kodu zarządzanego nie pochodzi z personifikacji realizuje poza kodu zarządzanego, takich jak platforma wywołania do kodu niezarządzanego lub poprzez bezpośrednie wywołania funkcji Win32. Tylko zarządzanego <xref:System.Security.Principal.WindowsIdentity> obiektów może przechodzić między punktami asynchroniczne, chyba że `alwaysFlowImpersonationPolicy` ustawiono element `true` (`<alwaysFlowImpersonationPolicy enabled="true"/>`). Ustawienie `alwaysFlowImpersonationPolicy` elementu `true` Określa, czy tożsamość systemu Windows zawsze przepływa między punktami asynchroniczne, niezależnie od tego, jak została wykonana personifikacji. Aby uzyskać więcej informacji na temat przechodzenia przez punkty asynchroniczne niezarządzany personifikacji, zobacz [ &lt;alwaysflowimpersonationpolicy —&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/alwaysflowimpersonationpolicy-element.md).  
  
 <xref:System.Security.SecurityContext> Jest częścią większego <xref:System.Threading.ExecutionContext> przepływów i przeprowadzanie migracji podczas <xref:System.Threading.ExecutionContext> przepływa lub migracji.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static System.Security.SecurityContext Capture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.SecurityContext Capture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::SecurityContext ^ Capture();" />
      <MemberSignature Language="F#" Value="static member Capture : unit -&gt; System.Security.SecurityContext" Usage="System.Security.SecurityContext.Capture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechwytuje kontekstu zabezpieczeń dla bieżącego wątku.</summary>
        <returns>Kontekst zabezpieczeń dla bieżącego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst zabezpieczeń przechwycony może odnosić się do innego wątku. <xref:System.Security.SecurityContext> Składa się z <xref:System.Threading.CompressedStack> i <xref:System.Security.Principal.WindowsIdentity> wykonywania wątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCopy">
      <MemberSignature Language="C#" Value="public System.Security.SecurityContext CreateCopy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecurityContext CreateCopy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.CreateCopy" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCopy () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecurityContext ^ CreateCopy();" />
      <MemberSignature Language="F#" Value="member this.CreateCopy : unit -&gt; System.Security.SecurityContext" Usage="securityContext.CreateCopy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego kontekstu zabezpieczeń.</summary>
        <returns>Kontekst zabezpieczeń dla bieżącego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący kontekst musi zostały zakupione w ramach przechwytywania lub operacji kopiowania. Ta metoda jest przydatne w przypadku stosowania przechwyconych <xref:System.Security.SecurityContext> wiele wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący kontekst zabezpieczeń został wcześniej użyty, został organizowanego między domenami aplikacji lub nie uzyskano za pomocą <see cref="M:System.Security.SecurityContext.Capture" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="securityContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Security.SecurityContext" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie `Dispose` po zakończeniu przy użyciu <xref:System.Security.SecurityContext>. `Dispose` Pozostawia metody <xref:System.Security.SecurityContext> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Security.SecurityContext> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Security.SecurityContext> klasy.  
  
 Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze `Dispose` przed zwolnieniem ostatniego odwołania do <xref:System.Security.SecurityContext>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Security.SecurityContext> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFlowSuppressed">
      <MemberSignature Language="C#" Value="public static bool IsFlowSuppressed ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFlowSuppressed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.IsFlowSuppressed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFlowSuppressed () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFlowSuppressed();" />
      <MemberSignature Language="F#" Value="static member IsFlowSuppressed : unit -&gt; bool" Usage="System.Security.SecurityContext.IsFlowSuppressed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy przepływ kontekstu zabezpieczeń została pominięta.</summary>
        <returns>
          <see langword="true" /> Jeśli przepływ została pominięta; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecurityContext.IsFlowSuppressed%2A> Przez składniki infrastruktury metodę, aby określić, czy należy przesłać <xref:System.Security.SecurityContext> informacje podczas operacji asynchronicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWindowsIdentityFlowSuppressed">
      <MemberSignature Language="C#" Value="public static bool IsWindowsIdentityFlowSuppressed ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWindowsIdentityFlowSuppressed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.IsWindowsIdentityFlowSuppressed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWindowsIdentityFlowSuppressed () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWindowsIdentityFlowSuppressed();" />
      <MemberSignature Language="F#" Value="static member IsWindowsIdentityFlowSuppressed : unit -&gt; bool" Usage="System.Security.SecurityContext.IsWindowsIdentityFlowSuppressed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy przepływ część tożsamości systemu Windows bieżący kontekst zabezpieczeń została pominięta.</summary>
        <returns>
          <see langword="true" /> Jeśli przepływ została pominięta; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecurityContext.IsWindowsIdentityFlowSuppressed%2A> Przez składniki infrastruktury metodę, aby określić, czy należy przesłać informacje o tożsamości systemu Windows podczas <xref:System.Security.SecurityContext> migruje podczas operacji asynchronicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFlow">
      <MemberSignature Language="C#" Value="public static void RestoreFlow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RestoreFlow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.RestoreFlow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RestoreFlow ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RestoreFlow();" />
      <MemberSignature Language="F#" Value="static member RestoreFlow : unit -&gt; unit" Usage="System.Security.SecurityContext.RestoreFlow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przywraca przepływ kontekstu zabezpieczeń między wątkami asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecurityContext.RestoreFlow%2A> Metoda jest wywoływana przez <xref:System.Threading.AsyncFlowControl.Undo%2A?displayProperty=nameWithType> metodę, aby cofnąć efekt wcześniej <xref:System.Security.SecurityContext.SuppressFlow%2A> wywołania metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kontekst zabezpieczeń jest <see langword="null" /> lub ciąg pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Security.SecurityContext securityContext, System.Threading.ContextCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Security.SecurityContext securityContext, class System.Threading.ContextCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.Run(System.Security.SecurityContext,System.Threading.ContextCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Security::SecurityContext ^ securityContext, System::Threading::ContextCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member Run : System.Security.SecurityContext * System.Threading.ContextCallback * obj -&gt; unit" Usage="System.Security.SecurityContext.Run (securityContext, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityContext" Type="System.Security.SecurityContext" />
        <Parameter Name="callback" Type="System.Threading.ContextCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="securityContext">Aby ustawić kontekstu zabezpieczeń.</param>
        <param name="callback">Delegat, który reprezentuje metodę na uruchomienie w kontekście zabezpieczeń określony.</param>
        <param name="state">Obiekt do przekazania do metody wywołania zwrotnego.</param>
        <summary>Uruchamia określonej metody w kontekście zabezpieczeń określonej w bieżącym wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst zabezpieczeń bieżącego wątku jest zwracana do jego poprzedniego stanu po zakończeniu wywołania metody.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Security.SecurityContext.Run%2A> metody do wykonania w kontekście zabezpieczeń określonej metody.  
  
 [!code-csharp[System.Security.SecurityContext.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecurityContext.Run/CS/form1.cs#1)]
 [!code-vb[System.Security.SecurityContext.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecurityContext.Run/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="securityContext" /> jest <see langword="null" />.  - lub - <paramref name="securityContext" /> nie uzyskano za pomocą operacji przechwytywania.  - lub - <paramref name="securityContext" /> jest już używany jako argument <see cref="M:System.Security.SecurityContext.Run(System.Security.SecurityContext,System.Threading.ContextCallback,System.Object)" /> wywołania metody.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SuppressFlow">
      <MemberSignature Language="C#" Value="public static System.Threading.AsyncFlowControl SuppressFlow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.AsyncFlowControl SuppressFlow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.SuppressFlow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SuppressFlow () As AsyncFlowControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::AsyncFlowControl SuppressFlow();" />
      <MemberSignature Language="F#" Value="static member SuppressFlow : unit -&gt; System.Threading.AsyncFlowControl" Usage="System.Security.SecurityContext.SuppressFlow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.AsyncFlowControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pomija przepływ kontekstu zabezpieczeń między wątkami asynchronicznego.</summary>
        <returns>
          <see cref="T:System.Threading.AsyncFlowControl" /> Struktury do przywrócenia przepływu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pomijania przepływ <xref:System.Security.SecurityContext> informacji na temat bieżącego wątku dla operacji asynchronicznych.  
  
 Środowisko uruchomieniowe języka wspólnego (CLR) ma informacje tylko operacji personifikacji wykonywane przy użyciu kodu zarządzanego. Środowisko CLR nie ma informacji o personifikacji wykonywane poza kodu zarządzanego, takich jak platforma wywołuje do kodu niezarządzanego, który wykonuje Personifikacja lub za pośrednictwem wywołania funkcji Win32. Tożsamość przepływ między punktami asynchroniczne, należy użyć zarządzanej <xref:System.Security.Principal.WindowsIdentity> i <xref:System.Security.Principal.WindowsImpersonationContext> metody.  
  
 Użyj <xref:System.Threading.AsyncFlowControl.Undo%2A> metody w zwróconym <xref:System.Threading.AsyncFlowControl> struktury do zwrócenia <xref:System.Security.SecurityContext> obiektu do jego poprzedniego stanu.  
  
 Ta metoda jest chroniony za pomocą <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> dla <xref:System.Security.Permissions.SecurityPermissionFlag.Infrastructure?displayProperty=nameWithType> uprawnienia. Składnik pełni zaufany można wywołać tę metodę, aby pominąć przepływu <xref:System.Security.SecurityContext> informacje podczas wywołania asynchronicznego. Gdy strumień jest pominięty, <xref:System.Security.SecurityContext.Capture%2A> metoda zwraca `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SuppressFlowWindowsIdentity">
      <MemberSignature Language="C#" Value="public static System.Threading.AsyncFlowControl SuppressFlowWindowsIdentity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.AsyncFlowControl SuppressFlowWindowsIdentity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityContext.SuppressFlowWindowsIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SuppressFlowWindowsIdentity () As AsyncFlowControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::AsyncFlowControl SuppressFlowWindowsIdentity();" />
      <MemberSignature Language="F#" Value="static member SuppressFlowWindowsIdentity : unit -&gt; System.Threading.AsyncFlowControl" Usage="System.Security.SecurityContext.SuppressFlowWindowsIdentity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.AsyncFlowControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pomija przepływ część tożsamości systemu Windows bieżący kontekst zabezpieczeń między wątkami asynchronicznego.</summary>
        <returns>Struktura do przywrócenia przepływu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pomijania przepływ tożsamości systemu Windows podczas <xref:System.Security.SecurityContext> migruje pomiędzy wątkami asynchronicznego.  
  
 Użyj <xref:System.Threading.AsyncFlowControl.Undo%2A> metody w zwróconym <xref:System.Threading.AsyncFlowControl> struktury do zwrócenia <xref:System.Security.SecurityContext> obiektu do jego poprzedniego stanu.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego (CLR) jest świadome personifikacji operacje wykonywane przy użyciu tylko kodu zarządzanego nie pochodzi z personifikacji realizuje poza kodu zarządzanego, takich jak platforma wywołania do kodu niezarządzanego lub poprzez bezpośrednie wywołania funkcji Win32. Tylko zarządzanego <xref:System.Security.Principal.WindowsIdentity> obiektów może przechodzić między punktami asynchroniczne, chyba że `alwaysFlowImpersonationPolicy` ustawiono element `true` (`<alwaysFlowImpersonationPolicy enabled="true"/>`). Ustawienie `alwaysFlowImpersonationPolicy` elementu `true` Określa, czy tożsamość systemu Windows zawsze przepływa między punktami asynchroniczne, niezależnie od tego, jak została wykonana personifikacji. Aby uzyskać więcej informacji na temat przechodzenia przez punkty asynchroniczne niezarządzany personifikacji, zobacz [ \<alwaysflowimpersonationpolicy — > elementu](~/docs/framework/configure-apps/file-schema/runtime/alwaysflowimpersonationpolicy-element.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
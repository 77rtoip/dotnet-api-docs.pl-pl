<Type Name="SecureString" FullName="System.Security.SecureString">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a1b83b7cb358be3a46e68daac29ed99f5f5e062e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36527818" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SecureString : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed SecureString extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecureString" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SecureString&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecureString sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type SecureString = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.SecureString</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje tekst, który powinny być poufne, takie jak, usuwając go w pamięci komputera, gdy nie są już potrzebne. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString> jest typu ciąg, który zawiera miary zabezpieczeń. Próbuje uniknąć przechowywanie potencjalnie poufnych ciągów w pamięci procesu jako zwykły tekst.  (Ograniczenia, jednak wystąpić [jak bezpieczne jest SecureString?](#HowSecure) sekcji.) Wartość wystąpienia <xref:System.Security.SecureString> jest automatycznie chronione przy użyciu mechanizmu obsługiwane przez podstawowej platformy po zainicjowaniu wystąpienia lub modyfikacji wartości. Aplikacja może renderować niezmienialne wystąpienie i uniknąć dalszych zmiany wywołując <xref:System.Security.SecureString.MakeReadOnly%2A> metody.  
  
 Maksymalna długość <xref:System.Security.SecureString> wystąpienia wynosi 65 536 znaków.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu za pomocą wystąpienia typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 <xref:System.Security.SecureString> Klasy i jej elementów członkowskich nie są widoczne dla modelu COM. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 W tej sekcji:  
  
 [Ciąg wersji programu vs. SecureString](#vsString)   
 [Operacje SecureString](#Ops)   
 [SecureString i międzyoperacyjne](#interop)   
 [Jak bezpieczne jest SecureString?](#HowSecure)  
  
<a name="vsString"></a>   
## <a name="string-versus-securestring"></a>Ciąg lub SecureString  
 Wystąpienie <xref:System.String?displayProperty=nameWithType> klasy jest niezmienialny i, gdy nie są już potrzebne, nie może być programowo zaplanowane do wyrzucanie elementów bezużytecznych; wystąpienia jest tylko do odczytu po utworzeniu i nie jest możliwe do przewidzenia, kiedy będzie wystąpienia usunięte z pamięci komputera. Ponieważ <xref:System.String?displayProperty=nameWithType> wystąpienia są niezmienne, operacje, które są wyświetlane, aby zmodyfikować istniejące wystąpienie faktycznie utwórz jego kopię do manipulowania. W związku z tym jeśli <xref:System.String> obiektu zawiera poufne informacje, takie jak hasła, numer karty kredytowej lub dane osobowe, istnieje ryzyko informacje mogą uzyskać dostęp, gdy jest używane, ponieważ aplikacja nie może usunąć dane z pamięci komputera .  
  
 A <xref:System.Security.SecureString> obiektu jest podobny do <xref:System.String> obiektów w tym ma wartość tekstową. Jednak wartość <xref:System.Security.SecureString> obiekt jest przypięta w pamięci, może używać mechanizm ochrony, takie jak szyfrowania, obsługiwanego przez system operacyjny, można modyfikować, dopóki aplikacja oznacza je jako tylko do odczytu i może być usunięty z pamięci komputera przy wywołaniu z aplikacji <xref:System.Security.SecureString.Dispose%2A> metody lub przez moduł zbierający elementy bezużyteczne .NET Framework.  
  
 Aby uzyskać informacje dotyczące ograniczenia <xref:System.Security.SecureString> , zobacz [jak bezpieczne SecureString jest?](#HowSecure) sekcji.  
  
 [Powrót do początku](#top)  
  
<a name="Ops"></a>   
## <a name="securestring-operations"></a>Operacje SecureString  
 <xref:System.Security.SecureString> Klasa zawiera elementy członkowskie, które umożliwiają wykonywanie następujących czynności:  
  
 Utwórz wystąpienie <xref:System.Security.SecureString> obiektu  
 Można utworzyć wystąpienia <xref:System.Security.SecureString> obiektu przez wywołanie jego konstruktora bez parametrów.  
  
 Dodawanie znaków <xref:System.Security.SecureString> obiektu  
 Można dodać jednego znaku w czasie, aby <xref:System.Security.SecureString> obiektu przez wywołanie jego <xref:System.Security.SecureString.AppendChar%2A> lub <xref:System.Security.SecureString.InsertAt%2A> metody.  
  
> [!IMPORTANT]
>  A <xref:System.Security.SecureString> obiekt nigdy nie powinien być skonstruowany na podstawie <xref:System.String>, ponieważ dane poufne już podlega konsekwencje trwałości pamięci niezmienne <xref:System.String> klasy. Najlepszym sposobem tworzenia <xref:System.Security.SecureString> obiekt jest niezarządzanego źródła znaku w czasie, takie jak <xref:System.Console.ReadKey%2A?displayProperty=nameWithType> metody.  
  
 Usuń znaki z <xref:System.Security.SecureString> obiektu  
 Można zastąpić indywidualnym przez wywołanie metody <xref:System.Security.SecureString.SetAt%2A> metody, Usuń znak poszczególnych przez wywołanie metody <xref:System.Security.SecureString.RemoveAt%2A> metody lub Usuń wszystkie znaki od <xref:System.Security.SecureString> wystąpienia przez wywołanie metody <xref:System.Security.SecureString.Clear%2A> — metoda.  
  
 Wprowadź <xref:System.Security.SecureString> obiektu tylko do odczytu  
 Po zdefiniowaniu ciąg który <xref:System.Security.SecureString> reprezentuje obiekt, należy wywołać jej <xref:System.Security.SecureString.MakeReadOnly%2A> metodę, aby oznaczyć ciąg tylko do odczytu.  
  
 Uzyskiwanie informacji <xref:System.Security.SecureString> obiektu  
 <xref:System.Security.SecureString> Klasa ma tylko dwa elementy członkowskie, które udostępniają informacje na temat ciągu: jego <xref:System.Security.SecureString.Length%2A> właściwość, która wskazuje liczbę jednostek kodu UTF16 zakodowane w ciągu; i <xref:System.Security.SecureString.IsReadOnly%2A>, metody, która wskazuje, czy to wystąpienie tylko do odczytu.  
  
 Zwolnij pamięć przydzielona programowi <xref:System.Security.SecureString> wystąpienia  
 Ponieważ <xref:System.Security.SecureString> implementuje <xref:System.IDisposable> interfejsu, zwolnij pamięci przez wywołanie metody <xref:System.Security.SecureString.Dispose%2A> metody.  
  
 <xref:System.Security.SecureString> Klasa nie ma elementów członkowskich inspekcję, porównaj lub przekonwertować wartości <xref:System.Security.SecureString>. Braku takich członków pomaga w ochronie wartość wystąpienia przed przypadkowym lub złośliwymi zagrożeń. Użyć odpowiednich członków grupy <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> klas, takich jak <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> metody do manipulowania wartość <xref:System.Security.SecureString> obiektu.  
  
 Biblioteka klas programu .NET Framework często używa <xref:System.Security.SecureString> wystąpień w następujący sposób:  
  
-   Aby podać informacje hasła do procesu za pomocą <xref:System.Diagnostics.ProcessStartInfo> struktury lub poprzez wywołanie przeciążenia <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> metodę, która ma parametr typu <xref:System.Security.SecureString>.  
  
-   Zapewnienie informacji o hasłach sieci przez wywołanie metody <xref:System.Net.NetworkCredential> konstruktora klasy, która ma parametr typu <xref:System.Security.SecureString> lub za pomocą <xref:System.Net.NetworkCredential.SecurePassword%2A?displayProperty=nameWithType> właściwości.  
  
-   Aby podać informacje hasło dla uwierzytelniania programu SQL Server przez wywołanie metody <xref:System.Data.SqlClient.SqlCredential.%23ctor%2A?displayProperty=nameWithType> konstruktora lub pobierania wartości <xref:System.Data.SqlClient.SqlCredential.Password%2A?displayProperty=nameWithType> właściwości.  
  
-   Aby przekazać ciąg do kodu niezarządzanego. Aby uzyskać więcej informacji, zobacz [SecureString i międzyoperacyjnego](#interop) sekcji.  
  
 [Powrót do początku](#top)  
  
<a name="interop"></a>   
## <a name="securestring-and-interop"></a>SecureString i międzyoperacyjne  
 Ponieważ system operacyjny nie obsługuje bezpośrednio <xref:System.Security.SecureString>, należy przekonwertować wartość <xref:System.Security.SecureString> obiektu na typ ciągu wymagana przed przekazaniem ciąg do metody natywnej.  <xref:System.Runtime.InteropServices.Marshal> Klasa ma pięć metod, które w tym:  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>, która konwertuje <xref:System.Security.SecureString> ciągu wartości ciągu binarnego (BSTR) rozpoznawany przez modelu COM.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType> i <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>, których kopia <xref:System.Security.SecureString> wartość na ciąg ANSI w pamięci niezarządzanej ciągu.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType> i <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>, których kopia <xref:System.Security.SecureString> wartość na ciąg Unicode w pamięci niezarządzanej ciągu.  
  
 Każda z tych metod tworzy ciąg zwykłego tekstu w pamięci niezarządzanej. Jest odpowiedzialny za deweloperowi zero wychodzących i zwolnić pamięć tego, jak jest już potrzebne. Każdej z metod alokacji konwersji i pamięć ciąg ma odpowiedniej metody do zera limit oraz o wolnym alokacji pamięci:  
  
|Metoda alokacji i konwersji|Zero i free — metoda|  
|--------------------------------------|--------------------------|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A?displayProperty=nameWithType>|  
  
 [Powrót do początku](#top)  
  
<a name="HowSecure"></a>   
## <a name="how-secure-is-securestring"></a>Jak bezpieczne jest SecureString?  
 Podczas tworzenia prawidłowo, <xref:System.Security.SecureString> wystąpienia chroni więcej danych niż <xref:System.String>. Podczas tworzenia ciąg ze źródła znaku w czasie <xref:System.String> tworzy wiele obiektów w pamięci, podczas gdy <xref:System.Security.SecureString> tworzy tylko jedno wystąpienie.  Wyrzucanie elementów bezużytecznych z <xref:System.String> obiektów jest deterministyczna. Ponadto, ponieważ jego pamięci nie jest przypięty, moduł zbierający elementy bezużyteczne spowoduje dodatkowych kopii <xref:System.String> wartości po przenoszenie i kompaktowanie pamięci. Z kolei ilość pamięci przydzielona do <xref:System.Security.SecureString> obiektu jest przypięty i pamięci, może zostać zwolniony przez wywołanie metody <xref:System.Security.SecureString.Dispose%2A> metody.  
  
 Mimo że dane przechowywane w <xref:System.Security.SecureString> wystąpienia jest bezpieczniejsza niż dane przechowywane w <xref:System.String> wystąpienia, występują znaczne ograniczenia w sposób bezpieczny <xref:System.Security.SecureString> wystąpienie jest. Należą do nich następujące elementy:  
  
 Platforma  
 W systemie operacyjnym Windows, zawartość <xref:System.Security.SecureString> tablicy znaków wewnętrzny instancji są szyfrowane. Jednak czy ze względu na Brak interfejsów API lub problemy dotyczące zarządzania kluczami, szyfrowanie nie jest dostępne na wszystkich platformach. Ze względu na tę zależność platformy <xref:System.Security.SecureString> nie szyfruje wewnętrznej pamięci masowej na platformie z systemem innym niż Windows. Innych technik są używane na tych platformach w celu zapewnienia dodatkowej ochrony.
  
 Czas trwania  
 Nawet jeśli <xref:System.Security.SecureString> implementacji jest w stanie korzystać z szyfrowania, zwykły tekst przypisany do <xref:System.Security.SecureString> wystąpienie może zostać uwidoczniona w różnym czasie:  
  
-   Ponieważ system Windows nie oferują implementacji bezpieczny ciąg, na poziomie systemu operacyjnego, programu .NET Framework jest nadal ma można przekonwertować wartości bezpieczny ciąg do jej reprezentacji w postaci zwykłego tekstu, aby można było go używać.  
  
-   Zawsze, gdy wartość bezpieczny ciąg jest modyfikowana za pomocą metod takich jak <xref:System.Security.SecureString.AppendChar%2A> lub <xref:System.Security.SecureString.RemoveAt%2A>, musi być odszyfrowane (tj. przekonwertowany z powrotem na zwykły tekst), modyfikować i ponownie szyfrowane.  
  
-   Jeśli bezpieczny ciąg jest używany w wywołaniu międzyoperacyjnego, muszą zostać skonwertowane do ciągu ANSI, ciąg Unicode lub ciąg binarny (BSTR). Aby uzyskać więcej informacji, zobacz [SecureString i międzyoperacyjnego](#interop) sekcji.  
  
 Przedział czasu, dla którego <xref:System.Security.SecureString> wartość wystąpienia jest widoczna tylko jest skrócona, w porównaniu z <xref:System.String> klasy.  
  
 Porównanie użycia magazynów  
 Ogólnie rzecz biorąc <xref:System.Security.SecureString> klasa definiuje mechanizm magazynu wartości ciągów, które powinny być chronione lub poufne. Poza .NET Framework sam mechanizm użycia obsługuje jednak <xref:System.Security.SecureString>. Oznacza to, że bezpieczny ciąg muszą zostać skonwertowane do użytecznej postaci (zwykle w postaci zwykłego tekstu), który może zostać rozpoznany przez jego obiekt docelowy i że odszyfrowywania i konwersji musi przypadać w przestrzeni.  
  
 Ogólne <xref:System.Security.SecureString> jest bezpieczniejsza niż <xref:System.String> ponieważ ogranicza ujawnienia danych poufnych ciągu. Jednak te ciągi nadal mogą być narażone na proces ani operacja, która ma dostęp do pamięci, takich jak złośliwe procesu uruchomionego na komputerze-hoście, zrzutu procesu lub plik wymiany widoczny dla użytkownika. Zamiast <xref:System.Security.SecureString> do ochrony haseł, zalecaną alternatywą jest użycie nieprzezroczystego uchwyt poświadczenia, które są przechowywane poza procesem.  
  
 [Powrót do początku](#top)  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Security.SecureString> do bezpiecznego hasła użytkownika do użycia jako poświadczenie, aby uruchomić nowego procesu.  
  
 [!code-csharp[System.Security.SecureString.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/ctor4.cs#4)]
 [!code-vb[System.Security.SecureString.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor4.vb#4)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
    <altmember cref="T:System.Runtime.InteropServices.Marshal" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
    <altmember cref="T:System.IDisposable" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.SecureString" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.SecureString" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto wartość domyślna (lub bez parametrów) konstruktora, aby utworzyć obiekt klasy <xref:System.Security.SecureString> obiektu. Następnie wywołuje <xref:System.Security.SecureString.AppendChar%2A> metody, aby dodać do tablicy znaków.  
  
 [!code-cpp[System.Security.SecureString.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor2.cpp#2)]
 [!code-csharp[System.Security.SecureString.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor2.cs#2)]
 [!code-vb[System.Security.SecureString.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor2.vb#2)]  
  
 Poniższy przykład tworzy <xref:System.Security.SecureString> obiekt z wartością <xref:System.String> obiektu.  
  
 [!code-cpp[System.Security.SecureString.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor3.cpp#3)]
 [!code-csharp[System.Security.SecureString.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor3.cs#3)]
 [!code-vb[System.Security.SecureString.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/Ctor3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego wystąpienia.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana na tej platformie.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString (char* value, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString(char* value, int length);" />
      <MemberSignature Language="F#" Value="new System.Security.SecureString : nativeptr&lt;char&gt; * int -&gt; System.Security.SecureString" Usage="new System.Security.SecureString (value, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy <see cref="T:System.Char" /> obiektów.</param>
        <param name="length">Liczba elementów <c>wartość</c> do uwzględnienia w tym nowym wystąpieniu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.SecureString" /> klasy z subarray z <see cref="T:System.Char" /> obiektów.  Ten konstruktor nie jest zgodny ze specyfikacją CLS. Alternatywnym, zgodnym ze specyfikacją CLS jest <see cref="M:System.Security.SecureString.#ctor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.Security.SecureString> obiekt, aby liczba znaków w `value` określonego przez `length`; wartość wystąpienia jest następnie szyfrowany.  
  
 W języku C# ten konstruktor jest zdefiniowany tylko w kontekście niebezpieczny kod.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Security.SecureString> obiektu przez przekazanie jej konstruktora wskaźnika do tablicy znaków.  
  
 [!code-cpp[System.Security.SecureString.Ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cpp/ctor1.cpp#1)]
 [!code-csharp[System.Security.SecureString.Ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cs/ctor1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza niż zero lub większy niż 65 536.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego ciągu bezpiecznego.</exception>
        <exception cref="T:System.NotSupportedException">Ta operacja nie jest obsługiwana na tej platformie.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendChar">
      <MemberSignature Language="C#" Value="public void AppendChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.AppendChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendChar (c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendChar(char c);" />
      <MemberSignature Language="F#" Value="member this.AppendChar : char -&gt; unit" Usage="secureString.AppendChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Znak do dołączenia do tego ciągu bezpiecznego.</param>
        <summary>Dołącza znak na końcu aktualnie bezpiecznego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli implementacja używa mechanizmu ochrony, takimi jak szyfrowanie, wartość ta bezpieczny ciąg, jeśli istnieje, nie jest chroniony; `c` jest dołączany; nowa wartość bezpieczny ciąg jest ponownego włączenia jego ochrony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, i <xref:System.Security.SecureString.Clear%2A> metod na wartość <xref:System.Security.SecureString> obiektu.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A> i <xref:System.Security.SecureString.RemoveAt%2A> metody może służyć do zbierania znaków w haśle.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Ten ciąg bezpieczny jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wykonanie tej operacji spowodowałoby, długość to bezpieczny ciąg przekracza 65 536 znaków.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego ciągu bezpiecznego.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="secureString.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wartość bieżącego bezpieczny ciąg.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mają być wyzerowane pamięci komputera, która zawiera wartość to bezpieczny ciąg, a następnie długość wartości to bezpieczny ciąg ma wartość zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, i <xref:System.Security.SecureString.Clear%2A> metod na wartość <xref:System.Security.SecureString> obiektu.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Ten ciąg bezpieczny jest tylko do odczytu.</exception>
        <altmember cref="P:System.Security.SecureString.Length" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecureString Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecureString ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Security.SecureString" Usage="secureString.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego bezpieczny ciąg.</summary>
        <returns>Duplikat tego ciągu bezpiecznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienie <xref:System.Security.SecureString> jest oznaczony jako tylko do odczytu, kopię tego wystąpienia nie będzie tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego ciągu bezpiecznego.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="secureString.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące <see cref="T:System.Security.SecureString" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString.Dispose%2A> Metoda zapisuje binarne zer alokacji pamięci, który zawiera wartość tego <xref:System.Security.SecureString> obiektu, a następnie zwalnia alokacji pamięci.  
  
 Aby uzyskać więcej informacji, zobacz [wyrzucanie elementów bezużytecznych](~/docs/standard/garbage-collection/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public void InsertAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.InsertAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : int * char -&gt; unit" Usage="secureString.InsertAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Gdzie umieścić indeks parametru <c>c</c> dodaje się.</param>
        <param name="c">Znak do wstawienia.</param>
        <summary>Wstawia znak w tym bezpiecznego ciągu w miejscu określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks jest liczony od zera; pierwszy znak w tym bezpieczny ciąg jest na pozycji indeksu zero.  
  
 Jeśli implementacja używa mechanizmu ochrony, takimi jak szyfrowanie, wartość bezpieczny ciąg, jeśli istnieje, nie jest chroniony; `c` dodaje się na pozycji indeksu określonego; nowa wartość jest ponownego włączenia jego ochrony. <xref:System.Security.SecureString.InsertAt%2A> Metody daje takie same wyniki jak <xref:System.Security.SecureString.AppendChar%2A> metodę, która wstawia znak na końcu bezpieczny ciąg, jeśli `index` parametr <xref:System.Security.SecureString.InsertAt%2A> jest równa długości tego wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, i <xref:System.Security.SecureString.Clear%2A> metod na wartość <xref:System.Security.SecureString> obiektu.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Ten ciąg bezpieczny jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera, lub większa niż długość tego ciągu bezpiecznego.  - lub - wykonanie tej operacji będzie długość to bezpieczny ciąg przekracza 65 536 znaków.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego ciągu bezpiecznego.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function IsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : unit -&gt; bool" Usage="secureString.IsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy to bezpieczny ciąg jest oznaczony jako tylko do odczytu.</summary>
        <returns>
          <see langword="true" /> Jeśli ten ciąg bezpieczny jest oznaczony jako tylko do odczytu. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wystąpieniu <xref:System.Security.SecureString> jest oznaczony jako tylko do odczytu przez <xref:System.Security.SecureString.MakeReadOnly%2A> metody próby zmodyfikuj wartość zgłasza wystąpienia <xref:System.InvalidOperationException>. Użyj <xref:System.Security.SecureString.IsReadOnly%2A> metody do testowania czy <xref:System.Security.SecureString> jest tylko do odczytu, przed podjęciem próby zmodyfikowania go.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecureString.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Security.SecureString.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę znaków w bieżącym bezpieczny ciąg.</summary>
        <value>Liczba <see cref="T:System.Char" /> obiektów w tym bezpiecznego ciągu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString.Length%2A> Właściwość zwraca liczbę <xref:System.Char> obiektów w tym wystąpieniu, nie liczbę znaków Unicode. Znak Unicode może być reprezentowany przez więcej niż jedną <xref:System.Char> obiektu.  
  
 Maksymalna długość <xref:System.Security.SecureString> wystąpienia wynosi 65 536 znaków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.MakeReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly();" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : unit -&gt; unit" Usage="secureString.MakeReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wartość tekstu tego bezpieczny ciąg tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicjowanie wartości tekstowej wystąpienia <xref:System.Security.SecureString> klasy z <xref:System.Security.SecureString.%23ctor%2A> konstruktory i zmodyfikuj wartości z <xref:System.Security.SecureString.Clear%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, <xref:System.Security.SecureString.InsertAt%2A>, i <xref:System.Security.SecureString.AppendChar%2A> metody.  
  
 Po dokonaniu końcowego modyfikacje, użyj <xref:System.Security.SecureString.MakeReadOnly%2A> metodę, aby wprowadzić wartość wystąpienia niezmienne (tylko do odczytu). Po wartość został oznaczony jako tylko do odczytu, dalsze próby go zmodyfikować zgłasza <xref:System.InvalidOperationException>.  
  
 Efekt wywoływania <xref:System.Security.SecureString.MakeReadOnly%2A> jest trwały ponieważ <xref:System.Security.SecureString> klasa udostępnia sposób stał bezpieczny ciąg można modyfikować. Użyj <xref:System.Security.SecureString.IsReadOnly%2A> metody, aby sprawdzić, czy wystąpienie <xref:System.Security.SecureString> jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A> i <xref:System.Security.SecureString.RemoveAt%2A> metody może służyć do zbierania znaków w haśle. Po zebraniu hasło staje się tylko do odczytu.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="secureString.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks znaków w tym ciągu bezpiecznego.</param>
        <summary>Usuwa znak na pozycji indeksu określony ciąg bezpieczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks jest liczony od zera; pierwszy znak w tym wystąpieniu jest na pozycji indeksu zero.  
  
 Jeśli implementacja używa mechanizmu ochrony, takimi jak szyfrowanie, wartość ta bezpieczny ciąg, jeśli istnieje, nie jest chroniony; znak na pozycji określony indeks zostanie usunięta; Nowa wartość jest następnie ponownego włączenia jego ochrony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, i <xref:System.Security.SecureString.Clear%2A> metod na wartość <xref:System.Security.SecureString> obiektu.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A> i <xref:System.Security.SecureString.RemoveAt%2A> metody może służyć do zbierania znaków w haśle.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Ten ciąg bezpieczny jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie może być większa niż zero, lub większa niż długość to bezpieczny ciąg.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego ciągu bezpiecznego.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAt">
      <MemberSignature Language="C#" Value="public void SetAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.SetAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.SetAt : int * char -&gt; unit" Usage="secureString.SetAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Indeks istniejącego znaku w tym ciągu bezpiecznego</param>
        <param name="c">Znak, który zastępuje istniejący znak.</param>
        <summary>Zamienia istniejący znak na pozycji indeksu określonego innego znaku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks jest liczony od zera; pierwszy znak w tym wystąpieniu jest na pozycji indeksu zero.  
  
 Jeśli implementacja używa mechanizmu ochrony, takimi jak szyfrowanie, wartość bezpieczny ciąg, jeśli istnieje, nie jest chroniony; `c` jest przypisana do położenia w określonym indeksie; nowa wartość jest ponownego włączenia jego ochrony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, i <xref:System.Security.SecureString.Clear%2A> metod na wartość <xref:System.Security.SecureString> obiektu.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">To bezpieczny ciąg został już usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Ten ciąg bezpieczny jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie może być większa niż zero, lub większa niż długość to bezpieczny ciąg.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wystąpił błąd podczas ochrony lub wyłączenie wartość tego ciągu bezpiecznego.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
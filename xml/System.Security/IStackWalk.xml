<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1eaa08d07e66ac33a9918473cbffbf7ad349aac6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39864328" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="61500-101">Zarządza przeszukiwania stosu, która określa, czy wszystkie obiekty wywołujące w stosie wywołań ma wymaganych uprawnień dostępu do chronionego zasobu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="61500-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61500-102">Częściowo zaufany kod zawsze stanowi zagrożenie dla bezpieczeństwa.</span><span class="sxs-lookup"><span data-stu-id="61500-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="61500-103">Czasami manipulacji do wykonania czynności w imieniu złośliwy kod, który nie ma uprawnień dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="61500-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="61500-104">W ten sposób złośliwy kod może osiągnąć wyższy dostępu zabezpieczeń nie powinien być dozwolony.</span><span class="sxs-lookup"><span data-stu-id="61500-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="61500-105">Środowisko uruchomieniowe języka wspólnego pomaga w ochronie kodu zarządzanego z te ataki, uruchamiając przeszukiwania stosu dla wszystkich wywołań.</span><span class="sxs-lookup"><span data-stu-id="61500-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="61500-106">Przeszukiwania stosu wymaga, że cały kod w stosie wywołań ma uprawnienie do dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="61500-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="61500-107">Ponieważ kod próby ataku zawsze będzie zawarty w stosie wywołań, będzie mogła przekroczyć własnych uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="61500-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="61500-108">Potwierdza kod wywołujący dostęp zasobu wskazywanego przez bieżący obiekt uprawnienia, nawet wtedy, gdy wyżej w stosie wywołań nie przyznano uprawnień dostępu do zasobu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61500-109">Wywoływanie <xref:System.Security.IStackWalk.Assert%2A> zatrzymuje sprawdzenie uprawnień na obiekty wywołujące wyżej w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="61500-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="61500-110">W związku z tym nawet jeśli te obiekty wywołujące nie masz wymaganych uprawnień, ich mogą nadal uzyskiwać dostęp do zasobów.</span><span class="sxs-lookup"><span data-stu-id="61500-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="61500-111">Potwierdzenie obowiązuje tylko wtedy, gdy kod wywołuje <xref:System.Security.IStackWalk.Assert%2A> przekazuje sprawdzenia zabezpieczeń dla uprawnień, że jest ona potwierdzające.</span><span class="sxs-lookup"><span data-stu-id="61500-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="61500-112">Wywołanie <xref:System.Security.IStackWalk.Assert%2A> jest efektywne, dopóki kod wywołujący powróci do obiektu wywołującego lub do momentu kolejne wywołanie <xref:System.Security.IStackWalk.Assert%2A> renderuje potwierdzenia poprzedniej nieefektywne.</span><span class="sxs-lookup"><span data-stu-id="61500-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="61500-113">Ponadto <xref:System.Security.CodeAccessPermission.RevertAssert%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> usuwa oczekujące <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="61500-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="61500-114"><xref:System.Security.IStackWalk.Assert%2A> jest ignorowany dla uprawnień nie udzielić, ponieważ żądanie dla tego uprawnienia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="61500-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="61500-115">Jednak jeśli niżej w stosie wywołań kod wywołuje <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest zgłaszany, gdy przeszukiwania stosu osiągnie kod, który próbowano wywołania <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="61500-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="61500-116">Dzieje się tak, ponieważ kod, który wywołuje <xref:System.Security.IStackWalk.Assert%2A> nie udzielono uprawnień, mimo że aplikacja próbowała <xref:System.Security.IStackWalk.Assert%2A> go.</span><span class="sxs-lookup"><span data-stu-id="61500-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="61500-117">Ponieważ wywołanie <xref:System.Security.IStackWalk.Assert%2A> usuwa wymóg, że wszystkie możesz pisać kod w łańcuch wywołań muszą mieć uprawnienie dostępu do określonego zasobu, można otworzyć się luk w zabezpieczeniach, jeśli niepoprawnie lub niewłaściwie.</span><span class="sxs-lookup"><span data-stu-id="61500-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="61500-118">W związku z tym należy używać ostrożnie doskonałe.</span><span class="sxs-lookup"><span data-stu-id="61500-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="61500-119">Kod wywołujący nie ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="61500-120">Określa w czasie wykonywania, czy wszystkie obiekty wywołujące w stosie wywołań przyznano uprawnienia określone przez bieżący obiekt uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-120">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61500-121">Ta metoda jest zwykle używana przez bezpieczne biblioteki, aby upewnić się, że obiekty wywołujące ma uprawnienia do uzyskania dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="61500-121">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="61500-122">Na przykład wywołuje klasę pliku w bibliotece bezpiecznych klasy <xref:System.Security.IStackWalk.Demand%2A> dla niezbędnych <xref:System.Security.Permissions.FileIOPermission> przed przystąpieniem do wykonywania operacji na pliku żądanego przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="61500-122">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="61500-123">Uprawnienia kod, który wywołuje tę metodę, nie będą badane; Sprawdzanie zaczyna się od bezpośredniego obiektu wywołującego kod i przechodzi w górę stosu.</span><span class="sxs-lookup"><span data-stu-id="61500-123">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="61500-124"><xref:System.Security.IStackWalk.Demand%2A> powiedzie się tylko wtedy, gdy nie <xref:System.Security.SecurityException> jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="61500-124"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="61500-125">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia określone przez bieżący obiekt uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-125">A caller higher in the call stack does not have the permission specified by the current permission object.</span>
          </span>
          <span data-ttu-id="61500-126">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-126">-or-</span>
          </span>
          <span data-ttu-id="61500-127">Obiekt wywołujący na stosie wywołań została wywołana <see cref="M:System.Security.IStackWalk.Deny" /> dla bieżącego obiektu uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-127">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="61500-128">Powoduje, że każdy <see cref="M:System.Security.IStackWalk.Demand" /> dla bieżącego obiektu, który przechodzi przez kod wywołujący, aby zakończyć się niepowodzeniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-128">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61500-129">Ta metoda uniemożliwia wywołującym wyżej w stosie wywołań uzyskiwania dostępu do chronionego zasobu za pomocą kodu, który wywołuje tę metodę, nawet wtedy, gdy te obiekty wywołujące przyznano uprawnienia dostępu do niego.</span><span class="sxs-lookup"><span data-stu-id="61500-129">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="61500-130">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="61500-130">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="61500-131"><xref:System.Security.IStackWalk.Deny%2A> można ograniczyć odpowiedzialność programisty lub pomagają zapobiegać luk w zabezpieczeniach przypadkowe, ponieważ zapobiega metodę, która wywołuje <xref:System.Security.IStackWalk.Deny%2A> używany w celu dostępu do zasobów chronionych przez odmowy uprawnień.</span><span class="sxs-lookup"><span data-stu-id="61500-131"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="61500-132">Wywołuje metodę <xref:System.Security.IStackWalk.Deny%2A> na uprawnienia i jeśli <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia, zostanie wywołany przez obiekt wywołujący niżej w stosie wywołań, sprawdzanie zabezpieczeń nie powiedzie się po osiągnięciu <xref:System.Security.IStackWalk.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="61500-132">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="61500-133"><xref:System.Security.IStackWalk.Deny%2A> jest ignorowany dla uprawnień nie udzielić, ponieważ żądanie dla tego uprawnienia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="61500-133"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="61500-134">
            <para>Nie można przesłonić tę metodę.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-134">
              <para>You cannot override this method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="61500-135">Powoduje, że każdy <see cref="M:System.Security.IStackWalk.Demand" /> dla wszystkich obiektów z wyjątkiem bieżącym przechodzący przez kod wywołujący, aby zakończyć się niepowodzeniem, nawet wtedy, gdy kod wyżej w stosie wywołań ma uprawnienia dostępu do innych zasobów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61500-135">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61500-136"><xref:System.Security.IStackWalk.PermitOnly%2A> jest podobny do <xref:System.Security.IStackWalk.Deny%2A>, oba powodują przeszukiwań stosu niepowodzeniem, jeśli w przeciwnym razie powiedzie.</span><span class="sxs-lookup"><span data-stu-id="61500-136"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="61500-137">Różnica jest to, że <xref:System.Security.IStackWalk.Deny%2A> określa uprawnienia, które spowoduje przejście przez stos zakończyć się niepowodzeniem, ale <xref:System.Security.IStackWalk.PermitOnly%2A> określa tylko uprawnienia, które nie powodują przejście przez stos nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="61500-137">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="61500-138">Wywołaj tę metodę, aby upewnić się, że Twój kod może służyć do dostępu do określonych zasobów.</span><span class="sxs-lookup"><span data-stu-id="61500-138">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="61500-139"><xref:System.Security.IStackWalk.PermitOnly%2A> jest ignorowany dla uprawnień nie udzielić, ponieważ żądanie dla tego uprawnienia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="61500-139"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="61500-140">Jednak jeśli kod niżej w wywołanie stosu później wywołania <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest zgłaszany, gdy przeszukiwania stosu osiągnie kod, który próbowano wywołania <xref:System.Security.IStackWalk.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="61500-140">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="61500-141">Jest to spowodowane kod, który wywołuje <xref:System.Security.IStackWalk.PermitOnly%2A> nie udzielono uprawnień, mimo że ona wywoływana <xref:System.Security.IStackWalk.PermitOnly%2A> dla tego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="61500-141">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="61500-142">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="61500-142">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
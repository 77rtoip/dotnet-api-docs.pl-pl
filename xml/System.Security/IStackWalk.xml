<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50cee1b779f4bf3586b066ea45f3b7cac364420b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36623134" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zarządza przeszukiwania stosu, który określa, czy wszystkie obiekty wywołujące w stosie wywołań ma uprawnienia wymagane do uzyskania dostępu do chronionego zasobu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Częściowo zaufany kod zawsze stanowi zagrożenie bezpieczeństwa. Czasami manipulacji do wykonywania zadań w imieniu złośliwy kod, który nie ma uprawnień do uzyskania dostępu do zasobu. W ten sposób złośliwego kodu można osiągnąć wyższy dostępu zabezpieczeń nie powinno być dozwolone.  
  
 Środowisko uruchomieniowe języka wspólnego pomaga w ochronie kodu zarządzanego z takiego ataku, uruchamiając przeszukiwania stosu dla wszystkich wywołań. Podczas przeszukiwana stosu wymaga czy całego kodu w stosie wywołań ma uprawnienie dostępu do chronionego zasobu. Ponieważ kod próby ataku zawsze będzie gdzieś w stosie wywołań, będzie mogła przekroczyć własnych uprawnień zabezpieczeń.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Potwierdza, że kod wywołujący ma dostęp do zasobu identyfikowana na podstawie bieżącego obiektu uprawnienia, nawet wtedy, gdy wyżej w stosie wywołań nie przyznano uprawnień dostępu do zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Security.IStackWalk.Assert%2A> zatrzymuje sprawdzenie uprawnień na obiekty wywołujące wyżej w stosie wywołań. W związku z tym nawet jeśli te obiekty wywołujące nie ma wymaganych uprawnień, ich mogą nadal uzyskiwać dostęp do zasobów. Potwierdzenia jest efektywne tylko wtedy, gdy kod, który wywołuje <xref:System.Security.IStackWalk.Assert%2A> przekazuje kontrola zabezpieczeń dla uprawnień, który jest ona potwierdzające.  
  
 Wywołanie <xref:System.Security.IStackWalk.Assert%2A> obowiązuje, dopóki kod wywołujący nie powróci do swojego obiektu wywołującego lub do czasu kolejne wywołanie <xref:System.Security.IStackWalk.Assert%2A> renderuje potwierdzenia poprzedniej żadnego efektu. Ponadto <xref:System.Security.CodeAccessPermission.RevertAssert%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> usuwa oczekujące <xref:System.Security.IStackWalk.Assert%2A>.  
  
 <xref:System.Security.IStackWalk.Assert%2A> jest ignorowany dla uprawnienia nie udzielić, ponieważ nie powiedzie się żądanie dla tego uprawnienia. Jednak jeśli niższy w stosie wywołań kod wywołuje <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest generowany, gdy kod, który próbowano nawiązać połączenie osiągnie przeszukiwania stosu <xref:System.Security.IStackWalk.Assert%2A>. Dzieje się tak, ponieważ kod, który wywołuje <xref:System.Security.IStackWalk.Assert%2A> nie udzielono uprawnień, mimo że próby <xref:System.Security.IStackWalk.Assert%2A> go.  
  
> [!CAUTION]
>  Ponieważ wywoływanie <xref:System.Security.IStackWalk.Assert%2A> usuwa wymaganie, że wszystkie kodu w łańcuchu wywołań musi mieć uprawnienie dostępu do określonego zasobu, można go otwarcie luk w zabezpieczeniach użycie nieprawidłowo lub niewłaściwie. W związku z tym należy można używać z dużą ostrożność.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod wywołujący nie ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa w czasie wykonywania, czy wszystkie obiekty wywołujące w stosie wywołań przyznano uprawnienia określone przez bieżący obiekt uprawnień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana zazwyczaj przez bezpieczne biblioteki, aby upewnić się, że obiekty wywołujące ma uprawnienia do uzyskania dostępu do zasobu. Na przykład wywołuje klasy pliku w bibliotece klas bezpiecznego <xref:System.Security.IStackWalk.Demand%2A> dla niezbędnych <xref:System.Security.Permissions.FileIOPermission> przed wykonaniem operacji na pliku żądanego przez obiekt wywołujący.  
  
 Uprawnienia kod, który wywołuje tę metodę, nie są sprawdzane; Sprawdzanie zaczyna się od bezpośredniego obiektu wywołującego kodu i jest przeprowadzane w górę stosu. <xref:System.Security.IStackWalk.Demand%2A> powiedzie się tylko wtedy, gdy nie <xref:System.Security.SecurityException> jest wywoływane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia określone przez bieżący obiekt uprawnień.  - lub - została wywołana przez obiekt wywołujący na stosie wywołań <see cref="M:System.Security.IStackWalk.Deny" /> dla bieżącego obiektu uprawnienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że każdy <see cref="M:System.Security.IStackWalk.Demand" /> dla bieżącego obiektu, który przechodzi przez kod wywołujący się niepowodzeniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda uniemożliwia dostęp do chronionych zasobów za pośrednictwem kod, który wywołuje tę metodę, nawet w przypadku tych wywołań przyznano uprawnień dostępu do niego wywołań wyżej w stosie wywołań. Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.  
  
 <xref:System.Security.IStackWalk.Deny%2A> można ograniczyć odpowiedzialność programisty lub pomagać w zapobieganiu luk w zabezpieczeniach przypadkowe, ponieważ uniemożliwia metodę, która wywołuje <xref:System.Security.IStackWalk.Deny%2A> z zasobów chronionych przez odmówiono uprawnień dostępu do użycia. Wywołuje metodę <xref:System.Security.IStackWalk.Deny%2A> na uprawnienia, a jeśli <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia jest wywoływany przez obiekt wywołujący niższe w stosie wywołań, sprawdzanie zabezpieczeń zakończy się niepowodzeniem, po osiągnięciu <xref:System.Security.IStackWalk.Deny%2A>.  
  
 <xref:System.Security.IStackWalk.Deny%2A> jest ignorowany dla uprawnienia nie udzielić, ponieważ nie powiedzie się żądanie dla tego uprawnienia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Nie można przesłonić tę metodę.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że każdy <see cref="M:System.Security.IStackWalk.Demand" /> dla wszystkich obiektów z wyjątkiem aktualny plan, który przechodzi przez kod wywołujący się niepowodzeniem, nawet jeśli kodu w stosie wywołań ma uprawnienia dostępu do innych zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> przypomina <xref:System.Security.IStackWalk.Deny%2A>, w tym zarówno spowodować przeszukiwań stosu się niepowodzeniem podczas ich w przeciwnym razie powiedzie się. Różnica jest to, że <xref:System.Security.IStackWalk.Deny%2A> określa uprawnienia, które spowoduje niepowodzenie przeszukiwania stosu, ale <xref:System.Security.IStackWalk.PermitOnly%2A> określa tylko uprawnienia, które nie powodują przeszukiwania stosu się niepowodzeniem. Wywołanie tej metody, aby upewnić się, że kodu można uzyskać dostępu do określonych zasobów.  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> jest ignorowany dla uprawnienia nie udzielić, ponieważ nie powiedzie się żądanie dla tego uprawnienia. Jednak jeśli kod niższe w wywołaniu później stosu wywołań <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest generowany, gdy kod, który próbowano nawiązać połączenie osiągnie przeszukiwania stosu <xref:System.Security.IStackWalk.PermitOnly%2A>. Jest to spowodowane kod, który wywołuje <xref:System.Security.IStackWalk.PermitOnly%2A> nie udzielono uprawnień, mimo że mu <xref:System.Security.IStackWalk.PermitOnly%2A> dla tego uprawnienia. Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
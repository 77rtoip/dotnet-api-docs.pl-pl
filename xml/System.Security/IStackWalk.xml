<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata><Meta Name="ms.openlocfilehash" Value="483fd0c19eb94202f890b134abe0af6b4d2336e7" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69161698" /></Metadata><TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1e839-101">Zarządza przemieszczeniem stosu, które określa, czy wszyscy wywołujący w stosie wywołań mają uprawnienia wymagane do uzyskiwania dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="1e839-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e839-102">Częściowo zaufany kod zawsze stanowi zagrożenie bezpieczeństwa.</span><span class="sxs-lookup"><span data-stu-id="1e839-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="1e839-103">Czasami może być manipulowany przez wykonywanie akcji w imieniu złośliwego kodu, który nie ma uprawnień dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="1e839-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="1e839-104">W ten sposób złośliwy kod może uzyskać wyższy dostęp do zabezpieczeń niż powinien być dozwolony.</span><span class="sxs-lookup"><span data-stu-id="1e839-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="1e839-105">Środowisko uruchomieniowe języka wspólnego pomaga chronić kod zarządzany przed atakami przez uruchomienie przechodzenia stosu na wszystkie wywołania.</span><span class="sxs-lookup"><span data-stu-id="1e839-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="1e839-106">Przechodzenie stosu wymaga, aby cały kod w stosie wywołań miał uprawnienia dostępu do chronionego zasobu.</span><span class="sxs-lookup"><span data-stu-id="1e839-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="1e839-107">Ponieważ kod próbujący atak był zawsze gdzieś w stosie wywołań, nie będzie można przekroczyć własnych uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="1e839-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e839-108">Potwierdza, że kod wywołujący może uzyskać dostęp do zasobu identyfikowanego przez bieżący obiekt uprawnień, nawet jeśli obiekty wywołujące wyższe w stosie nie uzyskały uprawnień dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="1e839-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e839-109">Wywołanie <xref:System.Security.IStackWalk.Assert%2A> powoduje zatrzymanie sprawdzania uprawnień dla obiektów wywołujących wyższych w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="1e839-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="1e839-110">W związku z tym nawet jeśli Ci wywołujący nie mają wymaganych uprawnień, nadal mogą uzyskać dostęp do zasobów.</span><span class="sxs-lookup"><span data-stu-id="1e839-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="1e839-111">Potwierdzenie ma zastosowanie tylko wtedy, gdy kod, który <xref:System.Security.IStackWalk.Assert%2A> wywołuje, przekazuje kontrolę zabezpieczeń dla uprawnienia, które jest potwierdzone.</span><span class="sxs-lookup"><span data-stu-id="1e839-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="1e839-112">Wywołanie <xref:System.Security.IStackWalk.Assert%2A> jest skuteczne do momentu, gdy wywoływany kod powróci do jego obiektu wywołującego lub <xref:System.Security.IStackWalk.Assert%2A> do momentu kolejnego wywołania powyższego potwierdzenia.</span><span class="sxs-lookup"><span data-stu-id="1e839-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="1e839-113"><xref:System.Security.CodeAccessPermission.RevertAssert%2A> Ponadto lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> usuwa oczekujące <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="1e839-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="1e839-114"><xref:System.Security.IStackWalk.Assert%2A>jest ignorowany dla uprawnień, które nie zostały przyznane, ponieważ żądanie tego uprawnienia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="1e839-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="1e839-115">Jeśli jednak kod niższy od wywołania <xref:System.Security.IStackWalk.Demand%2A> stosu wywołań dla tego uprawnienia <xref:System.Security.SecurityException> , jest generowany, gdy przechodzenie stosu osiągnie kod, który próbował wywołać <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="1e839-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="1e839-116">Dzieje się tak, ponieważ kod, <xref:System.Security.IStackWalk.Assert%2A> który został wywołany, nie otrzymał uprawnienia, nawet jeśli <xref:System.Security.IStackWalk.Assert%2A> próbował go.</span><span class="sxs-lookup"><span data-stu-id="1e839-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1e839-117">Ponieważ wywołanie <xref:System.Security.IStackWalk.Assert%2A> usuwa wymaganie, aby cały kod w łańcuchu wywołań musiał otrzymać uprawnienia dostępu do określonego zasobu, można otworzyć luki w zabezpieczeniach, jeśli są one używane nieprawidłowo lub niewłaściwie.</span><span class="sxs-lookup"><span data-stu-id="1e839-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="1e839-118">W związku z tym powinno być używane z dużą ostrożnością.</span><span class="sxs-lookup"><span data-stu-id="1e839-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1e839-119">Kod wywołujący nie ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span><span class="sxs-lookup"><span data-stu-id="1e839-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span></span></exception>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md"><span data-ttu-id="1e839-120">Korzystanie z metody Assert</span><span class="sxs-lookup"><span data-stu-id="1e839-120">Using the Assert Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e839-121">Określa w czasie wykonywania, czy wszystkie obiekty wywołujące w stosie wywołań mają przyznane uprawnienia określone przez bieżący obiekt uprawnień.</span><span class="sxs-lookup"><span data-stu-id="1e839-121">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e839-122">Ta metoda jest zwykle używana przez bezpieczne biblioteki w celu zapewnienia, że wywołujący mają uprawnienia dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="1e839-122">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="1e839-123">Na przykład Klasa plików w bezpiecznej bibliotece klas wywołuje <xref:System.Security.IStackWalk.Demand%2A> wymagane <xref:System.Security.Permissions.FileIOPermission> przed wykonaniem operacji na plikach zażądanej przez wywołującego.</span><span class="sxs-lookup"><span data-stu-id="1e839-123">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="1e839-124">Uprawnienia kodu, który wywołuje tę metodę, nie są badane; sprawdzenie rozpoczyna się od bezpośredniego wywołującego tego kodu i przechodzi do stosu.</span><span class="sxs-lookup"><span data-stu-id="1e839-124">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="1e839-125"><xref:System.Security.IStackWalk.Demand%2A>powiedzie się tylko wtedy <xref:System.Security.SecurityException> , gdy nie zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="1e839-125"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="1e839-126">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia określonego dla bieżącego obiektu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="1e839-126">A caller higher in the call stack does not have the permission specified by the current permission object.</span></span>  
  
<span data-ttu-id="1e839-127">—lub—</span><span class="sxs-lookup"><span data-stu-id="1e839-127">-or-</span></span> 
<span data-ttu-id="1e839-128">Obiekt wywołujący w stosie wywołań został <see cref="M:System.Security.IStackWalk.Deny" /> wywołany w bieżącym obiekcie uprawnień.</span><span class="sxs-lookup"><span data-stu-id="1e839-128">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e839-129">Powoduje, że dla bieżącego obiektu, który przechodzi przez kod wywołujący, nie powiedzie się. <see cref="M:System.Security.IStackWalk.Demand" /></span><span class="sxs-lookup"><span data-stu-id="1e839-129">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e839-130">Ta metoda uniemożliwia wywoływanie obiektów wywołujących wyższego poziomu w stosie wywołań dostępu do chronionego zasobu za pośrednictwem kodu, który wywołuje tę metodę, nawet jeśli Ci wywołujący mają uprawnienia dostępu do niej.</span><span class="sxs-lookup"><span data-stu-id="1e839-130">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="1e839-131">Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="1e839-131">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="1e839-132"><xref:System.Security.IStackWalk.Deny%2A>program może ograniczyć odpowiedzialność programisty lub zapobiec przypadkowemu występowaniu luk w zabezpieczeniach, ponieważ pomaga zapobiec metodzie, która wywołuje <xref:System.Security.IStackWalk.Deny%2A> z użycia w celu uzyskania dostępu do zasobu chronionego przez wyrzucane uprawnienie.</span><span class="sxs-lookup"><span data-stu-id="1e839-132"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="1e839-133">Jeśli metoda wywołuje <xref:System.Security.IStackWalk.Deny%2A> uprawnienie, a <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia wywoływany przez obiekt wywołujący jest niższy w stosie wywołań, sprawdzanie zabezpieczeń zakończy <xref:System.Security.IStackWalk.Deny%2A>się niepowodzeniem, gdy zostanie osiągnięty.</span><span class="sxs-lookup"><span data-stu-id="1e839-133">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="1e839-134"><xref:System.Security.IStackWalk.Deny%2A>jest ignorowany dla uprawnień, które nie zostały przyznane, ponieważ żądanie tego uprawnienia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="1e839-134"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1e839-135">Nie można zastąpić tej metody.</span><span class="sxs-lookup"><span data-stu-id="1e839-135">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e839-136">Powoduje, że dla wszystkich obiektów, z wyjątkiem bieżącego, który przechodzi przez wywoływany kod, nie powiedzie się, nawet jeśli kod wyższy w stosie wywołań przyznał uprawnienia dostępu do innych zasobów. <see cref="M:System.Security.IStackWalk.Demand" /></span><span class="sxs-lookup"><span data-stu-id="1e839-136">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e839-137"><xref:System.Security.IStackWalk.PermitOnly%2A>działa podobnie jak <xref:System.Security.IStackWalk.Deny%2A>w przypadku, gdy obie przyczyny kończą się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="1e839-137"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="1e839-138">Różnica polega na tym <xref:System.Security.IStackWalk.Deny%2A> , że określa uprawnienia, które spowodują niepowodzenie przechodzenia stosu <xref:System.Security.IStackWalk.PermitOnly%2A> , ale określa jedyne uprawnienia, które nie powodują błędów przeszukiwania stosu.</span><span class="sxs-lookup"><span data-stu-id="1e839-138">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="1e839-139">Wywołaj tę metodę, aby upewnić się, że kod może być używany w celu uzyskania dostępu tylko do określonych zasobów.</span><span class="sxs-lookup"><span data-stu-id="1e839-139">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="1e839-140"><xref:System.Security.IStackWalk.PermitOnly%2A>jest ignorowany dla uprawnień, które nie zostały przyznane, ponieważ żądanie tego uprawnienia nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="1e839-140"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="1e839-141">Jeśli jednak kod niższy na stosie wywołań później wywołuje <xref:System.Security.IStackWalk.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> , jest generowany, gdy przeszukiwany stos osiągnie kod, który próbował wywołać <xref:System.Security.IStackWalk.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="1e839-141">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="1e839-142">Wynika to z faktu, że <xref:System.Security.IStackWalk.PermitOnly%2A> wywoływany kod nie otrzymał uprawnienia, nawet jeśli został wywołany <xref:System.Security.IStackWalk.PermitOnly%2A> dla tego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="1e839-142">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="1e839-143">Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="1e839-143">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

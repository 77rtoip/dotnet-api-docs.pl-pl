<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c0dc0-101">Definiuje wewnętrzna struktura wszystkich uprawnień dostępu do kodu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-101">Defines the underlying structure of all code access permissions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-102">Uprawnienia dostępu do kodu umożliwia upewnij się, że wszystkie obiekty wywołujące kodu przyznano uprawnienia przeszukiwania stosu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-102">Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</span></span> <span data-ttu-id="c0dc0-103">Jeśli obiekt uprawnienie jest `null`, jest taka sama, jak dla obiektu uprawnień ze stanem obsługiwane <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-103">If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0dc0-104">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-104">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="c0dc0-105">Dziedziczenia z <xref:System.Security.CodeAccessPermission> klasy muszą być przyznane pełne zaufanie do poprawnego działania jako rozszerzenie infrastruktury zabezpieczeń uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-105">Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure.</span></span> <span data-ttu-id="c0dc0-106">Aby określić, czy dziedziczenia są w pełni zaufany <xref:System.Security.CodeAccessPermission> problemów <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> dla <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` i <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-106">To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> = `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-107">Poniższy przykład kodu pokazuje uprawnienia pochodną <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-107">The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="c0dc0-108">Aby uzyskać możliwość dziedziczenia do Podaj dowód i wyświetlania i modyfikowania zasad.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-108">for the ability of inheritors to provide evidence and view and modify policy.</span></span> <span data-ttu-id="c0dc0-109">Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-109">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span></span></permission>
    <block subset="none" type="overrides">
      <para><span data-ttu-id="c0dc0-110">Przy dziedziczeniu z <see cref="T:System.Security.CodeAccessPermission" />, musi implementować też <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-110">When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.</span></span>  
  
 <span data-ttu-id="c0dc0-111">Następujące <see cref="T:System.Security.CodeAccessPermission" /> musi zostać zastąpiona elementów członkowskich: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, i <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-111">The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span></span>  
  
 <span data-ttu-id="c0dc0-112">Musi także definiować konstruktora przyjmującego <see cref="T:System.Security.Permissions.PermissionState" /> jako jego parametr tylko.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-112">You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.</span></span>  
  
 <span data-ttu-id="c0dc0-113">Należy najpierw zastosować <see cref="T:System.SerializableAttribute" /> do klasy, która dziedziczy atrybut <see cref="T:System.Security.CodeAccessPermission" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-113">You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</span></span></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-114">Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.CodeAccessPermission" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-114">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-115">Ten konstruktor jest wywoływana w celu zainicjowania stanu w typie, gdy tworzone jest wystąpienie klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-115">This constructor is called to initialize state in the type whenever an instance of the derived class is created.</span></span> <span data-ttu-id="c0dc0-116">Mimo że można jawnie wywołać konstruktora w deklaracji konstruktora konstruktora klasy pochodnej, nie jest to zazwyczaj konieczne; Większość kompilatorów automatycznie wygeneruje wywołania dla Ciebie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-116">Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-117">Deklaruje, że kod wywołujący może uzyskać dostępu do zasobu chroniony na żądanie uprawnień przez kod, który wywołuje tę metodę, nawet jeśli wyżej w stosie wywołań nie przyznano uprawnień dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-117">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span></span> <span data-ttu-id="c0dc0-118">Przy użyciu <see cref="M:System.Security.CodeAccessPermission.Assert" /> może spowodować problemy zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-118">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-119">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-119">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="c0dc0-120">Wywoływanie <xref:System.Security.CodeAccessPermission.Assert%2A> uniemożliwia przeszukiwania stosu, pochodzących z niższych stos wywołań z kontynuowaniem górę stosu wywołań poza kod, który wywołuje tę metodę.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-120">Calling <xref:System.Security.CodeAccessPermission.Assert%2A> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</span></span> <span data-ttu-id="c0dc0-121">W związku z tym nawet jeśli obiekty wywołujące wyżej na stosie wywołań nie ma wymaganych uprawnień do uzyskania dostępu do zasobu, one nadal do niego dostęp przez kod, który wywołuje tę metodę w niezbędnych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-121">Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</span></span> <span data-ttu-id="c0dc0-122">Potwierdzenia jest efektywne tylko wtedy, gdy kod, który wywołuje <xref:System.Security.CodeAccessPermission.Assert%2A> przekazuje kontrola zabezpieczeń dla uprawnień, który jest ona potwierdzające.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-122">An assertion is effective only if the code that calls <xref:System.Security.CodeAccessPermission.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="c0dc0-123">Wywołanie <xref:System.Security.CodeAccessPermission.Assert%2A> obowiązuje, dopóki kod wywołujący nie powróci do swojego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-123">The call to <xref:System.Security.CodeAccessPermission.Assert%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="c0dc0-124">Tylko jeden <xref:System.Security.CodeAccessPermission.Assert%2A> może być aktywne w ramce.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-124">Only one <xref:System.Security.CodeAccessPermission.Assert%2A> can be active on a frame.</span></span> <span data-ttu-id="c0dc0-125">Próba wywołania <xref:System.Security.CodeAccessPermission.Assert%2A> podczas aktywnego <xref:System.Security.CodeAccessPermission.Assert%2A> istnieje na wyniki do ramki <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-125">An attempt to call <xref:System.Security.CodeAccessPermission.Assert%2A> when an active <xref:System.Security.CodeAccessPermission.Assert%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="c0dc0-126">Wywołanie <xref:System.Security.CodeAccessPermission.RevertAssert%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> do usunięcia aktywnego <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-126">Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span>  
  
 <span data-ttu-id="c0dc0-127"><xref:System.Security.CodeAccessPermission.Assert%2A> jest ignorowany dla uprawnienia nie udzielić, ponieważ nie powiedzie się żądanie dla tego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-127"><xref:System.Security.CodeAccessPermission.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="c0dc0-128">Jednak jeśli niższy w stosie wywołań kod wywołuje <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest generowany, gdy kod, który próbowano nawiązać połączenie osiągnie przeszukiwania stosu <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-128">However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="c0dc0-129">Dzieje się tak, ponieważ kod, który wywołuje <xref:System.Security.CodeAccessPermission.Assert%2A> nie udzielono uprawnień, mimo że próby <xref:System.Security.CodeAccessPermission.Assert%2A> go.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-129">This happens because the code that called <xref:System.Security.CodeAccessPermission.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.CodeAccessPermission.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c0dc0-130">Ponieważ wywoływanie <xref:System.Security.CodeAccessPermission.Assert%2A> usuwa wymaganie, że wszystkie kodu w łańcuchu wywołań musi mieć uprawnienie dostępu do określonego zasobu, można otworzyć się problemy z zabezpieczeniami, jeśli używane nieprawidłowo lub niewłaściwie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-130">Because calling <xref:System.Security.CodeAccessPermission.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</span></span> <span data-ttu-id="c0dc0-131">W związku z tym należy można używać z dużą ostrożność.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-131">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c0dc0-132">Kod wywołujący nie ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-132">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span></span>  
  
 <span data-ttu-id="c0dc0-133">—lub—</span><span class="sxs-lookup"><span data-stu-id="c0dc0-133">-or-</span></span>  
  
 <span data-ttu-id="c0dc0-134">Istnieje już aktywny <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-134">There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0dc0-135">dla funkcji do wywołania <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-135">for the ability to call <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span></span> <span data-ttu-id="c0dc0-136">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span><span class="sxs-lookup"><span data-stu-id="c0dc0-136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span></span></permission>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-137">Nie można przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-137">You cannot override this method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-138">Po zaimplementowaniu w klasie pochodnej, tworzy i zwraca identyczne kopię bieżącego obiektu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-138">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span></span></summary>
        <returns><span data-ttu-id="c0dc0-139">Kopię bieżącego obiektu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-139">A copy of the current permission object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-140">Kopię obiektu uprawnienie reprezentuje takie same prawa dostępu do zasobów do oryginalnego obiektu uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-140">A copy of a permission object represents the same access to resources as the original permission object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-141">Poniższy przykład kodu pokazuje zastępująca <xref:System.Security.CodeAccessPermission.Copy%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-141">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method.</span></span> <span data-ttu-id="c0dc0-142">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-142">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-143">Należy przesłonić tę metodę w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-143">You must override this method in a derived class.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-144">Wymusza <see cref="T:System.Security.SecurityException" /> na czas wykonywania Jeśli wszystkim zainteresowanym wyżej w stosie wywołań nie przyznano uprawnienia określone przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-144">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-145">Ta metoda jest używana zazwyczaj przez bezpieczne biblioteki, aby upewnić się, że obiekty wywołujące ma uprawnienia do uzyskania dostępu do zasobu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-145">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="c0dc0-146">Na przykład wywołuje klasy pliku w bibliotece klas bezpiecznego <xref:System.Security.CodeAccessPermission.Demand%2A> dla niezbędnych <xref:System.Security.Permissions.FileIOPermission> przed wykonaniem operacji na pliku żądanego przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-146">For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="c0dc0-147">Uprawnienia kod, który wywołuje tę metodę, nie są sprawdzane; Sprawdzanie zaczyna się od bezpośredniego obiektu wywołującego kodu i jest przeprowadzane w górę stosu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-147">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="c0dc0-148">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-148">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="c0dc0-149"><xref:System.Security.CodeAccessPermission.Demand%2A> powiedzie się tylko wtedy, gdy nie <xref:System.Security.SecurityException> jest wywoływane.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-149"><xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c0dc0-150">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia określone przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-150">A caller higher in the call stack does not have the permission specified by the current instance.</span></span>  
  
 <span data-ttu-id="c0dc0-151">—lub—</span><span class="sxs-lookup"><span data-stu-id="c0dc0-151">-or-</span></span>  
  
 <span data-ttu-id="c0dc0-152">Obiekt wywołujący wyżej w stosie wywołań została wywołana <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącego obiektu uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-152">A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-153">Nie można przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-153">You cannot override this method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-154">Zapobiega przy użyciu kodu, który wywołuje tę metodę, aby uzyskać dostęp do zasobu określonego przez bieżące wystąpienie obiekty wywołujące wyżej w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-154">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0dc0-155"><xref:System.Security.CodeAccessPermission.Deny%2A> Metoda powinna być używana tylko w celu ochrony zasobów przed przypadkowym dostępu przez całkowicie zaufanego kodu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-155">The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="c0dc0-156">Nie ją stosować do ochrony zasobów przed niewłaściwym użyciem zamierzone w kodzie niezaufanym.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-156">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="c0dc0-157">Na przykład jeśli — metoda `A` problemy <xref:System.Security.CodeAccessPermission.Deny%2A> uprawnienia, a następnie wywołania metody `B`, Metoda `B` overtly można zastąpić <xref:System.Security.CodeAccessPermission.Deny%2A> przez wystawienie <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-157">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="c0dc0-158">Wywołana metoda jest zawsze wyżej w stosie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-158">The called method is always higher in the stack.</span></span> <span data-ttu-id="c0dc0-159">W związku z tym jeśli — metoda `B` próbuje uzyskać dostęp do chronionego zasobu systemu zabezpieczeń, rozpocznie się sprawdzanie uprawnień z nią, ponieważ metoda `B` jest bezpośredniego obiektu wywołującego, a następnie przeszukiwań w dół stosu, aby upewnić się, że istnieje nie <xref:System.Security.CodeAccessPermission.Deny%2A> lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A> niżej w stosie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-159">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="c0dc0-160">Metoda `B`, który próbuje uzyskać dostęp do zasobu, można zatrzymać przeszukiwania stosu bezpośrednio za pomocą <xref:System.Security.CodeAccessPermission.Assert%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-160">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="c0dc0-161">W takim przypadku <xref:System.Security.CodeAccessPermission.Deny%2A> umieszczone na stosie przez metodę `A` (metody, wywołujący) nigdy nie został odnaleziony.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-161">In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="c0dc0-162">Ta metoda uniemożliwia dostęp do chronionych zasobów za pośrednictwem kod, który wywołuje tę metodę, nawet w przypadku tych wywołań przyznano uprawnień dostępu do niego wywołań wyżej w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-162">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="c0dc0-163">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-163">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="c0dc0-164"><xref:System.Security.CodeAccessPermission.Deny%2A> można ograniczyć odpowiedzialność programisty lub pomagać w zapobieganiu problemy z zabezpieczeniami przypadkowe, ponieważ zapobiega metodę, która wywołuje <xref:System.Security.CodeAccessPermission.Deny%2A> z zasobów chronionych przez odmówiono uprawnień dostępu do użycia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-164"><xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="c0dc0-165">Wywołuje metodę <xref:System.Security.CodeAccessPermission.Deny%2A> na uprawnienia, a jeśli <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia jest wywoływany przez obiekt wywołujący niższe w stosie wywołań, sprawdzanie zabezpieczeń zakończy się niepowodzeniem, po osiągnięciu <xref:System.Security.CodeAccessPermission.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-165">If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span>  
  
 <span data-ttu-id="c0dc0-166">Wywołanie <xref:System.Security.CodeAccessPermission.Deny%2A> obowiązuje, dopóki kod wywołujący nie powróci do swojego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-166">The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="c0dc0-167">Tylko jeden <xref:System.Security.CodeAccessPermission.Deny%2A> może być aktywne w ramce.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-167">Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame.</span></span> <span data-ttu-id="c0dc0-168">Próba wywołania <xref:System.Security.CodeAccessPermission.Deny%2A> podczas aktywnego <xref:System.Security.CodeAccessPermission.Deny%2A> istnieje na wyniki do ramki <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-168">An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="c0dc0-169">Wywołanie <xref:System.Security.CodeAccessPermission.RevertDeny%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> do usunięcia aktywnego <xref:System.Security.CodeAccessPermission.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-169">Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span> <span data-ttu-id="c0dc0-170"><xref:System.Security.CodeAccessPermission.Deny%2A> jest ignorowany dla uprawnienia nie udzielić, ponieważ nie powiedzie się żądanie dla tego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-170"><xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c0dc0-171">Istnieje już aktywny <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-171">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-172">Nie można przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-172">You cannot override this method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="c0dc0-173"><see cref="T:System.Security.CodeAccessPermission" /> Obiekt do porównania z bieżącym <see cref="T:System.Security.CodeAccessPermission" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-173">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span></span></param>
        <summary><span data-ttu-id="c0dc0-174">Określa, czy określony <see cref="T:System.Security.CodeAccessPermission" /> obiekt jest taki sam, jak bieżący <see cref="T:System.Security.CodeAccessPermission" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-174">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span></span></summary>
        <returns>
          <span data-ttu-id="c0dc0-175"><see langword="true" /> Jeśli określony <see cref="T:System.Security.CodeAccessPermission" /> obiekt jest taki sam, jak bieżący <see cref="T:System.Security.CodeAccessPermission" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-175"><see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-176">Aby uzyskać więcej informacji, zobacz <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-176">For more information, see <xref:System.Object.Equals%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem"><span data-ttu-id="c0dc0-177">Kodowanie XML na potrzeby rekonstrukcji obiektu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-177">The XML encoding to use to reconstruct the security object.</span></span></param>
        <summary><span data-ttu-id="c0dc0-178">W przypadku przesłonięcia w klasie pochodnej, rekonstruuje obiektu zabezpieczeń o określonym stanie kodowania XML.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-178">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-179">Kod niestandardowy, który rozszerza obiekty zabezpieczeń należy zaimplementować <xref:System.Security.CodeAccessPermission.ToXml%2A> i <xref:System.Security.CodeAccessPermission.FromXml%2A> metody, aby obiekty można kodować zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-179">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-180">Poniższy przykład kodu pokazuje zastępująca <xref:System.Security.CodeAccessPermission.FromXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-180">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.FromXml%2A> method.</span></span> <span data-ttu-id="c0dc0-181">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-181">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0dc0-182"><paramref name="elem" /> Parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-182">The <paramref name="elem" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0dc0-183"><paramref name="elem" /> Parametr zawiera kodowanie XML wystąpienia tego samego typu jak bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-183">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span></span>  
  
 <span data-ttu-id="c0dc0-184">—lub—</span><span class="sxs-lookup"><span data-stu-id="c0dc0-184">-or-</span></span>  
  
 <span data-ttu-id="c0dc0-185">Numer wersji <paramref name="elem" /> parametr nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-185">The version number of the <paramref name="elem" /> parameter is not supported.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-186">Należy przesłonić tę metodę w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-186">You must override this method in a derived class.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-187">Pobiera wartość skrótu dla <see cref="T:System.Security.CodeAccessPermission" /> obiekt, który jest odpowiedni do użycia w mieszania struktury algorytmów i danych, takich jak tablicy skrótów.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-187">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="c0dc0-188">Wartość skrótu dla bieżącego <see cref="T:System.Security.CodeAccessPermission" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-188">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-189">Wartość skrótu dla dwa wystąpienia tej samej uprawnienia mogą się różnić, dlatego wartość skrótu nie należy używać do porównywania dwóch <xref:System.Security.CodeAccessPermission> obiektów.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-189">The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="c0dc0-190">Uprawnienie do intersect z uprawnieniami bieżącego.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-190">A permission to intersect with the current permission.</span></span> <span data-ttu-id="c0dc0-191">Należy tego samego typu co bieżący uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-191">It must be of the same type as the current permission.</span></span></param>
        <summary><span data-ttu-id="c0dc0-192">Po zaimplementowaniu w klasie pochodnej, tworzy i zwraca uprawnienia, które jest przecięcia bieżące uprawnienia i określony.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-192">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span></span></summary>
        <returns><span data-ttu-id="c0dc0-193">Nowe uprawnienie reprezentuje część wspólną bieżące uprawnienia i określony.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-193">A new permission that represents the intersection of the current permission and the specified permission.</span></span> <span data-ttu-id="c0dc0-194">Jest to nowe uprawnienie <see langword="null" /> Jeśli część wspólną jest pusta.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-194">This new permission is <see langword="null" /> if the intersection is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-195">Część wspólną dwóch uprawnień jest uprawnienia, które opisano zestaw działań, które opisują one zarówno wspólnych.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-195">The intersection of two permissions is a permission that describes the set of operations they both describe in common.</span></span> <span data-ttu-id="c0dc0-196">Tylko zażąda przekazuje oba oryginalnego uprawnienia zostaną spełnione przecięcie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-196">Only a demand that passes both original permissions will pass the intersection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-197">Poniższy przykład kodu pokazuje zastępująca <xref:System.Security.CodeAccessPermission.Intersect%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-197">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Intersect%2A> method.</span></span> <span data-ttu-id="c0dc0-198">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-198">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0dc0-199"><paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest wystąpieniem tej samej klasy bieżące uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-199">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-200">Należy przesłonić tę metodę w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-200">You must override this method in a derived class.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="c0dc0-201">Uprawnienia, które ma być sprawdzane pod kątem relacji podzbioru.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-201">A permission that is to be tested for the subset relationship.</span></span> <span data-ttu-id="c0dc0-202">To uprawnienie musi być tego samego typu co bieżący uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-202">This permission must be of the same type as the current permission.</span></span></param>
        <summary><span data-ttu-id="c0dc0-203">Po zaimplementowaniu w klasie pochodnej, określa, czy bieżący uprawnienie jest podzbiorem określonego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-203">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span></span></summary>
        <returns>
          <span data-ttu-id="c0dc0-204"><see langword="true" /> Jeśli bieżące uprawnienia są podzbiorem określonego uprawnienia; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-204"><see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-205">Bieżące uprawnienia jest podzbiorem określonego uprawnienia, jeśli uprawnienia bieżącego określa zestaw operacji jest całkowicie zawarty w określonego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-205">The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</span></span> <span data-ttu-id="c0dc0-206">Na przykład uprawnienia reprezentujące dostęp do C:\example.txt jest podzbiorem uprawnienie reprezentujące dostęp do folderu C:\\.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-206">For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\\.</span></span> <span data-ttu-id="c0dc0-207">Jeśli ta metoda zwraca `true`, bieżący uprawnienie reprezentuje nie uzyskać dostęp do chronionych zasobów niż określone uprawnienie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-207">If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.</span></span>  
  
 <span data-ttu-id="c0dc0-208">Poniższe instrukcje muszą być `true` wszystkich zastąpień z <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-208">The following statements are required to be `true` for all overrides of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="c0dc0-209">*X*, *Y*, i *Z* reprezentowała obiekty uprawnienia dostępu kodu niestandardowego, które nie są puste odwołania *U* reprezentuje uprawnień dostępu kodu bez ograniczeń i *N* reprezentuje pusty uprawnienie o <xref:System.Security.Permissions.PermissionState> z <xref:System.Security.Permissions.PermissionState.None>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-209">*X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState.None>.</span></span>  
  
-   <span data-ttu-id="c0dc0-210">*X*. IsSubsetOf (*X*) zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-210">*X*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
-   <span data-ttu-id="c0dc0-211">*X*. IsSubsetOf (*Y*) zwraca taką samą wartość jak *Y*. IsSubsetOf (*X*) tylko wtedy, gdy *X* i *Y* reprezentują ten sam zestaw uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-211">*X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.</span></span>  
  
-   <span data-ttu-id="c0dc0-212">Jeśli *X*. IsSubsetOf (*Y*) i *Y*. IsSubsetOf (*Z*) zwrócą `true`, *X*. IsSubsetOf (*Z*) zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-212">If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.</span></span>  
  
-   <span data-ttu-id="c0dc0-213">*X*. IsSubsetOf (*U*) zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-213">*X*.IsSubsetOf(*U*) returns `true`.</span></span>  
  
-   <span data-ttu-id="c0dc0-214">*X*. IsSubsetOf (*N*) zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-214">*X*.IsSubsetOf(*N*) returns `false`.</span></span>  
  
-   <span data-ttu-id="c0dc0-215">*N*. IsSubsetOf (*X*) zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-215">*N*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
 <span data-ttu-id="c0dc0-216">Jeśli *X* i *Y* reprezentują niestandardowych kodów dostępu do uprawnień obiektów, które są puste odwołania *X*. IsSubsetOf (*Y*) zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-216">If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`.</span></span> <span data-ttu-id="c0dc0-217">Jeśli *Z* również ma wartość null, złożonej operacji zestawu *X*. Unii (*Y*). IsSubsetOf (*Z*) zwraca również wartość `true` ponieważ złożenie dwóch uprawnienia wartość null jest uprawnienie wartości null.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-217">If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-218">Poniższy przykład kodu pokazuje zastępująca <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-218">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="c0dc0-219">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-219">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0dc0-220"><paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest taki sam typ jak bieżące uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-220">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-221">Należy przesłonić tę metodę w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-221">You must override this method in a derived class.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-222">Zapobiega przy użyciu kodu, który wywołuje tę metodę, aby uzyskać dostęp do wszystkich zasobów z wyjątkiem zasobu określonego przez bieżące wystąpienie obiekty wywołujące wyżej w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-222">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0dc0-223"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> Metoda powinna być używana tylko w celu ochrony zasobów przed przypadkowym dostępu przez całkowicie zaufanego kodu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-223">The <xref:System.Security.CodeAccessPermission.PermitOnly%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="c0dc0-224">Nie ją stosować do ochrony zasobów przed niewłaściwym użyciem zamierzone w kodzie niezaufanym.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-224">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="c0dc0-225">Na przykład jeśli — metoda `A` problemy <xref:System.Security.CodeAccessPermission.PermitOnly%2A> uprawnienia, a następnie wywołania metody `B`, Metoda `B` overtly można zastąpić <xref:System.Security.CodeAccessPermission.PermitOnly%2A> przez wystawienie <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-225">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="c0dc0-226">Wywołana metoda jest zawsze wyżej w stosie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-226">The called method is always higher in the stack.</span></span> <span data-ttu-id="c0dc0-227">W związku z tym jeśli — metoda `B` próbuje uzyskać dostęp do chronionego zasobu systemu zabezpieczeń, rozpocznie się sprawdzanie uprawnień z nią, ponieważ metoda `B` jest bezpośredniego obiektu wywołującego, a następnie przeszukiwań w dół stosu, aby upewnić się, że istnieje nie <xref:System.Security.CodeAccessPermission.Deny%2A> lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A> niżej w stosie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-227">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="c0dc0-228">Metoda `B`, który próbuje uzyskać dostęp do zasobu, można zatrzymać przeszukiwania stosu bezpośrednio za pomocą <xref:System.Security.CodeAccessPermission.Assert%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-228">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="c0dc0-229">W takim przypadku <xref:System.Security.CodeAccessPermission.PermitOnly%2A> umieszczone na stosie przez metodę `A` (metody, wywołujący) nigdy nie został odnaleziony.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-229">In that case, the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="c0dc0-230"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> przypomina <xref:System.Security.CodeAccessPermission.Deny%2A>, w tym zarówno spowodować przeszukiwań stosu się niepowodzeniem podczas ich w przeciwnym razie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-230"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="c0dc0-231">Różnica jest to, że <xref:System.Security.CodeAccessPermission.Deny%2A> określa uprawnienia, które spowoduje niepowodzenie przeszukiwania stosu, ale <xref:System.Security.CodeAccessPermission.PermitOnly%2A> określa tylko uprawnienia, które nie powodują przeszukiwania stosu się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-231">The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span>  
  
 <span data-ttu-id="c0dc0-232">Wywołanie tej metody, aby upewnić się, że kodu można uzyskać dostępu do określonych zasobów.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-232">Call this method to ensure that your code can be used to access only the specified resources.</span></span> <span data-ttu-id="c0dc0-233">Wywołanie <xref:System.Security.CodeAccessPermission.PermitOnly%2A> obowiązuje, dopóki kod wywołujący nie powróci do swojego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-233">The call to <xref:System.Security.CodeAccessPermission.PermitOnly%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="c0dc0-234">Tylko jeden <xref:System.Security.CodeAccessPermission.PermitOnly%2A> może być aktywne w ramce.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-234">Only one <xref:System.Security.CodeAccessPermission.PermitOnly%2A> can be active on a frame.</span></span> <span data-ttu-id="c0dc0-235">Próba wywołania <xref:System.Security.CodeAccessPermission.PermitOnly%2A> podczas aktywnego <xref:System.Security.CodeAccessPermission.PermitOnly%2A> istnieje na wyniki do ramki <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-235">An attempt to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A> when an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="c0dc0-236">Wywołanie <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> do usunięcia aktywnego <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-236">Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span>  
  
 <span data-ttu-id="c0dc0-237"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> jest ignorowany dla uprawnienia nie udzielić, ponieważ nie powiedzie się żądanie dla tego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-237"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="c0dc0-238">Jednak jeśli kod niższe w wywołaniu później stosu wywołań <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest generowany, gdy kod, który próbowano nawiązać połączenie osiągnie przeszukiwania stosu <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-238">However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span> <span data-ttu-id="c0dc0-239">Jest to spowodowane kod, który wywołuje <xref:System.Security.CodeAccessPermission.PermitOnly%2A> nie udzielono uprawnień, mimo że mu <xref:System.Security.CodeAccessPermission.PermitOnly%2A> dla tego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-239">This is because the code that called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="c0dc0-240">Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-240">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c0dc0-241">Istnieje już aktywny <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-241">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-242">Nie można przesłonić tę metodę.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-242">You cannot override this method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-243">Powoduje, że wszystkie poprzednie zastąpienia dla bieżącej ramki do usunięcia, a nie działają.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-243">Causes all previous overrides for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-244">Jeśli nie ma żadnych zastąpień (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) dla bieżącej ramki <xref:System.ExecutionEngineException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-244">If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0dc0-245">Brak poprzedniej nie <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, lub <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-245">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-246">Powoduje, że wszystkie poprzednie <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki do usunięcia, a nie działają.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-246">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-247">W przypadku nie <xref:System.Security.CodeAccessPermission.Assert%2A> dla bieżącej ramki <xref:System.ExecutionEngineException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-247">If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0dc0-248">Brak poprzedniej nie <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-248">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-249">Powoduje, że wszystkie poprzednie <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki do usunięcia, a nie działają.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-249">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-250">W przypadku nie <xref:System.Security.CodeAccessPermission.Deny%2A> dla bieżącej ramki <xref:System.ExecutionEngineException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-250">If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0dc0-251">Brak poprzedniej nie <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-251">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-252">Powoduje, że wszystkie poprzednie <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki do usunięcia, a nie działają.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-252">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-253">W przypadku nie <xref:System.Security.CodeAccessPermission.PermitOnly%2A> dla bieżącej ramki <xref:System.ExecutionEngineException> jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-253">If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0dc0-254">Brak poprzedniej nie <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-254">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-255">Tworzy i zwraca reprezentację ciągu bieżącego obiektu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-255">Creates and returns a string representation of the current permission object.</span></span></summary>
        <returns><span data-ttu-id="c0dc0-256">Reprezentacja ciągu bieżącego obiektu uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-256">A string representation of the current permission object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-257">Ta metoda jest przydatna w debugowaniu, gdy ma zostać wyświetlone uprawnienia do postaci ciągu.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-257">This method is useful in debugging when you need to display the permission as a string.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0dc0-258">W przypadku przesłonięcia w klasie pochodnej tworzy kodowania XML obiektu zabezpieczeń oraz w jego bieżącym stanie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-258">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span></span></summary>
        <returns><span data-ttu-id="c0dc0-259">Kodowanie XML obiektu zabezpieczeń, łącznie z żadnych informacji o stanie.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-259">An XML encoding of the security object, including any state information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-260">Kod niestandardowy, który rozszerza obiekty zabezpieczeń należy zaimplementować <xref:System.Security.CodeAccessPermission.ToXml%2A> i <xref:System.Security.CodeAccessPermission.FromXml%2A> metody, aby obiekty można kodować zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-260">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-261">Poniższy przykład kodu pokazuje zastępująca <xref:System.Security.CodeAccessPermission.ToXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-261">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.ToXml%2A> method.</span></span> <span data-ttu-id="c0dc0-262">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-262">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-263">Należy przesłonić tę metodę w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-263">You must override this method in a derived class.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="c0dc0-264">Uprawnienie do łączenia z uprawnieniami bieżącego.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-264">A permission to combine with the current permission.</span></span> <span data-ttu-id="c0dc0-265">Należy tego samego typu co bieżący uprawnień.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-265">It must be of the same type as the current permission.</span></span></param>
        <summary><span data-ttu-id="c0dc0-266">W przypadku przesłonięcia w klasie pochodnej tworzy uprawnienia, które łączy bieżące uprawnienia i określony.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-266">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span></span></summary>
        <returns><span data-ttu-id="c0dc0-267">Nowe uprawnienie reprezentuje złożenie bieżące uprawnienia i określony.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-267">A new permission that represents the union of the current permission and the specified permission.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0dc0-268">Wynik wywołania <xref:System.Security.CodeAccessPermission.Union%2A> jest uprawnienia, które reprezentuje wszystkie operacje reprezentowany przez bieżące uprawnienia i określonego uprawnienia.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-268">The result of a call to <xref:System.Security.CodeAccessPermission.Union%2A> is a permission that represents all the operations represented by both the current permission and the specified permission.</span></span> <span data-ttu-id="c0dc0-269">Wszelkie żądania, który przekazuje albo uprawnienie przekazuje ich union.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-269">Any demand that passes either permission passes their union.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0dc0-270">Poniższy przykład kodu pokazuje zastępująca <xref:System.Security.CodeAccessPermission.Union%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-270">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Union%2A> method.</span></span> <span data-ttu-id="c0dc0-271">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.CodeAccessPermission> klasy.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-271">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0dc0-272"><paramref name="other" /> Parametr nie jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-272">The <paramref name="other" /> parameter is not <see langword="null" />.</span></span> <span data-ttu-id="c0dc0-273">Ta metoda jest obsługiwana tylko na tym poziomie podczas przekazywania <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-273">This method is only supported at this level when passed <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="c0dc0-274">Należy przesłonić tę metodę w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-274">You must override this method in a derived class.</span></span> <span data-ttu-id="c0dc0-275">Ma zwracać kopię uprawnienia, jeśli wartość <paramref name="other" /> parametr jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0dc0-275">You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</span></span></para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
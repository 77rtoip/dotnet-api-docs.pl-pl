<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="601db96d6568f82c6748112c908cd958d402cf4c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69161838" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje podstawową strukturę wszystkich uprawnień dostępu kodu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uprawnienia dostępu kodu używają przeszukiwania stosu, aby upewnić się, że wszystkie obiekty wywołujące kod uzyskały uprawnienie. Jeśli obiekt uprawnień jest `null`, jest obsługiwany w taki sam sposób, jak obiekt uprawnień o stanie. <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>  
  
 Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań.  
  
 Dziedziczenia <xref:System.Security.CodeAccessPermission> klasy muszą mieć przyznane pełne zaufanie, aby funkcjonowały prawidłowo jako uprawnienia rozszerzające infrastrukturę zabezpieczeń. Aby określić, że dziedziczenia są w pełni zaufane <xref:System.Security.CodeAccessPermission> , <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> wystawia <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>dla `true` <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` i  = .  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje uprawnienie pochodne od <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Aby umożliwić dziedziczenie i wyświetlanie i modyfikowanie zasad. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</permission>
    <block subset="none" type="overrides"><para>W przypadku dziedziczenia <see cref="T:System.Security.CodeAccessPermission" />z, należy również <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> zaimplementować interfejs.  
  
Następujące <see cref="T:System.Security.CodeAccessPermission" /> elementy członkowskie muszą zostać zastąpione <see cref="M:System.Security.CodeAccessPermission.Copy" />: <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" /> <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />,, i <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  
  
Należy również zdefiniować konstruktora, który przyjmuje <see cref="T:System.Security.Permissions.PermissionState" /> jako jedyny parametr.  
  
Należy zastosować <see cref="T:System.SerializableAttribute" /> atrybut do klasy, która dziedziczy z <see cref="T:System.Security.CodeAccessPermission" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.CodeAccessPermission" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany, aby zainicjować stan w typie za każdym razem, gdy tworzone jest wystąpienie klasy pochodnej. Chociaż można jawnie wywołać ten Konstruktor w deklaracji konstruktora klasy pochodnej, nie jest to zwykle konieczne. większość kompilatorów automatycznie generuje wywołanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deklaruje, że kod wywołujący może uzyskać dostęp do zasobu chronionego przez żądanie dostępu za pomocą kodu, który wywołuje tę metodę, nawet jeśli obiekty wywołujące wyższego poziomu stosu nie uzyskały uprawnienia dostępu do zasobu. Korzystanie <see cref="M:System.Security.CodeAccessPermission.Assert" /> z programu może spowodować problemy z zabezpieczeniami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań. Wywołania <xref:System.Security.CodeAccessPermission.Assert%2A> uniemożliwiają przechodzenie stosu w dół w stosie wywołań w celu przechodzenia przez stos wywołań poza kod, który wywołuje tę metodę. W związku z tym nawet jeśli obiekty wywołujące wyższe na stosie wywołań nie mają wymaganych uprawnień dostępu do zasobu, nadal mogą uzyskać do niego dostęp za pomocą kodu, który wywołuje tę metodę na niezbędnych uprawnieniach. Potwierdzenie ma zastosowanie tylko wtedy, gdy kod, który <xref:System.Security.CodeAccessPermission.Assert%2A> wywołuje, przekazuje kontrolę zabezpieczeń dla uprawnienia, które jest potwierdzone.  
  
 Wywołanie <xref:System.Security.CodeAccessPermission.Assert%2A> jest skuteczne do momentu powracania kodu wywołującego do obiektu wywołującego. Tylko jeden <xref:System.Security.CodeAccessPermission.Assert%2A> może być aktywny w ramce. Próba wywołania <xref:System.Security.CodeAccessPermission.Assert%2A> , gdy element aktywny <xref:System.Security.CodeAccessPermission.Assert%2A> istnieje w ramce, spowoduje wystąpienie elementu <xref:System.Security.SecurityException>. <xref:System.Security.CodeAccessPermission.RevertAssert%2A> Wywołaj <xref:System.Security.CodeAccessPermission.RevertAll%2A> lub, aby usunąć <xref:System.Security.CodeAccessPermission.Assert%2A>aktywny.  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A>jest ignorowany dla uprawnień, które nie zostały przyznane, ponieważ żądanie tego uprawnienia nie powiedzie się. Jeśli jednak kod niższy od wywołania <xref:System.Security.CodeAccessPermission.Demand%2A> stosu wywołań dla tego uprawnienia <xref:System.Security.SecurityException> , jest generowany, gdy przechodzenie stosu osiągnie kod, który próbował wywołać <xref:System.Security.CodeAccessPermission.Assert%2A>. Dzieje się tak, ponieważ kod, <xref:System.Security.CodeAccessPermission.Assert%2A> który został wywołany, nie otrzymał uprawnienia, nawet jeśli <xref:System.Security.CodeAccessPermission.Assert%2A> próbował go.  
  
> [!CAUTION]
>  Ponieważ wywołanie <xref:System.Security.CodeAccessPermission.Assert%2A> usuwa wymaganie, aby cały kod w łańcuchu wywołań musiał otrzymać uprawnienia dostępu do określonego zasobu, można otworzyć problemy z zabezpieczeniami, jeśli są używane nieprawidłowo lub niewłaściwie. W związku z tym powinno być używane z dużą ostrożnością.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod wywołujący nie ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.  
  
—lub— 
Istnieje już aktywny <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania <see cref="M:System.Security.CodeAccessPermission.Assert" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></permission>
        <block subset="none" type="overrides"><para>Nie można zastąpić tej metody.</para></block>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">Korzystanie z metody Assert</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu przez klasę pochodną program tworzy i zwraca identyczną kopię bieżącego obiektu uprawnienia.</summary>
        <returns>Kopia bieżącego obiektu uprawnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopia obiektu uprawnień reprezentuje ten sam dostęp do zasobów co oryginalny obiekt uprawnień.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przesłonięcie <xref:System.Security.CodeAccessPermission.Copy%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Należy zastąpić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Security.SecurityException" /> Wymusza w czasie wykonywania, jeśli wszystkie obiekty wywołujące wyższe w stosie wywołań nie udzieliły uprawnienia określonego przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana przez bezpieczne biblioteki w celu zapewnienia, że wywołujący mają uprawnienia dostępu do zasobu. Na przykład Klasa plików w bezpiecznej bibliotece klas wywołuje <xref:System.Security.CodeAccessPermission.Demand%2A> wymagane <xref:System.Security.Permissions.FileIOPermission> przed wykonaniem operacji na plikach zażądanej przez wywołującego.  
  
 Uprawnienia kodu, który wywołuje tę metodę, nie są badane; sprawdzenie rozpoczyna się od bezpośredniego wywołującego tego kodu i przechodzi do stosu. Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań. <xref:System.Security.CodeAccessPermission.Demand%2A>powiedzie się tylko wtedy <xref:System.Security.SecurityException> , gdy nie zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyższy w stosie wywołań nie ma uprawnienia określonego przez bieżące wystąpienie.  
  
—lub— 
Obiekt wywołujący wyższy w stosie wywołań został <see cref="M:System.Security.CodeAccessPermission.Deny" /> wywołany w bieżącym obiekcie uprawnień.</exception>
        <block subset="none" type="overrides"><para>Nie można zastąpić tej metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapobiega wywoływaniu obiektów wywołujących w stosie wywołań przy użyciu kodu wywołującego tę metodę w celu uzyskania dostępu do zasobu określonego przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Security.CodeAccessPermission.Deny%2A> Metoda powinna być używana tylko w celu ochrony zasobów przed przypadkowym dostępem przez w pełni zaufany kod. Nie należy używać go do ochrony zasobów przed zamierzonym nieprawidłowym użyciem przez kod niezaufany. Na przykład, jeśli metoda `A` <xref:System.Security.CodeAccessPermission.Deny%2A> wystawia dla uprawnienia, a następnie wywołuje `B`metodę, `B` <xref:System.Security.CodeAccessPermission.Assert%2A>Metoda może overtly zastąpić <xref:System.Security.CodeAccessPermission.Deny%2A> elementu przez wygenerowanie. Wywołana metoda jest zawsze wyższa w stosie. W związku z tym `B` , jeśli metoda próbuje uzyskać dostęp do chronionego zasobu, system zabezpieczeń rozpocznie sprawdzanie pod `B` kątem uprawnień, ponieważ metoda jest bezpośrednim obiektem wywołującym, a następnie przeprowadzi stos w <xref:System.Security.CodeAccessPermission.Deny%2A> celu potwierdzenia, że nie ma lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A> niższy na stosie. Metoda `B`, która próbuje uzyskać dostęp do zasobu, może przestać przechodzenie stosu natychmiast przy <xref:System.Security.CodeAccessPermission.Assert%2A> użyciu metody. W takim przypadku <xref:System.Security.CodeAccessPermission.Deny%2A> umieszczenie w stos według metody `A` (Metoda wywołująca) nigdy nie jest odnajdywane.  
  
 Ta metoda uniemożliwia wywoływanie obiektów wywołujących wyższego poziomu w stosie wywołań dostępu do chronionego zasobu za pośrednictwem kodu, który wywołuje tę metodę, nawet jeśli Ci wywołujący mają uprawnienia dostępu do niej. Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań.  
  
 <xref:System.Security.CodeAccessPermission.Deny%2A>program może ograniczyć odpowiedzialność programisty lub zapobiec przypadkowemu występowaniu problemów z zabezpieczeniami, ponieważ pomaga zapobiec metodzie <xref:System.Security.CodeAccessPermission.Deny%2A> , która wywołuje z użycia w celu uzyskania dostępu do zasobów chronionych przez uprawnienie odmowa. Jeśli metoda wywołuje <xref:System.Security.CodeAccessPermission.Deny%2A> uprawnienie, a <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia wywoływany przez obiekt wywołujący jest niższy w stosie wywołań, sprawdzanie zabezpieczeń zakończy <xref:System.Security.CodeAccessPermission.Deny%2A>się niepowodzeniem, gdy zostanie osiągnięty.  
  
 Wywołanie <xref:System.Security.CodeAccessPermission.Deny%2A> jest skuteczne do momentu powracania kodu wywołującego do obiektu wywołującego. Tylko jeden <xref:System.Security.CodeAccessPermission.Deny%2A> może być aktywny w ramce. Próba wywołania <xref:System.Security.CodeAccessPermission.Deny%2A> , gdy element aktywny <xref:System.Security.CodeAccessPermission.Deny%2A> istnieje w ramce, spowoduje wystąpienie elementu <xref:System.Security.SecurityException>. <xref:System.Security.CodeAccessPermission.RevertDeny%2A> Wywołaj <xref:System.Security.CodeAccessPermission.RevertAll%2A> lub, aby usunąć <xref:System.Security.CodeAccessPermission.Deny%2A>aktywny. <xref:System.Security.CodeAccessPermission.Deny%2A>jest ignorowany dla uprawnień, które nie zostały przyznane, ponieważ żądanie tego uprawnienia nie powiedzie się.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Istnieje już aktywny <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki.</exception>
        <block subset="none" type="overrides"><para>Nie można zastąpić tej metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany <see cref="T:System.Security.CodeAccessPermission" />z bieżącym. <see cref="T:System.Security.CodeAccessPermission" /></param>
        <summary>Określa, czy określony <see cref="T:System.Security.CodeAccessPermission" /> obiekt jest równy bieżącemu. <see cref="T:System.Security.CodeAccessPermission" /></summary>
        <returns><see langword="true" />Jeśli określony <see cref="T:System.Security.CodeAccessPermission" /> obiekt jest równy bieżącemu <see cref="T:System.Security.CodeAccessPermission" />; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Object.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">Kodowanie XML do użycia w celu odtworzenia obiektu zabezpieczeń.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, rekonstruuje obiekt zabezpieczeń z określonym stanem z kodowania XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod niestandardowy, który rozszerza obiekty zabezpieczeń, musi <xref:System.Security.CodeAccessPermission.ToXml%2A> implementować <xref:System.Security.CodeAccessPermission.FromXml%2A> metody i, aby uczynić obiekty Security-encodable.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przesłonięcie <xref:System.Security.CodeAccessPermission.FromXml%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="elem" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="elem" /> Parametr nie zawiera kodowania XML dla wystąpienia tego samego typu co bieżące wystąpienie.  
  
—lub— 
Numer <paramref name="elem" /> wersji parametru nie jest obsługiwany.</exception>
        <block subset="none" type="overrides"><para>Należy zastąpić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kod skrótu dla <see cref="T:System.Security.CodeAccessPermission" /> obiektu, który jest odpowiedni do użycia w algorytmach wyznaczania wartości skrótu i struktur danych, takich jak tabela skrótów.</summary>
        <returns>Kod skrótu dla bieżącego <see cref="T:System.Security.CodeAccessPermission" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod skrótu dla dwóch wystąpień tego samego uprawnienia może być inny, dlatego nie należy używać kodu skrótu do porównywania dwóch <xref:System.Security.CodeAccessPermission> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do przecięcia z bieżącym uprawnieniem. Musi być tego samego typu co bieżące uprawnienie.</param>
        <summary>W przypadku wdrożenia przez klasę pochodną program tworzy i zwraca uprawnienie, które jest częścią wspólną bieżącego uprawnienia i określonego uprawnienia.</summary>
        <returns>Nowe uprawnienie, które reprezentuje część wspólną bieżącego uprawnienia i określonego uprawnienia. To nowe uprawnienie jest <see langword="null" /> , jeśli część wspólna jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wspólną częścią dwóch uprawnień jest uprawnienie, które opisuje zestaw operacji, które oba często opisują. Tylko żądanie przekazujące pierwotne uprawnienia spowoduje przekazanie przedziału.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przesłonięcie <xref:System.Security.CodeAccessPermission.Intersect%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie<see langword="null" /> jest ani wystąpieniem tej samej klasy, co bieżące uprawnienie.</exception>
        <block subset="none" type="overrides"><para>Należy zastąpić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie, które ma zostać przetestowane dla relacji podzbioru. To uprawnienie musi być tego samego typu co bieżące uprawnienie.</param>
        <summary>W przypadku implementacji przez klasę pochodną określa, czy bieżące uprawnienie jest podzbiorem określonego uprawnienia.</summary>
        <returns><see langword="true" />Jeśli bieżące uprawnienie jest podzbiorem określonego uprawnienia; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące uprawnienie jest podzbiorem określonego uprawnienia, jeśli bieżące uprawnienie określa zestaw operacji, które są w całości zawarte w określonym uprawnienia. Na przykład uprawnienie, które reprezentuje dostęp do C:\example.txt, jest podzbiorem uprawnienia, które reprezentuje dostęp do C:\\. Jeśli ta metoda zwróci `true`wartość, bieżące uprawnienie nie reprezentuje więcej dostępu do chronionego zasobu niż określone uprawnienie.  
  
 Następujące instrukcje są wymagane `true` dla wszystkich zastąpień <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metody. *X*, *Y*i *Z* reprezentują niestandardowe obiekty uprawnień dostępu do kodu, które nie są odwołaniami null, *U* reprezentuje nieograniczone uprawnienia dostępu do kodu, a *N* reprezentuje puste uprawnienie z <xref:System.Security.Permissions.PermissionState> <xref:System.Security.Permissions.PermissionState.None>.  
  
-   *X*. IsSubsetOf — (*X*) zwraca `true`wartość.  
  
-   *X*. IsSubsetOf — (*Y*) zwraca tę samą wartość jak *Y*. IsSubsetOf — (*X*) if i tylko wtedy, gdy *X* i *Y* reprezentują ten sam zestaw uprawnień.  
  
-   Jeśli *X*. IsSubsetOf — (*Y*) i *Y*. IsSubsetOf — (*Z*) oba zwracają `true`, *X*. IsSubsetOf — (*Z*) zwraca `true`.  
  
-   *X*. IsSubsetOf — (*U*) zwraca `true`wartość.  
  
-   *X*. IsSubsetOf — (*N*) zwraca `false`wartość.  
  
-   *N*. IsSubsetOf — (*X*) zwraca `true`wartość.  
  
 Jeśli *X* i *Y* reprezentują niestandardowe obiekty uprawnień dostępu do kodu, które są odwołaniami null, *X*. IsSubsetOf — (*Y*) zwraca `true`wartość. Jeśli *z* ma również wartość null, operacja zestawu złożonego *X*. Unia (*Y*). IsSubsetOf — (*Z*) również zwraca `true` , ponieważ Unia dwóch uprawnień null jest uprawnieniem null.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przesłonięcie <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie<see langword="null" /> ma tego samego typu co bieżące uprawnienie.</exception>
        <block subset="none" type="overrides"><para>Należy zastąpić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapobiega wywoływaniu obiektów wywołujących w stosie wywołań przy użyciu kodu wywołującego tę metodę w celu uzyskania dostępu do wszystkich zasobów z wyjątkiem zasobu określonego przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Security.CodeAccessPermission.PermitOnly%2A> Metoda powinna być używana tylko w celu ochrony zasobów przed przypadkowym dostępem przez w pełni zaufany kod. Nie należy używać go do ochrony zasobów przed zamierzonym nieprawidłowym użyciem przez kod niezaufany. Na przykład, jeśli metoda `A` <xref:System.Security.CodeAccessPermission.PermitOnly%2A> wystawia dla uprawnienia, a następnie wywołuje `B`metodę, `B` <xref:System.Security.CodeAccessPermission.Assert%2A>Metoda może overtly zastąpić <xref:System.Security.CodeAccessPermission.PermitOnly%2A> elementu przez wygenerowanie. Wywołana metoda jest zawsze wyższa w stosie. W związku z tym `B` , jeśli metoda próbuje uzyskać dostęp do chronionego zasobu, system zabezpieczeń rozpocznie sprawdzanie pod `B` kątem uprawnień, ponieważ metoda jest bezpośrednim obiektem wywołującym, a następnie przeprowadzi stos w <xref:System.Security.CodeAccessPermission.Deny%2A> celu potwierdzenia, że nie ma lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A> niższy na stosie. Metoda `B`, która próbuje uzyskać dostęp do zasobu, może przestać przechodzenie stosu natychmiast przy <xref:System.Security.CodeAccessPermission.Assert%2A> użyciu metody. W takim przypadku <xref:System.Security.CodeAccessPermission.PermitOnly%2A> umieszczenie w stos według metody `A` (Metoda wywołująca) nigdy nie jest odnajdywane.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A>działa podobnie jak <xref:System.Security.CodeAccessPermission.Deny%2A>w przypadku, gdy obie przyczyny kończą się niepowodzeniem. Różnica polega na tym <xref:System.Security.CodeAccessPermission.Deny%2A> , że określa uprawnienia, które spowodują niepowodzenie przechodzenia stosu <xref:System.Security.CodeAccessPermission.PermitOnly%2A> , ale określa jedyne uprawnienia, które nie powodują błędów przeszukiwania stosu.  
  
 Wywołaj tę metodę, aby upewnić się, że kod może być używany w celu uzyskania dostępu tylko do określonych zasobów. Wywołanie <xref:System.Security.CodeAccessPermission.PermitOnly%2A> jest skuteczne do momentu powracania kodu wywołującego do obiektu wywołującego. Tylko jeden <xref:System.Security.CodeAccessPermission.PermitOnly%2A> może być aktywny w ramce. Próba wywołania <xref:System.Security.CodeAccessPermission.PermitOnly%2A> , gdy element aktywny <xref:System.Security.CodeAccessPermission.PermitOnly%2A> istnieje w ramce, spowoduje wystąpienie elementu <xref:System.Security.SecurityException>. <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> Wywołaj <xref:System.Security.CodeAccessPermission.RevertAll%2A> lub, aby usunąć <xref:System.Security.CodeAccessPermission.PermitOnly%2A>aktywny.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A>jest ignorowany dla uprawnień, które nie zostały przyznane, ponieważ żądanie tego uprawnienia nie powiedzie się. Jeśli jednak kod niższy na stosie wywołań później wywołuje <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> , jest generowany, gdy przeszukiwany stos osiągnie kod, który próbował wywołać <xref:System.Security.CodeAccessPermission.PermitOnly%2A>. Wynika to z faktu, że <xref:System.Security.CodeAccessPermission.PermitOnly%2A> wywoływany kod nie otrzymał uprawnienia, nawet jeśli został wywołany <xref:System.Security.CodeAccessPermission.PermitOnly%2A> dla tego uprawnienia. Stos wywołań jest zazwyczaj reprezentowany jako rosnący, więc metody wyższe w metodach wywołania stosu wywołań są niższe w stosie wywołań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Istnieje już aktywny <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</exception>
        <block subset="none" type="overrides"><para>Nie można zastąpić tej metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie poprzednie zastąpienia bieżącej ramki zostaną usunięte i nie będą już obowiązywały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku braku zastąpień<xref:System.Security.CodeAccessPermission.Assert%2A>( <xref:System.Security.CodeAccessPermission.Deny%2A>, lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) dla bieżącej ramki <xref:System.ExecutionEngineException> jest zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Brak poprzedniej <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />lub <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="M:System.Security.CodeAccessPermission.Assert" /> wszystkie poprzednie dla bieżącej ramki zostaną usunięte i nie będą już obowiązywały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie <xref:System.Security.CodeAccessPermission.Assert%2A> ma dla bieżącej ramki <xref:System.ExecutionEngineException> , zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Brak poprzedniej <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="M:System.Security.CodeAccessPermission.Deny" /> wszystkie poprzednie dla bieżącej ramki zostaną usunięte i nie będą już obowiązywały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie <xref:System.Security.CodeAccessPermission.Deny%2A> ma dla bieżącej ramki <xref:System.ExecutionEngineException> , zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Brak poprzedniej <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> wszystkie poprzednie dla bieżącej ramki zostaną usunięte i nie będą już obowiązywały.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie <xref:System.Security.CodeAccessPermission.PermitOnly%2A> ma dla bieżącej ramki <xref:System.ExecutionEngineException> , zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Brak poprzedniej <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca reprezentację ciągu dla bieżącego obiektu uprawnienia.</summary>
        <returns>Reprezentacja ciągu bieżącego obiektu uprawnień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna w debugowaniu, gdy konieczne jest wyświetlenie uprawnienia jako ciągu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy Kodowanie XML obiektu zabezpieczeń i jego bieżący stan.</summary>
        <returns>Kodowanie XML obiektu zabezpieczeń, w tym informacje o stanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod niestandardowy, który rozszerza obiekty zabezpieczeń, musi <xref:System.Security.CodeAccessPermission.ToXml%2A> implementować <xref:System.Security.CodeAccessPermission.FromXml%2A> metody i, aby uczynić obiekty Security-encodable.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przesłonięcie <xref:System.Security.CodeAccessPermission.ToXml%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Należy zastąpić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">Uprawnienie do łączenia z bieżącym uprawnieniem. Musi być tego samego typu co bieżące uprawnienie.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy uprawnienie, które jest złożeniem bieżącego uprawnienia i określonym uprawnieniem.</summary>
        <returns>Nowe uprawnienie, które reprezentuje związek z bieżącym uprawnieniem i określonym uprawnieniem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynikiem wywołania <xref:System.Security.CodeAccessPermission.Union%2A> jest uprawnienie, które reprezentuje wszystkie operacje reprezentowane przez bieżące uprawnienie i określone uprawnienie. Każde żądanie, które przekazuje jedno uprawnienie, przekazuje ich Unię.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przesłonięcie <xref:System.Security.CodeAccessPermission.Union%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="other" /> Parametr nie<see langword="null" />jest. Ta metoda jest obsługiwana tylko na tym poziomie, gdy <see langword="null" />jest zakończony.</exception>
        <block subset="none" type="overrides"><para>Należy zastąpić tę metodę w klasie pochodnej. Należy zwrócić kopię uprawnienia, jeśli wartość <paramref name="other" /> parametru to. <see langword="null" /></para></block>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd74e86633f6613c381cb4b198001d006f41e336" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55377572" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje wewnętrzna struktura wszystkie uprawnienia dostępu kodu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uprawnienia dostępu kodu Użyj przeszukiwania stosu, aby upewnić się, że wszystkie obiekty wywołujące kodu przyznano uprawnienie. Jeśli jest obiektem uprawień `null`, taka sama jak obiekt uprawnień ze stanem zapewniona jest obsługa <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.  
  
 Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań.  
  
 Obiektów dziedziczących z <xref:System.Security.CodeAccessPermission> klasy muszą otrzymać pełne zaufanie do poprawnego działania jako uprawnienia rozszerzanie infrastruktura zabezpieczeń. Aby określić, że obiektów dziedziczących są w pełni zaufane, <xref:System.Security.CodeAccessPermission> problemów <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> dla <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` i <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje uprawnienia pochodną <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Aby uzyskać możliwość obiektów dziedziczących Podaj dowód i wyświetlanie i modyfikowanie zasad. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</permission>
    <block subset="none" type="overrides"><para>Przy dziedziczeniu z <see cref="T:System.Security.CodeAccessPermission" />, należy także zaimplementować <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interfejsu.  
  
Następujące <see cref="T:System.Security.CodeAccessPermission" /> musi zostać zastąpiona elementów członkowskich: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, i <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  
  
Należy także zdefiniować Konstruktor, który pobiera <see cref="T:System.Security.Permissions.PermissionState" /> jako jedynym parametrem.  
  
Należy najpierw zastosować <see cref="T:System.SerializableAttribute" /> atrybutów do klasy, która dziedziczy po elemencie <see cref="T:System.Security.CodeAccessPermission" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.CodeAccessPermission" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana, aby zainicjować stanu w typie, zawsze wtedy, gdy tworzone jest wystąpienie klasy pochodnej. Mimo że ten konstruktor może jawnie wywołać w deklaracji konstruktora w konstruktorze klasy pochodnej, nie jest to zazwyczaj konieczne; Większość kompilatorów automatycznie wygeneruje wywołanie dla Ciebie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deklaruje, że kod wywołujący może uzyskać dostępu do zasobu, chronione przez żądanie uprawnień za pomocą kodu, który wywołuje tę metodę, nawet wtedy, gdy wyżej w stosie wywołań nie przyznano uprawnień dostępu do zasobu. Za pomocą <see cref="M:System.Security.CodeAccessPermission.Assert" /> może prowadzić do problemów zabezpieczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań. Wywoływanie <xref:System.Security.CodeAccessPermission.Assert%2A> zapobiega stosów, pochodzących z niższych stos wywołań z przejściem na górę stosu wywołań poza kod, który wywołuje tę metodę. W związku z tym nawet jeśli obiekty wywołujące wyżej na stosie wywołań, nie masz wymaganych uprawnień do uzyskania dostępu do zasobu, są nadal do niego dostęp za pośrednictwem kodu, który wywołuje tę metodę w niezbędnych uprawnień. Potwierdzenie obowiązuje tylko wtedy, gdy kod wywołuje <xref:System.Security.CodeAccessPermission.Assert%2A> przekazuje sprawdzenia zabezpieczeń dla uprawnień, że jest ona potwierdzające.  
  
 Wywołanie <xref:System.Security.CodeAccessPermission.Assert%2A> jest efektywne, dopóki kod wywołujący powraca do obiektu wywołującego. Tylko jeden <xref:System.Security.CodeAccessPermission.Assert%2A> może być aktywne w ramce. Próba wywołania <xref:System.Security.CodeAccessPermission.Assert%2A> podczas aktywnego <xref:System.Security.CodeAccessPermission.Assert%2A> istnieje w ramce skutkuje <xref:System.Security.SecurityException>. Wywołaj <xref:System.Security.CodeAccessPermission.RevertAssert%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> można usunąć aktywnego <xref:System.Security.CodeAccessPermission.Assert%2A>.  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> jest ignorowany dla uprawnień nie udzielić, ponieważ żądanie dla tego uprawnienia nie powiedzie się. Jednak jeśli niżej w stosie wywołań kod wywołuje <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest zgłaszany, gdy przeszukiwania stosu osiągnie kod, który próbowano wywołania <xref:System.Security.CodeAccessPermission.Assert%2A>. Dzieje się tak, ponieważ kod, który wywołuje <xref:System.Security.CodeAccessPermission.Assert%2A> nie udzielono uprawnień, mimo że aplikacja próbowała <xref:System.Security.CodeAccessPermission.Assert%2A> go.  
  
> [!CAUTION]
>  Ponieważ wywołanie <xref:System.Security.CodeAccessPermission.Assert%2A> usuwa wymóg, że wszystkie możesz pisać kod w łańcuch wywołań muszą mieć uprawnienie dostępu do określonego zasobu, można otworzyć się problemy z zabezpieczeniami, jeśli niepoprawnie lub niewłaściwie. W związku z tym należy używać ostrożnie doskonałe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod wywołujący nie ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.  
  
—lub— 
Istnieje już aktywna <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wywoływania <see cref="M:System.Security.CodeAccessPermission.Assert" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></permission>
        <block subset="none" type="overrides"><para>Nie można przesłonić tę metodę.</para></block>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">Korzystanie z metody Assert</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, tworzy i zwraca identyczną kopię bieżącego obiektu uprawnień.</summary>
        <returns>Kopię bieżącego obiektu uprawnień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopię obiektu uprawnienie reprezentuje taki sam dostęp do zasobów jako oryginalnego obiektu uprawnień.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje nadpisanie <xref:System.Security.CodeAccessPermission.Copy%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Należy przesłonić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza <see cref="T:System.Security.SecurityException" /> w czasie wykonywania, jeśli wszystkie obiekty wywołujące wyżej w stosie wywołań nie przyznano uprawnienia określone przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana przez bezpieczne biblioteki, aby upewnić się, że obiekty wywołujące ma uprawnienia do uzyskania dostępu do zasobu. Na przykład wywołuje klasę pliku w bibliotece bezpiecznych klasy <xref:System.Security.CodeAccessPermission.Demand%2A> dla niezbędnych <xref:System.Security.Permissions.FileIOPermission> przed przystąpieniem do wykonywania operacji na pliku żądanego przez obiekt wywołujący.  
  
 Uprawnienia kod, który wywołuje tę metodę, nie będą badane; Sprawdzanie zaczyna się od bezpośredniego obiektu wywołującego kod i przechodzi w górę stosu. Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań. <xref:System.Security.CodeAccessPermission.Demand%2A> powiedzie się tylko wtedy, gdy nie <xref:System.Security.SecurityException> jest wywoływane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia określone przez bieżące wystąpienie.  
  
—lub— 
Obiekt wywołujący wyżej w stosie wywołań została wywołana <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącego obiektu uprawnień.</exception>
        <block subset="none" type="overrides"><para>Nie można przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uniemożliwia wywołującym wyżej w stosie wywołań przy użyciu kodu, który wywołuje tę metodę, aby uzyskać dostęp do zasobu, określony przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Security.CodeAccessPermission.Deny%2A> Metoda powinna służyć tylko po to, aby chronić zasoby przed przypadkowym dostępem przez w pełni zaufany kod. Nie można stosować do ochrony zasobów z zamierzone nieuprawnione użycie przez niezaufany kod. Na przykład jeśli metoda `A` problemów <xref:System.Security.CodeAccessPermission.Deny%2A> uprawnień, a następnie wywołuje metodę `B`, — Metoda `B` overtly można zastąpić <xref:System.Security.CodeAccessPermission.Deny%2A> wydając <xref:System.Security.CodeAccessPermission.Assert%2A>. Metoda wywoływana jest zawsze wyżej w stosie. W związku z tym jeśli metoda `B` próbuje uzyskać dostęp do chronionego zasobu systemu zabezpieczeń, rozpocznie się sprawdzanie uprawnień z on, ponieważ metoda `B` jest bezpośredniego obiektu wywołującego i przeszukiwania i w dół stosu, aby upewnić się, że istnieje nie <xref:System.Security.CodeAccessPermission.Deny%2A> lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A> niżej w stosie. Metoda `B`, który próbuje uzyskać dostęp do zasobu, można zatrzymać przeszukiwania stosu natychmiast za pomocą <xref:System.Security.CodeAccessPermission.Assert%2A> metody. W takim przypadku <xref:System.Security.CodeAccessPermission.Deny%2A> umieszczenie w stosie przez metodę `A` (wywoływania metody) nigdy nie został odnaleziony.  
  
 Ta metoda uniemożliwia wywołującym wyżej w stosie wywołań uzyskiwania dostępu do chronionego zasobu za pomocą kodu, który wywołuje tę metodę, nawet wtedy, gdy te obiekty wywołujące przyznano uprawnienia dostępu do niego. Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań.  
  
 <xref:System.Security.CodeAccessPermission.Deny%2A> można ograniczyć odpowiedzialność programisty lub zapobiec problemom przypadkowym zabezpieczeń, ponieważ zapobiega metodę, która wywołuje <xref:System.Security.CodeAccessPermission.Deny%2A> używany w celu dostępu do zasobów chronionych przez odmowy uprawnień. Wywołuje metodę <xref:System.Security.CodeAccessPermission.Deny%2A> na uprawnienia i jeśli <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia, zostanie wywołany przez obiekt wywołujący niżej w stosie wywołań, sprawdzanie zabezpieczeń nie powiedzie się po osiągnięciu <xref:System.Security.CodeAccessPermission.Deny%2A>.  
  
 Wywołanie <xref:System.Security.CodeAccessPermission.Deny%2A> jest efektywne, dopóki kod wywołujący powraca do obiektu wywołującego. Tylko jeden <xref:System.Security.CodeAccessPermission.Deny%2A> może być aktywne w ramce. Próba wywołania <xref:System.Security.CodeAccessPermission.Deny%2A> podczas aktywnego <xref:System.Security.CodeAccessPermission.Deny%2A> istnieje w ramce skutkuje <xref:System.Security.SecurityException>. Wywołaj <xref:System.Security.CodeAccessPermission.RevertDeny%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> można usunąć aktywnego <xref:System.Security.CodeAccessPermission.Deny%2A>. <xref:System.Security.CodeAccessPermission.Deny%2A> jest ignorowany dla uprawnień nie udzielić, ponieważ żądanie dla tego uprawnienia nie powiedzie się.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Istnieje już aktywna <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki.</exception>
        <block subset="none" type="overrides"><para>Nie można przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Security.CodeAccessPermission" /> Obiekt do porównania z bieżącym <see cref="T:System.Security.CodeAccessPermission" />.</param>
        <summary>Określa, czy określony <see cref="T:System.Security.CodeAccessPermission" /> obiekt jest taki sam do bieżącego <see cref="T:System.Security.CodeAccessPermission" />.</summary>
        <returns><see langword="true" /> Jeśli określony <see cref="T:System.Security.CodeAccessPermission" /> obiekt jest taki sam do bieżącego <see cref="T:System.Security.CodeAccessPermission" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Object.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">Kodowanie XML na potrzeby rekonstrukcji obiektu zabezpieczeń.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rekonstruuje obiektu zabezpieczeń przy użyciu określonego stanu z Kodowanie XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod niestandardowy, który rozszerza obiekty zabezpieczeń należy zaimplementować <xref:System.Security.CodeAccessPermission.ToXml%2A> i <xref:System.Security.CodeAccessPermission.FromXml%2A> metody w celu dokonania obiekty można kodować zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje nadpisanie <xref:System.Security.CodeAccessPermission.FromXml%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elem" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elem" /> Parametr zawiera kodowanie XML w przypadku wystąpienia tego samego typu jak bieżące wystąpienie.  
  
—lub— 
Numer wersji <paramref name="elem" /> parametr nie jest obsługiwany.</exception>
        <block subset="none" type="overrides"><para>Należy przesłonić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla <see cref="T:System.Security.CodeAccessPermission" /> obiekt, który jest odpowiedni do użytku w mieszania algorytmów i struktur danych, takich jak Tabela skrótów.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Security.CodeAccessPermission" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość skrótu dla dwóch wystąpień tego samego uprawnienia mogą się różnić, dlatego wartość skrótu nie należy używać do porównywania dwóch <xref:System.Security.CodeAccessPermission> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do przecięcia z uprawnieniami bieżącego. Należy się tego samego typu jak bieżące uprawnienia.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, tworzy i zwraca uprawnienia, które jest częścią bieżącego uprawnienie oraz uprawnienie określoną wspólną.</summary>
        <returns>Nowe uprawnienia, które reprezentuje część wspólną bieżące uprawnienia i określony. Jest to nowe uprawnienie <see langword="null" /> Jeśli część wspólną jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Część wspólną dwóch uprawnień jest uprawnień, który opisuje zestaw operacji, które opisują one zarówno we wspólnych. Żądanie, który przekazuje zarówno pierwotnych uprawnień zostaną spełnione część wspólną.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje nadpisanie <xref:System.Security.CodeAccessPermission.Intersect%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest wystąpieniem tej samej klasy jako bieżące uprawnienia.</exception>
        <block subset="none" type="overrides"><para>Należy przesłonić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienia, które ma zostać przetestowana dla relacji podzbioru. To uprawnienie musi być tego samego typu jak bieżące uprawnienia.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, określa, czy bieżące uprawnienia jest podzbiorem określone uprawnienie.</summary>
        <returns><see langword="true" /> Jeśli bieżący uprawnienie jest podzbiorem określone uprawnienie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące uprawnienia są podzbiorem określone uprawnienie, jeśli bieżące uprawnienia określa zestaw operacji, który jest całkowicie zawarty w określone uprawnienie. Na przykład uprawnienia, która reprezentuje dostęp do C:\example.txt stanowią podzbiór zestawu uprawnień, która reprezentuje dostęp do C:\\. Jeśli ta metoda zwraca `true`, bieżące uprawnienia reprezentuje nie uzyskać dostęp do chronionych zasobów niż określone uprawnienie.  
  
 Poniższe instrukcje muszą być `true` dla wszystkich zastąpień <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metody. *X*, *Y*, i *Z* reprezentowała obiekty uprawnień dostępu do kodu niestandardowego, które nie są puste odwołania *U* reprezentuje uprawnienia dostępu kodu bez ograniczeń i *N* reprezentuje pusty uprawnienia o <xref:System.Security.Permissions.PermissionState> z <xref:System.Security.Permissions.PermissionState.None>.  
  
-   *X*. Issubsetof — (*X*) zwraca `true`.  
  
-   *X*. Issubsetof — (*Y*) zwraca taką samą wartość jak *Y*. Issubsetof — (*X*) tylko wtedy, gdy *X* i *Y* reprezentują ten sam zestaw uprawnień.  
  
-   Jeśli *X*. Issubsetof — (*Y*) i *Y*. Issubsetof — (*Z*) zwracają `true`, *X*. Issubsetof — (*Z*) zwraca `true`.  
  
-   *X*. Issubsetof — (*U*) zwraca `true`.  
  
-   *X*. Issubsetof — (*N*) zwraca `false`.  
  
-   *N*. Issubsetof — (*X*) zwraca `true`.  
  
 Jeśli *X* i *Y* reprezentuje kod niestandardowy dostęp do uprawnień obiektów, które są puste odwołania *X*. Issubsetof — (*Y*) zwraca `true`. Jeśli *Z* również ma wartość null, operacja ustawienia złożony *X*. Złożenia (*Y*). Issubsetof — (*Z*) zwraca również wartość `true` ponieważ sumę dwóch uprawnień o wartości null jest uprawnień o wartości null.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje nadpisanie <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest tego samego typu jak bieżące uprawnienia.</exception>
        <block subset="none" type="overrides"><para>Należy przesłonić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uniemożliwia wywołującym wyżej w stosie wywołań przy użyciu kodu, który wywołuje tę metodę, aby uzyskiwać dostęp do wszystkich zasobów, z wyjątkiem zasób określony przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Security.CodeAccessPermission.PermitOnly%2A> Metoda powinna służyć tylko po to, aby chronić zasoby przed przypadkowym dostępem przez w pełni zaufany kod. Nie można stosować do ochrony zasobów z zamierzone nieuprawnione użycie przez niezaufany kod. Na przykład jeśli metoda `A` problemów <xref:System.Security.CodeAccessPermission.PermitOnly%2A> uprawnień, a następnie wywołuje metodę `B`, — Metoda `B` overtly można zastąpić <xref:System.Security.CodeAccessPermission.PermitOnly%2A> wydając <xref:System.Security.CodeAccessPermission.Assert%2A>. Metoda wywoływana jest zawsze wyżej w stosie. W związku z tym jeśli metoda `B` próbuje uzyskać dostęp do chronionego zasobu systemu zabezpieczeń, rozpocznie się sprawdzanie uprawnień z on, ponieważ metoda `B` jest bezpośredniego obiektu wywołującego i przeszukiwania i w dół stosu, aby upewnić się, że istnieje nie <xref:System.Security.CodeAccessPermission.Deny%2A> lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A> niżej w stosie. Metoda `B`, który próbuje uzyskać dostęp do zasobu, można zatrzymać przeszukiwania stosu natychmiast za pomocą <xref:System.Security.CodeAccessPermission.Assert%2A> metody. W takim przypadku <xref:System.Security.CodeAccessPermission.PermitOnly%2A> umieszczenie w stosie przez metodę `A` (wywoływania metody) nigdy nie został odnaleziony.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> jest podobny do <xref:System.Security.CodeAccessPermission.Deny%2A>, oba powodują przeszukiwań stosu niepowodzeniem, jeśli w przeciwnym razie powiedzie. Różnica jest to, że <xref:System.Security.CodeAccessPermission.Deny%2A> określa uprawnienia, które spowoduje przejście przez stos zakończyć się niepowodzeniem, ale <xref:System.Security.CodeAccessPermission.PermitOnly%2A> określa tylko uprawnienia, które nie powodują przejście przez stos nie powiedzie się.  
  
 Wywołaj tę metodę, aby upewnić się, że Twój kod może służyć do dostępu do określonych zasobów. Wywołanie <xref:System.Security.CodeAccessPermission.PermitOnly%2A> jest efektywne, dopóki kod wywołujący powraca do obiektu wywołującego. Tylko jeden <xref:System.Security.CodeAccessPermission.PermitOnly%2A> może być aktywne w ramce. Próba wywołania <xref:System.Security.CodeAccessPermission.PermitOnly%2A> podczas aktywnego <xref:System.Security.CodeAccessPermission.PermitOnly%2A> istnieje w ramce skutkuje <xref:System.Security.SecurityException>. Wywołaj <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> lub <xref:System.Security.CodeAccessPermission.RevertAll%2A> można usunąć aktywnego <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> jest ignorowany dla uprawnień nie udzielić, ponieważ żądanie dla tego uprawnienia nie powiedzie się. Jednak jeśli kod niżej w wywołanie stosu później wywołania <xref:System.Security.CodeAccessPermission.Demand%2A> dla tego uprawnienia <xref:System.Security.SecurityException> jest zgłaszany, gdy przeszukiwania stosu osiągnie kod, który próbowano wywołania <xref:System.Security.CodeAccessPermission.PermitOnly%2A>. Jest to spowodowane kod, który wywołuje <xref:System.Security.CodeAccessPermission.PermitOnly%2A> nie udzielono uprawnień, mimo że ona wywoływana <xref:System.Security.CodeAccessPermission.PermitOnly%2A> dla tego uprawnienia. Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań mogą wywoływać metod niższe w stosie wywołań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Istnieje już aktywna <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</exception>
        <block subset="none" type="overrides"><para>Nie można przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie poprzednie zastąpienia dla bieżącej ramki, który ma zostać usunięty, a nie działają.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieją żadne zastąpienia (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, lub <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) dla bieżącej ramki <xref:System.ExecutionEngineException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Istnieje nie poprzedniej <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, lub <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie poprzednie <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki, który ma zostać usunięty, a nie działają.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ma nie <xref:System.Security.CodeAccessPermission.Assert%2A> dla bieżącej ramki <xref:System.ExecutionEngineException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Istnieje nie poprzedniej <see cref="M:System.Security.CodeAccessPermission.Assert" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie poprzednie <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki, który ma zostać usunięty, a nie działają.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ma nie <xref:System.Security.CodeAccessPermission.Deny%2A> dla bieżącej ramki <xref:System.ExecutionEngineException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Istnieje nie poprzedniej <see cref="M:System.Security.CodeAccessPermission.Deny" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie poprzednie <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki, który ma zostać usunięty, a nie działają.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ma nie <xref:System.Security.CodeAccessPermission.PermitOnly%2A> dla bieżącej ramki <xref:System.ExecutionEngineException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Istnieje nie poprzedniej <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> dla bieżącej ramki.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca ciąg reprezentujący bieżący obiekt uprawnień.</summary>
        <returns>Ciąg reprezentujący bieżący obiekt uprawnień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna podczas debugowania, gdy zachodzi potrzeba wyświetlenia uprawnień jako ciąg.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej tworzy Kodowanie XML obiektu zabezpieczeń oraz w jego bieżącym stanie.</summary>
        <returns>Kodowanie XML obiektu zabezpieczeń, w tym wszelkich informacji o stanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod niestandardowy, który rozszerza obiekty zabezpieczeń należy zaimplementować <xref:System.Security.CodeAccessPermission.ToXml%2A> i <xref:System.Security.CodeAccessPermission.FromXml%2A> metody w celu dokonania obiekty można kodować zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje nadpisanie <xref:System.Security.CodeAccessPermission.ToXml%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Należy przesłonić tę metodę w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">Uprawnienie do łączenia z uprawnieniami bieżącego. Należy się tego samego typu jak bieżące uprawnienia.</param>
        <summary>Po przesłonięciu w klasie pochodnej tworzy uprawnienia, które jest złożenie bieżące uprawnienia i określony.</summary>
        <returns>Nowe uprawnienie, który reprezentuje sumę bieżące uprawnienia i określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wywołania <xref:System.Security.CodeAccessPermission.Union%2A> uprawnienia, który reprezentuje wszystkie operacje, które są reprezentowane przez bieżące uprawnienia i określone uprawnienie. Wszelkie żądania spełniającą albo uprawnienie przekazuje ich Unii.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje nadpisanie <xref:System.Security.CodeAccessPermission.Union%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Security.CodeAccessPermission> klasy.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="other" /> Parametr nie jest <see langword="null" />. Ta metoda jest obsługiwana tylko na tym poziomie, gdy przekazywane <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Należy przesłonić tę metodę w klasie pochodnej. Użytkownik powinien zwrócić kopię uprawnienia, jeśli wartość <paramref name="other" /> parametr <see langword="null" />.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4ee0efcb11958b06d8fb52b41af80abd98605cfd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36527622" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <TypeSignature Language="F#" Value="type HostSecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia kontrolą i dostosowywaniem zachowania zabezpieczeń dla domeny aplikacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia nowego <xref:System.AppDomain>, typowe kwerendy środowiska uruchomieniowego języka <xref:System.AppDomainManager> obecność <xref:System.Security.HostSecurityManager>, który uczestniczy w podejmowaniu decyzji dotyczących zabezpieczeń <xref:System.AppDomain>.  Dostawców hosta powinien implementować Menedżera zabezpieczeń hosta, która dziedziczy <xref:System.Security.HostSecurityManager> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia bardzo prosta implementacja <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym lub przezroczyste.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <block subset="none" type="overrides">
      <para>Niektórzy członkowie <see cref="T:System.Security.HostSecurityManager" /> są wywoływane zawsze, gdy zestaw jest załadowany, jawnie lub niejawnie. <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> i <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> metod nie musi załadować żadnych zestawów, ponieważ w ten sposób spowoduje członków <see cref="T:System.Security.HostSecurityManager" /> trwa rekursywnie wywołuje. Aby uniknąć odwołań cyklicznych, należy utworzyć nowe wystąpienia klasy, które mogą spowodować zestawów do załadowania, bezpośrednio lub pośrednio, w konstruktorze klasy, która pochodzi z <see cref="T:System.Security.HostSecurityManager" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.HostSecurityManager" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
        <block subset="none" type="overrides">
          <para>Tworzenie wystąpienia klas, które mogą spowodować zestawy załadowana jawnie lub niejawnie, w tym konstruktorze.  Metody dostępu get dla <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> właściwości i <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> i <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> metody są wywoływane zawsze, gdy zestaw jest ładowany i spowoduje, że ich kolejnych ładowania zestawów odwołań cyklicznych.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust&#xA;override this.DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust" Usage="hostSecurityManager.DetermineApplicationTrust (applicationEvidence, activatorEvidence, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Świadectwo aplikacji do aktywacji.</param>
        <param name="activatorEvidence">Opcjonalnie dowód aktywowanej domeny aplikacji.</param>
        <param name="context">Kontekst zaufania.</param>
        <summary>Określa, czy aplikacja ma być wykonany.</summary>
        <returns>Obiekt, który zawiera poufnych informacji o aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną. Podstawowa implementacja wywołuje Menedżera zabezpieczeń aplikacji, aby ustalić, czy aplikacja ma być wykonany.  
  
 Podstawowa implementacja nie używa dowód aktywatora. Jednak implementacji przesłoniętych można użyć dowód aktywatora ustalenie dowodów zabezpieczeń domeny aplikacji próby aktywowania aplikacji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> metodę dla Menedżera zabezpieczeń hosta niestandardowego. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.HostSecurityManager> klasy.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationEvidence" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Runtime.Hosting.ActivationArguments" /> w świadectwo aplikacji nie można odnaleźć obiektu.  - lub - <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> właściwość w argumenty aktywacji jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Security.Policy.ApplicationTrust" /> Udzielić minimalnych żądania określony przez zestaw nie wchodzi w skład zestawu <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainPolicy : System.Security.Policy.PolicyLevel" Usage="System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera zasady zabezpieczeń dla bieżącej domeny aplikacji.</summary>
        <value>Zasady zabezpieczeń dla bieżącej domeny aplikacji. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może zostać zastąpiona w klasie pochodnej. Podstawowa implementacja zawsze zwraca `null`.  
  
 Ta właściwość jest wywołana w <xref:System.AppDomain> czas utworzenia. Umożliwia umożliwiają określanie zasad dla bieżącego hosta <xref:System.AppDomain>.  Poziomu zasad składa się z następujących czynności:  
  
-   Zbiór grup kodów zorganizowane w jedno drzewo odblokowanym dostępem.  
  
-   Zestaw zestawy uprawnień o nazwie, które są określone przez grupy kod, aby określić uprawnienia, aby otrzymać kod należące do grupy kodu.  
  
-   Lista całkowicie zaufanych zestawów.  
  
> [!IMPORTANT]
>  Zobacz uwagi dotyczące dziedziczenia dla <xref:System.Security.HostSecurityManager> klasa implementacji krytyczne informacje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Security.HostSecurityManagerOptions" Usage="System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera flagę reprezentująca składniki zasad zabezpieczeń potencjalnie do hosta.</summary>
        <value>Jedna z wartości wyliczenia, które określa składniki zasad zabezpieczeń. Wartość domyślna to <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może zostać zastąpiona w klasie pochodnej. Podstawowa implementacja zawsze zwraca <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 Pochodne hosta można zmienić wartości tej właściwości, gdy tylko podzestaw <xref:System.Security.HostSecurityManagerOptions> ma znaczenie.  Możliwe podzestawy obejmują none, odrzuconych zestawu, poziomu zasad i świadectwa zestawu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Security.HostSecurityManager.Flags%2A> właściwość Menedżera zabezpieczeń hosta niestandardowego. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.HostSecurityManager> klasy.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAppDomainEvidence evidenceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Typ dowodu.</param>
        <summary>Żądania typu dowód określonej domeny aplikacji.</summary>
        <returns>Żądana aplikacja dowód domeny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną. Podstawowa implementacja zwraca `null`.  
  
 Środowisko uruchomieniowe języka wspólnego wywołuje tę metodę, gdy wymagany jest dowód określonego typu dla bieżącego <xref:System.AppDomain>. Zwrócona wartość jest używana jako dowód hosta dostarczone i są przechowywane w <xref:System.AppDomain.Evidence%2A> Kolekcja <xref:System.AppDomain.CurrentDomain%2A> właściwości. Można użyć <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> metodę, aby uzyskać dowód wygenerowane z kolekcji.  
  
 Aby uzyskać wywołanie zwrotne do tej metody, należy określić hosty <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> oflagowane w <xref:System.Security.HostSecurityManager.Flags%2A> właściwości.  
  
 Ta metoda generuje dowód pozwala hostom na opóźnienie generacji dowody dla <xref:System.AppDomain> dopóki dowody jest wymagana. W wersji .NET Framework 3.5 i wcześniejszymi wersjami, została niezbędne do zapewnienia <xref:System.AppDomain> dowód w czasie ładowania przez zastąpienie <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> metody. Firma Microsoft zaleca użycie <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> aby udowodnić, zamiast przesłaniać metodę <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Metoda jest wywoływana wstecz do tylko dla typów dowód, że host jest określona w przesłonięciu <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> metody.  
  
 Zwracana wartość `null` wskazuje, że host nie może wygenerować dowód określonego typu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> metodę dla Menedżera zabezpieczeń hosta niestandardowego. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.HostSecurityManager> klasy.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAssemblyEvidence (evidenceType, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Typ dowodu.</param>
        <param name="assembly">Zestaw docelowy.</param>
        <summary>Żądania typu dowodów dla zestawu.</summary>
        <returns>Dowód żądany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną. Podstawowa implementacja zwraca `null`.  
  
 Środowisko uruchomieniowe języka wspólnego wywołuje tę metodę, gdy wymagany jest dowód określonego typu dla bieżącego zestawu. Zwrócona wartość jest używana jako dowód hosta dostarczone i są przechowywane w <xref:System.Reflection.Assembly.Evidence%2A> właściwości. Można użyć <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> metoda wygenerowanego dowodów z <xref:System.Reflection.Assembly.Evidence%2A> właściwości.  
  
 Aby uzyskać wywołanie zwrotne do tej metody, należy określić hosty <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> oflagowane w <xref:System.Security.HostSecurityManager.Flags%2A> właściwości.  
  
 Ta metoda generuje dowód pozwala hostom na opóźnienie generacji dowody dla <xref:System.AppDomain> dopóki dowody jest wymagana. W .NET Framework 3.5 i wcześniejszymi wersjami, została niezbędne do zapewnienia <xref:System.AppDomain> dowód w czasie ładowania przez zastąpienie <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> metody. Firma Microsoft zaleca użycie <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> aby udowodnić, zamiast przesłaniać metodę <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Metoda jest wywoływana wstecz do tylko dla typów dowód, że host jest określona w przesłonięciu <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> metody.  
  
 Zwracana wartość `null` wskazuje, że host nie może wygenerować dowód określonego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]&#xA;override this.GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa typy dowody, które host może dostarczyć domeny aplikacji, jeśli jest to wymagane.</summary>
        <returns>Tablica typów dowód.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną. Podstawowa implementacja zwraca `null`.  
  
 Typy zwracane przez tę metodę określają czy <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> metoda jest wywoływana wstecz do. Obecności typu na tej liście nie oznacza, że host musi mieć możliwość wygenerowania tego typu dowód, ale czy może istnieć możliwość. Z tego powodu najlepiej jest nadmiernie Określ zamiast w obszarze określenie typów na tej liście.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]&#xA;override this.GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Zestaw docelowy.</param>
        <summary>Określa typy dowód hosta można podać dla zestawu, jeśli jest to wymagane.</summary>
        <returns>Tablica typów dowód.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną. Podstawowa implementacja zwraca `null`.  
  
 Typy zwracane przez tę metodę określają czy <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> metoda jest wywoływana wstecz do. Obecności typu na tej liście nie oznacza, że host musi mieć możliwość wygenerowania tego typu dowód, ale czy może istnieć możliwość. Z tego powodu najlepiej jest nadmiernie Określ zamiast w obszarze określenie typów na tej liście.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAppDomainEvidence inputEvidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Dodatkowych dowodów do dodania do <see cref="T:System.AppDomain" /> dowód.</param>
        <summary>Udostępnia ładowany zestaw dowód domeny aplikacji.</summary>
        <returns>Dowód służący do <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zostać zastąpiona w klasie pochodnej.  
  
 Ta metoda jest wywoływana przy każdym <xref:System.AppDomain> tworzony jest obiekt. `inputEvidence` Parametr jest obliczana dowód od środowiska CLR. Implementacja hosta można zwiększyć lub zmniejszyć dowody. Wartość zwracana jest dowód służący do domeny aplikacji.  Podstawowa implementacja zawsze zwraca obiekt dowód przekazany jako `inputEvidence` parametru.  
  
> [!IMPORTANT]
>  Zobacz uwagi dotyczące dziedziczenia dla <xref:System.Security.HostSecurityManager> klasa implementacji krytyczne informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAssemblyEvidence (loadedAssembly, inputEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Załadowany zestaw.</param>
        <param name="inputEvidence">Dodatkowych dowodów do dodania do świadectwa zestawu.</param>
        <summary>Udostępnia żądanie dowodu zestawu dla zestawu ładowany.</summary>
        <returns>Dowód do użycia dla zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zostać zastąpiona w klasie pochodnej.  
  
 Ta metoda jest wywoływana, gdy zestaw jest załadowany, jawnie lub niejawnie. Przekazane parametry są ładowany zestaw i obliczona dowód od środowiska CLR. Implementacja hosta można zwiększyć lub zmniejszyć dowody. Wartość zwracana jest dowód do użycia dla zestawu.  Podstawowa implementacja zawsze zwraca obiekt dowód przekazany jako `inputEvidence` parametru.  
  
> [!IMPORTANT]
>  Zobacz uwagi dotyczące dziedziczenia dla <xref:System.Security.HostSecurityManager> klasa implementacji krytyczne informacje.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> metodę dla Menedżera zabezpieczeń hosta niestandardowego. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Security.HostSecurityManager> klasy.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet&#xA;override this.ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="hostSecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowód, używany do oceny zasad.</param>
        <summary>Określa co uprawnień udzielanych do kodu na podstawie określonego dowód.</summary>
        <returns>Zestaw uprawnień, które mogą być przyznane przez system zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje aparat zasad zabezpieczeń, zapewniając dowód określony. Wynik jest określany przez zasady zabezpieczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
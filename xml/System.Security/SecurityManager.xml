<Type Name="SecurityManager" FullName="System.Security.SecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="239214f62562382c97bea65d76974e1216b11844" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36424042" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class SecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class SecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityManager abstract sealed" />
  <TypeSignature Language="F#" Value="type SecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia punkt głównego dostępu dla klas interakcji z systemu zabezpieczeń. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja zabezpieczenia oferuje metody dostępu i modyfikowania konfiguracji zasad zabezpieczeń. Nie można utworzyć wystąpienia <xref:System.Security.SecurityManager>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckExecutionRights">
      <MemberSignature Language="C#" Value="public static bool CheckExecutionRights { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckExecutionRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.CheckExecutionRights" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckExecutionRights As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckExecutionRights { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckExecutionRights : bool with get, set" Usage="System.Security.SecurityManager.CheckExecutionRights" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kod musi mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> w celu wykonania.</summary>
        <value>
          <see langword="true" /> Jeśli kod musi zawierać <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> Aby wykonać; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest `false`, nawet kodu bez <xref:System.Security.Permissions.SecurityPermissionFlag.Execution> może zostać uruchomiony. Sprawdzenie wykonywania jest kosztowne i może wyeliminować korzyści wynikające z opóźnieniem zasad rozpoznawania. Ta właściwość jest udostępniana, aby wyłączyć sprawdzanie, gdy jest wymagane wykonanie.  
  
 Zmiana ta właściwość nie jest trwały do <xref:System.Security.SecurityManager.SavePolicy%2A> jest wywoływana. Zmiana nie będzie wpływu nowych procesów, dopóki nie jest trwały w rejestrze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadRequiresSecurityContextCapture">
      <MemberSignature Language="C#" Value="public static bool CurrentThreadRequiresSecurityContextCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CurrentThreadRequiresSecurityContextCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CurrentThreadRequiresSecurityContextCapture () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CurrentThreadRequiresSecurityContextCapture();" />
      <MemberSignature Language="F#" Value="static member CurrentThreadRequiresSecurityContextCapture : unit -&gt; bool" Usage="System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy bieżący wątek wymaga przechwytywania kontekstu zabezpieczeń, jeśli jego stanu zabezpieczeń ma zostać utworzony ponownie w późniejszym czasie w czasie.</summary>
        <returns>
          <see langword="false" /> Jeśli stosu zawiera aplikacji częściowo zaufanej domeny, nie częściowo zaufane zestawy i braku aktywnego <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> lub <see cref="M:System.Security.CodeAccessPermission.Deny" /> Modyfikatory; <see langword="true" /> Jeśli środowisko uruchomieniowe języka wspólnego nie może zagwarantować, że stos nie zawiera żadnego z tych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> metody, aby buforować dane poufne, które są uzyskiwane po wymagań zabezpieczeń.  
  
 Jeśli <xref:System.Security.CodeAccessPermission.Assert%2A> została wywołana metoda wyższej na stosie, dane nie mają być buforowane bez Przechwytywanie odpowiadający mu kontekst zabezpieczeń. W przeciwnym razie poufne dane, które są uzyskiwane w ramach <xref:System.Security.CodeAccessPermission.Assert%2A> mogą stać się dostępne dla kodu, który jest przestanie działać z tym <xref:System.Security.CodeAccessPermission.Assert%2A> w miejscu.  
  
> [!IMPORTANT]
>  Wartość zwracana jest wiarygodne tylko wtedy, gdy jest `false`, co oznacza, że zagwarantowanie wątek nie jest wymagane przechwytywania kontekstu zabezpieczeń. Metoda może zwrócić wartość true, gdy przechwytywanie kontekstu zabezpieczeń nie jest konieczne w celu uniknięcia luk w zabezpieczeniach.  
  
 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> jest krytyczny dla zabezpieczeń, ponieważ jest głównie w celu uniknięcia kontekstu zabezpieczeń niepotrzebnych przechwytuje, która wskazuje, że kod przy użyciu jego jest istotnych dla zabezpieczeń i musi być sprawdzona.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStandardSandbox">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet GetStandardSandbox(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ GetStandardSandbox(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member GetStandardSandbox : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.GetStandardSandbox evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowód hosta, aby dopasować do zestawu uprawnień.</param>
        <summary>Pobiera zestaw uprawnień, które można bezpiecznie przydzielić do aplikacji, która została podana dowód.</summary>
        <returns>Zestaw uprawnień może być używany jako zestaw dla aplikacji, która została podana dowód uprawnień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  W [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], host dowody w `evidence` musi zawierać <xref:System.Security.Policy.Zone?displayProperty=nameWithType> dowód.  
>   
>  W poniższej tabeli przedstawiono zestawy uprawnień, które są zwracane w każdej strefie.  
  
|Strefy|Zestaw uprawnień|  
|----------|--------------------|  
|<xref:System.Security.SecurityZone.MyComputer>|`FullTrust`|  
|<xref:System.Security.SecurityZone.Intranet>|`LocalIntranet`|  
|<xref:System.Security.SecurityZone.Trusted>|`Internet`|  
|<xref:System.Security.SecurityZone.Internet>|`Internet`|  
|<xref:System.Security.SecurityZone.Untrusted>|Brak|  
|<xref:System.Security.SecurityZone.NoZone>|Brak|  
  
 Inne dowody, takie jak <xref:System.Security.Policy.Url> lub <xref:System.Security.Policy.Site>, można rozważyć.  
  
 Zestaw uprawnień zwrócony mogą posłużyć piaskownicy do uruchomienia aplikacji. Należy pamiętać, ta metoda nie określa zasady, ale pomaga hosta do ustalenia, czy zestaw uprawnień żądany przez aplikację jest uzasadnione. Ta metoda może służyć do mapowania strefy piaskownicy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Security.SecurityManager.GetStandardSandbox%2A> metodę, aby uzyskać uprawnienia do ustawienia aplikacji piaskownicy. Aby uzyskać więcej informacji na temat uruchamiania aplikacji w bibliotece, zobacz [porady: uruchamianie częściowo zaufanego kodu w bibliotece](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  
  
 [!code-csharp[sandboxingApis#1](~/samples/snippets/csharp/VS_Snippets_CLR/SandboxingAPIs/CS/program.cs#1)]
 [!code-vb[sandboxingApis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SandboxingAPIs/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetZoneAndOrigin">
      <MemberSignature Language="C#" Value="public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetZoneAndOrigin([out] class System.Collections.ArrayList&amp; zone, [out] class System.Collections.ArrayList&amp; origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetZoneAndOrigin (ByRef zone As ArrayList, ByRef origin As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetZoneAndOrigin([Runtime::InteropServices::Out] System::Collections::ArrayList ^ % zone, [Runtime::InteropServices::Out] System::Collections::ArrayList ^ % origin);" />
      <MemberSignature Language="F#" Value="static member GetZoneAndOrigin :  *  -&gt; unit" Usage="System.Security.SecurityManager.GetZoneAndOrigin (zone, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="zone" Type="System.Collections.ArrayList&amp;" RefType="out" />
        <Parameter Name="origin" Type="System.Collections.ArrayList&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="zone">Parametr wyjściowy, który zawiera <see cref="T:System.Collections.ArrayList" /> z nadanego <see cref="P:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone" /> obiektów.</param>
        <param name="origin">Parametr wyjściowy, który zawiera <see cref="T:System.Collections.ArrayList" /> z nadanego <see cref="T:System.Security.Permissions.UrlIdentityPermission" /> obiektów.</param>
        <summary>Pobiera nadanego tożsamości strefy i zestawów uprawnień tożsamości adresu URL dla bieżącego zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecaną alternatywą do tej metody jest użycie adresu URL i strefy dowód wykonywany zestaw do wywołania <xref:System.Security.SecurityManager.ResolvePolicy%2A> dla każdego typu dowodu. Zestawy uprawnień zwrócony z <xref:System.Security.SecurityManager.ResolvePolicy%2A> wywołania zidentyfikować uprawnienia do wykonywania zestawu na podstawie strefy i adres URL źródła.  
  
> [!NOTE]
>  Ten element członkowski sprawia, że żądanie łącza ECMA klucza publicznego, który nie jest prawidłowy klucz kryptograficzny, ale klucz pseudo. W programie .NET Framework linkdemand dla klucza pseudo ECMA jest automatycznie konwertowany na żądanie łącza dla klucza publicznego firmy Microsoft. Wyjątek zabezpieczeń jest oparta na Microsoft klucz publiczny nie klucza pseudo ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Żądanie <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> nie powiodło się.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsGranted">
      <MemberSignature Language="C#" Value="public static bool IsGranted (System.Security.IPermission perm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGranted(class System.Security.IPermission perm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.IsGranted(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsGranted (perm As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsGranted(System::Security::IPermission ^ perm);" />
      <MemberSignature Language="F#" Value="static member IsGranted : System.Security.IPermission -&gt; bool" Usage="System.Security.SecurityManager.IsGranted perm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="perm" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="perm">Uprawnienie do przetestowania grant obiektu wywołującego.</param>
        <summary>Określa, czy można udzielić uprawnienia do obiektu wywołującego.</summary>
        <returns>
          <see langword="true" /> Jeśli uprawnienia do obiektu wywołującego obejmują uprawnienie <paramref name="perm" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Udzielanie uprawnień jest określany przez zasady i różni się od żądanie może ulec zastąpień, takich jak potwierdzenia. Ponadto <xref:System.Security.SecurityManager.IsGranted%2A> tylko testy przyznawania wywołującego zestawu kod, niezależnie od innych obiektów wywołujących na stosie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromFile">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromFile (path As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromFile(System::String ^ path, System::Security::PolicyLevelType type);" />
      <MemberSignature Language="F#" Value="static member LoadPolicyLevelFromFile : string * System.Security.PolicyLevelType -&gt; System.Security.Policy.PolicyLevel" Usage="System.Security.SecurityManager.LoadPolicyLevelFromFile (path, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku fizycznego do pliku zawierającego informacje o zasadach zabezpieczeń.</param>
        <param name="type">Jedna z wartości wyliczenia, które określa typ poziomu zasad do załadowania.</param>
        <summary>Ładunki <see cref="T:System.Security.Policy.PolicyLevel" /> z określonego pliku.</summary>
        <returns>Poziom załadować zasad.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wskazuje plik <paramref name="path" /> parametr nie istnieje.</exception>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.  - lub - kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.  - lub - kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.  - lub - kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wyświetlania i modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromString">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromString (str As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromString(System::String ^ str, System::Security::PolicyLevelType type);" />
      <MemberSignature Language="F#" Value="static member LoadPolicyLevelFromString : string * System.Security.PolicyLevelType -&gt; System.Security.Policy.PolicyLevel" Usage="System.Security.SecurityManager.LoadPolicyLevelFromString (str, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="str">Reprezentacja XML poziomu zasad zabezpieczeń w tym samym formularzu, w których występuje w pliku konfiguracji.</param>
        <param name="type">Jedna z wartości wyliczenia, które określa typ poziomu zasad do załadowania.</param>
        <summary>Ładunki <see cref="T:System.Security.Policy.PolicyLevel" /> z określonego ciągu.</summary>
        <returns>Poziom załadować zasad.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> Parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wyświetlania i modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PolicyHierarchy">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator PolicyHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator PolicyHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.PolicyHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PolicyHierarchy () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ PolicyHierarchy();" />
      <MemberSignature Language="F#" Value="static member PolicyHierarchy : unit -&gt; System.Collections.IEnumerator" Usage="System.Security.SecurityManager.PolicyHierarchy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia moduł wyliczający hierarchii zasad zabezpieczeń przez poziomy, takie jak zasady komputera i użytkownika, zasady dostępu do.</summary>
        <returns>Moduł wyliczający dla <see cref="T:System.Security.Policy.PolicyLevel" /> obiekty tworzące hierarchii zasad zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony modułu wyliczającego zapewnia kolejnych <xref:System.Security.Policy.PolicyLevel> obiekty reprezentujące zasady na odpowiednich (komputera, użytkownika, enterprise, domeny aplikacji) poziomu hierarchii. Te obiekty są obiektami zasad na żywo; Zmiana tych obiektów może mieć nieprzewidywalne skutki.  
  
 Minimalna zasad hierarchia składa się z poziomu komputera, na poziomie przedsiębiorstwa i na poziomie użytkownika. Jednak hierarchia może zawierać dodatkowe poziomy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość wyświetlania i modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolvePolicy">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, jakie uprawnienia, aby udzielić kodu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowód, używany do oceny zasad.</param>
        <summary>Określa co uprawnień udzielanych do kodu na podstawie określonego dowód.</summary>
        <returns>Zestaw uprawnień, które może być przyznane przez system zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje aparat zasad zabezpieczeń, zapewniając dowód tożsamości wywołującego kodu. Wynik jest określany przez zasady zabezpieczeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence[] evidences) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ResolvePolicy (evidences As Evidence()) As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(cli::array &lt;System::Security::Policy::Evidence ^&gt; ^ evidences);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicy : System.Security.Policy.Evidence[] -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolvePolicy evidences" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidences" Type="System.Security.Policy.Evidence[]" />
      </Parameters>
      <Docs>
        <param name="evidences">Tablica obiektów dowód używane do oceny zasad.</param>
        <summary>Określa co uprawnień udzielanych do kodu na podstawie określonego dowód.</summary>
        <returns>Zestaw uprawnień, który jest odpowiednia dla wszystkich dowodów podana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje aparat zasad zabezpieczeń, zapewniając tablicę <xref:System.Security.Policy.Evidence> obiektów. Zestaw uprawnień zwrócony reprezentuje tylko te uprawnienia, które są stosowane do każdej dowód w tablicy. Te uprawnienia są równoważne lub podzbiór uprawnienia, które zasady mogą mieć udzielone każdej poszczególnych dowód. Ta metoda działa tak, jakby wykonywana przecięcie wyników rozpoznawania zasad na wszystkich <xref:System.Security.Policy.Evidence> obiektów w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet reqdPset, class System.Security.PermissionSet optPset, class System.Security.PermissionSet denyPset, [out] class System.Security.PermissionSet&amp; denied) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ reqdPset, System::Security::PermissionSet ^ optPset, System::Security::PermissionSet ^ denyPset, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % denied);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicy : System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet *  -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolvePolicy (evidence, reqdPset, optPset, denyPset, denied)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="reqdPset" Type="System.Security.PermissionSet" />
        <Parameter Name="optPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denyPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denied" Type="System.Security.PermissionSet&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowód, używany do oceny zasad.</param>
        <param name="reqdPset">Uprawnienia wymagane kod musi być uruchamiane.</param>
        <param name="optPset">Opcjonalne uprawnienia, które zostaną użyte, jeśli przyznano, ale nie są wymagane dla kodu do uruchomienia.</param>
        <param name="denyPset">Odmówiono uprawnienia, które nigdy nie muszą uprawnienie do kodu, nawet wtedy, gdy zasady, w przeciwnym razie pozwala.</param>
        <param name="denied">Parametr wyjściowy, który zawiera zestaw uprawnień nie.</param>
        <summary>Określa co uprawnień udzielanych do kodu na podstawie żądań i dowód określony.</summary>
        <returns>Zestaw uprawnień, które mogą zostać udzielone przez system zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje aparat zasad zabezpieczeń obejmujące dowód tożsamości wywołującego kodu oraz zestaw uprawnień kodu żądania. Wynik jest określany przez zasady zabezpieczeń. Ta metoda zwraca zestaw uprawnień, które mogą zostać udzielone przez system zabezpieczeń, natomiast zestaw uprawnień, które zostałyby odrzucone jako parametr wyjściowy. Czynne uprawnienia nadanego, są lokalizacje w zestawie nadanego, które nie znajdują się w zestawie odmowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Zasady nie powiedzie się, można udzielić minimalnych wymaganych uprawnień, określony przez <paramref name="reqdPset" /> parametru.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicyGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator ResolvePolicyGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ ResolvePolicyGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member ResolvePolicyGroups : System.Security.Policy.Evidence -&gt; System.Collections.IEnumerator" Usage="System.Security.SecurityManager.ResolvePolicyGroups evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowód, ustawić przed jest obliczane zasad.</param>
        <summary>Pobiera kolekcję grup kodów dopasowania określonej dowód.</summary>
        <returns>Wyliczenie zestawu grup kodów dopasowania dowody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna w analizowanie działania konfiguracji określonych zasad z określonych rodzajów dowód.  
  
 Grupy kodów zostaną zwrócone ze wszystkich odpowiednich poziomów hierarchii zasad odpowiadającym `evidence` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSystemPolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolveSystemPolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolveSystemPolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member ResolveSystemPolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="System.Security.SecurityManager.ResolveSystemPolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowód, używany do oceny zasad.</param>
        <summary>Określa uprawnienia, których chcesz udzielić kodu oparte na dowód określony, z wyłączeniem zasady dla <see cref="T:System.AppDomain" /> poziom.</summary>
        <returns>Zestaw uprawnień, które może być przyznane przez system zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje aparat zasad zabezpieczeń i dostarcza mu dowód tożsamości wywołującego kodu. Wynik jest określany przez zasady zabezpieczeń systemu bez żadnego <xref:System.AppDomain> zasad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="SavePolicy">
      <MemberSignature Language="C#" Value="public static void SavePolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicy();" />
      <MemberSignature Language="F#" Value="static member SavePolicy : unit -&gt; unit" Usage="System.Security.SecurityManager.SavePolicy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje stan zasad zabezpieczeń zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Taka metoda ogranicza zasady, zgodnie z udostępnianych przez <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, i inne klasy tej konfiguracji reprezentują zasad zabezpieczeń. O ile ta metoda jest wywoływana, zmiany wprowadzone w obiektach zasad nie zostaną zapisane i nie będzie miało wpływ na kolejne aplikacji działa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SavePolicyLevel">
      <MemberSignature Language="C#" Value="public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicyLevel(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicyLevel (level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicyLevel(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberSignature Language="F#" Value="static member SavePolicyLevel : System.Security.Policy.PolicyLevel -&gt; unit" Usage="System.Security.SecurityManager.SavePolicyLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">Obiekt poziomu zasad do zapisania.</param>
        <summary>Zapisuje poziomu zasad zabezpieczeń zmodyfikowane załadowany z <see cref="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Policy.PolicyLevel> Zostanie zapisany w tej samej lokalizacji, z którego ładowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda używa zasad zabezpieczeń (CAS) dostępu kodu, które jest przestarzałe w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]. Aby włączyć zasady CAS na zgodność ze starszymi wersjami programu .NET Framework, użyj [&lt;legacyCasPolicy&gt; element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityEnabled">
      <MemberSignature Language="C#" Value="public static bool SecurityEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SecurityEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.SecurityEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SecurityEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityEnabled : bool with get, set" Usage="System.Security.SecurityManager.SecurityEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The security manager cannot be turned off on MS runtime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zabezpieczenia są włączone.</summary>
        <value>
          <see langword="true" /> Jeśli włączono zabezpieczeń; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana przez [Caspol.exe (narzędzie zasad zabezpieczenia dostępu kodu)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)  
  
 `-security` (`-s`) opcję, aby wyłączyć zabezpieczeń opartych na kodzie.  
  
 <xref:System.Security.SecurityManager.SecurityEnabled%2A> Umożliwia administratorom wyłączyć zabezpieczenia dostępu kodu. Gdy zabezpieczenia dostępu kodu są wyłączone, wszystkie żądania dostępu do kodu kończą się powodzeniem. Efektywne, spowoduje to przydzielenie cały kod `FullTrust`. Wyłączenie zabezpieczeń dostępu kodu omija system zabezpieczeń, dzięki czemu może wykonywać kod nieco lepsza niż przyznawanie zasad zabezpieczeń równoważne `FullTrust` dla całego kodu. Ta właściwość nie wyłączać opartej na rolach zabezpieczeń; w związku z tym <xref:System.Security.Permissions.PrincipalPermission> zapotrzebowanie nie dotyczy.  
  
> [!CAUTION]
>  Wyłączenie zabezpieczeń dostępu kodu sprawia, że system staje się podatny na ataki złośliwego kodu, takiego jak wirusy i robaki. Wyłączenie zabezpieczeń dostępu kodu nie automatycznie blokuje kodu zarządzanego z systemem w dowolny sposób. IT tylko przyczyny kodu do uruchomienia bez ograniczeń przez system zabezpieczeń dostępu kodu zarządzanego i powinny być przeprowadzone wyłącznie z najbardziej najwyższą ostrożność. Wyłączenie zabezpieczeń w celu uzyskania dodatkowych wydajności należy przypisywać tylko wtedy gdy innych środków zabezpieczeń mających na celu pomóc w ochronie zabezpieczeń systemu. Przykłady innych środków ostrożności to: odłączenie od sieci publicznych, fizyczne zabezpieczanie komputerów i tak dalej.  
  
 Zmiana tej właściwości nie są utrwalane w rejestrze, dopóki <xref:System.Security.SecurityManager.SavePolicy%2A> jest wywoływana. Zmiana nie będzie wpływu nowych procesów, dopóki nie jest trwały w rejestrze. Zmiana wartości tej właściwości w uruchomionego procesu nie zawsze zmiany stanu w oczekiwany sposób. Aby zmiany zostały wprowadzone, należy wywołać <xref:System.Security.SecurityManager.SavePolicy%2A> i uruchomić nowego procesu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Kod, który wywołuje tę metodę ma <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do modyfikowania zasad. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="IPermission" FullName="System.Security.IPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="def0fec4287ee20f28cae73ca940d9d545fb635c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36527854" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPermission : System.Security.ISecurityEncodable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPermission implements class System.Security.ISecurityEncodable" />
  <TypeSignature Language="DocId" Value="T:System.Security.IPermission" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPermission&#xA;Implements ISecurityEncodable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPermission : System::Security::ISecurityEncodable" />
  <TypeSignature Language="F#" Value="type IPermission = interface&#xA;    interface ISecurityEncodable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje metody implementowane przez typy uprawnień.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uprawnienia w środowisku uruchomieniowym języka są obiektami, które opisują zestawów działań, które mogą być chronione dla określonych zasobów. Obiekt uprawnienia w tym artykule opisano operacje lub dostępu, który podlega kontroli zabezpieczeń; reprezentuje dostępu lub w prawo w celu wykonania operacji. Uprawnienia są używane zarówno przez kod aplikacji i systemu .NET Framework zabezpieczeń w następujący sposób.  
  
-   Kod żądania uprawnienia, które wymaga, aby można było uruchomić.  
  
-   Zasady systemu zabezpieczeń przyznaje uprawnienia do kodu, aby go uruchomić.  
  
-   Kod wymaga, aby wywołanie kodu ma uprawnienie.  
  
-   Kod zastępuje stosu zabezpieczeń przy użyciu potwierdzenia / / zezwolenia tylko odmowa.  
  
> [!NOTE]
>  Jeśli piszesz nowe uprawnienie należy zaimplementować ten interfejs w klasie.  
  
> [!IMPORTANT]
>  Uprawnienia są dostępne przez wiele wątków. Podczas implementowania interfejsu, użytkownik musi zagwarantować, że <xref:System.Security.IPermission.IsSubsetOf%2A>, <xref:System.Security.IPermission.Intersect%2A>, <xref:System.Security.IPermission.Union%2A>, i <xref:System.Security.IPermission.Copy%2A> implementacje metod są bezpieczne dla wątków.  
  
   
  
## Examples  
 Ten przykład przedstawia sposób definiowania klasy uprawnień do użycia z zabezpieczeniami dostępu kodu. Wszystkie interfejsy niezbędne uprawnienia są implementowane.  
  
 [!code-cpp[Permission#1](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#1)]
 [!code-csharp[Permission#1](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#1)]
 [!code-vb[Permission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="iPermission.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca identyczne kopię bieżącego uprawnień.</summary>
        <returns>Kopię bieżącego uprawnień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopię uprawnienie reprezentuje takie same prawa dostępu do zasobów oryginalnego uprawnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementacja <xref:System.Security.IPermission.Copy%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.IPermission> klasy.  
  
 [!code-cpp[Permission#4](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#4)]
 [!code-csharp[Permission#4](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#4)]
 [!code-vb[Permission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iPermission.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.Security.SecurityException" /> w czasie wykonywania, jeśli nie są spełnione wymagania dotyczące zabezpieczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana zazwyczaj przez bezpieczne biblioteki, aby upewnić się, że obiekty wywołujące ma uprawnienia do uzyskania dostępu do zasobu. Na przykład wywołuje klasy pliku w bibliotece klas bezpiecznego <xref:System.Security.CodeAccessPermission.Demand%2A> dla niezbędnych <xref:System.Security.Permissions.FileIOPermission> przed wykonaniem operacji na pliku żądanego przez obiekt wywołujący.  
  
 Mimo że większość klas, które implementują metody tego interfejsu spełniają kryteria bezpieczeństwa przez wykonanie pełnego stosów, przeszukiwania stosu nie jest wykonywane zawsze. Na przykład implementację, która wykonuje przeszukiwania stosu <xref:System.Security.Permissions.PrincipalPermission.Demand%2A?displayProperty=nameWithType>.  
  
 Podczas przeszukiwania stosu nie są sprawdzane uprawnienia kod, który wywołuje tę metodę; Sprawdzanie zaczyna się od bezpośredniego obiektu wywołującego kodu i jest przeprowadzane w górę stosu. Stos wywołań jest zazwyczaj reprezentowany jako rośnie, tak, aby metody wyżej w stosie wywołań wywoływać metody niższe w stosie wywołań. <xref:System.Security.CodeAccessPermission.Demand%2A> powiedzie się tylko wtedy, gdy nie <xref:System.Security.SecurityException> jest wywoływane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="iPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do intersect z uprawnieniami bieżącego. Należy tego samego typu co bieżący uprawnień.</param>
        <summary>Tworzy i zwraca uprawnienia, które jest przecięcia bieżące uprawnienia i określony.</summary>
        <returns>Nowe uprawnienie reprezentuje część wspólną bieżące uprawnienia i określony. Jest to nowe uprawnienie <see langword="null" /> Jeśli część wspólną jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Część wspólną dwóch uprawnień jest uprawnienia, które opisano zestaw działań, które opisują one zarówno wspólnych. Tylko zażąda przekazuje oba oryginalnego uprawnienia zostaną spełnione przecięcie.  
  
 Poniższe instrukcje muszą być spełnione wszystkie implementacji <xref:System.Security.IPermission.Intersect%2A> metody. `X` i `Y` reprezentują <xref:System.Security.IPermission> odwołania do obiektów, które nie są `null`.  
  
-   `X`. INTERSECT (`X`) zwraca wartość równa `X`.  
  
-   `X`. INTERSECT (`Y`) zwraca taką samą wartość jak `Y`. INTERSECT (`X`).  
  
-   `X`. INTERSECT (`null`) zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementacja <xref:System.Security.IPermission.Intersect%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.IPermission> klasy.  
  
 [!code-cpp[Permission#2](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#2)]
 [!code-csharp[Permission#2](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#2)]
 [!code-vb[Permission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest wystąpieniem tej samej klasy bieżące uprawnienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="iPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienia, które ma być sprawdzane pod kątem relacji podzbioru. To uprawnienie musi być tego samego typu co bieżący uprawnień.</param>
        <summary>Określa, czy bieżące uprawnienia podzbiór określonego uprawnienia.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące uprawnienia są podzbiorem określonego uprawnienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące uprawnienia jest podzbiorem określonego uprawnienia, jeśli uprawnienia bieżącego określa zestaw operacji jest całkowicie zawarty w określonego uprawnienia. Na przykład uprawnienia reprezentujące dostęp do C:\example.txt jest podzbiorem uprawnienie reprezentujące dostęp do folderu C:\\. Jeśli ta metoda zwraca `true`, bieżący uprawnienie reprezentuje nie uzyskać dostęp do chronionych zasobów niż określone uprawnienie.  
  
 Poniższe instrukcje muszą być spełnione wszystkie implementacji <xref:System.Security.IPermission.IsSubsetOf%2A> metody. `X`, `Y`, i `Z` reprezentują <xref:System.Security.IPermission> obiektów, które nie są `null`.  
  
-   `X`. IsSubsetOf (`X`) zwraca `true`.  
  
-   `X`. IsSubsetOf (`Y`) zwraca taką samą wartość jak `Y`. IsSubsetOf (`X`) tylko wtedy, gdy `X` i `Y` reprezentują ten sam zestaw uprawnień.  
  
-   Jeśli `X`. IsSubsetOf (`Y`) i `Y`. IsSubsetOf (`Z`) zwrócą `true`, `X`. IsSubsetOf (`Z`) zwraca `true`.  
  
 Jeśli `X` reprezentuje pustą <xref:System.Security.IPermission> obiektu ze stanem uprawnienia <xref:System.Security.Permissions.PermissionState.None> i `Y` reprezentuje <xref:System.Security.IPermission> obiekt `null`, `X`. IsSubsetOf (`Y`) zwraca `true`. Jeśli `Z` jest również pusty uprawnienia operacji złożone ustawienia `X`. Union(Z). Zwraca także IsSubsetOf(Y) `true` ponieważ złożenie dwóch uprawnienia pusty pusty uprawnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementacja <xref:System.Security.IPermission.IsSubsetOf%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.IPermission> klasy.  
  
 [!code-cpp[Permission#3](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#3)]
 [!code-csharp[Permission#3](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#3)]
 [!code-vb[Permission#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest taki sam typ jak bieżące uprawnienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="iPermission.Union target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do łączenia z uprawnieniami bieżącego. Należy tego samego typu co bieżący uprawnień.</param>
        <summary>Tworzy uprawnienia, które łączy bieżące uprawnienia i określony.</summary>
        <returns>Nowe uprawnienie reprezentuje złożenie bieżące uprawnienia i określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wywołania <xref:System.Security.IPermission.Union%2A> jest uprawnienia, które reprezentuje wszystkie operacje reprezentowany przez bieżące uprawnienia i określonego uprawnienia. Wszelkie żądania, który przekazuje albo uprawnienie przekazuje ich union.  
  
 Poniższe instrukcje muszą być spełnione wszystkie implementacji <xref:System.Security.IPermission.Union%2A> metody. `X` i `Y` reprezentują <xref:System.Security.IPermission> obiektów, które nie są `null`.  
  
-   `X`. Unii (`X`) zwraca obiekt, który ma taką samą wartość jak `X`.  
  
-   `X`. Unii (`Y`) zwraca obiekt, który ma taką samą wartość jak zwracany przez obiekt `Y`. Unii (`X`).  
  
-   `X`. Unii (`null`) zwraca obiekt, który ma taką samą wartość jak `X`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementacja <xref:System.Security.IPermission.Union%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Security.IPermission> klasy.  
  
 [!code-cpp[Permission#5](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#5)]
 [!code-csharp[Permission#5](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#5)]
 [!code-vb[Permission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#5)]  
  
-  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> Parametr nie jest <see langword="null" /> i nie jest taki sam typ jak bieżące uprawnienia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
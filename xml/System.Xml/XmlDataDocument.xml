<Type Name="XmlDataDocument" FullName="System.Xml.XmlDataDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="269851ce0bce3ca09412babec7031c9530854019" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36435680" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlDataDocument : System.Xml.XmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDataDocument extends System.Xml.XmlDocument" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDataDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDataDocument&#xA;Inherits XmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDataDocument : System::Xml::XmlDocument" />
  <TypeSignature Language="F#" Value="type XmlDataDocument = class&#xA;    inherit XmlDocument" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlDocument</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("XmlDataDocument class will be removed in a future release.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia danych strukturalnych przechowywane, pobieranie i manipulowanie za pośrednictwem relacyjne <see cref="T:System.Data.DataSet" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa rozszerza <xref:System.Xml.XmlDocument>. Dzięki temu można załadować danych relacyjnych lub danych XML i manipulowania danych przy użyciu sieci World Wide Web konsorcjum W3C modelu DOM (Document Object). Modelu DOM przedstawia dane jako hierarchię obiektów węzła. Ponieważ `XmlDataDocument` implementuje <xref:System.Xml.XPath.IXPathNavigable> interfejsu, może również służyć jako dokument źródłowy dla <xref:System.Xml.Xsl.XslTransform> klasy.  
  
 `XmlDataDocument` Zamknij przynależności ma `DataSet` klasy, która dostarcza relacyjny widok danych XML. Wszelkie zmiany wprowadzone do `XmlDataDocument` są uwzględniane w `DataSet` i na odwrót.  
  
 Aby załadować `DataSet` danych XML za pomocą <xref:System.Data.DataSet.ReadXmlSchema%2A> do tworzenia mapowania relacyjnego. Dane XML mogą następnie ładowane przy użyciu <xref:System.Xml.XmlDataDocument.Load%2A> lub <xref:System.Xml.XmlDocument.LoadXml%2A>.  
  
 Aby załadować relacyjnej bazie danych, określ `DataSet` zawierającego dane relacyjne jako parametr w <xref:System.Xml.XmlDataDocument.%23ctor%2A> konstruktora.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDataDocument" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDataDocument" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pusta <xref:System.Data.DataSet> jest utworzona i skojarzona z `XmlDataDocument`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument (System.Data.DataSet dataset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataSet dataset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument(System::Data::DataSet ^ dataset);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDataDocument : System.Data.DataSet -&gt; System.Xml.XmlDataDocument" Usage="new System.Xml.XmlDataDocument dataset" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataset" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataset">
          <see langword="DataSet" /> Załadować do <see langword="XmlDataDocument" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDataDocument" /> klasy z określonym <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` Jest zsynchronizowany z określonym `DataSet`. Wszystkie dane w `DataSet` jest natychmiast dostępna za pośrednictwem `XmlDataDocument`. Zmiany wprowadzone w `DataSet` są propagowane w `XmlDataDocument`. Wszystkie zmiany dokonane w `XmlDataDocument`, o ile są one zgodne `DataSet` schematu, są propagowane w `DataSet`.  
  
   
  
## Examples  
 Poniższy przykład ładuje tabelę klienta do `XmlDataDocument`.  
  
 W przykładzie użyto bazy danych Northwind programu SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.SqlClient.SqlConnection" />
        <altmember cref="T:System.Data.SqlClient.SqlDataAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDataDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">
          <see langword="true" /> Aby rekursywnie sklonować poddrzewo w określonym węźle; <see langword="false" /> sklonować tylko węzeł.</param>
        <summary>Tworzy kopię bieżącego węzła.</summary>
        <returns>Sklonowany węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klonowanie `XmlDataDocument` również klonów <xref:System.Data.DataSet> schematu.  
  
 Jeśli `deep` ustawiono `false`, sklonowany `DataSet` ma nie dane; żadne wiersze.  
  
 Jeśli `deep` ustawiono `true`, sklonowany `DataSet` ustawieniu ze schematem i następnie wypełniony danymi.  
  
 Zobacz <xref:System.Xml.XmlNode.CloneNode%2A> w `XmlNode` klasy, aby wyświetlić tabelę opisujące, jak ta metoda ma zachowywać się z poszczególnych typów innego węzła.  
  
   
  
## Examples  
 Poniższy przykład załaduje `DataSet` do `XmlDataDocument` , a następnie tworzy pobieżnego klonu `XmlDataDocument`.  
  
 W przykładzie użyto bazy danych Northwind programu SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks nowego elementu. Jeśli String.Empty lub <see langword="null" />, brak nie ma prefiksu.</param>
        <param name="localName">Lokalna nazwa nowego elementu.</param>
        <param name="namespaceURI">Przestrzeń nazw zasobów identyfikator URI (Uniform) nowego elementu. Jeśli String.Empty lub <see langword="null" />, nie namespaceURI nie istnieje.</param>
        <summary>Tworzy element z określonym <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> , i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Note to Inheritors` Przeciążenie tej funkcji, nie może służyć do rozszerzalności. Zamiast tego można zwrócić elementu utworzone przez klasę podstawową, ale w takim przypadku `XmlDataDocument`. Zobacz poniższy przykład.  
  
```csharp  
class MyXmlDataDocument : XmlDataDocument {  
 public override XmlElement CreateElement(string prefix, string localName, string nsURI) {  
   //Ensure we are returning the base class implementation of element.  
   XmlElement e = base.CreateElement(prefix, localName, nsURI);  
   //Add additional code here.  
   return e;    //Return the element created by XmlDataDocument.  
 }      
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDataDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa odwołania do jednostki.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlEntityReference" /> o określonej nazwie.</summary>
        <returns>
          <see cref="T:System.Xml.XmlEntityReference" /> o określonej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlEntityReference> Nie można utworzyć węzłów <xref:System.Xml.XmlDataDocument> obiektów. Wywołanie tej metody zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywołanie tej metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected override System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDataDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <see cref="T:System.Xml.XmlNode" /> Ma Nawigatora wstępnie ustawiony na.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania tego dokumentu. <see langword="XPathNavigator" /> Znajduje się w węźle określony w <paramref name="node" /> parametru.</summary>
        <returns>
          <see langword="XPathNavigator" /> Służące do nawigacji dokumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XPathNavigator` Zapewnia tylko do odczytu, losowy dostęp do danych. Ponieważ jest zoptymalizowany do przekształcenia XSLT, zapewnia korzyści wydajności, gdy jest używany jako mechanizmu wejściowych do <xref:System.Xml.Xsl.XslTransform.Transform%2A> metody.  
  
   
  
## Examples  
 Aby wyświetlić przekształcenie XSLT przy użyciu `XmlDataDocument` i `XPathNavigator`, zobacz <xref:System.Xml.Xsl.XslTransform.Transform%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Xsl.XslTransform" />
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDataDocument.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Xml.XmlDataDocument.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.DataSet" /> zapewnia relacyjne reprezentację danych w <see langword="XmlDataDocument" />.</summary>
        <value>A <see langword="DataSet" /> można uzyskać dostęp do danych <see langword="XmlDataDocument" /> przy użyciu modelu relacyjne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataSet` Umożliwia dostęp do danych w `XmlDataDocument` przy użyciu modelu relacyjne. Oznacza to, że można danych należy traktować jak tabele i widoki, wiersze i kolumny, relacji i tak dalej. Zmiany wprowadzone w `DataSet` są od razu widoczne w `XmlDataDocument`.  
  
   
  
## Examples  
 Poniższy przykład modyfikuje cen przy użyciu książki `DataSet` metody.  
  
 [!code-cpp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/VB/source.vb#1)]  
  
 W przykładzie użyto następujące dwa pliki jako dane wejściowe.  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement GetElementById (string elemId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement GetElementById(string elemId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementById (elemId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ GetElementById(System::String ^ elemId);" />
      <MemberSignature Language="F#" Value="override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementById elemId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elemId">Identyfikator atrybutu do dopasowania.</param>
        <summary>Pobiera <see cref="T:System.Xml.XmlElement" /> o określonym identyfikatorze. Ta metoda nie jest obsługiwana przez <see cref="T:System.Xml.XmlDataDocument" /> klasy. Wywołanie tej metody zgłasza wyjątek.</summary>
        <returns>
          <see cref="T:System.Xml.XmlElement" /> o określonym identyfikatorze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest obsługiwana przez <xref:System.Xml.XmlDataDocument> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywołanie tej metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromRow">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement GetElementFromRow (System.Data.DataRow r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement GetElementFromRow(class System.Data.DataRow r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementFromRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementFromRow (r As DataRow) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ GetElementFromRow(System::Data::DataRow ^ r);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromRow : System.Data.DataRow -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementFromRow r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="r">
          <see langword="DataRow" /> Których skojarzone <see langword="XmlElement" /> do pobrania.</param>
        <summary>Pobiera <see cref="T:System.Xml.XmlElement" /> skojarzonego z określonym <see cref="T:System.Data.DataRow" />.</summary>
        <returns>
          <see langword="XmlElement" /> Zawierający reprezentację określonego <see langword="DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład załaduje `DataSet` do `XmlDataDocument` , a następnie tworzy `XmlElement` reprezentujący pierwszy rekord klienta.  
  
 W przykładzie użyto bazy danych Northwind programu SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDataDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa do dopasowania. Jest dopasowywana <see cref="P:System.Xml.XmlDocument.Name" /> właściwości pasujących węzła. Specjalna wartość "*" dopasowuje wszystkie tagi.</param>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich elementów podrzędnych, które pasują do określonego <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>
          <see cref="T:System.Xml.XmlNodeList" /> Zawierający listę wszystkich zgodne węzły.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Zaleca się, że używasz <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> lub <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> zamiast metody <xref:System.Xml.XmlDataDocument.GetElementsByTagName%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRowFromElement">
      <MemberSignature Language="C#" Value="public System.Data.DataRow GetRowFromElement (System.Xml.XmlElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow GetRowFromElement(class System.Xml.XmlElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetRowFromElement(System.Xml.XmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRowFromElement (e As XmlElement) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ GetRowFromElement(System::Xml::XmlElement ^ e);" />
      <MemberSignature Language="F#" Value="member this.GetRowFromElement : System.Xml.XmlElement -&gt; System.Data.DataRow" Usage="xmlDataDocument.GetRowFromElement e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Xml.XmlElement" />
      </Parameters>
      <Docs>
        <param name="e">
          <see langword="XmlElement" /> Których skojarzone <see langword="DataRow" /> do pobrania.</param>
        <summary>Pobiera <see cref="T:System.Data.DataRow" /> skojarzonego z określonym <see cref="T:System.Xml.XmlElement" />.</summary>
        <returns>
          <see langword="DataRow" /> Zawierający reprezentację <see langword="XmlElement" />; <see langword="null" /> w przypadku nie <see langword="DataRow" /> skojarzone z <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład modyfikuje ceny pierwszej książki.  
  
 [!code-cpp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CPP/getrow.cpp#1)]
 [!code-csharp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CS/getrow.cs#1)]
 [!code-vb[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/VB/getrow.vb#1)]  
  
 W przykładzie użyto następujących plików wejściowych:  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładunki <see langword="XmlDataDocument" /> przy użyciu określonego źródła danych i synchronizuje <see cref="T:System.Data.DataSet" /> z ładowanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby wyświetlić dane XML relationally, należy określić schematu na potrzeby mapowania danych. Można to zrobić przez wywołanie <xref:System.Data.DataSet.ReadXmlSchema%2A> metody lub przez tworzenie tabel i kolumn w `DataSet` ręcznie. Ten krok należy wykonać przed wywołaniem `Load`.  
  
 `XmlDataDocument` nie obsługuje tworzenia odwołań do jednostek. Jeśli dane zawierają odwołania do jednostki, `Load` metoda rozpoznaje i rozwija wszystkie odwołania do jednostek. Jednak jeśli używasz `Load` przeciążenia, które przyjmuje <xref:System.Xml.XmlReader> jako argument, należy określić `XmlReader` to rozwiąże jednostek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDataDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Strumień, zawierający można załadować dokumentu XML.</param>
        <summary>Ładunki <see langword="XmlDataDocument" /> z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` nie obsługuje tworzenia odwołań do jednostek. Jeśli dane zawierają odwołania do jednostki, `Load` metoda rozpoznaje i rozwija wszystkie odwołania do jednostek.  
  
> [!NOTE]
>  Aby wyświetlić dane XML relationally, należy określić schematu na potrzeby mapowania danych. Można to zrobić przez wywołanie <xref:System.Data.DataSet.ReadXmlSchema%2A> metody lub przez tworzenie tabel i kolumn w `DataSet` ręcznie. Ten krok należy wykonać przed wywołaniem `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDataDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">
          <see langword="TextReader" /> Używane do strumieniowego źródła danych XML do dokumentu.</param>
        <summary>Ładunki <see langword="XmlDataDocument" /> z określonego <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` nie obsługuje tworzenia odwołań do jednostek. Jeśli dane zawierają odwołania do jednostki, `Load` metoda rozpoznaje i rozwija wszystkie odwołania do jednostek.  
  
> [!NOTE]
>  Aby wyświetlić dane XML relationally, należy określić schematu na potrzeby mapowania danych. Można to zrobić przez wywołanie <xref:System.Data.DataSet.ReadXmlSchema%2A> metody lub przez tworzenie tabel i kolumn w `DataSet` ręcznie. Ten krok należy wykonać przed wywołaniem `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="override this.Load : string -&gt; unit" Usage="xmlDataDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Adres URL pliku zawierającego dokument XML do załadowania.</param>
        <summary>Ładunki <see langword="XmlDataDocument" /> przy użyciu określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` nie obsługuje tworzenia odwołań do jednostek. Jeśli dane zawierają odwołania do jednostki, `Load` metoda rozpoznaje i rozwija wszystkie odwołania do jednostek.  
  
> [!NOTE]
>  Aby wyświetlić dane XML relationally, należy określić schematu na potrzeby mapowania danych. Można to zrobić przez wywołanie <xref:System.Data.DataSet.ReadXmlSchema%2A> metody lub przez tworzenie tabel i kolumn w `DataSet` ręcznie. Ten krok należy wykonać przed wywołaniem `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDataDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XmlReader" /> Zawierający można załadować dokumentu XML.</param>
        <summary>Ładunki <see langword="XmlDataDocument" /> z określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` nie obsługuje tworzenia odwołań do jednostek. Jeśli źródło danych zawiera odwołania do jednostki, należy utworzyć <xref:System.Xml.XmlValidatingReader> z <xref:System.Xml.XmlValidatingReader.EntityHandling%2A> właściwości wartość elementu EntityHandling.ExpandEntities (jest to domyślne zachowanie) i przekaż `XmlValidatingReader` do `Load` metody. Jeśli nie używasz `XmlValidatingReader`, `Load` metoda zgłasza wyjątek.  
  
 `Load` Metody zawsze zachowuje znaczący biały znak. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy biały znak są zachowywane. Wartość domyślna to `false`, biały znak nie są zachowywane.  
  
 Jeśli czytnik jest w stanie początkowym (czyli ReadState=ReadState.Initial) `Load` zużywa całą zawartość czytnika danych i tworzy DOM z ich znalezienia.  
  
 Jeśli czytnik jest już ustawiony na jednego z węzłów przy głębokości "n", ta metoda ładuje ten węzeł i wszystkie kolejne elementy równorzędne do tagu końcowego, który zamyka głębokość "n". Ma to następujące wyniki.  
  
 Jeśli bieżącego węzła i jego następujące elementy równorzędne wyglądać podobnie do następującego:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` zgłasza wyjątek, ponieważ dokument nie może mieć dwóch elementów głównego poziomu. Jeśli bieżącego węzła i jego następujące elementy równorzędne wyglądać podobnie do następującego:  
  
```xml  
<!--comment--><?process  
    instruction?><!--comment--></endtag>  
```  
  
 `Load` się pomyślnie; jednak należy niekompletne drzewa modelu DOM, ponieważ nie istnieje żaden element głównego poziomu. Należy dodać element poziomu głównego przed zapisaniem dokumentu. w przeciwnym razie <xref:System.Xml.XmlDocument.Save%2A> metoda zgłasza wyjątek.  
  
 Jeśli czytnik jest ustawiony na węzeł liścia, który jest nieprawidłowy dla poziomu głównego dokumentu (na przykład białe miejsca lub atrybut węzłem), czytnik będzie kontynuowane do odczytu, dopóki nie zostanie on ustawiony na węźle, który może służyć do katalogu głównego. Dokument rozpoczyna się w tym momencie ładowania.  
  
   
  
## Examples  
 Poniższy przykład modyfikuje cen przy użyciu książki `DataSet` metody.  
  
 [!code-cpp[XmlDataDocument.Load#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.Load/CPP/loadrdr.cpp#1)]
 [!code-csharp[XmlDataDocument.Load#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.Load/CS/loadrdr.cs#1)]
 [!code-vb[XmlDataDocument.Load#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.Load/VB/loadrdr.vb#1)]  
  
 W przykładzie użyto następujących dwóch plików wejściowych.  
  
 `2books.xml`  
  
 [!code-xml[XmlDataDocument.Load#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/2books.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[XmlDataDocument.Load#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/test.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Trwa ładowanie pliku XML zawiera odwołania do jednostek i czytnik nie może rozpoznać jednostki.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="XmlTextReader" FullName="System.Xml.XmlTextReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f244d79f2e8a979f710d906f7c06c1e472e9cb53" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69439473" /></Metadata><TypeSignature Language="C#" Value="public class XmlTextReader : System.Xml.XmlReader, System.Xml.IXmlLineInfo, System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlTextReader extends System.Xml.XmlReader implements class System.Xml.IXmlLineInfo, class System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlTextReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlTextReader&#xA;Inherits XmlReader&#xA;Implements IXmlLineInfo, IXmlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlTextReader : System::Xml::XmlReader, System::Xml::IXmlLineInfo, System::Xml::IXmlNamespaceResolver" />
  <TypeSignature Language="F#" Value="type XmlTextReader = class&#xA;    inherit XmlReader&#xA;    interface IXmlLineInfo&#xA;    interface IXmlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlReader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlLineInfo</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.IXmlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje czytnik, który zapewnia szybki, niebuforowany, dostęp do danych XML.  
  
Począwszy od .NET Framework 2,0 zaleca się użycie <see cref="T:System.Xml.XmlReader" /> klasy zamiast.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 <xref:System.Xml.XmlTextReader>zapewnia dostęp tylko do odczytu do strumienia danych XML. Bieżący węzeł odwołuje się do węzła, w którym znajduje się czytnik. Czytnik jest zaawansowany przy użyciu dowolnej metody odczytu i właściwości odzwierciedlają wartość bieżącego węzła.  
  
 Ta klasa implementuje <xref:System.Xml.XmlReader> i jest zgodna z XML W3C (XML) 1,0 i przestrzenie nazw w zaleceniach XML. `XmlTextReader`oferuje następujące funkcje:  
  
-   Wymusza reguły poprawnie sformułowanego kodu XML.  
  
-   `XmlTextReader`nie zapewnia walidacji danych.  
  
-   Sprawdza, `DocumentType` czy węzły są poprawnie sformułowane. `XmlTextReader`sprawdza, czy DTD jest poprawnie sformułowany, ale nie sprawdza poprawności przy użyciu DTD.  
  
-   W przypadku węzłów <xref:System.Xml.XmlTextReader.NodeType%2A> , `XmlNodeType.EntityReference`gdzie jest, zwracany `EntityReference` jest pojedynczy pusty <xref:System.Xml.XmlTextReader.Value%2A> węzeł (czyli Właściwość to `String.Empty`).  
  
> [!NOTE]
>  Rzeczywiste deklaracje jednostek w DTD nazywa `Entity` się węzłami. Gdy odwołujesz się do tych węzłów w danych, są one `EntityReference` nazywane węzłami.  
  
-   Nie rozszerza atrybutów domyślnych.  
  
 Ponieważ program `XmlTextReader` nie wykonuje dodatkowych sprawdzeń wymaganych do weryfikacji danych, zapewnia szybki analizator składni.  
  
 Aby przeprowadzić walidację danych, należy użyć <xref:System.Xml.XmlReader>walidacji.  
  
 Aby odczytać dane XML z <xref:System.Xml.XmlDocument>, użyj. <xref:System.Xml.XmlNodeReader>  
  
 `XmlTextReader`zgłasza błędy analizy w kodzie XML. <xref:System.Xml.XmlException> Po zgłoszeniu wyjątku stan czytnika nie jest przewidywalny. Na przykład raportowany typ węzła może być inny niż rzeczywisty typ węzła bieżącego węzła. Użyj właściwości <xref:System.Xml.XmlTextReader.ReadState%2A> , aby sprawdzić, czy czytnik jest w stanie błędu.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Poniżej przedstawiono kwestie, które należy wziąć pod uwagę <xref:System.Xml.XmlTextReader> podczas korzystania z klasy.  
  
-   Zgłoszone <xref:System.Xml.XmlTextReader> wyjątki mogą ujawniać informacje o ścieżce, które nie mają być rzutowane do aplikacji. Aplikacje muszą przechwycić wyjątki i odpowiednio je przetworzyć.  
  
-   Przetwarzanie DTD jest domyślnie włączone. Wyłącz przetwarzanie DTD, Jeśli obawiasz się o problemach z odmową usługi lub w przypadku postępowania z niezaufanymi źródłami. Ustaw właściwość na <xref:System.Xml.DtdProcessing.Prohibit> , aby wyłączyć przetwarzanie DTD. <xref:System.Xml.XmlTextReader.DtdProcessing%2A>  
  
     Jeśli jest włączone przetwarzanie DTD, można użyć <xref:System.Xml.XmlSecureResolver> , aby ograniczyć zasoby <xref:System.Xml.XmlTextReader> , do których może uzyskać dostęp. Możesz również projektować aplikację, tak aby przetwarzanie XML było ograniczone do pamięci i czasu. Na przykład skonfiguruj limity limitu czasu w aplikacji ASP.NET.  
  
-   Dane XML mogą zawierać odwołania do zasobów zewnętrznych, takich jak plik DTD. Domyślnie zasoby zewnętrzne są rozwiązywane przy użyciu <xref:System.Xml.XmlUrlResolver> obiektu bez poświadczeń użytkownika. Aby zapewnić lepszą ochronę, wykonaj jedną z następujących czynności:  
  
    -   Ogranicz zasoby, do których <xref:System.Xml.XmlTextReader> może uzyskać dostęp, <xref:System.Xml.XmlTextReader.XmlResolver%2A> ustawiając właściwość na <xref:System.Xml.XmlSecureResolver> obiekt.  
  
    -   Nie Zezwalaj <xref:System.Xml.XmlReader> na otwieranie jakichkolwiek zasobów zewnętrznych przez <xref:System.Xml.XmlTextReader.XmlResolver%2A> ustawienie właściwości na `null`.  
  
-   Dane XML mogą zawierać dużą liczbę atrybutów, deklaracji przestrzeni nazw, zagnieżdżonych elementów i tak dalej, które wymagają znacznego czasu na przetworzenie. Aby ograniczyć rozmiar danych wejściowych wysyłanych do programu <xref:System.Xml.XmlTextReader>, Utwórz niestandardową implementację IStream i podaj <xref:System.Xml.XmlTextReader>ją.  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A> Metoda może służyć do obsługi dużych strumieni danych. Ta metoda odczytuje małą liczbę znaków w czasie zamiast przydzielać pojedynczy ciąg dla całej wartości.  
  
-   Domyślnie jednostki ogólne nie są rozwinięte. Ogólne jednostki są rozszerzane po wywołaniu <xref:System.Xml.XmlTextReader.ResolveEntity%2A> metody.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Ta klasa ma żądanie dziedziczenia. Aby dziedziczyć z programu <see langword="XmlTextReader" />, wymagane jest pełne zaufanie.</para></block>
    <related type="Article" href="~/docs/standard/data/xml/index.md">Dokumenty i dane XML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see langword="XmlTextReader" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Strumień zawierający dane XML do odczytania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym strumieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Dekoduje strumień przy użyciu <xref:System.Text.Encoding?displayProperty=nameWithType>. <xref:System.Xml.XmlTextReader>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.TextReader -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input"><see langword="TextReader" /> Zawierający dane XML do odczytania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Zakłada się, że `TextReader` jest już ustawiony prawidłowy kodowanie. Jest on używany przez klientów, którzy już odczytały niektóre elementy ze strumienia w wieloczęściowym scenariuszu MIME.  
  
   
  
## Examples  
 Poniższy przykład ładuje ciąg XML do `XmlTextReader` obiektu <xref:System.IO.StringReader> za pomocą klasy.  
  
 [!code-cpp[XmlTextReader.cctor1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.cctor1/CPP/rdrcctor1.cpp#1)]
 [!code-csharp[XmlTextReader.cctor1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.cctor1/CS/rdrcctor1.cs#1)]
 [!code-vb[XmlTextReader.cctor1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.cctor1/VB/rdrcctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader url" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL pliku zawierającego dane XML. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym plikiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Jeśli plik znajduje się w zasobie, który wymaga poświadczeń dostępu, użyj <xref:System.Xml.XmlTextReader.XmlResolver%2A> właściwości, aby określić niezbędne poświadczenia.  
  
> [!NOTE]
>  W wersji 1,1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]częściowo zaufanego kodu nie można `XmlResolver` ustawić właściwości. Obejście polega na utworzeniu programu <xref:System.Xml.XmlUrlResolver> z wymaganymi poświadczeniami, przekazania identyfikatora URI <xref:System.Xml.XmlUrlResolver.GetEntity%2A?displayProperty=nameWithType> do metody `XmlTextReader` , a następnie <xref:System.IO.Stream> skonstruować przy użyciu obiektu. Obejście to opisano w poniższym C# kodzie.  
  
```csharp  
// Create a resolver with the necessary credentials.  
XmlUrlResolver resolver = new XmlUrlResolver();  
NetworkCredential nc = new NetworkCredential(SecurelyStoredUserName, SecurelyStoredPassword, SecurelyStoredDomain);  
resolver.Credentials = nc;   
// Get a Stream object containing the XML file.  
Uri myUri = new Uri ("http://myServer/data/books.xml");  
Stream s=(Stream)resolver.GetEntity(myUri, null, typeof(Stream));  
// Construct a reader using the Stream object.  
XmlTextReader reader = new XmlTextReader(s);  
```  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla wszystkie węzły.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `items.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć określonego pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można znaleźć części pliku lub katalogu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="url" />jest pustym ciągiem.</exception>
        <exception cref="T:System.Net.WebException">Nie można rozpoznać nazwy pliku zdalnego.  
  
 —lub—  
  
 Wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="url" />nie jest prawidłowym identyfikatorem URI.</exception>
        <altmember cref="P:System.Xml.XmlTextReader.XmlResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt"><see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">Strumień zawierający dane XML do odczytania.</param>
        <param name="nt"><see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym strumieniem i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Dekoduje strumień przy użyciu <xref:System.Text.Encoding?displayProperty=nameWithType>. <xref:System.Xml.XmlTextReader>  
  
 Jeśli określisz tabelę nazw, ten konstruktor używa nazw zdefiniowanych już w tej tabeli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Wartość <paramref name="input" /> <paramref name="nt" /> lub. <see langword="null" /></exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.TextReader * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input"><see langword="TextReader" /> Zawierający dane XML do odczytania.</param>
        <param name="nt"><see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.IO.TextReader" /> i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Zakłada się, że `TextReader` jest już ustawiony prawidłowy kodowanie. Jest on używany przez klientów, którzy już odczytały niektóre elementy ze strumienia w wieloczęściowym scenariuszu MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><paramref name="nt" /> Wartość to<see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.Stream -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL służący do rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość.</param>
        <param name="input">Strumień zawierający dane XML do odczytania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym adresem URL i strumieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.TextReader -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL służący do rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość.</param>
        <param name="input"><see langword="TextReader" /> Zawierający dane XML do odczytania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym adresem URL i <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Zakłada się, że `TextReader` jest już ustawiony prawidłowy kodowanie. Jest on używany przez klientów, którzy już odczytały niektóre elementy ze strumienia w wieloczęściowym scenariuszu MIME.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL pliku zawierającego dane XML do odczytania.</param>
        <param name="nt"><see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym plikiem i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><paramref name="nt" /> Wartość to<see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć określonego pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można znaleźć części pliku lub katalogu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="url" />jest pustym ciągiem.</exception>
        <exception cref="T:System.Net.WebException">Nie można rozpoznać nazwy pliku zdalnego.  
  
 —lub—  
  
 Wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="url" />nie jest prawidłowym identyfikatorem URI.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As Stream, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream * System.Xml.XmlNodeType * System.Xml.XmlParserContext -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (xmlFragment, fragType, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.IO.Stream" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Strumień zawierający fragment XML do przeanalizowania.</param>
        <param name="fragType"><see cref="T:System.Xml.XmlNodeType" /> Fragment kodu XML. Określa również, co może zawierać fragment. (Patrz Poniższa tabela).</param>
        <param name="context">, <see cref="T:System.Xml.XmlParserContext" /> W<paramref name="xmlFragment" /> którym ma zostać przeanalizowany. Obejmuje <see cref="T:System.Xml.XmlNameTable" /> to użycie, kodowanie, zakres przestrzeni nazw, bieżące <c>XML: lang</c>i zakres <c>XML: Space</c> .</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym strumieniem, <see cref="T:System.Xml.XmlNodeType" />i <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ten Konstruktor analizuje dany ciąg jako fragment kodu XML. Jeśli fragment XML jest elementem lub atrybutem, można pominąć reguły poziomu głównego dla poprawnie sformułowanych dokumentów XML.  
  
 Poniższa tabela zawiera listę prawidłowych `fragType`wartości dla.  
  
|XmlNodeType|Fragment może zawierać|  
|-----------------|--------------------------|  
|`Element`|Dowolna prawidłowa zawartość elementu (na przykład dowolna kombinacja elementów, komentarzy, instrukcji przetwarzania, sekcji CDATA, tekstu i odwołań do jednostek).<br /><br /> Można również podać deklarację XML. Pozwala to określić kodowanie dla fragmentu kodu XML, a nie trzeba go ustawić dla <xref:System.Xml.XmlParserContext> obiektu.|  
|`Attribute`|Wartość atrybutu (część wewnątrz cudzysłowu).|  
|`Document`|Zawartość całego dokumentu XML. Wymusza to reguły poziomu dokumentu.|  
  
 Czytnik używa następujących elementów do określenia kodowania strumienia.  
  
1.  <xref:System.Xml.XmlParserContext.Encoding%2A?displayProperty=nameWithType> Sprawdza właściwość, aby określić kodowanie.  
  
2.  Jeśli właściwość jest `null`, czytnik sprawdza obecność znacznika kolejności bajtów na początku strumienia. `Encoding`  
  
3.  Jeśli właściwość jest `null`i nie zostanie znaleziony znacznik kolejności bajtów, czytnik zakłada, że strumień jest zakodowany w UTF-8. `Encoding`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><paramref name="fragType" />nie jest elementem, atrybutem ani dokumentem <see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlFragment" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.Stream * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL służący do rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość. Jeśli <paramref name="url" /> jest <see langword="null" />, jest<see langword="BaseURI" /> ustawiona na <see langword="String.Empty" />.</param>
        <param name="input">Strumień zawierający dane XML do odczytania.</param>
        <param name="nt"><see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym adresem URL, strumieniem i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Wartość <paramref name="input" /> <paramref name="nt" /> lub. <see langword="null" /></exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.TextReader * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL służący do rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość. Jeśli <paramref name="url" /> jest <see langword="null" />, jest<see langword="BaseURI" /> ustawiona na <see langword="String.Empty" />.</param>
        <param name="input"><see langword="TextReader" /> Zawierający dane XML do odczytania.</param>
        <param name="nt"><see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.IO.TextReader" /> adresem URL i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Zakłada się, że `TextReader` jest już ustawiony prawidłowy kodowanie. Jest on używany przez klientów, którzy już odczytały niektóre elementy ze strumienia w wieloczęściowym scenariuszu MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="nt" /> Wartość to<see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As String, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.Xml.XmlNodeType * System.Xml.XmlParserContext -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (xmlFragment, fragType, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.String" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Ciąg zawierający fragment XML do przeanalizowania.</param>
        <param name="fragType"><see cref="T:System.Xml.XmlNodeType" /> Fragment kodu XML. Określa również, co może zawierać ciąg fragmentu. (Patrz Poniższa tabela).</param>
        <param name="context">, <see cref="T:System.Xml.XmlParserContext" /> W<paramref name="xmlFragment" /> którym ma zostać przeanalizowany. Obejmuje <see cref="T:System.Xml.XmlNameTable" /> to użycie, kodowanie, zakres przestrzeni nazw, bieżące <c>XML: lang</c>i zakres <c>XML: Space</c> .</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym ciągiem, <see cref="T:System.Xml.XmlNodeType" />, i <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ten Konstruktor analizuje dany ciąg jako fragment kodu XML. Jeśli fragment XML jest elementem lub atrybutem, można pominąć reguły poziomu głównego dla poprawnie sformułowanych dokumentów XML. Ten konstruktor może obsługiwać ciągi zwracane z <xref:System.Xml.XmlReader.ReadInnerXml%2A>.  
  
 W poniższej tabeli wymieniono prawidłowe wartości `fragType` i sposób, w jaki czytnik analizuje każdy z różnych typów węzłów.  
  
|XmlNodeType|Fragment może zawierać|  
|-----------------|--------------------------|  
|Element|Dowolna prawidłowa zawartość elementu (na przykład dowolna kombinacja elementów, komentarzy, instrukcji przetwarzania, sekcji CDATA, tekstu i odwołań do jednostek).<br /><br /> Można również podać deklarację XML. Pozwala to określić kodowanie dla fragmentu kodu XML, a nie trzeba go ustawić dla <xref:System.Xml.XmlParserContext> obiektu.|  
|Atrybut|Wartość atrybutu (część wewnątrz cudzysłowu).|  
|dokument|Zawartość całego dokumentu XML. Wymusza to reguły poziomu dokumentu.|  
  
   
  
## Examples  
 Poniższy przykład analizuje fragment XML. Używa `XmlParserContext` i jej <xref:System.Xml.XmlNamespaceManager> do obsługi rozpoznawania przestrzeni nazw.  
  
 [!code-cpp[XmlTextReader.Cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Cctor/CPP/readfrag.cpp#1)]
 [!code-csharp[XmlTextReader.Cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Cctor/CS/readfrag.cs#1)]
 [!code-vb[XmlTextReader.Cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Cctor/VB/readfrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><paramref name="fragType" />nie <see langword="Element" />jest, <see langword="Attribute" />, ani <see langword="Document" /> .<see langword="XmlNodeType" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlFragment" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlParserContext" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public override int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlTextReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę atrybutów w bieżącym węźle.</summary>
        <value>Liczba atrybutów w bieżącym węźle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość ma zastosowanie tylko `Element`do `DocumentType` węzłów `XmlDeclaration` i. (Inne typy węzłów nie mają atrybutów).  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlTextReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy identyfikator URI bieżącego węzła.</summary>
        <value>Podstawowy identyfikator URI bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Dokument w sieci XML zawiera fragmenty danych zagregowane przy użyciu różnych mechanizmów dołączania standardowego W3C i w związku z tym zawierają węzły, które pochodzą z różnych miejsc. Przykładem są jednostki DTD, ale nie jest to ograniczone do elementów DTD. Podstawowy identyfikator URI informuje o miejscu, z którego pochodzą te węzły. Jeśli nie ma podstawowego identyfikatora URI dla zwracanych węzłów (na przykład zostały one przeanalizowane z ciągu w pamięci), `String.Empty` jest zwracany.  
  
   
  
## Examples  
 Poniższy przykład wyświetla podstawowy identyfikator URI dla każdego węzła.  
  
 [!code-cpp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `baseuri.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.BaseURI Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public override bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xml.XmlTextReader" /> implementuje metody odczytywania zawartości binarnej.</summary>
        <value><see langword="true" />Jeśli metody odczytu zawartości binarnej są zaimplementowane; w <see langword="false" />przeciwnym razie. Klasa zawsze zwraca wartość <see langword="true" />. <see cref="T:System.Xml.XmlTextReader" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Metody odczytu zawartości <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>binarnej zawierają metody, <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlTextReader.ReadElementContentAsBase64%2A>, i. <xref:System.Xml.XmlTextReader.ReadElementContentAsBinHex%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public override bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xml.XmlTextReader" /> <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> implementuje metodę.</summary>
        <value><see langword="true" /><see cref="T:System.Xml.XmlTextReader" /> Jeśli <see langword="false" />implementuje metodę;wprzeciwnymrazie.<see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> Klasa zawsze zwraca wartość <see langword="false" />. <see cref="T:System.Xml.XmlTextReader" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Zwraca a <xref:System.NotSupportedException> Jeśli<xref:System.Xml.XmlReader.ReadValueChunk%2A> Metoda jest wywoływana. <xref:System.Xml.XmlTextReader>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public override bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten czytnik może analizować i rozwiązywać jednostki.</summary>
        <value><see langword="true" />Jeśli czytelnik może analizować i rozwiązywać jednostki; w przeciwnym razie. <see langword="false" /> Klasa zawsze zwraca wartość <see langword="true" />. <see langword="XmlTextReader" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Jest to zmiana w [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] wersji. W poprzednich wersjach `XmlTextReader` Klasa nie mogła rozpoznać jednostek i `CanResolveEntity` jest zawsze zwracana `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="xmlTextReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmienia wartość <see cref="P:System.Xml.XmlReader.ReadState" /> na <see langword="Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda zwalnia także wszystkie zasoby przechowywane podczas odczytywania. Jeśli ten czytnik został skonstruowany przy użyciu strumienia, ta metoda również `Close` wywołuje źródłowy strumień.  
  
 Jeśli `Close` został już wywołany, nie jest wykonywana żadna akcja.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlTextReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera głębokość bieżącego węzła w dokumencie XML.</summary>
        <value>Głębokość bieżącego węzła w dokumencie XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład wyświetla każdy węzeł, w tym jego głębokość, numer wiersza i położenie wiersza.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberSignature Language="F#" Value="member this.DtdProcessing : System.Xml.DtdProcessing with get, set" Usage="System.Xml.XmlTextReader.DtdProcessing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Xml.DtdProcessing" /> Wyliczenie.</summary>
        <value><see cref="T:System.Xml.DtdProcessing" /> Wyliczenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczenie zawiera moduł wyliczający <xref:System.Xml.DtdProcessing.Ignore> <xref:System.Xml.DtdProcessing.Parse>,i. <xref:System.Xml.DtdProcessing.Prohibit> <xref:System.Xml.DtdProcessing> <xref:System.Xml.DtdProcessing.Parse>jest zachowaniem domyślnym. <xref:System.Xml.XmlTextReader.DtdProcessing%2A> Właściwość`ProhibitDTD` zastępuje właściwość i dodaje możliwość ignorowania elementu DOCTYPE.  
  
> [!IMPORTANT]
>  Jeśli właściwość jest ustawiona na <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>, <xref:System.Xml.XmlTextReader> nie będzie zgłaszać elementów DTD. <xref:System.Xml.XmlTextReader.DtdProcessing%2A> Oznacza to, że DTD/DOCTYPE zostanie utracony w danych wyjściowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding" Usage="System.Xml.XmlTextReader.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dokumentu.</summary>
        <value>Wartość kodowania. Jeśli żaden atrybut kodowania nie istnieje i nie ma znacznika kolejności bajtów, ta wartość domyślna to UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ponieważ <xref:System.Xml.XmlTextReader> używa<xref:System.Text.Encoding?displayProperty=nameWithType> klasy ,`XmlTextReader` obsługuje także wszystkie kodowania obsługiwane przez tę klasę. Wyjątkiem jest kodowanie, takie jak UTF-7 lub EBCDIC, które mapuje `<?xml` sekwencję na różne wartości bajtowe niż UTF-8.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityHandling">
      <MemberSignature Language="C#" Value="public System.Xml.EntityHandling EntityHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.EntityHandling EntityHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EntityHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityHandling As EntityHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::EntityHandling EntityHandling { System::Xml::EntityHandling get(); void set(System::Xml::EntityHandling value); };" />
      <MemberSignature Language="F#" Value="member this.EntityHandling : System.Xml.EntityHandling with get, set" Usage="System.Xml.XmlTextReader.EntityHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.EntityHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób, w jaki czytnik obsługuje jednostki.</summary>
        <value>Jedna z <see cref="T:System.Xml.EntityHandling" /> wartości. Jeśli nie <see langword="EntityHandling" /> jest określony, <see langword="EntityHandling.ExpandCharEntities" />domyślnie jest to.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Tę właściwość można zmienić na bieżąco i zaczyna obowiązywać po następnym <xref:System.Xml.XmlTextReader.Read%2A> wywołaniu.  
  
 Gdy `EntityHandling` jest ustawiona na `ExpandCharEntities`, wartości atrybutów są tylko częściowo znormalizowane. Czytnik normalizuje każdy pojedynczy węzeł tekstowy niezależnie od zawartości sąsiadujących węzłów odwołania.  
  
 Aby zilustrować różnicę między trybami obsługi jednostek, należy wziąć pod uwagę następujące XML:  
  
```  
<!DOCTYPE doc [<!ENTITY num "123">]>  
    <doc> &#65; &num; </doc>  
```  
  
 Gdy `EntityHandling` jest ustawiony na `ExpandEntities` węzeł elementu "doc", zawiera jeden węzeł tekstowy z rozwiniętym tekstem jednostki:  
  
|Ścisł|Typ węzła|Nazwa|Wartość|  
|-----------|---------------|----------|-----------|  
|1|`Text`||A 123|  
  
 Gdy `EntityHandling` jest ustawiona na `ExpandCharEntities`, i <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A> jest ustawiona na `Significant` lub `All`, element "doc" rozszerza jednostkę znaku i zwraca jednostkę ogólną jako węzeł:  
  
|Ścisł|Typ węzła|Nazwa|Wartość|  
|-----------|---------------|----------|-----------|  
|1|`Text`||ELEMENT|  
|1|`EntityReference`|numerowan||  
|1|`SignificantWhitespace`|||  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public override bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlTextReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy czytnik jest umieszczony na końcu strumienia.</summary>
        <value><see langword="true" />Jeśli czytnik jest umieszczony na końcu strumienia; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : int -&gt; string" Usage="xmlTextReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu. Jest to indeks zaczynający się od zera. (Pierwszy atrybut ma indeks 0).</param>
        <summary>Pobiera wartość atrybutu o określonym indeksie.</summary>
        <returns>Wartość określonego atrybutu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda nie przenosi czytnika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr jest mniejszy niż 0 lub większy lub <see cref="P:System.Xml.XmlTextReader.AttributeCount" />równy. <paramref name="i" /></exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : string -&gt; string" Usage="xmlTextReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>Pobiera wartość atrybutu o określonej nazwie.</summary>
        <returns>Wartość określonego atrybutu. Jeśli atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda nie przenosi czytnika.  
  
 Jeśli czytnik jest umieszczony w `DocumentType` węźle, ta metoda może być używana do pobierania literałów publicznych i systemowych, na przykład`reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu ISBN.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `attrs.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.GetAttribute1 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : string * string -&gt; string" Usage="xmlTextReader.GetAttribute (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nazwa lokalna atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>Pobiera wartość atrybutu z określoną nazwą lokalną i identyfikatorem URI przestrzeni nazw.</summary>
        <returns>Wartość określonego atrybutu. Jeśli atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracany. Ta metoda nie przenosi czytnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Następujący kod XML zawiera atrybut w określonej przestrzeni nazw:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Można wyszukać `dt:type` atrybut przy użyciu jednego argumentu (prefiksu i nazwy lokalnej) lub dwóch argumentów (nazwa lokalna i identyfikator URI przestrzeni nazw):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Aby wyszukać `xmlns:dt` atrybut, użyj jednego z następujących argumentów:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Te informacje można również uzyskać przy użyciu <xref:System.Xml.XmlTextReader.Prefix%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetNamespacesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GetNamespacesInScope(System::Xml::XmlNamespaceScope scope);" />
      <MemberSignature Language="F#" Value="member this.GetNamespacesInScope : System.Xml.XmlNamespaceScope -&gt; System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="xmlTextReader.GetNamespacesInScope scope" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Xml.XmlNamespaceScope" /> Wartość określająca typ węzłów przestrzeni nazw do zwrócenia.</param>
        <summary>Pobiera kolekcję zawierającą wszystkie przestrzenie nazw, które są obecnie w zakresie.</summary>
        <returns><see cref="T:System.Collections.IDictionary" /> Obiekt, który zawiera wszystkie bieżące przestrzenie nazw w zakresie. Jeśli czytnik nie znajduje się w elemencie, zwracany jest pusty słownik (brak przestrzeni nazw).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Słownik składa się z kolekcji nazw nazw z prefiksem. Może służyć do wyliczania przestrzeni nazw znajdujących się w zakresie. Słownik to odłączona kopia listy przestrzeni nazw czytnika. Pozostaje niezmieniona jako pozycja czytnika, bieżąca lista obszarów nazw znajdujących się w zakresie, zmianach.  
  
 W poniższej tabeli opisano, w <xref:System.Xml.XmlNamespaceScope> jaki sposób wartość wyliczenia wpływa na to, czy domyślne i wbudowane przestrzenie nazw są zwracane <xref:System.Xml.XmlTextReader.GetNamespacesInScope%2A>przez.  
  
|XmlNamespaceScope wartość|xmlns:xml|xmlns:xmlns|xmlns=""|  
|-----------------------------|---------------|-----------------|---------------|  
|`All`|tak|znaleziono|znaleziono|  
|`ExcludeXml`|znaleziono|znaleziono|znaleziono|  
|`Local`|znaleziono|znaleziono|tak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetRemainder">
      <MemberSignature Language="C#" Value="public System.IO.TextReader GetRemainder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.TextReader GetRemainder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetRemainder" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRemainder () As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::TextReader ^ GetRemainder();" />
      <MemberSignature Language="F#" Value="member this.GetRemainder : unit -&gt; System.IO.TextReader" Usage="xmlTextReader.GetRemainder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera resztę zbuforowanego kodu XML.</summary>
        <returns>A <see cref="T:System.IO.TextReader" /> zawiera resztę zbuforowanego kodu XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ponieważ <xref:System.Xml.XmlTextReader> program zawiera buforowaną `Read`wartość, musi być w stanie zwrócić resztę nieużywanego buforu, aby nie zostały utracone żadne dane. Dzięki temu protokoły (takie jak wieloczęściowe MIME) mogą spakować plik XML w tym samym strumieniu co inne elementy.  
  
 Po wywołaniu tej metody <xref:System.Xml.XmlTextReader.EOF%2A> jest ustawiona na. `true`  
  
   
  
## Examples  
 Poniższy przykład odczytuje pierwszą część dokumentu XML, a następnie używa `GetRemainder` do zakończenia odczytywania dokumentu przy użyciu drugiego czytnika.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/VB/source.vb#1)]  
  
 W przykładzie zastosowano plik `tworeads.xml`wejściowy.  
  
 [!code-xml[Classic WebData XmlTextReader.GetRemainder Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasLineInfo">
      <MemberSignature Language="C#" Value="public bool HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function HasLineInfo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasLineInfo();" />
      <MemberSignature Language="F#" Value="abstract member HasLineInfo : unit -&gt; bool&#xA;override this.HasLineInfo : unit -&gt; bool" Usage="xmlTextReader.HasLineInfo " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy Klasa może zwracać informacje o wierszu.</summary>
        <returns><see langword="true" />Jeśli klasa może zwracać informacje o wierszu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public override bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlTextReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł może być <see cref="P:System.Xml.XmlTextReader.Value" /> inny niż. <see langword="String.Empty" /></summary>
        <value><see langword="true" />Jeśli węzeł, w którym znajduje się czytnik jest obecnie umieszczony, <see langword="Value" /> <see langword="false" />może mieć wartość; w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Poniższa tabela zawiera listę typów węzłów, które mają wartość zwracaną.  
  
|Typ węzła|Wartość|  
|---------------|-----------|  
|`Attribute`|Wartość atrybutu.|  
|`CDATA`|Zawartość sekcji CDATA.|  
|`Comment`|Zawartość komentarza.|  
|`DocumentType`|Podzestaw wewnętrzny.|  
|`ProcessingInstruction`|Cała zawartość, z wyłączeniem celu.|  
|`SignificantWhitespace`|Odstęp między adiustacją w modelu zawartości mieszanej.|  
|`Text`|Zawartość węzła tekstowego.|  
|`Whitespace`|Odstęp między znakami.|  
|`XmlDeclaration`|Zawartość deklaracji.|  
  
   
  
## Examples  
 Poniższy przykład wyświetla wartość dla każdego węzła, który może mieć wartość.  
  
 [!code-cpp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `book1.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.HasValue Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public override bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlTextReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł jest atrybutem wygenerowanym z wartości domyślnej zdefiniowanej w DTD lub schemacie.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />wartość. (<see cref="T:System.Xml.XmlTextReader" /> nie rozszerza atrybutów domyślnych).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość ma zastosowanie tylko do węzłów atrybutów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public override bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł jest pustym elementem (na przykład <c>&lt;element/&gt;</c>).</summary>
        <value><see langword="true" />Jeśli bieżącym<see cref="P:System.Xml.XmlTextReader.NodeType" /> węzłem jest element (Equals <see langword="XmlNodeType.Element" />) kończący się na <c>/ &gt;</c>; w przeciwnym <see langword="false" />razie,.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość umożliwia określenie różnicy między następującymi elementami:  
  
 `<item num="123"/>`(`IsEmptyElement` is`true`).  
  
 `<item num="123">`(`IsEmptyElement` is`false`, chociaż zawartość elementu jest pusta).  
  
 Odpowiedni `EndElement` węzeł nie jest generowany dla pustych elementów.  
  
 `IsEmptyElement`po prostu raportuje, czy element w dokumencie źródłowym miał tag elementu końcowego.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość tekstową każdego elementu.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `elems.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlTextReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu.</param>
        <summary>Pobiera wartość atrybutu o określonym indeksie.</summary>
        <value>Wartość atrybutu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlTextReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlTextReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa lokalna atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>Pobiera wartość atrybutu z określoną nazwą lokalną i identyfikatorem URI przestrzeni nazw.</summary>
        <value>Wartość określonego atrybutu. Jeśli atrybut nie zostanie znaleziony, zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumber { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int" Usage="System.Xml.XmlTextReader.LineNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LineNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący numer wiersza.</summary>
        <value>Numer bieżącego wiersza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość jest najczęściej używana do raportowania błędów, ale może być wywoływana w dowolnym momencie. Wartość początkowa dla tej właściwości to `1`.  
  
 W połączeniu <xref:System.Xml.XmlTextReader.LinePosition%2A>z, `1,1` wartość wskazuje początku dokumentu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla każdy węzeł, w tym jego głębokość, numer wiersza i położenie wiersza.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LinePosition">
      <MemberSignature Language="C#" Value="public int LinePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePosition" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LinePosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LinePosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LinePosition : int" Usage="System.Xml.XmlTextReader.LinePosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LinePosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą pozycję wiersza.</summary>
        <value>Pozycja bieżącego wiersza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość jest najczęściej używana do raportowania błędów, ale może być wywoływana w dowolnym momencie. Wartość początkowa właściwości to `1`.  
  
 Wskazana pozycja jest pierwszym znakiem tekstu w znaczniku.  
  
```  
<root>  
abc<tag/>  
</root>  
```  
  
 W pierwszym wierszu poprzedniego tekstu XML, `LinePosition` z `2` odpowiada znakowi `r`; w drugim wierszu, `LinePosition` z `5` odpowiada znakowi `t`; i w trzecim wierszu, `LinePosition`odpowiadaznakowi. `3` `r`  
  
 W połączeniu <xref:System.Xml.XmlTextReader.LineNumber%2A>z, `1,1` wartość wskazuje początku dokumentu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla każdy węzeł, w tym jego głębokość, numer wiersza i położenie wiersza.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlTextReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalną nazwę bieżącego węzła.</summary>
        <value>Nazwa bieżącego węzła z usuniętym prefiksem. Na przykład <see langword="LocalName" /> jest <see langword="book" /> dla elementu <c>&lt;BK: Book.&gt;</c>  
  
Dla typów węzłów, które nie mają nazwy ( <see langword="Text" />na przykład, <see langword="Comment" />i tak dalej), ta właściwość zwraca. <see langword="String.Empty" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę lokalną każdego węzła i, jeśli istnieje, prefiks i identyfikator URI przestrzeni nazw.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `book2.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public override string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="override this.LookupNamespace : string -&gt; string" Usage="xmlTextReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks, którego identyfikator URI przestrzeni nazw ma zostać rozpoznany. Aby dopasować domyślną przestrzeń nazw, należy przekazać pusty ciąg. Ten ciąg nie musi być atomowy.</param>
        <summary>Rozpoznaje prefiks przestrzeni nazw w zakresie bieżącego elementu.</summary>
        <returns>Identyfikator URI przestrzeni nazw, do którego są mapowane <see langword="null" /> prefiks lub jeśli nie znaleziono pasującego prefiksu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 W poniższym kodzie XML, jeśli czytnik jest umieszczony na `href` atrybucie, prefiks `a` jest rozpoznawany przez wywołanie `reader.LookupNamespace("a")`. Zwrócony ciąg to `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
 <item>  
 <ref href="a:b"/>  
 </item>  
</root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="true" /> , a <paramref name="prefix" /> wartość to <see langword="null" />. <see cref="P:System.Xml.XmlTextReader.Namespaces" /></exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przenosi do określonego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : int -&gt; unit" Usage="xmlTextReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu.</param>
        <summary>Przenosi do atrybutu o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr jest mniejszy niż 0 lub większy lub <see cref="P:System.Xml.XmlReader.AttributeCount" />równy. <paramref name="i" /></exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : string -&gt; bool" Usage="xmlTextReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>Przenosi do atrybutu o określonej nazwie.</summary>
        <returns><see langword="true" />Jeśli atrybut zostanie znaleziony; w przeciwnym razie. <see langword="false" /> Jeśli <see langword="false" />pozycja czytnika nie zmienia się.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Po wywołaniu `MoveToAttribute` <xref:System.Xml.XmlTextReader.Name%2A>właściwości ,<xref:System.Xml.XmlTextReader.NamespaceURI%2A>, i<xref:System.Xml.XmlTextReader.Prefix%2A> odzwierciedlają właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : string * string -&gt; bool" Usage="xmlTextReader.MoveToAttribute (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nazwa lokalna atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>Przenosi do atrybutu z określoną nazwą lokalną i identyfikatorem URI przestrzeni nazw.</summary>
        <returns><see langword="true" />Jeśli atrybut zostanie znaleziony; w przeciwnym razie. <see langword="false" /> Jeśli <see langword="false" />pozycja czytnika nie zmienia się.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Po wywołaniu `MoveToAttribute` <xref:System.Xml.XmlTextReader.Name%2A>właściwości ,<xref:System.Xml.XmlTextReader.NamespaceURI%2A>, i<xref:System.Xml.XmlTextReader.Prefix%2A> odzwierciedlają właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public override bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToElement();" />
      <MemberSignature Language="F#" Value="override this.MoveToElement : unit -&gt; bool" Usage="xmlTextReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do elementu, który zawiera bieżący węzeł atrybutu.</summary>
        <returns><see langword="true" />Jeśli czytnik jest umieszczony na atrybucie (czytnik przechodzi do elementu, który jest właścicielem atrybutu); <see langword="false" /> jeśli czytnik nie jest umieszczony w atrybucie (pozycja czytnika nie zmienia się).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Użyj tej metody, aby powrócić do elementu po przejściu przez jego atrybuty. Ta metoda przenosi czytnik do jednego z następujących typów węzłów: `Element`, `DocumentType`, lub `XmlDeclaration`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="override this.MoveToFirstAttribute : unit -&gt; bool" Usage="xmlTextReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do pierwszego atrybutu.</summary>
        <returns><see langword="true" />Jeśli istnieje atrybut (czytnik przechodzi do pierwszego atrybutu); w przeciwnym razie (pozycja czytnika nie zmienia się). <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość pierwszego atrybutu węzła głównego.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `attrs.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.MoveToFirstAttribute Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="override this.MoveToNextAttribute : unit -&gt; bool" Usage="xmlTextReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do następnego atrybutu.</summary>
        <returns><see langword="true" />Jeśli istnieje następny atrybut; <see langword="false" /> Jeśli nie ma więcej atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Jeśli bieżący węzeł jest węzłem elementu, ta metoda jest równoważna z <xref:System.Xml.XmlTextReader.MoveToFirstAttribute%2A>. Jeśli `MoveToNextAttribute` zwraca`true`, czytnik przechodzi do następnego atrybutu; w przeciwnym razie pozycja czytnika nie zmienia się.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlTextReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną nazwę bieżącego węzła.</summary>
        <value>Kwalifikowana nazwa bieżącego węzła. Na przykład <see langword="Name" /> jest <see langword="bk:book" /> dla elementu <c>&lt;BK: Book.&gt;</c>  
  
Zwracana nazwa jest zależna <see cref="P:System.Xml.XmlTextReader.NodeType" /> od węzła. Poniższe typy węzłów zwracają wymienione wartości. Wszystkie inne typy węzłów zwracają pusty ciąg.  
  
 <list type="table"><listheader><term> Typ węzła 
 </term><description> Nazwa 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Nazwa atrybutu.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Nazwa typu dokumentu.  
  
 </description></item><item><term><see langword="Element" /></term><description> Nazwa tagu.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Nazwa jednostki, do której się odwołuje.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Obiekt docelowy instrukcji przetwarzania.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Ciąg <see langword="xml" />literału.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla wszystkie węzły.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Namespaces">
      <MemberSignature Language="C#" Value="public bool Namespaces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Namespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Namespaces" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Namespaces { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Namespaces : bool with get, set" Usage="System.Xml.XmlTextReader.Namespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma być obsługiwana przestrzeń nazw.</summary>
        <value><see langword="true" />do obsługi przestrzeni nazw; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość określa, czy czytnik obsługuje przestrzenie [nazw W3C w](https://www.w3.org/TR/REC-xml-names) rekomendacji XML.  
  
 Nie można ustawić właściwości po wystąpieniu operacji odczytu. `Namespaces`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ustawienie tej właściwości po wystąpieniu operacji odczytu (<see cref="P:System.Xml.XmlTextReader.ReadState" /> nie <see langword="ReadState.Initial" />jest).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public override string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlTextReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI przestrzeni nazw (zgodnie z definicją w specyfikacji W3C przestrzeni nazw) węzła, na którym jest umieszczony czytnik.</summary>
        <value>Identyfikator URI przestrzeni nazw bieżącego węzła; w przeciwnym razie pusty ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość ma zastosowanie tylko `Element` do `Attribute` węzłów i.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę lokalną każdego węzła i, jeśli istnieje, prefiks i identyfikator URI przestrzeni nazw.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `book2.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlTextReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Xml.XmlNameTable" /> Pobiera skojarzoną z tą implementacją.</summary>
        <value><see langword="XmlNameTable" /> Umożliwienie uzyskania wykorzystanej przez siebie wersji ciągu w węźle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Wszystkie nazwy węzłów i atrybutów zwracane z <xref:System.Xml.XmlTextReader> są atomowe `NameTable`przy użyciu. Gdy taka sama nazwa jest zwracana wiele razy (na przykład `Customer`), zwracany jest ten sam `String` obiekt dla tej nazwy. Dzięki temu można napisać wydajny kod, który wykonuje porównania obiektów w tych ciągach zamiast kosztownych porównywania ciągów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlTextReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ bieżącego węzła.</summary>
        <value>Jedna z <see cref="T:System.Xml.XmlNodeType" /> wartości reprezentujących typ bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość nigdy nie zwraca następujących `XmlNodeType` typów: `Document`, `DocumentFragment`, `Entity` `EndEntity`, lub `Notation`.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla wszystkie węzły.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Normalization">
      <MemberSignature Language="C#" Value="public bool Normalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Normalization" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Normalization" />
      <MemberSignature Language="VB.NET" Value="Public Property Normalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Normalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Normalization : bool with get, set" Usage="System.Xml.XmlTextReader.Normalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy znormalizować wartości białych znaków i atrybutów.</summary>
        <value><see langword="true" />Aby znormalizować; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Tę właściwość można zmienić w dowolnym momencie i zacznie obowiązywać przy następnej operacji odczytu.  
  
> [!NOTE]
>  Jeśli jest używany do <xref:System.Xml.XmlValidatingReader>konstruowania, do normalizacji wartości atrybutów, `Normalization` musi być ustawiony na `true`. <xref:System.Xml.XmlTextReader>  
  
 Jeśli `Normalization` jest ustawiona na `false`, powoduje także wyłączenie sprawdzania zakresu znaków dla jednostek liczbowych. W wyniku tego dozwolone są jednostki znaków, takie `&#0;`jak.  
  
 Poniżej opisano normalizację wartości atrybutów:  
  
-   Aby uzyskać odwołanie do znaku, Dołącz do wartości atrybutu znak przywoływany.  
  
-   W przypadku odwołania do jednostki rekursywnie przetwarza tekst zastępczy jednostki.  
  
-   W przypadku znaku odstępu (#x20, #xD, #xA #x9) Dodaj #x20 do znormalizowanej wartości. (Tylko jeden #x20 jest dołączany dla sekwencji "#xD # xA" będącej częścią zewnętrznej przeanalizowanej jednostki lub wartości literału wewnętrznej jednostki analizowanej).  
  
-   Przetwarzaj inne znaki, dołączając je do znormalizowanej wartości.  
  
-   Jeśli zadeklarowana wartość nie jest CDATA, Odrzuć wszelkie spacje wiodące i końcowe (#x20) i Zastąp sekwencje znaków spacji (#x20) znakiem pojedynczego odstępu (#x20).  
  
 `XmlTextReader` Tylko wykonuje normalizację atrybutu lub CDATA. Nie robi normalizacji specyficznej dla definicji DTD, chyba że jest `XmlValidatingReader`opakowany w obrębie.  
  
 Zapoznaj się z zaleceniem W3C XML 1,0, aby uzyskać więcej informacji na temat normalizacji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zachowanie czytnika z włączonym normalizem, a następnie wyłączanie.  
  
 [!code-cpp[XmlTextReader.Normalization#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Normalization/CPP/readnormal.cpp#1)]
 [!code-csharp[XmlTextReader.Normalization#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Normalization/CS/readnormal.cs#1)]
 [!code-vb[XmlTextReader.Normalization#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Normalization/VB/readnormal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ustawienie tej właściwości, gdy czytnik jest zamknięty (<see cref="P:System.Xml.XmlTextReader.ReadState" /> is <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public override string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlTextReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prefiks przestrzeni nazw skojarzony z bieżącym węzłem.</summary>
        <value>Prefiks przestrzeni nazw skojarzony z bieżącym węzłem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę lokalną każdego węzła i, jeśli istnieje, prefiks i identyfikator URI przestrzeni nazw.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `book2.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProhibitDtd : bool with get, set" Usage="System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Use DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zezwolić na przetwarzanie DTD. Ta właściwość jest przestarzała. Zamiast nich należy używać słów kluczowych <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />.</summary>
        <value><see langword="true" />Aby uniemożliwić przetwarzanie DTD; w <see langword="false" />przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Przetwarzanie DTD jest domyślnie włączone w celu zapewnienia zgodności z poprzednimi wersjami. Jeśli jednak aplikacja nie wymaga przetwarzania DTD, należy wyłączyć to ustawienie. Wyłączenie przetwarzania DTD może być przydatne w zapobieganiu niektórym atakom typu "odmowa usługi". Jeśli jest ustawiona `true`na, czytnik <xref:System.Xml.XmlException> zgłasza, gdy zostanie napotkana zawartość DTD.  
  
 Jeśli jest włączone przetwarzanie DTD, należy pamiętać, aby uwzględnić definicje DTD z niezaufanych źródeł i możliwy atak typu "odmowa usługi". Użyj, <xref:System.Xml.XmlSecureResolver> aby ograniczyć zasoby <xref:System.Xml.XmlTextReader> , do których może uzyskać dostęp. Możesz również projektować aplikację, tak aby przetwarzanie XML było ograniczone do pamięci i czasu. Na przykład skonfiguruj limity limitu czasu w aplikacji ASP.NET  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public override char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlTextReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera znak cudzysłowu używany do umieszczania wartości węzła atrybutu.</summary>
        <value>Znak cudzysłowu ("or") służący do ujmowania wartości węzła atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość ma zastosowanie tylko do węzła atrybutu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="xmlTextReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny węzeł ze strumienia.</summary>
        <returns><see langword="true" />Jeśli następny węzeł został pomyślnie odczytany; <see langword="false" /> Jeśli nie ma więcej węzłów do odczytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Gdy czytelnik jest najpierw tworzony i inicjowany, nie ma dostępnych informacji. Musisz wywołać `Read` , aby odczytać pierwszy węzeł.  
  
 Aby można było rozpocząć analizowanie, ta metoda wymaga co najmniej czterech bajtów ze strumienia danych. Jeśli zostanie zwróconych mniej niż cztery bajty, a w strumieniu nie ma więcej danych, metoda zakończy się niepowodzeniem. Jeśli strumień zawiera więcej danych, metoda będzie blokować analizowanie do momentu otrzymania wartości czwartego bajtu.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla każdy węzeł.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania kodu XML.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public override bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="override this.ReadAttributeValue : unit -&gt; bool" Usage="xmlTextReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analizuje wartość atrybutu w jeden lub więcej <see langword="Text" />, <see langword="EntityReference" />lub <see langword="EndEntity" /> węzłów.</summary>
        <returns><see langword="true" />Jeśli istnieją węzły do zwrócenia.  
  
 <see langword="false" />Jeśli czytnik nie jest umieszczony w węźle atrybutu podczas wywołania początkowego lub wszystkie wartości atrybutów zostały odczytane.  
  
Pusty atrybut, taki jak, <c>misc = ""</c>, zwraca <see langword="true" /> z pojedynczym węzłem <see langword="String.Empty" />o wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Użyj tej metody po wywołaniu `MoveToAttribute` do odczytu w węzłach odwołania tekstu lub jednostki, które tworzą wartość atrybutu. <xref:System.Xml.XmlReader.Depth%2A> Węzły wartości atrybutów to jeden i głębokość węzła atrybutu; zwiększa się i zmniejsza o jeden po kroku do i z ogólnych odwołań do jednostek.  
  
   
  
## Examples  
 Poniższy przykład odczytuje atrybut z tekstem i węzłami jednostek.  
  
 [!code-cpp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CPP/readattrval.cpp#1)]
 [!code-csharp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CS/readattrval.cs#1)]
 [!code-vb[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/VB/readattrval.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBase64">
      <MemberSignature Language="C#" Value="public int ReadBase64 (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBase64(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBase64 (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBase64(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberSignature Language="F#" Value="member this.ReadBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadBase64 (array, offset, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica znaków, która służy jako bufor, do którego jest zapisywana zawartość tekstu.</param>
        <param name="offset">Indeks (liczony od zera) do tablicy określającej, gdzie Metoda może rozpocząć zapis w buforze.</param>
        <param name="len">Liczba bajtów do zapisu w buforze.</param>
        <summary>Dekoduje Base64 i zwraca zdekodowane bajty binarne.</summary>
        <returns>Liczba bajtów zapisywana w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Podobnie <xref:System.Xml.XmlTextReader.ReadChars%2A>jak można wywołać tę metodę w celu odczytania dużych strumieni tekstu osadzonego. Dekoduje zawartość base64 i zwraca zdekodowane bajty binarne (na przykład wbudowany obraz GIF kodowany algorytmem Base64) do buforu. See RFC 1521. (Specyfikacje RFC można uzyskać z [witryny Request for Comments w sieci Web](https://www.rfc-editor.org)).  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik zawierający dane base64 i BinHex.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 Przykład używa pliku`binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Sekwencja Base64 jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />&lt; 0lub<paramref name="len" /> 0 lub .&gt; <paramref name="len" /> &lt; <paramref name="array" /> Długość — <paramref name="offset" />.</exception>
        <altmember cref="M:System.Xml.XmlTextWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBinHex">
      <MemberSignature Language="C#" Value="public int ReadBinHex (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBinHex(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBinHex (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBinHex(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberSignature Language="F#" Value="member this.ReadBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadBinHex (array, offset, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica bajtów, która służy jako bufor, w którym zapisywane są dekodowane bajty binarne.</param>
        <param name="offset">Indeks (liczony od zera) do tablicy określającej, gdzie Metoda może rozpocząć zapis w buforze.</param>
        <param name="len">Liczba bajtów do zapisu w buforze.</param>
        <summary>Dekoduje <see langword="BinHex" /> i zwraca zdekodowane bajty binarne.</summary>
        <returns>Liczba bajtów zapisywana w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Podobnie <xref:System.Xml.XmlTextReader.ReadChars%2A>jak można wywołać tę metodę w celu odczytania dużych strumieni tekstu osadzonego. Dekoduje `BinHex` zawartość i zwraca zdekodowane bajty binarne (na przykład wbudowany `BinHex` zakodowany obraz GIF) do buforu.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik zawierający `Base64` dane i. `BinHex`  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 Przykład używa pliku`binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><see langword="BinHex" /> Sekwencja jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />&lt; 0lub<paramref name="len" /> 0 lub .&gt; <paramref name="len" /> &lt; <paramref name="array" /> Długość — <paramref name="offset" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public int ReadChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChars (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadChars : char[] * int * int -&gt; int" Usage="xmlTextReader.ReadChars (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która służy jako bufor, do którego jest zapisywana zawartość tekstu.</param>
        <param name="index">Pozycja w miejscu <paramref name="buffer" /> , w którym metoda może rozpocząć zapisywanie zawartości tekstowej.</param>
        <param name="count">Liczba znaków do zapisu <paramref name="buffer" />.</param>
        <summary>Odczytuje zawartość tekstową elementu do buforu znaków. Ta metoda jest przeznaczona do odczytywania dużych strumieni tekstu osadzonego przez wywołanie go kolejno.</summary>
        <returns>Liczba znaków odczytanych. Może to być <see langword="0" /> , jeśli czytnik nie znajduje się na elemencie lub nie ma więcej treści tekstowych do zwrócenia w bieżącym kontekście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Jest to najbardziej wydajny sposób przetwarzania bardzo dużych strumieni tekstu osadzonego w dokumencie XML. Zamiast przydzielać duże obiekty ciągów, `ReadChars` funkcja zwraca zawartość tekstową buforowo. Ta metoda jest przeznaczona do pracy tylko w węzłach elementów. Inne typy węzłów powodują `ReadChars` zwrócenie. `0`  
  
 W poniższym kodzie XML, jeśli czytnik znajduje się w tagu początkowym, `ReadChars` zwraca `test` i umieszcza czytnik po tagu końcowym.  
  
```xml  
<Item>test</Item>  
```  
  
 `ReadChars`ma następujące funkcje:  
  
-   Ta metoda jest przeznaczona do pracy tylko w węzłach elementów. Inne typy węzłów powodują `ReadChars` zwrócenie wartości 0.  
  
-   Ta metoda zwraca rzeczywistą zawartość znaku. Nie jest podejmowana próba rozpoznania jednostek, CDATA ani innych napotkanych znaczników. `ReadChars`zwraca wszystkie elementy między tagiem początkowym a tagiem końcowym, w tym znacznikiem.  
  
-   `ReadChars`ignoruje znaczniki XML, które nie są poprawnie sformułowane. Na przykład podczas odczytywania następującego ciągu `<A>1<A>2</A>` `ReadChars` XML zwraca wartość `1<A>2</A>`. (Zwraca znacznik z pary pasujących elementów i ignoruje inne).  
  
-   Ta metoda nie wykonuje żadnej normalizacji.  
  
-   Gdy `ReadChars` osiągnął koniec strumienia znaków, zwraca wartość 0, a czytnik jest umieszczony po tagu końcowym.  
  
-   Metody odczytu atrybutów nie są dostępne podczas korzystania `ReadChars`z.  
  
 Na przykład przy użyciu następującego kodu XML:  
  
```xml  
<thing>  
 some text  
</thing>  
<item>  
</item>  
```  
  
 Czytnik jest umieszczony na `<item>` elemencie na końcu pętli while.  
  
```csharp  
if (XmlNodeType.Element == reader.NodeType && "thing" == reader.Name)  
{  
 while(0 != reader.ReadChars(buffer, 0, 1)  
 {  
 // Do something.  
 // Attribute values are not available at this point.  
 }  
}  
```  
  
   
  
## Examples  
 Poniższy przykład odczytuje dane w kodzie XML `ReadChars`przy użyciu polecenia.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty `items.xml` plik jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="count" />jest większy niż obszar określony w <paramref name="buffer" /> (rozmiar buforu — <paramref name="index" />).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość to<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
          <see langword="&lt; 0" />lub <paramref name="count" /> .<see langword="&lt; 0" /></exception>
        <altmember cref="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego ma zostać skopiowany otrzymany tekst. Ta wartość nie może <see langword="null" />być.</param>
        <param name="index">Przesunięcie do buforu, gdzie rozpocząć kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania do buforu. Rzeczywista liczba skopiowanych bajtów jest zwracana z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca <see langword="Base64" /> zdekodowane bajty binarne.</summary>
        <returns>Liczba bajtów zapisywana w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda strumieniuje zawartość, dekoduje `Base64` zawartość i zwraca zdekodowane bajty binarne (na przykład obraz GIF zakodowany w tekście `Base64`) do buforu. Ta metoda może być wywoływana kolejno w celu odczytania dużych strumieni tekstu osadzonego. Aby uzyskać więcej informacji, zobacz artykuł RFC 1521, "MIME (Multipurpose Internet Mail Extensions), część jeden: Mechanizmy określania i opisywania formatu treści wiadomości internetowych. Specyfikacje RFC można uzyskać z [witryny Request for Comments w sieci Web](https://www.rfc-editor.org).  
  
> [!NOTE]
>  Nie należy uzyskiwać dostępu do żadnej z właściwości czytnika między wywołaniami <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> metody, dopóki metoda nie zwróci wartości 0.  
  
 Ta metoda ma następujące zachowanie:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>Zwraca wartość 0, gdy osiągnął koniec strumienia bajtów, na którym działał. Czytnik jest ustawiony w pierwszym węźle nienależącym do zawartości.  
  
-   W przypadku poproszenia o mniej lub dokładnej liczbie bajtów niż pozostawiono w strumieniu, czytnik pozostaje w bieżącym położeniu.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>nie jest obsługiwane w następujących typach węzłów XML: `Element`, `XmlDeclaration` `Notation` `Document` `DocumentType` `None`,,,,, `DocumentFragment` ,.`Entity`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość to<see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />nie jest obsługiwany w bieżącym węźle.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks w buforze lub indeksie + Count jest większy niż rozmiar przydzielonego buforu.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego ma zostać skopiowany otrzymany tekst. Ta wartość nie może <see langword="null" />być.</param>
        <param name="index">Przesunięcie do buforu, gdzie rozpocząć kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania do buforu. Rzeczywista liczba skopiowanych bajtów jest zwracana z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca <see langword="BinHex" /> zdekodowane bajty binarne.</summary>
        <returns>Liczba bajtów zapisywana w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda strumieniuje zawartość, dekoduje `BinHex` zawartość i zwraca zdekodowane bajty binarne (na przykład wbudowany `BinHex` zakodowany obraz GIF) do buforu. Ta metoda może być wywoływana kolejno w celu odczytania dużych strumieni tekstu osadzonego.  
  
> [!NOTE]
>  Nie należy uzyskiwać dostępu do żadnej z właściwości czytnika między wywołaniami <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> metody, dopóki metoda nie zwróci wartości 0.  
  
 Ta metoda ma następujące zachowanie:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>Zwraca wartość 0, gdy osiągnął koniec strumienia bajtów, na którym działał. Czytnik jest ustawiony w pierwszym węźle nienależącym do zawartości.  
  
-   W przypadku poproszenia o mniej lub dokładnej liczbie bajtów niż pozostawiono w strumieniu, czytnik pozostaje w bieżącym położeniu.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>nie jest obsługiwane w następujących typach węzłów XML: `Element`, `XmlDeclaration` `Notation` `Document` `DocumentType` `None`,,,,, `DocumentFragment` ,.`Entity`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość to<see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />nie jest obsługiwane w bieżącym węźle.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks w buforze lub indeksie + Count jest większy niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlTextReader" /> Implementacja nie obsługuje tej metody.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego ma zostać skopiowany otrzymany tekst. Ta wartość nie może <see langword="null" />być.</param>
        <param name="index">Przesunięcie do buforu, gdzie rozpocząć kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania do buforu. Rzeczywista liczba skopiowanych bajtów jest zwracana z tej metody.</param>
        <summary>Odczytuje element i dekoduje zawartość Base64.</summary>
        <returns>Liczba bajtów zapisywana w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda odczytuje zawartość elementu, dekoduje ją przy użyciu kodowania base64 i zwraca zdekodowane bajty binarne (na przykład wbudowany obraz GIF kodowany algorytmem Base64) do buforu. Aby uzyskać więcej informacji, zobacz artykuł RFC 1521, "MIME (Multipurpose Internet Mail Extensions), część jeden: Mechanizmy określania i opisywania formatu treści wiadomości internetowych. Specyfikacje RFC można uzyskać z [witryny Request for Comments w sieci Web](https://www.rfc-editor.org).  
  
 Ta metoda może odczytywać tylko elementy prostej zawartości. Element może zawierać tekst, biały znak, znaczący odstęp, sekcje CDATA, komentarze i instrukcje przetwarzania. Może również zawierać odwołania do jednostek, które są automatycznie rozszerzane. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobna do <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> metody, z tą różnicą, że może być wywoływana tylko w typach węzłów elementów.  
  
 Jeśli wartość jest większa niż liczba bajtów w dokumencie lub jeśli jest równa liczbie bajtów w dokumencie <xref:System.Xml.XmlTextReader> , odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę odczytanych bajtów. `count` Następne <xref:System.Xml.XmlTextReader> wywołanie metody zwraca zero i przenosi czytnik do węzła <xref:System.Xml.XmlNodeType.EndElement>po.  
  
 Jeśli zostanie wywołana <xref:System.Xml.XmlTextReader.Read%2A> przed użyciem całej zawartości elementu, czytelnik może zachowywać się tak, jakby była używana pierwsza zawartość, a <xref:System.Xml.XmlTextReader.Read%2A> następnie została wywołana. Oznacza to, że czytelnik odczytuje cały tekst do momentu napotkania elementu końcowego. Następnie odczytuje węzeł tag końcowy, odczytuje następny węzeł, a następnie umieszcza go w następnym kolejnym węźle.  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A?displayProperty=nameWithType> , aby zobaczyć przykład za pomocą tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość to<see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest węzłem elementu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks w buforze lub indeksie + Count jest większy niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlTextReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera zawartość mieszaną.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości na żądany typ.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego ma zostać skopiowany otrzymany tekst. Ta wartość nie może <see langword="null" />być.</param>
        <param name="index">Przesunięcie do buforu, gdzie rozpocząć kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania do buforu. Rzeczywista liczba skopiowanych bajtów jest zwracana z tej metody.</param>
        <summary>Odczytuje element i dekoduje <see langword="BinHex" /> zawartość.</summary>
        <returns>Liczba bajtów zapisywana w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda odczytuje zawartość elementu, dekoduje ją przy użyciu `BinHex` kodowania i zwraca zdekodowane bajty binarne (na przykład wbudowany `BinHex` zakodowany obraz GIF) do buforu.  
  
 Ta metoda może odczytywać tylko elementy prostej zawartości. Element może zawierać tekst, biały znak, znaczący odstęp, sekcje CDATA, komentarze i instrukcje przetwarzania. Może również zawierać odwołania do jednostek, które są automatycznie rozszerzane. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobna do <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> metody, z tą różnicą, że może być wywoływana tylko w typach węzłów elementów.  
  
 Jeśli wartość jest większa niż liczba bajtów w dokumencie lub jeśli jest równa liczbie bajtów w dokumencie <xref:System.Xml.XmlTextReader> , odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę odczytanych bajtów. `count` Następne <xref:System.Xml.XmlTextReader> wywołanie metody zwraca zero i przenosi czytnik do węzła <xref:System.Xml.XmlNodeType.EndElement>po.  
  
 Jeśli zostanie wywołana <xref:System.Xml.XmlTextReader.Read%2A> przed użyciem całej zawartości elementu, czytelnik może zachowywać się tak, jakby była używana pierwsza zawartość, a <xref:System.Xml.XmlTextReader.Read%2A> następnie została wywołana. Oznacza to, że czytelnik odczytuje cały tekst do momentu napotkania elementu końcowego. Następnie odczytuje węzeł tag końcowy, odczytuje następny węzeł, a następnie umieszcza go w następnym kolejnym węźle.  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A?displayProperty=nameWithType> , aby zobaczyć przykład za pomocą tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość to<see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest węzłem elementu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks w buforze lub indeksie + Count jest większy niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera zawartość mieszaną.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości na żądany typ.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public override System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlTextReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan czytnika.</summary>
        <value>Jedna z <see cref="T:System.Xml.ReadState" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public override string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="override this.ReadString : unit -&gt; string" Usage="xmlTextReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość elementu lub węzła tekstowego jako ciąg.</summary>
        <returns>Zawartość węzła elementu lub tekstu. Może to być pusty ciąg, jeśli czytnik jest umieszczony w innym miejscu niż element lub węzeł tekstowy, lub jeśli nie ma więcej zawartości tekstowej do zwrócenia w bieżącym kontekście.  
  
 <see langword="Note:" />Węzłem tekstu może być element lub węzeł tekstu atrybutu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Jeśli jest ustawiona na element, `ReadString` łączy cały tekst, znaczący biały znak, odstępy i `CData` typy węzłów sekcji i zwraca dane połączone jako zawartość elementu. Jest ona zatrzymywana w przypadku napotkania dowolnego znacznika, w tym komentarzy i instrukcji przetwarzania. Może to nastąpić w modelu zawartości mieszanej lub gdy odczytywany jest tag końcowy elementu.  
  
 W przypadku położenia w węźle tekstowym program `ReadString` wykonuje takie samo łączenie z węzła tekstowego do znacznika końcowego elementu. Jeśli czytnik jest umieszczony w węźle tekstu atrybutu, `ReadString` ma takie same funkcje jak w przypadku, gdy czytelnik miał miejsce w tagu początkowym elementu. Zwraca wszystkie połączone węzły tekstu elementu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość tekstową każdego elementu.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 W przykładzie jest użyty plik, `elems.xml`, jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania kodu XML.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę wykonania nieprawidłowej operacji.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public void ResetState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResetState" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetState();" />
      <MemberSignature Language="F#" Value="member this.ResetState : unit -&gt; unit" Usage="xmlTextReader.ResetState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje stan czytnika do stanie ReadState. Initial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta metoda umożliwia przeanalizowanie wielu dokumentów XML w jednym strumieniu. Gdy docierasz do końca dokumentu XML, możesz wywołać `ResetState` , aby zresetować stan czytnika w przygotowaniu dla następnego dokumentu XML.  
  
> [!IMPORTANT]
>  Dokumenty w strumieniu muszą mieć takie samo kodowanie. Jeśli tak się nie dzieje, gdy `ResetState` zostanie <xref:System.Xml.XmlException> wywołane wywołanie jest zgłaszane. (Jest to zmiana w zachowaniu z .NET Framework wersja 1,1 i wcześniejsza).  
  
 Nie ma to wpływ `ResetState`na następujące właściwości.  
  
-   <xref:System.Xml.XmlTextReader.Normalization%2A>  
  
-   <xref:System.Xml.XmlTextReader.Namespaces%2A>  
  
-   <xref:System.Xml.XmlTextReader.XmlResolver%2A>  
  
-   <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A>  
  
   
  
## Examples  
 Poniższy przykład analizuje dwa dokumenty XML w jednym strumieniu.  
  
 [!code-cpp[XmlTextReader.ResetState#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ResetState/CPP/resetstate.cpp#1)]
 [!code-csharp[XmlTextReader.ResetState#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ResetState/CS/resetstate.cs#1)]
 [!code-vb[XmlTextReader.ResetState#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ResetState/VB/resetstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywoływanie <see langword="ResetState" /> , jeśli czytnik został skonstruowany <see cref="T:System.Xml.XmlParserContext" />przy użyciu.</exception>
        <exception cref="T:System.Xml.XmlException">Dokumenty w jednym strumieniu nie mają tego samego kodowania.</exception>
        <altmember cref="T:System.Xml.ReadState" />
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public override void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResolveEntity();" />
      <MemberSignature Language="F#" Value="override this.ResolveEntity : unit -&gt; unit" Usage="xmlTextReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoznaje odwołanie do jednostki dla <see langword="EntityReference" /> węzłów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Jeśli czytnik jest umieszczony w `EntityReference` węźle (`XmlNodeType.EntityReference`), jeśli <xref:System.Xml.XmlTextReader.Read%2A> jest wywoływana po wywołaniu tej metody, tekst zamiany jednostki zostanie przeanalizowany. Po zakończeniu tekstu zastępujący jednostki jest zwracany `EndEntity` węzeł, aby zamknąć zakres odwołania do jednostki.  
  
> [!NOTE]
>  Po wywołaniu tej metody, jeśli jednostka jest częścią wartości atrybutu, należy wywołać <xref:System.Xml.XmlTextReader.ReadAttributeValue%2A> krok do jednostki.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlTextReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt użyty do utworzenia tego <see cref="T:System.Xml.XmlTextReader" /> wystąpienia. <see cref="T:System.Xml.XmlReaderSettings" /></summary>
        <value>Obiekt użyty do utworzenia tego <see cref="T:System.Xml.XmlTextReader" /> wystąpienia; <see cref="T:System.Xml.XmlReaderSettings" /> Jeśli czytelnik nie został utworzony <see cref="Overload:System.Xml.XmlReader.Create" /> przy użyciu metody. <see langword="null" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> Zalecanym sposobem jest utworzenie <xref:System.Xml.XmlReader> <xref:System.Xml.XmlReaderSettings> wystąpień<xref:System.Xml.XmlReader.Create%2A> przy użyciu klasy i metody. [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] Pozwala to na pełne wykorzystanie wszystkich nowych funkcji wprowadzonych w programie [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Aby uzyskać więcej informacji, zobacz sekcję uwagi na <xref:System.Xml.XmlReader> stronie referencyjnej.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public override void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Skip();" />
      <MemberSignature Language="F#" Value="override this.Skip : unit -&gt; unit" Usage="xmlTextReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pomija elementy podrzędne bieżącego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 W poniższych danych wejściowych XML, jeśli czytnik jest umieszczony w `<a>` węźle lub dowolnym z jego atrybutów, wywoływanie `Skip` `<b>` położenia czytnika do węzła.  
  
 Jeśli czytnik jest umieszczony w węźle liścia już (takim jak `<x>` węzeł lub węzeł `abc`tekstowy), wywoływanie `Skip` jest takie samo jak wywołanie <xref:System.Xml.XmlTextReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
  <x/>abc<y/>  
</a>  
<b>  
 ...  
</b>  
```  
  
 Ta metoda sprawdza poprawnie sformułowany kod XML.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlLineInfo.HasLineInfo">
      <MemberSignature Language="C#" Value="bool IXmlLineInfo.HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Xml.IXmlLineInfo.HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlLineInfo#HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Function HasLineInfo () As Boolean Implements IXmlLineInfo.HasLineInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Xml.IXmlLineInfo.HasLineInfo() = System::Xml::IXmlLineInfo::HasLineInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.IXmlLineInfo.HasLineInfo" />Zobacz.</summary>
        <returns><see langword="true" />Jeśli <see cref="P:System.Xml.IXmlLineInfo.LineNumber" /> i <see cref="P:System.Xml.IXmlLineInfo.LinePosition" /> mogą<see langword="false" />być dostarczone; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Xml.XmlTextReader> gdy wystąpienie jest rzutowane <xref:System.Xml.IXmlLineInfo> do interfejsu.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.GetNamespacesInScope">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IDictionary&lt;string,string&gt; IXmlNamespaceResolver.GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String) Implements IXmlNamespaceResolver.GetNamespacesInScope" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System::Xml::XmlNamespaceScope scope) = System::Xml::IXmlNamespaceResolver::GetNamespacesInScope;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Xml.XmlNamespaceScope" /> Wartość określająca typ węzłów przestrzeni nazw do zwrócenia.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />Zobacz.</summary>
        <returns><see cref="T:System.Collections.IDictionary" /> Zawierający bieżącą przestrzeń nazw w zakresie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Xml.XmlTextReader> gdy wystąpienie jest rzutowane <xref:System.Xml.IXmlNamespaceResolver> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupNamespace">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupNamespace (prefix As String) As String Implements IXmlNamespaceResolver.LookupNamespace" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupNamespace(System::String ^ prefix) = System::Xml::IXmlNamespaceResolver::LookupNamespace;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks, którego przestrzeń nazw ma zostać znaleziona.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)" />Zobacz.</summary>
        <returns>Identyfikator URI przestrzeni nazw, który jest mapowany na prefiks; <see langword="null" /> jeśli prefiks nie jest zamapowany na identyfikator URI przestrzeni nazw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Xml.XmlTextReader> gdy wystąpienie jest rzutowane <xref:System.Xml.IXmlNamespaceResolver> do interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupPrefix">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupPrefix (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupPrefix (namespaceName As String) As String Implements IXmlNamespaceResolver.LookupPrefix" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupPrefix(System::String ^ namespaceName) = System::Xml::IXmlNamespaceResolver::LookupPrefix;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="namespaceName">Identyfikator URI przestrzeni nazw, którego prefiks ma zostać znaleziony.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)" />Zobacz.</summary>
        <returns>Prefiks mapowany na identyfikator URI przestrzeni nazw; <see langword="null" /> Jeśli identyfikator URI przestrzeni nazw nie jest zamapowany na prefiks.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public override string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlTextReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość tekstową bieżącego węzła.</summary>
        <value>Zwracana wartość zależy <see cref="P:System.Xml.XmlTextReader.NodeType" /> od węzła. Poniższa tabela zawiera listę typów węzłów, które mają wartość zwracaną. Wszystkie inne typy węzłów zwracają <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Typ węzła 
 </term><description> Wartość 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Wartość atrybutu.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Zawartość sekcji CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Zawartość komentarza.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Podzestaw wewnętrzny.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Cała zawartość, z wyłączeniem celu.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Biały znak w <see langword="xml:space" />zakresie "preserve".  
  
 </description></item><item><term><see langword="Text" /></term><description> Zawartość węzła tekstowego.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Odstęp między znakami.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Zawartość deklaracji.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla każdy węzeł.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="WhitespaceHandling">
      <MemberSignature Language="C#" Value="public System.Xml.WhitespaceHandling WhitespaceHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WhitespaceHandling WhitespaceHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property WhitespaceHandling As WhitespaceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::WhitespaceHandling WhitespaceHandling { System::Xml::WhitespaceHandling get(); void set(System::Xml::WhitespaceHandling value); };" />
      <MemberSignature Language="F#" Value="member this.WhitespaceHandling : System.Xml.WhitespaceHandling with get, set" Usage="System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WhitespaceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, jak biały znak jest obsługiwany.</summary>
        <value>Jedna z <see cref="T:System.Xml.WhitespaceHandling" /> wartości. Wartość domyślna to <see langword="WhitespaceHandling.All" /> (zwraca <see langword="Whitespace" /> i <see langword="SignificantWhitespace" /> węzły).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Tę właściwość można zmienić w dowolnym momencie i zacznie obowiązywać przy następnej operacji odczytu.  
  
 Ponieważ nie ma dla niego dostępnych informacji DTD, `SignificantWhitepsace` węzły `xml:space='preserve'` są zwracane tylko w obrębie zakresu. `XmlTextReader`  
  
   
  
## Examples  
 Poniższy przykład odczytuje fragment XML.  
  
 [!code-cpp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono nieprawidłową wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Ustawienie tej właściwości, gdy czytnik jest zamknięty (<see cref="P:System.Xml.XmlTextReader.ReadState" /> is <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlTextReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see langword="xml:lang" /> zakres.</summary>
        <value>Bieżący <see langword="xml:lang" /> zakres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Ta właściwość reprezentuje `xml:lang` zakres, w którym znajduje się bieżący węzeł. Na przykład poniżej znajduje się fragment XML z `xml:lang` ustawionym na angielski stan USA w elemencie głównym:  
  
 \<główny plik XML: lang = "pl-US" >  
  
 \<Nazwa > Fred\</Name >  
  
 \</root >  
  
 Gdy czytnik jest umieszczony na `name` elemencie, można użyć tej właściwości, aby sprawdzić, czy znajduje się w zakresie atrybutu w języku angielskim `xml:lang` USA.  
  
   
  
## Examples  
 Poniższy przykład wyświetla `xml:lang` wartość dla każdego węzła.  
  
 [!code-cpp[XmlTextReader.XmlLang#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlLang/CPP/readlang.cpp#1)]
 [!code-csharp[XmlTextReader.XmlLang#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlLang/CS/readlang.cs#1)]
 [!code-vb[XmlTextReader.XmlLang#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlLang/VB/readlang.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlTextReader.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Xml.XmlResolver" /> Ustawia używany do rozpoznawania odwołań DTD.</summary>
        <value><see langword="XmlResolver" /> Do użycia. Jeśli jest ustawiona <see langword="null" />na, zasoby zewnętrzne nie są rozpoznawane.  
  
W wersji 1,1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu obiekt wywołujący musi być w pełni zaufany, aby można było <see langword="XmlResolver" />określić.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
 Czytnik używa `XmlResolver` do rozpoznawania lokalizacji pliku załadowanego do czytnika, a także do rozpoznawania odwołań DTD. Na przykład, jeśli XML zawiera deklarację DOCTYPE, `<!DOCTYPE book SYSTEM book.dtd>` czytelnik rozpoznaje ten plik zewnętrzny i zapewnia, że DTD jest poprawnie sformułowany. Czytnik nie używa elementu DTD do walidacji.  
  
 Tę właściwość można zmienić w dowolnym momencie i zacznie obowiązywać przy następnej operacji odczytu. Jeśli ta właściwość jest ustawiona na `null`, wszelkie zewnętrzne odwołania DTD napotkane przez czytnik nie są rozpoznawane.  
  
 W wersji 1,1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu, jeśli ta właściwość nie jest ustawiona, poziom zaufania aplikacji określa zachowanie domyślne.  
  
 `Fully trusted code:`Czytnik używa ustawienia domyślnego <xref:System.Xml.XmlUrlResolver> bez poświadczeń użytkownika. Jeśli do uzyskania dostępu do zasobu sieciowego jest wymagane uwierzytelnianie, użyj `XmlResolver` właściwości, aby `XmlResolver` określić z wymaganymi poświadczeniami.  
  
 `Semi-trusted code:`Właściwość jest ustawiona na `null`. `XmlResolver` Zasoby zewnętrzne nie zostały rozwiązane.  
  
   
  
## Examples  
 Poniższy przykład używa `XmlResolver` właściwości, aby określić poświadczenia niezbędne do uzyskania dostępu do pliku sieciowe.  
  
 [!code-cpp[XmlTextReader.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlResolver/CPP/rdr_resolver.cpp#1)]
 [!code-csharp[XmlTextReader.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlResolver/CS/rdr_resolver.cs#1)]
 [!code-vb[XmlTextReader.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlResolver/VB/rdr_resolver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlTextReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see langword="xml:space" /> zakres.</summary>
        <value>Jedna z <see cref="T:System.Xml.XmlSpace" /> wartości. Jeśli zakres <see langword="xml:space" /> nie istnieje, ta właściwość <see langword="XmlSpace.None" />domyślnie przyjmuje wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od .NET Framework 2,0 zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpień przy <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> użyciu metody, aby skorzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład analizuje plik i zwraca znaczący biały znak, jeśli `xml:space='preserve'` zostanie znaleziony zakres.  
  
 [!code-cpp[XmlTextReader.XmlSpace#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlSpace/CPP/readspace.cpp#1)]
 [!code-csharp[XmlTextReader.XmlSpace#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlSpace/CS/readspace.cs#1)]
 [!code-vb[XmlTextReader.XmlSpace#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlSpace/VB/readspace.vb#1)]  
  
 W przykładzie jest użyty plik, `authors.xml`, jako dane wejściowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
  </Members>
</Type>

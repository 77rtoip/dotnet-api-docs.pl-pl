<Type Name="XmlTextReader" FullName="System.Xml.XmlTextReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc7d765170296a270026ece865d6eb31cd64ddfa" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061677" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlTextReader : System.Xml.XmlReader, System.Xml.IXmlLineInfo, System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlTextReader extends System.Xml.XmlReader implements class System.Xml.IXmlLineInfo, class System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlTextReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlTextReader&#xA;Inherits XmlReader&#xA;Implements IXmlLineInfo, IXmlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlTextReader : System::Xml::XmlReader, System::Xml::IXmlLineInfo, System::Xml::IXmlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlReader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlLineInfo</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.IXmlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje czytnik umożliwia szybkie, niebuforowanym, tylko do przodu dostęp do danych XML.  
  
 Począwszy od programu .NET Framework 2.0, firma Microsoft zaleca użycie <see cref="T:System.Xml.XmlReader" /> zamiast klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 <xref:System.Xml.XmlTextReader> Umożliwia dostęp tylko do przodu, tylko do odczytu do strumienia danych XML. Bieżący węzeł odwołuje się do węzła, na którym znajduje się czytnika. Czytnik jest zaawansowane przy użyciu dowolnej z metod odczytu i właściwości uwzględnia wartość bieżącego węzła.  
  
 Ta klasa implementuje <xref:System.Xml.XmlReader> i odpowiada W3C Extensible Markup Language (XML) 1.0 i przestrzenie nazw w zalecenia XML. `XmlTextReader` udostępnia następujące funkcje:  
  
-   Wymusza zasady poprawnie sformułowany plik XML.  
  
-   `XmlTextReader` nie zapewnia sprawdzanie poprawności danych.  
  
-   Sprawdza, czy `DocumentType` węzły są poprawnie sformułowany. `XmlTextReader` sprawdza DTD dla składniowej, ale nie można zweryfikować za pomocą definicji DTD.  
  
-   Dla węzłów gdzie <xref:System.Xml.XmlTextReader.NodeType%2A> jest `XmlNodeType.EntityReference`, pojedynczy pusty `EntityReference` węzła jest zwracany (oznacza to, <xref:System.Xml.XmlTextReader.Value%2A> jest właściwość `String.Empty`).  
  
> [!NOTE]
>  Rzeczywiste deklaracje jednostek w definicji DTD są nazywane `Entity` węzłów. W przypadku odwoływania się do tych węzłów danych, są one nazywane `EntityReference` węzłów.  
  
-   Nie zwiększa atrybutów domyślnych.  
  
 Ponieważ `XmlTextReader` nie przeprowadza kontroli dodatkowe wymagane do weryfikacji danych zapewnia szybkie składniowej analizatora składni.  
  
 Aby przeprowadzić sprawdzanie poprawności danych, należy użyć, sprawdzanie poprawności <xref:System.Xml.XmlReader>.  
  
 Do odczytywania danych XML z <xref:System.Xml.XmlDocument>, użyj <xref:System.Xml.XmlNodeReader>.  
  
 `XmlTextReader` zgłasza wyjątek <xref:System.Xml.XmlException> na XML analizy błędów. Po zgłoszenia wyjątku stan czytnika danych nie jest przewidywalne. Na przykład typ węzła zgłoszone może być różni się od typu rzeczywistego węzła bieżącego węzła. Użyj <xref:System.Xml.XmlTextReader.ReadState%2A> właściwość do sprawdzenia, czy czytnik jest w stanie błędu.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące zabezpieczeń  
 Oto co należy wziąć pod uwagę przy użyciu <xref:System.Xml.XmlTextReader> klasy.  
  
-   Wyjątki zgłaszane <xref:System.Xml.XmlTextReader> może ujawnić informacje o ścieżce, który nie ma przepuszcza do aplikacji. Aplikacji należy przechwytywać wyjątki i odpowiednio je przetworzyć.  
  
-   Przetwarzanie elementu DTD jest domyślnie włączona. Wyłącz DTD przetwarzania, jeśli masz obawy problemów "odmowa usługi" lub jeśli mamy do czynienia z niezaufanego źródła. Ustaw <xref:System.Xml.XmlTextReader.DtdProcessing%2A> właściwości <xref:System.Xml.DtdProcessing.Prohibit> Aby wyłączyć przetwarzanie elementu DTD.  
  
     Jeśli przetwarzanie elementu DTD włączone, można użyć <xref:System.Xml.XmlSecureResolver> do ograniczania zasobów który <xref:System.Xml.XmlTextReader> może uzyskać dostęp. Można również projektować aplikacji, tak aby przetwarzania XML pamięci i ograniczonego czasu. Na przykład Konfigurowanie limitów czasu w aplikacji ASP.NET.  
  
-   Dane XML mogą zawierać odwołania do zasobów zewnętrznych, takich jak plik definicji DTD. Domyślnie zasobów zewnętrznych są rozpoznawane przy użyciu <xref:System.Xml.XmlUrlResolver> obiektu bez poświadczeń użytkownika. Można zabezpieczyć ją, wykonując jedną z następujących czynności:  
  
    -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlTextReader> dostęp przez ustawienie <xref:System.Xml.XmlTextReader.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
  
    -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlTextReader.XmlResolver%2A> właściwości `null`.  
  
-   Dane XML mogą zawierać dużej liczby atrybutów, deklaracje przestrzeni nazw, elementów zagnieżdżonych i tak dalej wymagające znacznej ilości czasu na przetwarzanie. Aby ograniczyć rozmiar danych wejściowych, które są wysyłane do <xref:System.Xml.XmlTextReader>, Utwórz niestandardowe implementacji IStream i dostarczenie jej <xref:System.Xml.XmlTextReader>.  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A> Metody można użyć do obsługi dużych strumieni danych. Ta metoda odczytuje niewielkiej liczby znaków w czasie zamiast przydzielania pojedynczy ciąg dla wartości całkowitej.  
  
-   Domyślnie jednostki ogólne nie są rozwinięte. Ogólne jednostki są rozwinięte podczas wywoływania <xref:System.Xml.XmlTextReader.ResolveEntity%2A> metody.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Ta klasa ma żądanie dziedziczenia. Pełne zaufanie musi dziedziczyć <see langword="XmlTextReader" />.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlTextReader" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Strumień zawierających dane XML do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 <xref:System.Xml.XmlTextReader> Dekoduje stream przy użyciu <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">
          <see langword="TextReader" /> Zawierających dane XML do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Zakłada ona, że `TextReader` jest już ustawiony na prawidłowe kodowanie. To jest używany przez klientów, którzy już przeczytanie kilka rzeczy, ze strumienia w scenariuszu wieloczęściowej MIME.  
  
   
  
## Examples  
 Poniższy przykład załaduje ciągu XML do `XmlTextReader` przy użyciu <xref:System.IO.StringReader> klasy.  
  
 [!code-cpp[XmlTextReader.cctor1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.cctor1/CPP/rdrcctor1.cpp#1)]
 [!code-csharp[XmlTextReader.cctor1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.cctor1/CS/rdrcctor1.cs#1)]
 [!code-vb[XmlTextReader.cctor1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.cctor1/VB/rdrcctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL pliku zawierającego dane XML. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Jeśli plik znajduje się na zasobie, który wymaga poświadczeń dostępu, użyj <xref:System.Xml.XmlTextReader.XmlResolver%2A> właściwości w celu określenia niezbędnych poświadczeń.  
  
> [!NOTE]
>  W wersji 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], częściowo zaufanego kodu nie można ustawić `XmlResolver` właściwości. Obejście polega na utworzeniu <xref:System.Xml.XmlUrlResolver> niezbędne poświadczenia, przekaż identyfikator URI do <xref:System.Xml.XmlUrlResolver.GetEntity%2A?displayProperty=nameWithType> metody, a następnie konstrukcja `XmlTextReader` przy użyciu powstałe w ten sposób <xref:System.IO.Stream> obiektu. Obejście opisano w następującym kodzie C#.  
  
```csharp  
// Create a resolver with the necessary credentials.  
XmlUrlResolver resolver = new XmlUrlResolver();  
NetworkCredential nc = new NetworkCredential(SecurelyStoredUserName, SecurelyStoredPassword, SecurelyStoredDomain);  
resolver.Credentials = nc;   
// Get a Stream object containing the XML file.  
Uri myUri = new Uri ("http://myServer/data/books.xml");  
Stream s=(Stream)resolver.GetEntity(myUri, null, typeof(Stream));  
// Construct a reader using the Stream object.  
XmlTextReader reader = new XmlTextReader(s);  
```  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `items.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonego pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można odnaleźć części nazwy pliku lub katalogu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="url" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.Net.WebException">Nie można rozpoznać nazwy pliku zdalnego.  
  
 —lub—  
  
 Wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="url" /> nie jest prawidłowym identyfikatorem URI.</exception>
        <altmember cref="P:System.Xml.XmlTextReader.XmlResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader(System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">Strumień zawierających dane XML do odczytu.</param>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonego strumienia i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 <xref:System.Xml.XmlTextReader> Dekoduje stream przy użyciu <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 Jeśli określisz tabeli nazw ten konstruktor korzysta z nazw już zdefiniowane w tej tabeli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="input" /> Lub <paramref name="nt" /> wartość jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">
          <see langword="TextReader" /> Zawierających dane XML do odczytu.</param>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonym <see cref="T:System.IO.TextReader" /> i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Zakłada ona, że `TextReader` jest już ustawiony na prawidłowe kodowanie. To jest używany przez klientów, którzy już przeczytanie kilka rzeczy, ze strumienia w scenariuszu wieloczęściowej MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="nt" /> Wartość jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL do użycia w celu rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość.</param>
        <param name="input">Strumień zawierających dane XML do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> z określonego adresu URL i strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL do użycia w celu rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość.</param>
        <param name="input">
          <see langword="TextReader" /> Zawierających dane XML do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy pod określonym adresem URL i <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Zakłada ona, że `TextReader` jest już ustawiony na prawidłowe kodowanie. To jest używany przez klientów, którzy już przeczytanie kilka rzeczy, ze strumienia w scenariuszu wieloczęściowej MIME.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL pliku zawierającego dane XML, do odczytu.</param>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonego pliku i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="nt" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonego pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można odnaleźć części nazwy pliku lub katalogu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="url" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.Net.WebException">Nie można rozpoznać nazwy pliku zdalnego.  
  
 —lub—  
  
 Wystąpił błąd podczas przetwarzania żądania.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="url" /> nie jest prawidłowym identyfikatorem URI.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As Stream, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.IO.Stream" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Strumień, zawierający fragmentu XML do analizy.</param>
        <param name="fragType">
          <see cref="T:System.Xml.XmlNodeType" /> Fragmentu XML. Określa również, co może zawierać fragmentu. (Zobacz poniżej).</param>
        <param name="context">
          <see cref="T:System.Xml.XmlParserContext" /> w którym <c>xmlFragment</c> ma zostać przeanalizowany. Obejmuje to <see cref="T:System.Xml.XmlNameTable" /> do użytku, kodowania, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c>i <c>XML: Space</c> zakresu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonego obiektu stream, <see cref="T:System.Xml.XmlNodeType" />, i <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ten konstruktor analizuje podanego ciągu jako fragment XML. Jeżeli fragmentu XML jest element lub atrybut, można pominąć reguły poziomu głównego dla poprawnie sformułowanym dokumentów XML.  
  
 Poniższa tabela zawiera listę prawidłowych wartości dla `fragType`.  
  
|XmlNodeType|Może zawierać fragmentu|  
|-----------------|--------------------------|  
|`Element`|Zawartość elementu prawidłowy (na przykład dowolną kombinację elementy, komentarze, przetwarzanie instrukcji, CDATA sekcje, tekst i odwołań do jednostek).<br /><br /> Należy dostarczyć także deklaracji XML. Dzięki temu można określić kodowanie fragmentem kodu XML, zamiast go <xref:System.Xml.XmlParserContext> obiektu.|  
|`Attribute`|Wartość atrybutu (część wewnątrz cudzysłowów).|  
|`Document`|Zawartość całego dokumentu XML. To wymusza reguły poziomu dokumentu.|  
  
 Czytnik są używane następujące określić kodowania strumienia.  
  
1.  Sprawdza <xref:System.Xml.XmlParserContext.Encoding%2A?displayProperty=nameWithType> właściwości w celu określenia kodowania.  
  
2.  Jeśli `Encoding` właściwość jest `null`, czytnik sprawdza występowanie znacznik kolejności bajtów na początku strumienia.  
  
3.  Jeśli `Encoding` właściwość jest `null`i Brak znacznika kolejności bajtów zostanie znaleziony, zakłada czytnik strumienia jest zakodowany w formacie UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="fragType" /> nie jest elementu, atrybutu lub dokument <see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xmlFragment" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL do użycia w celu rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość. Jeśli <c>adres url</c> jest <see langword="null" />, <see langword="BaseURI" /> ma ustawioną wartość <see langword="String.Empty" />.</param>
        <param name="input">Strumień zawierających dane XML do odczytu.</param>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy pod określonym adresem URL, przesyłanie strumieniowe i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="input" /> Lub <paramref name="nt" /> wartość jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL do użycia w celu rozpoznawania zasobów zewnętrznych. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> Jest ustawiona na tę wartość. Jeśli <c>adres url</c> jest <see langword="null" />, <see langword="BaseURI" /> ma ustawioną wartość <see langword="String.Empty" />.</param>
        <param name="input">
          <see langword="TextReader" /> Zawierających dane XML do odczytu.</param>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy pod określonym adresem URL <see cref="T:System.IO.TextReader" /> i <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Zakłada ona, że `TextReader` jest już ustawiony na prawidłowe kodowanie. To jest używany przez klientów, którzy już przeczytanie kilka rzeczy, ze strumienia w scenariuszu wieloczęściowej MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nt" /> Wartość jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As String, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.String" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Ciąg zawierający fragmentu XML do analizy.</param>
        <param name="fragType">
          <see cref="T:System.Xml.XmlNodeType" /> Fragmentu XML. Określa również, co może zawierać ciągu fragmentu. (Zobacz poniżej).</param>
        <param name="context">
          <see cref="T:System.Xml.XmlParserContext" /> w którym <c>xmlFragment</c> ma zostać przeanalizowany. Obejmuje to <see cref="T:System.Xml.XmlNameTable" /> do użytku, kodowania, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c>i <c>XML: Space</c> zakresu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlTextReader" /> klasy z określonego ciągu <see cref="T:System.Xml.XmlNodeType" />, i <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ten konstruktor analizuje podanego ciągu jako fragment XML. Jeżeli fragmentu XML jest element lub atrybut, można pominąć reguły poziomu głównego dla poprawnie sformułowanym dokumentów XML. Ten konstruktor może obsłużyć ciągi zwrócony z <xref:System.Xml.XmlReader.ReadInnerXml%2A>.  
  
 Poniższa tabela zawiera listę prawidłowych wartości dla `fragType` i jak czytnik analizuje poszczególnych typów innego węzła.  
  
|XmlNodeType|Może zawierać fragmentu|  
|-----------------|--------------------------|  
|Element|Zawartość elementu prawidłowy (na przykład dowolną kombinację elementy, komentarze, przetwarzanie instrukcji, CDATA sekcje, tekst i odwołań do jednostek).<br /><br /> Należy dostarczyć także deklaracji XML. Dzięki temu można określić kodowanie fragmentem kodu XML, zamiast go <xref:System.Xml.XmlParserContext> obiektu.|  
|Atrybut|Wartość atrybutu (część wewnątrz cudzysłowów).|  
|dokument|Zawartość całego dokumentu XML. To wymusza reguły poziomu dokumentu.|  
  
   
  
## Examples  
 Poniższy przykład analizuje XML fragment. Używa `XmlParserContext` i jego <xref:System.Xml.XmlNamespaceManager> do obsługi rozpoznawania nazw.  
  
 [!code-cpp[XmlTextReader.Cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Cctor/CPP/readfrag.cpp#1)]
 [!code-csharp[XmlTextReader.Cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Cctor/CS/readfrag.cs#1)]
 [!code-vb[XmlTextReader.Cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Cctor/VB/readfrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="fragType" /> nie jest <see langword="Element" />, <see langword="Attribute" />, lub <see langword="Document" /><see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xmlFragment" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlParserContext" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public override int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int AttributeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę atrybutów w bieżącym węźle.</summary>
        <value>Liczba atrybutów dla bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość ma zastosowanie w przypadku `Element`, `DocumentType` i `XmlDeclaration` tylko węzłów. (Inne typy węzłów nie ma atrybutów).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy identyfikator URI bieżącego węzła.</summary>
        <value>Podstawowy identyfikator URI bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Sieciowych dokumentu XML składa się z fragmentów dane zagregowane przy użyciu różnych mechanizmów standardowe włączenia W3C, dlatego zawiera węzły, które pochodzą z różnych miejscach. Jednostki DTD są na przykład, ale nie jest ograniczone do elementów DTD. Podstawowy identyfikator URI informuje, skąd pochodzą te węzły. Jeśli nie istnieje żadne podstawowy identyfikator URI dla węzłów zwracanych (na przykład one zostały pochodzącą z analizy ciąg w pamięci), `String.Empty` jest zwracany.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono podstawowy identyfikator URI dla każdego z węzłów.  
  
 [!code-cpp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `baseuri.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.BaseURI Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public override bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Xml.XmlTextReader" /> implementuje metody odczytu zawartości binarnej.</summary>
        <value>
          <see langword="true" /> Jeśli binarne metody odczytu zawartości są wykonywane; w przeciwnym razie <see langword="false" />. <see cref="T:System.Xml.XmlTextReader" /> Klasy zawsze zwraca <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Zawartość binarną do odczytu metod uwzględnić <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlTextReader.ReadElementContentAsBase64%2A>, i <xref:System.Xml.XmlTextReader.ReadElementContentAsBinHex%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public override bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Xml.XmlTextReader" /> implementuje <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> metody.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xml.XmlTextReader" /> implementuje <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> metody; w przeciwnym razie <see langword="false" />. <see cref="T:System.Xml.XmlTextReader" /> Klasy zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 <xref:System.Xml.XmlTextReader> Zgłasza <xref:System.NotSupportedException> Jeśli <xref:System.Xml.XmlReader.ReadValueChunk%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public override bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten czytnik można przeanalizować i rozwiązać jednostek.</summary>
        <value>
          <see langword="true" /> Jeśli czytnik można przeanalizować i rozwiązać jednostek; w przeciwnym razie <see langword="false" />. <see langword="XmlTextReader" /> Klasy zawsze zwraca <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Jest to zmiana w [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] wersji. W poprzednich wersjach `XmlTextReader` klasy nie można rozpoznać jednostki i `CanResolveEntity` zawsze zwracana `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmiany <see cref="P:System.Xml.XmlReader.ReadState" /> do <see langword="Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda również zwalnia wszystkie zasoby utrzymywane podczas odczytu. Jeśli ten czytnik został skonstruowany przy użyciu strumienia, ta metoda wywołuje również `Close` w strumieniu podstawowym.  
  
 Jeśli `Close` została już wywołana, jest wykonywana żadna akcja.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera głębokość bieżącego węzła w dokumencie XML.</summary>
        <value>Głębokość bieżącego węzła w dokumencie XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdego węzła w tym jego głębokość, numer wiersza i pozycji.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Xml.DtdProcessing" /> wyliczenia.</summary>
        <value>
          <see cref="T:System.Xml.DtdProcessing" /> Wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.DtdProcessing> Zawiera wyliczenie <xref:System.Xml.DtdProcessing.Prohibit>, <xref:System.Xml.DtdProcessing.Ignore>, i <xref:System.Xml.DtdProcessing.Parse> wyliczenia. <xref:System.Xml.DtdProcessing.Parse> jest to zachowanie domyślne. <xref:System.Xml.XmlTextReader.DtdProcessing%2A> Zamienia właściwość `ProhibitDTD` właściwości i dodaje funkcję ignorowania DOCTYPE element.  
  
> [!IMPORTANT]
>  Jeśli <xref:System.Xml.XmlTextReader.DtdProcessing%2A> właściwość jest ustawiona na <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>, <xref:System.Xml.XmlTextReader> ani zgłaszać elementów DTD. Oznacza to, że DTD/DOCTYPE zostaną utracone na dane wyjściowe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowania dokumentu.</summary>
        <value>Wartość kodowania. Jeśli istnieje bez atrybutu kodowania i nie jest kolejności bajtów, to domyślnie UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ponieważ <xref:System.Xml.XmlTextReader> używa <xref:System.Text.Encoding?displayProperty=nameWithType> klasy `XmlTextReader` obsługuje również wszystkie rodzaje kodowania obsługiwane przez tę klasę. Wyjątkiem jest kodowanie, takich jak UTF-7 lub EBCDIC, która mapuje `<?xml` sekwencji do wartości innej niż UTF-8.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityHandling">
      <MemberSignature Language="C#" Value="public System.Xml.EntityHandling EntityHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.EntityHandling EntityHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EntityHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityHandling As EntityHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::EntityHandling EntityHandling { System::Xml::EntityHandling get(); void set(System::Xml::EntityHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.EntityHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, jak czytnik obsługuje jednostki.</summary>
        <value>Jeden z <see cref="T:System.Xml.EntityHandling" /> wartości. Jeśli nie <see langword="EntityHandling" /> jest określony, domyślnie <see langword="EntityHandling.ExpandCharEntities" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość może zostać zmieniona na bieżąco i ma wpływ po następnej <xref:System.Xml.XmlTextReader.Read%2A> wywołania.  
  
 Gdy `EntityHandling` ma ustawioną wartość `ExpandCharEntities`, wartości atrybutów są tylko częściowo znormalizowany. Czytnik normalizuje każdy węzeł tekstowy poszczególnych niezależnie od zawartości węzłów odwołanie do jednostki sąsiadujących ze sobą.  
  
 Aby zilustrować różnica między jednostki tryby obsługi należy wziąć pod uwagę następujące XML:  
  
```  
<!DOCTYPE doc [<!ENTITY num "123">]>  
    <doc> &#65; &num; </doc>  
```  
  
 Gdy `EntityHandling` ustawiono `ExpandEntities` węzeł elementu "doc" zawiera jeden węzeł tekstowy tekstem jednostki rozszerzonej:  
  
|Głębokość|Typ węzła|Nazwa|Wartość|  
|-----------|---------------|----------|-----------|  
|1|`Text`||A 123|  
  
 Gdy `EntityHandling` ustawiono `ExpandCharEntites`, i <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A> ma ustawioną wartość `Significant` lub `All`, element "doc" rozszerza jednostki znaku i zwraca obiekt ogólne jako węzeł:  
  
|Głębokość|Typ węzła|Nazwa|Wartość|  
|-----------|---------------|----------|-----------|  
|1|`Text`||ELEMENT|  
|1|`EntityReference`|NUM||  
|1|`SignificantWhitespace`|||  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public override bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EOF { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy czytnik znajduje się pod koniec strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli czytnik znajduje się na końcu strumienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu. Jest to indeks zaczynający się od zera. (Pierwszy atrybut ma indeks 0).</param>
        <summary>Pobiera wartość atrybutu z określonym indeksem.</summary>
        <returns>Wartość określonego atrybutu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda nie powoduje przeniesienia czytnika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> Parametru jest mniejszy niż 0 lub większą lub równą <see cref="P:System.Xml.XmlTextReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>Pobiera wartość atrybutu o określonej nazwie.</summary>
        <returns>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda nie powoduje przeniesienia czytnika.  
  
 Jeśli czytnik jest ustawiony na `DocumentType` węzła, ta metoda służy do pobrania publicznego i systemu literały, na przykład `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu ISBN.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `attrs.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.GetAttribute1 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>Pobiera wartość atrybutu o określonej nazwie lokalnych i identyfikator URI przestrzeni nazw.</summary>
        <returns>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracany. Ta metoda nie powoduje przeniesienia czytnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Następujący kod XML zawiera atrybut w określonej przestrzeni nazw:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Można wyszukać `dt:type` atrybutu przy użyciu jednego argumentu (prefiks i nazwa lokalna) lub dwóch argumentów (lokalna nazwa i identyfikator URI przestrzeni nazw):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Do wyszukiwania `xmlns:dt` atrybutu, użyj jednej z następujących argumentów:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Można także uzyskać te informacje przy użyciu <xref:System.Xml.XmlTextReader.Prefix%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetNamespacesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GetNamespacesInScope(System::Xml::XmlNamespaceScope scope);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">
          <see cref="T:System.Xml.XmlNamespaceScope" /> Wartość, która określa typ węzłów przestrzeni nazw do zwrócenia.</param>
        <summary>Pobiera kolekcję, która zawiera wszystkie przestrzenie nazw obecnie w zakresie.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" /> Obiekt, który zawiera wszystkie bieżące w zakresie przestrzeni nazw. Jeśli czytnik nie jest umieszczony w elemencie, zwracany jest pusty słownik (nie przestrzeni nazw).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Słownik składa się z kolekcji z kluczami według prefiksu nazwy przestrzeni nazw. Może służyć do wyliczenia w zakresie przestrzeni nazw. Słownik jest odłączony kopię listy nazw czytnika. Pozostaje niezmieniony czytnika pozycji, bieżącą listę w zakresie przestrzeni nazw, zmiany.  
  
 W poniższej tabeli opisano sposób <xref:System.Xml.XmlNamespaceScope> wpływa na wartość wyliczenia czy lub nie domyślne i wbudowane przestrzenie nazw są zwracane przez <xref:System.Xml.XmlTextReader.GetNamespacesInScope%2A>.  
  
|Wartość XmlNamespaceScope|xmlns:xml|xmlns:xmlns|xmlns=""|  
|-----------------------------|---------------|-----------------|---------------|  
|`All`|Tak|Brak|Brak|  
|`ExcludeXml`|Brak|Brak|Brak|  
|`Local`|Brak|Brak|Tak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetRemainder">
      <MemberSignature Language="C#" Value="public System.IO.TextReader GetRemainder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.TextReader GetRemainder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetRemainder" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRemainder () As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::TextReader ^ GetRemainder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pozostałej części buforowanego XML.</summary>
        <returns>A <see cref="T:System.IO.TextReader" /> zawierającego pozostałej części buforowanego XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ponieważ <xref:System.Xml.XmlTextReader> jest buforowany `Read`, musi być może zwrócić w pozostałej części nieużywane buforu, tak aby nie zostały utracone żadne dane. Dzięki temu protokołów (na przykład wieloczęściowej MIME) pakietu kodu XML w strumieniu jako inne czynności.  
  
 Po wywołaniu tej metody <xref:System.Xml.XmlTextReader.EOF%2A> ma ustawioną wartość `true`.  
  
   
  
## Examples  
 Poniższy przykład odczytuje pierwszej części dokumentu XML, a następnie używa `GetRemainder` przeprowadzenie odczytywanie dokumentu przy użyciu drugiego czytnika.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku wejściowego `tworeads.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.GetRemainder Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasLineInfo">
      <MemberSignature Language="C#" Value="public bool HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function HasLineInfo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasLineInfo();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klasa może zwrócić informacji wiersza.</summary>
        <returns>
          <see langword="true" /> Jeśli klasa może zwrócić informacji wiersza. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public override bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł może mieć <see cref="P:System.Xml.XmlTextReader.Value" /> innych niż <see langword="String.Empty" />.</summary>
        <value>
          <see langword="true" /> Jeśli węzeł, na którym aktualnie znajduje się czytnik może mieć <see langword="Value" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 W poniższej tabeli wymieniono typy węzłów, które mają wartość do zwrócenia.  
  
|Typ węzła|Wartość|  
|---------------|-----------|  
|`Attribute`|Wartość atrybutu.|  
|`CDATA`|Zawartość sekcji CDATA.|  
|`Comment`|Zawartość komentarza.|  
|`DocumentType`|Podzestawie wewnętrznym.|  
|`ProcessingInstruction`|Całej zawartości, z wyłączeniem obiektu docelowego.|  
|`SignificantWhitespace`|Biały znak między znaczników w mieszanych modelu zawartości.|  
|`Text`|Zawartości węzła tekstowego.|  
|`Whitespace`|Biały znak między znaczników.|  
|`XmlDeclaration`|Zawartość deklaracji.|  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wartości dla każdego węzła, który może mieć wartości.  
  
 [!code-cpp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `book1.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.HasValue Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public override bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł jest atrybut, który został wygenerowany na podstawie wartości domyślnej zdefiniowanej w definicji DTD lub schemat.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />. (<see cref="T:System.Xml.XmlTextReader" /> nie zwiększa atrybutów domyślnych.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość jest stosowana tylko do atrybutu węzłów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public override bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmptyElement { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł jest elementem pustym (na przykład <c> &lt;MyElement /&gt;</c>).</summary>
        <value>
          <see langword="true" /> Jeśli bieżący węzeł jest elementem (<see cref="P:System.Xml.XmlTextReader.NodeType" /> jest równe <see langword="XmlNodeType.Element" />) który kończy się wyrazem <c> / &gt; </c>; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość umożliwia określenie różnica między następującymi:  
  
 `<item num="123"/>` (`IsEmptyElement` jest `true`).  
  
 `<item num="123">` (`IsEmptyElement` jest `false`, mimo że zawartość elementu jest pusta).  
  
 Odpowiadającego `EndElement` węzła nie jest generowane dla elementów pustych.  
  
 `IsEmptyElement` po prostu raporty, czy tag końcowy element ma element w dokumencie źródłowym.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element zawartości tekstowej.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `elems.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumber { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LineNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący numer wiersza.</summary>
        <value>Numer bieżącego wiersza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość jest najczęściej używana do raportowania błędów, ale można wywołać w dowolnej chwili. Początkowa wartość dla tej właściwości jest `1`.  
  
 Połączone z <xref:System.Xml.XmlTextReader.LinePosition%2A>, wartość `1,1` wskazuje początek dokumentu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdego węzła w tym jego głębokość, numer wiersza i pozycji.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LinePosition">
      <MemberSignature Language="C#" Value="public int LinePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePosition" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LinePosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LinePosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePosition { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LinePosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą pozycję w linii.</summary>
        <value>Bieżąca pozycja wiersza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość jest najczęściej używana do raportowania błędów, ale można wywołać w dowolnej chwili. Początkowa wartość właściwości jest `1`.  
  
 Pozycji to pierwszy znak tekstu w znaczniku.  
  
```  
<root>  
abc<tag/>  
</root>  
```  
  
 W pierwszym wierszu tekstu XML `LinePosition` z `2` odpowiada znak `r`; w drugim wierszu `LinePosition` z `5` odpowiada znak `t`; i na trzeci wiersz `LinePosition` z `3` odpowiada znak `r`.  
  
 Połączone z <xref:System.Xml.XmlTextReader.LineNumber%2A>, wartość `1,1` wskazuje początek dokumentu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdego węzła w tym jego głębokość, numer wiersza i pozycji.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę lokalnego bieżącego węzła.</summary>
        <value>Nazwa bieżącego węzła z prefiksem usunięte. Na przykład <see langword="LocalName" /> jest <see langword="book" /> dla elementu <c> &lt;bk:book&gt;</c>.  
  
 Dla typów węzłów, które nie mają nazwę (takich jak <see langword="Text" />, <see langword="Comment" />i tak dalej), ta właściwość zwraca <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono lokalna nazwa każdego węzła i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `book2.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public override string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks, którego identyfikator URI przestrzeni nazw ma zostać rozwiązany. Aby dopasować domyślnej przestrzeni nazw, należy przekazać pusty ciąg. Ten ciąg ma być atomized.</param>
        <summary>Usuwa prefiks przestrzeni nazw w zakresie bieżącego elementu.</summary>
        <returns>Identyfikator URI przestrzeni nazw, do którego mapuje prefiks lub <see langword="null" /> przypadku nieznalezienia nie zgodny prefiks.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 W poniższych XML, jeśli czytnik jest ustawiony na `href` atrybutu prefiks `a` został rozwiązany przez wywołanie metody `reader.LookupNamespace("a")`. Zwrócony ciąg jest `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
 <item>  
 <ref href="a:b"/>  
 </item>  
</root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Xml.XmlTextReader.Namespaces" /> Właściwość jest ustawiona na <see langword="true" /> i <paramref name="prefix" /> wartość jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przenosi do określonego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void MoveToAttribute(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu.</param>
        <summary>Przenosi do atrybutu o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> Parametru jest mniejszy niż 0 lub większą lub równą <see cref="P:System.Xml.XmlReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>Przenosi do atrybut o określonej nazwie.</summary>
        <returns>
          <see langword="true" /> Jeśli ten atrybut zostanie odnaleziony; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, pozycja czytnika nie ulega zmianie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Po wywołaniu `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, i <xref:System.Xml.XmlTextReader.Prefix%2A> właściwości odzwierciedla właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>Przenosi do atrybut o określonej nazwie lokalnych i identyfikator URI przestrzeni nazw.</summary>
        <returns>
          <see langword="true" /> Jeśli ten atrybut zostanie odnaleziony; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, pozycja czytnika nie ulega zmianie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Po wywołaniu `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, i <xref:System.Xml.XmlTextReader.Prefix%2A> właściwości odzwierciedla właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public override bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi element, który zawiera bieżący węzeł atrybutów.</summary>
        <returns>
          <see langword="true" /> Jeśli czytnik jest ustawiony na atrybut (czytnik jest przenoszony do elementu, który jest właścicielem atrybut); <see langword="false" /> Jeśli czytnik nie jest ustawiony na atrybut (pozycja czytnik nie ulega zmianie).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Użyj tej metody, aby powrócić do elementu po nawigować przez jego atrybuty. Ta metoda przenosi czytnik do jednego z następujących typów węzła: `Element`, `DocumentType`, lub `XmlDeclaration`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToFirstAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do pierwszego atrybutu.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje atrybut (czytnik przenosi do pierwszego atrybutu); w przeciwnym razie <see langword="false" /> (pozycja czytnik nie ulega zmianie).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu pierwszego węzła głównego.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `attrs.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.MoveToFirstAttribute Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToNextAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnego atrybutu.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje atrybut dalej; <see langword="false" /> nie więcej atrybutach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Jeśli bieżący węzeł jest węzłem elementu, ta metoda jest odpowiednikiem <xref:System.Xml.XmlTextReader.MoveToFirstAttribute%2A>. Jeśli `MoveToNextAttribute` zwraca `true`, czytnik przechodzi do następnego atrybutu; w przeciwnym razie pozycja czytnik nie ulega zmianie.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-cpp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną nazwę bieżącego węzła.</summary>
        <value>Kwalifikowana nazwa bieżącego węzła. Na przykład <see langword="Name" /> jest <see langword="bk:book" /> dla elementu <c> &lt;bk:book&gt;</c>.  
  
 Nazwa zwrócona jest zależna od <see cref="P:System.Xml.XmlTextReader.NodeType" /> węzła. Następujące typy węzłów zwracać wartości listy. Wszystkie inne typy węzła zwraca pusty ciąg.  
  
 <list type="table"><listheader><term> Typ węzła  
  
 </term><description> Nazwa  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description> Nazwa atrybutu.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Nazwa typu dokumentu.  
  
 </description></item><item><term><see langword="Element" /></term><description> Nazwa tagu.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Nazwa odwołania do jednostki.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Elementem docelowym instrukcji przetwarzania.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Literał <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Namespaces">
      <MemberSignature Language="C#" Value="public bool Namespaces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Namespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Namespaces" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Namespaces { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy w celu obsługi przestrzeni nazw.</summary>
        <value>
          <see langword="true" /> do obsługi przestrzeni nazw. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość określa, czy czytnik obsługuje przestrzeni nazw W3C w zalecenie XML znajduje się w www.w3.org/TR/REC-xml-names.  
  
 `Namespaces` Nie można ustawić właściwości, po zakończeniu operacji odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ustawienie tej właściwości po zakończeniu operacji odczytu (<see cref="P:System.Xml.XmlTextReader.ReadState" /> nie jest <see langword="ReadState.Initial" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public override string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI (zgodnie z definicją w specyfikacji Namespace W3C) węzła w przestrzeni nazw na znajduje się czytnika.</summary>
        <value>Przestrzeń nazw identyfikatora URI bieżącego węzła; w przeciwnym razie ciągiem pustym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość ma zastosowanie w przypadku `Element` i `Attribute` tylko węzłów.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono lokalna nazwa każdego węzła i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `book2.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlNameTable" /> skojarzone z tą implementacją.</summary>
        <value>
          <see langword="XmlNameTable" /> Dzięki któremu można pobrać wersję atomized ciągu w węźle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Wszystkie nazwy węzła i atrybut zwrócony z <xref:System.Xml.XmlTextReader> są atomized przy użyciu `NameTable`. Gdy takiej samej nazwie są zwracane wielokrotnie (na przykład `Customer`), następnie takie same `String` obiekt jest zwracany dla tej nazwy. Dzięki temu można napisać kod wydajne, który obiekt porównania na te ciągi, zamiast porównania ciągu kosztowne.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ bieżącego węzła.</summary>
        <value>Jeden z <see cref="T:System.Xml.XmlNodeType" /> wartości reprezentujący typ bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość nie zwraca następujące `XmlNodeType` typów: `Document`, `DocumentFragment`, `Entity`, `EndEntity`, lub `Notation`.  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Normalization">
      <MemberSignature Language="C#" Value="public bool Normalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Normalization" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Normalization" />
      <MemberSignature Language="VB.NET" Value="Public Property Normalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Normalization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do normalizacji biały znak i wartości atrybutów.</summary>
        <value>
          <see langword="true" /> do normalizacji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Tę właściwość można zmienić w dowolnym momencie i zostaną uwzględnione w następnej operacji odczytu.  
  
> [!NOTE]
>  Jeśli <xref:System.Xml.XmlTextReader> jest używany do tworzenia <xref:System.Xml.XmlValidatingReader>, do normalizacji wartości atrybutów `Normalization` musi mieć ustawioną `true`.  
  
 Jeśli `Normalization` ma ustawioną wartość `false`, to również wyłącza sprawdzanie dla jednostek liczbowego zakresu znaków. W związku z tym znak jednostek, takich jak `&#0;`, są dozwolone.  
  
 Poniżej opisano normalizacji wartość atrybutu:  
  
-   Odwołania do znaku Dołącz znak, do którego istnieje odwołanie do wartości atrybutu.  
  
-   Dla odwołania do jednostki rekursywnie przetworzyć tekst zastępczy jednostki.  
  
-   Znak odstępu (#x20, #xD, #xA, #x9) Dołącz #x20 na znormalizowaną wartość. (Tylko pojedynczy #x20 jest dołączany do sekwencję "#xD #xA", która jest częścią analizowanej jednostki zewnętrznej lub wartość literału jednostki wewnętrzny przeanalizowanej jednostki.)  
  
-   Przetwarzanie innych znaków przez dodanie ich do wartość znormalizowana.  
  
-   Jeśli zadeklarowanej nie jest CDATA, Odrzuć wszystkie wiodące i końcowe znaków spacji (#x20) i Zastąp sekwencje znaków spacji (#x20) znak pojedynczego spacji (#x20).  
  
 `XmlTextReader` Przeprowadza tylko operacje normalizacji CDATA lub atrybutu. Nie ma normalizacji specyficzne dla definicji DTD, chyba że zawinięty w `XmlValidatingReader`.  
  
 Zapoznaj się z zaleceniem W3C XML 1.0, aby zapoznać się przy normalizacji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia zachowanie czytnika przy normalizacji włączona, a następnie wyłączone.  
  
 [!code-cpp[XmlTextReader.Normalization#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Normalization/CPP/readnormal.cpp#1)]
 [!code-csharp[XmlTextReader.Normalization#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Normalization/CS/readnormal.cs#1)]
 [!code-vb[XmlTextReader.Normalization#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Normalization/VB/readnormal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ustawienie tej właściwości, gdy proces czytający jest zamykany (<see cref="P:System.Xml.XmlTextReader.ReadState" /> jest <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public override string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prefiks przestrzeni nazw skojarzone z bieżącego węzła.</summary>
        <value>Prefiks przestrzeni nazw skojarzone z bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono lokalna nazwa każdego węzła i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `book2.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zezwolić na przetwarzanie elementu DTD. Ta właściwość jest przestarzała. Zamiast nich należy używać słów kluczowych <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />.</summary>
        <value>
          <see langword="true" /> Aby uniemożliwić przetwarzanie elementu DTD; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Przetwarzanie elementu DTD jest domyślnie włączona dla zapewnienia zgodności. Jednak jeśli aplikacja wymaga przetwarzanie elementu DTD, należy wyłączyć to ustawienie. Wyłączanie DTD przetwarzania może być przydatne w celu zapobiegania niektórych "odmowa usługi". Jeśli ustawiono `true`, zgłasza czytnik <xref:System.Xml.XmlException> po napotkaniu żadnej zawartości DTD.  
  
 Jeśli przetwarzanie elementu DTD włączone, należy wiedzieć, w tym elementów DTD ze źródeł niezaufanych i możliwe "odmowa usługi". Użyj <xref:System.Xml.XmlSecureResolver> do ograniczania zasobów który <xref:System.Xml.XmlTextReader> może uzyskać dostęp. Można również projektować aplikacji, tak aby przetwarzania XML pamięci i ograniczonego czasu. Na przykład Konfigurowanie limitów czasu w aplikacji platformy ASP.NET  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public override char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera znak cudzysłowu ująć węzła atrybutu.</summary>
        <value>Znak cudzysłowu ("lub") używany do ująć węzła atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość jest stosowana tylko do węzła atrybutu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny węzeł ze strumienia.</summary>
        <returns>
          <see langword="true" /> Jeśli węzeł next został odczytany pomyślnie; <see langword="false" /> Jeśli nie ma żadnych więcej węzłów do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Czytnik jest najpierw utworzenia i zainicjowana, nie ma żadnych informacji dostępne. Należy wywołać `Read` odczytać pierwszy węzeł.  
  
 Ta metoda wymaga co najmniej cztery bajtów ze strumienia danych, aby rozpocząć analizy. Jeśli nie ma więcej danych w strumieniu zwracane są mniej niż cztery bajty, metoda zakończy się niepowodzeniem. Jeśli istnieje więcej danych w strumieniu, metoda będzie blokował analizowania aż do otrzymania czwarty bajt.  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdy węzeł.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania pliku XML.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public override bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ReadAttributeValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analizuje wartość atrybutu do co najmniej jeden <see langword="Text" />, <see langword="EntityReference" />, lub <see langword="EndEntity" /> węzłów.</summary>
        <returns>
          <see langword="true" /> Jeśli ma węzłów do zwrócenia.  
  
 <see langword="false" /> Czytnik nie jest ustawiony na węzła atrybutu po nawiązaniu połączenia początkowego lub wartości atrybutów zostały przeczytane.  
  
 Pusta atrybutów, takich jak <c>różne = ""</c>, zwraca <see langword="true" /> z jednego węzła przy użyciu wartości <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda po wywołaniu `MoveToAttribute` do przeczytania węzłów odwołania tekst lub jednostki, które składają się wartość atrybutu. <xref:System.Xml.XmlReader.Depth%2A> Węzłów wartość atrybutu jest jeden plus głębokość węzła atrybutu; powoduje zwiększenie i zmniejsza przez jeden po kroku do i z odwołań do jednostek ogólnych.  
  
   
  
## Examples  
 Poniższy przykład odczytuje atrybutu z węzłami tekstu i jednostek.  
  
 [!code-cpp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CPP/readattrval.cpp#1)]
 [!code-csharp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CS/readattrval.cs#1)]
 [!code-vb[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/VB/readattrval.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBase64">
      <MemberSignature Language="C#" Value="public int ReadBase64 (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBase64(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBase64 (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBase64(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica znaków, która pełni rolę bufora, do którego zawartość tekstową są zapisywane.</param>
        <param name="offset">Liczony od zera indeks w tablicy określającym, której metody można rozpocząć zapisać w buforze.</param>
        <param name="len">Liczba bajtów do zapisania w buforze.</param>
        <summary>Dekoduje Base64 i zwraca dekodowane binarne bajty.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Podobnie jak <xref:System.Xml.XmlTextReader.ReadChars%2A>, tę metodę można wywołać kolejno odczytać dużych strumieni osadzonych tekstu. Dekoduje zawartości Base64 i zwraca dekodowane bajty binarne (na przykład wbudowanego Base64 zakodowane obrazu GIF) w buforze. Zobacz dokument RFC 1521. (Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](https://www.rfc-editor.org).)  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik zawierający dane Base64 i BinHex.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 Przykład używa pliku `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Sekwencją Base64 nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> &lt; 0, lub <paramref name="len" /> &lt; 0, lub <paramref name="len" /> &gt; <paramref name="array" />. Długość - <paramref name="offset" />.</exception>
        <altmember cref="M:System.Xml.XmlTextWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBinHex">
      <MemberSignature Language="C#" Value="public int ReadBinHex (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBinHex(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBinHex (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBinHex(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica bajtów służącym jako buforu, do którego są zapisywane dekodowane binarne bajty.</param>
        <param name="offset">Liczony od zera indeks w tablicy określającym, której metody można rozpocząć zapisać w buforze.</param>
        <param name="len">Liczba bajtów do zapisania w buforze.</param>
        <summary>Dekoduje <see langword="BinHex" /> i zwraca dekodowane binarne bajty.</summary>
        <returns>Liczba bajtów zapisanych w buforze użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Podobnie jak <xref:System.Xml.XmlTextReader.ReadChars%2A>, tę metodę można wywołać kolejno odczytać dużych strumieni osadzonych tekstu. Dekoduje on `BinHex` zawartości i zwraca dekodowane bajty binarne (na przykład wbudowanego `BinHex` zakodowanego obrazu GIF) w buforze.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik zawierający `Base64` i `BinHex` danych.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 Przykład używa pliku `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <see langword="BinHex" /> Sekwencji jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> &lt; 0, lub <paramref name="len" /> &lt; 0, lub <paramref name="len" /> &gt; <paramref name="array" />. Długość - <paramref name="offset" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public int ReadChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChars (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która pełni rolę bufora, do którego zawartość tekstową są zapisywane.</param>
        <param name="index">Pozycja w <c>buforu</c> gdzie metody można rozpocząć pisanie zawartość tekstową.</param>
        <param name="count">Liczba znaków do zapisania w <c>buforu</c>.</param>
        <summary>Odczytuje zawartość tekst elementu w buforze znaków. Ta metoda jest przeznaczona do odczytu wywołując kolejno dużych strumieni osadzonych tekstu.</summary>
        <returns>Liczba znaków do odczytu. Może to być <see langword="0" /> Jeśli czytnik nie jest umieszczony w elemencie lub brak więcej zawartości tekstu do zwrócenia w bieżącym kontekście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Jest to najbardziej wydajny sposób przetwarzania bardzo dużych strumieni tekstu osadzony w dokumencie XML. Zamiast Alokacja obiektów dużych ciąg `ReadChars` zwraca bufora zawartości tekstowej w czasie. Ta metoda jest przeznaczona do pracy tylko w przypadku elementu węzłów. Inny węzeł typów Przyczyna `ReadChars` do zwrócenia `0`.  
  
 W poniższych XML, jeśli czytnik znajduje się w tagu początkowym `ReadChars` zwraca `test` i umieszcza czytnik po tagu końcowego.  
  
```xml  
<Item>test</Item>  
```  
  
 `ReadChars` udostępnia następujące funkcje:  
  
-   Ta metoda jest przeznaczona do pracy w tylko węzły elementów. Inny węzeł typów Przyczyna `ReadChars` do zwrócenia 0.  
  
-   Ta metoda zwraca znak, który faktycznie zawartości. Próba rozpoznania jednostek, CDATA lub innymi znacznikami napotkał nie istnieje. `ReadChars` Zwraca wszystkie elementy tagu początkowego tagu końcowego, w tym znaczników.  
  
-   `ReadChars` ignoruje znaczników XML, który nie jest poprawnie sformułowany. Na przykład podczas czytania następujący ciąg XML `<A>1<A>2</A>`, `ReadChars` zwraca `1<A>2</A>`. (Go zwraca kod znaczników z pasujących pary elementu i ignoruje innych użytkowników.)  
  
-   Ta metoda nie wszystkie normalizacji.  
  
-   Gdy `ReadChars` osiągnął koniec strumienia znaków, zwracana jest wartość 0 i czytnik jest ustawiana po tagu końcowego.  
  
-   Metody nie są dostępne podczas używania odczytać atrybutu `ReadChars`.  
  
 Na przykład przy użyciu następującego kodu XML:  
  
```xml  
<thing>  
 some text  
</thing>  
<item>  
</item>  
```  
  
 Czytnik jest ustawiony na `<item>` element w końcu while w pętli.  
  
```csharp  
if (XmlNodeType.Element == reader.NodeType && "thing" == reader.Name)  
{  
 while(0 != reader.ReadChars(buffer, 0, 1)  
 {  
 // Do something.  
 // Attribute values are not available at this point.  
 }  
}  
```  
  
   
  
## Examples  
 Poniższy przykład treści XML przy użyciu `ReadChars`.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/VB/source.vb#1)]  
  
 W przykładzie użyto `items.xml` pliku jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> jest większa niż określona w miejsce <paramref name="buffer" /> (rozmiar - buforu <paramref name="index" />).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />
          <see langword="&lt; 0" /> lub <paramref name="count" /><see langword="&lt; 0" />.</exception>
        <altmember cref="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca <see langword="Base64" /> zdekodować binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda prześle strumieniowo zawartość, dekoduje `Base64` zawartości i zwraca dekodowane bajty binarne (na przykład wbudowanego `Base64`-zakodowanego obrazu GIF) w buforze. Tę metodę można wywołać kolejno odczytać dużych strumieni osadzonych tekstu. Aby uzyskać więcej informacji, zobacz dokument RFC 1521, "części MIME (Multipurpose Internet Mail Extensions) co: mechanizmy określania i opisujące formatu treści wiadomości Internet". Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](https://www.rfc-editor.org).  
  
> [!NOTE]
>  Nie mają do żadnej właściwości czytnika między wywołań <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> metody do momentu metoda zwraca wartość 0.  
  
 Ta metoda ma następującą charakterystykę:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> Zwraca wartość 0, jeśli osiągnęła koniec strumienia bajtów, które zostało zasilany. Czytnik znajduje się na pierwszym węźle-content.  
  
-   Jeśli możesz poprosić o mniej lub liczbą bajtów niż pozostaną w strumieniu czytnik pozostaje w bieżącym położeniu.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> nie jest obsługiwane na następujących typach węzła XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> nie jest obsługiwany w bieżącym węźle.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca <see langword="BinHex" /> zdekodować binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda prześle strumieniowo zawartość, dekoduje `BinHex` zawartości i zwraca dekodowane bajty binarne (na przykład wbudowanego `BinHex` zakodowanego obrazu GIF) w buforze. Tę metodę można wywołać kolejno odczytać dużych strumieni osadzonych tekstu.  
  
> [!NOTE]
>  Nie mają do żadnej właściwości czytnika między wywołań <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> metody do momentu metoda zwraca wartość 0.  
  
 Ta metoda ma następującą charakterystykę:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> Zwraca wartość 0, jeśli osiągnęła koniec strumienia bajtów, które zostało zasilany. Czytnik znajduje się na pierwszym węźle-content.  
  
-   Jeśli możesz poprosić o mniej lub liczbą bajtów niż pozostaną w strumieniu czytnik pozostaje w bieżącym położeniu.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> nie jest obsługiwane na następujących typach węzła XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> nie jest obsługiwana w bieżącym węźle.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlTextReader" /> Implementacja nie obsługuje tej metody.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje element i dekoduje zawartości Base64.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda odczytuje zawartość elementu, dekoduje przy użyciu kodowania Base64 i zwraca dekodowane bajtów binarnych (na przykład wbudowanego Base64 zakodowane obrazu GIF) w buforze. Aby uzyskać więcej informacji, zobacz dokument RFC 1521, "części MIME (Multipurpose Internet Mail Extensions) co: mechanizmy określania i opisujące formatu treści wiadomości Internet". Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](https://www.rfc-editor.org).  
  
 Ta metoda może odczytywać tylko elementy zawartości prostej. Element może zawierać tekstu, biały znak, znaczący biały znak, sekcjach CDATA, komentarze i instrukcji przetwarzania. Może również zawierać odwołań do jednostek, które są automatycznie rozwinięte. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobny do <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> metody, ale można wywołać tylko dla typów węzeł elementu.  
  
 Jeśli `count` wartość jest większa niż liczba bajtów w dokumencie, lub jeśli jest taka sama liczba bajtów w dokumencie <xref:System.Xml.XmlTextReader> odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę bajtów do odczytu. Następne <xref:System.Xml.XmlTextReader> wywołanie metody zwraca zero i przenosi czytnik do następującego węzła <xref:System.Xml.XmlNodeType.EndElement>.  
  
 Jeśli należy wywołać <xref:System.Xml.XmlTextReader.Read%2A> przed całą zawartość elementu jest używany, czytnik może zachowywać się tak, jakby został wykorzystany pierwszy zawartości, a następnie <xref:System.Xml.XmlTextReader.Read%2A> wywołano metodę. Oznacza to, czy czytnik odczytuje cały tekst, dopóki nie napotkano end element. Następnie odczytuje węzła tagu końcowego, odczytuje następny węzeł i umieszcza się w węźle kolejnych dalej.  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A?displayProperty=nameWithType> na przykład za pomocą tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest węzłem elementu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlTextReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera zawartością mieszaną.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości na żądanego typu.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje element i dekoduje <see langword="BinHex" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda odczytuje zawartość elementu, za pomocą dekoduje `BinHex` kodowania i zwraca dekodowane bajty binarne (na przykład wbudowanego `BinHex` zakodowanego obrazu GIF) w buforze.  
  
 Ta metoda może odczytywać tylko elementy zawartości prostej. Element może zawierać tekstu, biały znak, znaczący biały znak, sekcjach CDATA, komentarze i instrukcji przetwarzania. Może również zawierać odwołań do jednostek, które są automatycznie rozwinięte. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobny do <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> metody, ale można wywołać tylko dla typów węzeł elementu.  
  
 Jeśli `count` wartość jest większa niż liczba bajtów w dokumencie, lub jeśli jest taka sama liczba bajtów w dokumencie <xref:System.Xml.XmlTextReader> odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę bajtów do odczytu. Następne <xref:System.Xml.XmlTextReader> wywołanie metody zwraca zero i przenosi czytnik do następującego węzła <xref:System.Xml.XmlNodeType.EndElement>.  
  
 Jeśli należy wywołać <xref:System.Xml.XmlTextReader.Read%2A> przed całą zawartość elementu jest używany, czytnik może zachowywać się tak, jakby został wykorzystany pierwszy zawartości, a następnie <xref:System.Xml.XmlTextReader.Read%2A> wywołano metodę. Oznacza to, czy czytnik odczytuje cały tekst, dopóki nie napotkano end element. Następnie odczytuje węzła tagu końcowego, odczytuje następny węzeł i umieszcza się w węźle kolejnych dalej.  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A?displayProperty=nameWithType> na przykład za pomocą tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest węzłem elementu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera zawartością mieszaną.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości na żądanego typu.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public override System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera stan czytnika danych.</summary>
        <value>Jeden z <see cref="T:System.Xml.ReadState" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public override string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość elementu lub węzłem tekstowym jako ciąg.</summary>
        <returns>Zawartość elementu lub tekstu węzła. To może być pustym ciągiem, jeśli czytnik jest ustawiony na inną niż element lub tekst węzła lub jeśli brak więcej zawartości tekstu do zwrócenia w bieżącym kontekście.  
  
 <see langword="Note:" /> Węzeł tekstowy może być elementu lub atrybutu węzeł tekstowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Jeśli znajduje się w elemencie `ReadString` łączy wszystkie tekstu, znaczący biały znak odstępu, i `CData` węzła sekcji typów ze sobą i zwraca połączone dane jako zawartość elementu. Zatrzymuje go po napotkaniu żadnych znaczników, w tym komentarzy i instrukcji przetwarzania. Może mieć to miejsce, w mieszanych modelu zawartości lub podczas odczytywania tagu końcowym elementu.  
  
 Jeśli znajduje się w węźle tekstu `ReadString` przeprowadza tego samego łączenia z węzła tekstowego do tagu końcowym elementu. Jeśli czytnik jest ustawiony na węzeł tekstowy atrybut `ReadString` ma taką samą funkcję jak czytnik gdyby pozycji w tagu początkowym elementu. Zwraca element połączonych węzły tekstowe.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element zawartości tekstowej.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `elems.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania pliku XML.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę nieprawidłowej operacji.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public void ResetState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResetState" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje stan czytnika danych ReadState.Initial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta metoda umożliwia przeanalizować wielu dokumentów XML w jednego strumienia. Po osiągnięciu koniec dokumentu XML można wywołać `ResetState` Resetowanie stanu czytnika danych w ramach przygotowania do następnego dokumentu XML.  
  
> [!IMPORTANT]
>  Dokumenty w strumieniu muszą współużytkować tego samego kodu. Jeśli to nie jest to, gdy `ResetState` jest nazywany <xref:System.Xml.XmlException> jest generowany. (Jest to zmiana w porównaniu z .NET Framework w wersji 1.1 i starszych).  
  
 Nie dotyczy następujących właściwości `ResetState`.  
  
-   <xref:System.Xml.XmlTextReader.Normalization%2A>  
  
-   <xref:System.Xml.XmlTextReader.Namespaces%2A>  
  
-   <xref:System.Xml.XmlTextReader.XmlResolver%2A>  
  
-   <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A>  
  
   
  
## Examples  
 Poniższy przykład analizuje dwa dokumenty XML w jednego strumienia.  
  
 [!code-cpp[XmlTextReader.ResetState#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ResetState/CPP/resetstate.cpp#1)]
 [!code-csharp[XmlTextReader.ResetState#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ResetState/CS/resetstate.cs#1)]
 [!code-vb[XmlTextReader.ResetState#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ResetState/VB/resetstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywoływanie <see langword="ResetState" /> Jeśli czytnik został skonstruowany przy użyciu <see cref="T:System.Xml.XmlParserContext" />.</exception>
        <exception cref="T:System.Xml.XmlException">Dokumenty w jednego strumienia nie współużytkują tego samego kodu.</exception>
        <altmember cref="T:System.Xml.ReadState" />
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public override void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResolveEntity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa odwołanie do jednostki dla <see langword="EntityReference" /> węzłów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Jeśli czytnik jest ustawiony na `EntityReference` węzła (`XmlNodeType.EntityReference`), jeśli <xref:System.Xml.XmlTextReader.Read%2A> jest wywoływana po wywołaniu tej metody, tekst zastępczy jednostki zostanie przeanalizowany. Po zakończeniu operacji tekst zastępczy jednostki `EndEntity` węzła jest zwracana do zamknięcia zakresu odwołanie do jednostki.  
  
> [!NOTE]
>  Po wywołaniu tej metody, jeśli jednostka jest częścią wartości atrybutu należy wywołać <xref:System.Xml.XmlTextReader.ReadAttributeValue%2A> do kroku do jednostki.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public override void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Skip();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pomija elementy podrzędne bieżącego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 W poniższych XML wejściowych, jeśli czytnik jest ustawiony na `<a>` węzła lub dowolny z jego atrybuty wywoływania `Skip` umieszcza czytelnika `<b>` węzła.  
  
 Jeśli czytnik jest już ustawiony na węzeł liścia (takich jak `<x>` węzła lub węzeł tekstowy `abc`), wywoływania `Skip` jest taka sama jak wywołanie <xref:System.Xml.XmlTextReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
  <x/>abc<y/>  
</a>  
<b>  
 ...  
</b>  
```  
  
 Ta metoda sprawdza, czy poprawnie sformułowany plik XML.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.GetNamespacesInScope">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IDictionary&lt;string,string&gt; IXmlNamespaceResolver.GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String) Implements IXmlNamespaceResolver.GetNamespacesInScope" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System::Xml::XmlNamespaceScope scope) = System::Xml::IXmlNamespaceResolver::GetNamespacesInScope;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">
          <see cref="T:System.Xml.XmlNamespaceScope" /> Wartość, która określa typ węzłów przestrzeni nazw do zwrócenia.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" /> Zawierający bieżącej przestrzeni nazw w zakresie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Xml.XmlTextReader> wystąpienia jest rzutowane na <xref:System.Xml.IXmlNamespaceResolver> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupNamespace">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupNamespace (prefix As String) As String Implements IXmlNamespaceResolver.LookupNamespace" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupNamespace(System::String ^ prefix) = System::Xml::IXmlNamespaceResolver::LookupNamespace;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks, którego identyfikator URI przestrzeni nazw chcesz odnaleźć.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)" />.</summary>
        <returns>Przestrzeń nazw identyfikatora URI, który jest zamapowany na prefiksie; <see langword="null" /> , jeśli prefiks nie jest mapowane na identyfikator URI przestrzeni nazw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Xml.XmlTextReader> wystąpienia jest rzutowane na <xref:System.Xml.IXmlNamespaceResolver> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupPrefix">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupPrefix (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupPrefix (namespaceName As String) As String Implements IXmlNamespaceResolver.LookupPrefix" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupPrefix(System::String ^ namespaceName) = System::Xml::IXmlNamespaceResolver::LookupPrefix;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceName">Prefiks, którego chcesz znaleźć identyfikator URI przestrzeni nazw.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)" />.</summary>
        <returns>Prefiks, który jest mapowany na przestrzeń nazw identyfikatora URI; <see langword="null" /> Jeśli identyfikator URI przestrzeni nazw nie jest zamapowana na prefiks.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public override string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartości tekstowej bieżącego węzła.</summary>
        <value>Wartość zwracana jest zależna od <see cref="P:System.Xml.XmlTextReader.NodeType" /> węzła. W poniższej tabeli wymieniono typy węzłów, które mają wartość do zwrócenia. Zwracane typy inny węzeł <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Typ węzła  
  
 </term><description> Wartość  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description> Wartość atrybutu.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Zawartość sekcji CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Zawartość komentarza.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Podzestawie wewnętrznym.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Całej zawartości, z wyłączeniem obiektu docelowego.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Biały znak w ciągu <see langword="xml:space" />= "preserve" zakresu.  
  
 </description></item><item><term><see langword="Text" /></term><description> Zawartości węzła tekstowego.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Biały znak między znaczników.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Zawartość deklaracji.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdy węzeł.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 Przykład używa pliku `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="WhitespaceHandling">
      <MemberSignature Language="C#" Value="public System.Xml.WhitespaceHandling WhitespaceHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WhitespaceHandling WhitespaceHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property WhitespaceHandling As WhitespaceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::WhitespaceHandling WhitespaceHandling { System::Xml::WhitespaceHandling get(); void set(System::Xml::WhitespaceHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WhitespaceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą sposób obsługi biały znak.</summary>
        <value>Jeden z <see cref="T:System.Xml.WhitespaceHandling" /> wartości. Wartość domyślna to <see langword="WhitespaceHandling.All" /> (zwraca <see langword="Whitespace" /> i <see langword="SignificantWhitespace" /> węzłach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Tę właściwość można zmienić w dowolnym momencie i zostaną uwzględnione w następnej operacji odczytu.  
  
 Ponieważ `XmlTextReader` nie ma definicji DTD informacje są dostępne, `SignificantWhitepsace` zwracane są tylko węzły w `xml:space='preserve'` zakresu.  
  
   
  
## Examples  
 Poniższy przykład odczytuje XML fragment.  
  
 [!code-cpp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określono nieprawidłową wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Ustawienie tej właściwości, gdy proces czytający jest zamykany (<see cref="P:System.Xml.XmlTextReader.ReadState" /> jest <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see langword="xml:lang" /> zakresu.</summary>
        <value>Bieżący <see langword="xml:lang" /> zakresu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Ta właściwość reprezentuje `xml:lang` zakres, w którym znajduje się bieżącego węzła. Na przykład poniżej przedstawiono fragment XML z `xml:lang` ustawiony na US English w elemencie głównym:  
  
 \<główny XML: lang = "en-us" >  
  
 \<nazwa > Krzysztof \< /name >  
  
 \</ root >  
  
 Gdy czytnik jest ustawiony na `name` elementu, można użyć tej właściwości można znaleźć się w zakresie US English `xml:lang` atrybutu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono `xml:lang` wartość dla każdego z węzłów.  
  
 [!code-cpp[XmlTextReader.XmlLang#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlLang/CPP/readlang.cpp#1)]
 [!code-csharp[XmlTextReader.XmlLang#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlLang/CS/readlang.cs#1)]
 [!code-vb[XmlTextReader.XmlLang#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlLang/VB/readlang.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia <see cref="T:System.Xml.XmlResolver" /> używany do rozpoznawania odwołań DTD.</summary>
        <value>
          <see langword="XmlResolver" /> Do użycia. Jeśli ustawiono <see langword="null" />, zasobów zewnętrznych nie są rozpoznawane.  
  
 W wersji 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], wywołujący musi być w pełni zaufany, aby określić <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
 Czytnik używa `XmlResolver` rozwiązania lokalizacji pliku załadowane do czytnika i rozpoznać odwołań do definicji DTD. Na przykład, jeśli dane XML zawarte deklaracji DOCTYPE `<!DOCTYPE book SYSTEM book.dtd>` czytnik rozpoznaje tego pliku i zapewnia, że element DTD jest poprawnie sformułowany. Czytnik nie używa element DTD do weryfikacji.  
  
 Tę właściwość można zmienić w dowolnym momencie i zostaną uwzględnione w następnej operacji odczytu. Jeśli ta właściwość jest ustawiona na `null`, DTD odwołań zewnętrznych napotykane przez czytnik nie są rozpoznawane.  
  
 W wersji 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], jeśli ta właściwość nie jest ustawiona, poziom zaufania aplikacji określa zachowanie domyślne.  
  
 `Fully trusted code:` Czytnik używa domyślnego <xref:System.Xml.XmlUrlResolver> bez poświadczeń użytkownika. Jeśli wymagane jest uwierzytelnienie dostępu do zasobu sieciowego, użyj `XmlResolver` właściwości w celu określenia `XmlResolver` niezbędne poświadczenia.  
  
 `Semi-trusted code:` `XmlResolver` Właściwość jest ustawiona na `null`. Nie można rozpoznać zasobów zewnętrznych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `XmlResolver` właściwość, aby określić poświadczenia niezbędne do dostępu do sieci pliku.  
  
 [!code-cpp[XmlTextReader.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlResolver/CPP/rdr_resolver.cpp#1)]
 [!code-csharp[XmlTextReader.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlResolver/CS/rdr_resolver.cs#1)]
 [!code-vb[XmlTextReader.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlResolver/VB/rdr_resolver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see langword="xml:space" /> zakresu.</summary>
        <value>Jeden z <see cref="T:System.Xml.XmlSpace" /> wartości. Jeśli nie <see langword="xml:space" /> zakresu istnieje, ta właściwość jest równa <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> metodę, aby móc korzystać z nowych funkcji.  
  
   
  
## Examples  
 W poniższym przykładzie analizy pliku oraz zwraca znaczący biały znak, jeśli `xml:space='preserve'` znaleźć zakresu.  
  
 [!code-cpp[XmlTextReader.XmlSpace#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlSpace/CPP/readspace.cpp#1)]
 [!code-csharp[XmlTextReader.XmlSpace#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlSpace/CS/readspace.cs#1)]
 [!code-vb[XmlTextReader.XmlSpace#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlSpace/VB/readspace.vb#1)]  
  
 W przykładzie użyto pliku `authors.xml`, jak wejściowego.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
  </Members>
</Type>
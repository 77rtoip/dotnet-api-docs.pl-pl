<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="26034cdebb82d836299773cc3636436edaa5198c" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298963" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDocument&#xA;Inherits XmlNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDocument : System::Xml::XmlNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje dokumentu XML. Ta klasa służy do ładowania, sprawdzanie poprawności, edytować, Dodaj i umieść w dokumencie XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a> <xref:System.Xml.XmlDocument> Klasa znajduje się w pamięci reprezentację dokumentu XML. Implementuje W3C [XML modelu DOM (Document Object)](~/docs/standard/data/xml/xml-document-object-model-dom.md) poziom 1 Core i Core DOM poziomu 2.  
  
 *DOM* oznacza *modelu obiektu dokumentu*. Aby uzyskać więcej informacji na temat, zobacz [XML modelu DOM (Document Object)](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 XML można załadować do modelu DOM, za pomocą <xref:System.Xml.XmlDocument> klasy, a następnie programowo odczytu, modyfikowania i usuwania XML w dokumencie.  
  
 Jeśli chcesz pry Otwórz <xref:System.Xml.XmlDocument> i zobacz, jak jest implementowane, zobacz [źródło odwołania](https://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Zadania  
  
-   [Ładowanie do modelu obiektu dokumentu XML](#Load)  
  
-   [Sprawdzić jego poprawność schematu](#Validation)  
  
-   [Przejdź w drzewie dokumentu](#Navigate)  
  
-   [Znajdź węzłów](#Find)  
  
-   [Edytuj węzły](#Edit)  
  
-   [Dodaj węzły](#Add)  
  
-   [Usuń węzły](#Remove)  
  
-   [Pozycja węzłów](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Ładowanie do modelu obiektu dokumentu XML  
 Rozpoczynać dokument XML, takiego jak to. Jest kilka książek w kolekcji. Ale zawiera podstawowe elementy znajdował się w dokumentach XML; przestrzeń nazw, elementy, które zawierają dane i atrybuty, które opisują dane.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 Następnie załaduj te dane do modelu DOM, dzięki czemu można pracować z nim w pamięci. Najbardziej popularnym sposobem na to jest odwoływać się do pliku na komputerze lokalnym lub w sieci.  
  
 W tym przykładzie ładuje XML z pliku. Jeśli plik nie istnieje, po prostu generuje niektórych XML i który ładuje.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [odczytywanie dokumentu XML do modelu DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Sprawdzić jego poprawność schematu  
 Rozpocznij od schematu XML, takich jak ta. Ten schemat definiuje typów danych w pliku XML i atrybutów, które są wymagane.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Utwórz <xref:System.Xml.XmlReader> obiekt przy użyciu schematu, a następnie załadować tego obiektu do modelu DOM. Tworzenie obsługi zdarzeń, który wykonuje się, gdy kod próbuje zmodyfikować pliku XML w sposób, który narusza zasady schematu.  
  
 Te bloki kodu pokazują metody pomocnicze, które wykonują wszystkie te.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [sprawdzania poprawności dokumentu XML w modelu DOM](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Przejdź w drzewie dokumentu  
 Właściwości umożliwia nawigowanie po dokumentu XML. Jednak przed skorzystaniem z nich umożliwia szybkie przeglądanie kilka warunków. Dokument składa się z węzłów. Każdy węzeł ma jako pojedynczej *nadrzędnej* węzła bezpośrednio nad nim. Tylko węzeł, który nie ma węzła nadrzędnego jest głównego dokumentu, ponieważ jest on węzłem najwyższego poziomu. Większość węzłów może mieć *podrzędnych* węzły, które są węzłami bezpośrednio pod nimi. Węzły, które są na tym samym poziomie są *elementów równorzędnych*.  
  
 Poniższe przykłady przedstawiają metody uzyskania węzła głównego, przejście do pierwszego węzła podrzędnego węzła głównego, uzyskać dostępu do żadnego z jego węzłów podrzędnych, wrócić do węzła nadrzędnego, a następnie przejdź między węzłami tego samego poziomu.  
  
 **Rozpoczynać się od węzła głównego.**  
  
 W tym przykładzie pobiera węzła głównego, a następnie używa tego węzła do wyjściowego zawartość dokumentu do konsoli.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Pobierz węzłów podrzędnych**  
  
 W tym przykładzie przechodzi do pierwszy węzeł podrzędny węzła głównego i następnie iterację w węzłach podrzędnych tego węzła, jeśli takie istnieją.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Powrócić do węzła nadrzędnego**  
  
 Użyj <xref:System.Xml.XmlDocument.ParentNode%2A> właściwości.  
  
 **Odwołuje się do ostatniego węzła podrzędnego**  
  
 W tym przykładzie zapisuje ceny książki do konsoli (która jest ostatni węzeł podrzędny węzła książki).  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Przejdź do przodu, w tym samym poziomie**  
  
 W tym przykładzie przenosi do przodu książki książki. Podręcznik węzły są ze sobą na tym samym poziomie.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Przejdź wstecz dla elementów równorzędnych**  
  
 W tym przykładzie Przechodzi wstecz od książki do książki.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Znajdź węzłów  
 Najbardziej popularnym sposobem sprawdzenia co najmniej jeden węzeł danych jest użycie ciągu kwerendy XPath, ale są również metody, które nie wymagają.  
  
 **Pobierz pojedynczy węzeł**  
  
 W tym przykładzie lokalizuje książkę przy użyciu numeru ISBN.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 Ciąg używany w tym przykładzie jest kwerenda Xpath. Można znaleźć więcej przykładów je tutaj: [przykłady XPath](https://msdn.microsoft.com/library/ms256086.aspx).  
  
 Można również użyć <xref:System.Xml.XmlDocument.GetElementById%2A> można pobrać węzłów. Aby użyć tej metody, musisz zdefiniować identyfikatory w deklaracjach definicji typu dokumentu z pliku XML.  
  
 Po uzyskaniu węzła można pobrać wartości atrybutów i węzłów podrzędnych. W tym przykładzie robi to węzeł książki.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Pobierz kolekcję węzłów**  
  
 W tym przykładzie wybiera wszystkie źródłowe, gdzie jest nazwisko autora **Austen**, a następnie zmienia cen tych książek.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Kolekcja węzłów można również uzyskać za pomocą nazwy węzła. Na przykład w tym przykładzie pobiera zbiór wszystkich tytułów książek.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [Wybierz węzły za pomocą wyrażenia XPath nawigacji](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Edytuj węzły  
 W tym przykładzie edytuje książki węzła i jego atrybuty.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Dowiedz się więcej:** [modyfikowanie węzłów, zawartość i wartości w dokumencie XML](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Dodaj węzły  
 Aby dodać węzeł, użyj <xref:System.Xml.XmlDocument.CreateElement%2A> metody lub <xref:System.Xml.XmlDocument.CreateNode%2A> metody.  
  
 Aby dodać węzeł danych, takich jak książkę, użyj <xref:System.Xml.XmlDocument.CreateElement%2A> metody.  
  
 Dla każdego typu węzła, takie jak użycie komentarza, węzeł odstępem lub węzeł CDATA, <xref:System.Xml.XmlDocument.CreateNode%2A> metody.  
  
 W tym przykładzie tworzy węzeł książki, dodaje attrubutes do tego węzła, a następnie dodanie tego węzła do dokumentu.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [Wstawianie węzły w dokumencie XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Usuń węzły  
 Aby usunąć węzeł, użyj <xref:System.Xml.XmlNode.RemoveChild%2A> metody.  
  
 W tym przykładzie usuwa książkę z dokumentu i żadnych spacji, wyświetlany tylko przed książki węzła.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [usuwanie węzłów, zawartość i wartości z dokumentu XML](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Pozycja węzłów  
 Można wybrać miejsce węzeł jest wyświetlany w dokumencie przy użyciu <xref:System.Xml.XmlNode.InsertBefore%2A> i <xref:System.Xml.XmlNode.InsertAfter%2A> metody.  
  
 W tym przykładzie przedstawiono dwie metody pomocnika. Jeden z nich przenosi wyższej węzła na liście. Przenosi innego węzła niższa.  
  
 Te metody można użyć w aplikacji, która umożliwia użytkownikom przechodzenie książek w górę i w dół na liście — książki. Gdy użytkownik wybierze książkę i naciska klawisz w górę lub w dół przycisku, kodu można wywoływać metod takich pozycji odpowiedniego węzła książki przed lub po innych węzłów książki.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Kompletne przykładowe:** [manipulowanie XML w pamięci przy użyciu klasy XmlDocument i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.XmlNodeChangedEventHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDocument" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDocument" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniżej przedstawiono przykładowy czas ładowania weryfikacji. Walidacja definicji (DTD) typu dokumentu <xref:System.Xml.XmlReader> jest przekazywana do <xref:System.Xml.XmlDocument.Load%2A> — metoda i <xref:System.Xml.Schema.ValidationEventHandler> jest dostarczany w celu powiadomienia użytkowników o jakieś błędy sprawdzania poprawności. W tym przykładzie zostanie znaleziony błąd sprawdzania poprawności, ale dokument jest nadal ładowany. Alternatywnie można zdefiniować, sprawdzanie poprawności <xref:System.Xml.XmlReader> zgłosić wyjątek, i Zatrzymaj proces ładowania, gdy błąd sprawdzania poprawności zostanie znaleziony, nie określając <xref:System.Xml.Schema.ValidationEventHandler>. Aby uzyskać więcej informacji o weryfikacji danych XML, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 W przykładzie użyto `bookDTD.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlDocument.Load(System.String)" />
        <altmember cref="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New (imp As XmlImplementation)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; XmlDocument(System::Xml::XmlImplementation ^ imp);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">
          <see langword="XmlImplementation" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlDocument" /> klasy z określonym <see cref="T:System.Xml.XmlImplementation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument(System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlDocument" /> klasy z określonym <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy identyfikator URI bieżącego węzła.</summary>
        <value>Lokalizacja, z której została załadowana węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sieciowych dokumentu XML składa się z fragmentów dane zagregowane przy użyciu różnych mechanizmów standardowe włączenia W3C, dlatego zawiera węzły, które pochodzą z różnych miejscach. `BaseURI` Informuje, skąd pochodzą te węzły.  
  
 Dla węzłów dokumentu `BaseURI` Zwraca lokalizację dokumentu XML. Na przykład jeśli `XmlDocument` został załadowany przy użyciu następujących dokumentów wywołania. Obciążenia ("http://server/mydata.xml"), `BaseURI` dokumentu jest węzeł http://server/mydata.xml. Jednak jeśli <xref:System.Xml.XmlDocument.Load%2A> metody jest przekierowywane przez serwer do inny identyfikator URI `BaseURI` zwraca oryginalnego identyfikatora URI przekazane do `Load` metody.  
  
 Ta właściwość jest rozszerzenie Microsoft do modelu DOM (Document Object). Aby uzyskać dodatkowe informacje na temat `BaseURI` i będzie pracował inne typy węzłów, zobacz <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">
          <see langword="true" /> Aby rekursywnie sklonować poddrzewo w określonym węźle; <see langword="false" /> sklonować tylko węzeł.</param>
        <summary>Tworzy duplikat tego węzła.</summary>
        <returns>Sklonowany <see langword="XmlDocument" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy jako Konstruktor kopiujący dla węzłów. Sklonowany węzeł nie ma nadrzędnego (<xref:System.Xml.XmlNode.ParentNode%2A> zwraca `null`).  
  
 Jeśli `deep` jest `true`, sklonowany węzeł zawiera wszystkie węzły podrzędne, w przeciwnym razie tylko `XmlDocument` węzeł został sklonowany. Zobacz <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> metody, aby zobaczyć, jak ta metoda ma zachowywać się na inne typy węzłów.  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnicę między bezpośrednich i pobieżnego klonu.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> o określonej nazwie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (name As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu. Jeśli nazwa zawiera dwukropek, <see cref="P:System.Xml.XmlNode.Prefix" /> właściwość odzwierciedla część nazwy przed pierwszym dwukropek i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwość odzwierciedla część nazwy po pierwszym dwukropkiem. <see cref="P:System.Xml.XmlNode.NamespaceURI" /> Pozostanie pusta, chyba że prefiks jest rozpoznany prefiks wbudowanych takich jak xmlns. W takim przypadku <see langword="NamespaceURI" /> ma wartość http://www.w3.org/2000/xmlns/.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> z określonym <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>Nowe <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Mogą być dodawane do <xref:System.Xml.XmlElement> przy użyciu <xref:System.Xml.XmlElement.SetAttributeNode%2A> metody.  
  
   
  
## Examples  
 Poniżej tworzy atrybut i dodaje go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (qualifiedName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Kwalifikowana nazwa atrybutu. Jeśli nazwa zawiera dwukropek, a następnie <see cref="P:System.Xml.XmlNode.Prefix" /> właściwości będzie odzwierciedlać część nazwy przed dwukropkiem i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwości będzie odzwierciedlać część nazwy po dwukropkiem.</param>
        <param name="namespaceURI">Jego identyfikator namespaceURI atrybutu. Jeśli nazwa kwalifikowana obejmuje prefiksu xmlns, to ten parametr musi być http://www.w3.org/2000/xmlns/.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> o określonej nazwie kwalifikowanej i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Mogą być dodawane do <xref:System.Xml.XmlElement> przy użyciu <xref:System.Xml.XmlElement.SetAttributeNode%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks atrybutu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne.</param>
        <param name="localName">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne. Jeśli <c>prefiks</c> jest xmlns, a następnie ten parametr musi być http://www.w3.org/2000/xmlns/; w przeciwnym razie jest zwracany wyjątek.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> z określonym <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Mogą być dodawane do <xref:System.Xml.XmlElement> przy użyciu <xref:System.Xml.XmlElement.SetAttributeNode%2A> metody.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateCDataSection (data As String) As XmlCDataSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlCDataSection ^ CreateCDataSection(System::String ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Zawartość nowego <see langword="XmlCDataSection" />.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlCDataSection" /> zawierający określone dane.</summary>
        <returns>Nowe <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły CDataSection są dozwolone w obrębie elementu węzłów i w węzłach EntityReference podczas węzeł EntityReference nie jest elementem podrzędnym węzła atrybutu .  
  
   
  
## Examples  
 Poniższy przykład tworzy węzeł CDATA i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateComment (data As String) As XmlComment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlComment ^ CreateComment(System::String ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Zawartość nowego <see langword="XmlComment" />.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlComment" /> zawierający określone dane.</summary>
        <returns>Nowe <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły komentarza są dozwolone tylko w węzłach dokumentu, Element i EntityReference, po EntityReference węzeł nie jest elementem podrzędnym atrybutu węzeł.  
  
   
  
## Examples  
 Poniższy przykład tworzy komentarz i dodaje go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDefaultAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XmlAttribute ^ CreateDefaultAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks atrybutu (jeśli istnieje).</param>
        <param name="localName">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu (jeśli istnieje).</param>
        <summary>Tworzy domyślnego atrybutu z określonego prefiksu, lokalna nazwa i identyfikator URI przestrzeni nazw.</summary>
        <returns>Nowe <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentFragment () As XmlDocumentFragment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentFragment ^ CreateDocumentFragment();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>Nowe <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można wstawić DocumentFragment węzły do dokumentu. Jednak można wstawić węzła DocumentFragment do dokumentu.  
  
   
  
## Examples  
 Poniższy przykład umożliwia dodanie nowych węzłów do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentType (name As String, publicId As String, systemId As String, internalSubset As String) As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentType ^ CreateDocumentType(System::String ^ name, System::String ^ publicId, System::String ^ systemId, System::String ^ internalSubset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="publicId" Type="System.String" />
        <Parameter Name="systemId" Type="System.String" />
        <Parameter Name="internalSubset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa typu dokumentu.</param>
        <param name="publicId">Identyfikatora publicznego typu dokumentu lub <see langword="null" />. Można określić publicznego identyfikatora URI oraz identyfikatora systemowego do zidentyfikowania lokalizacji zewnętrznego podzestawu DTD.</param>
        <param name="systemId">Systemowy identyfikator typu dokumentu lub <see langword="null" />. Określa adres URL lokalizacji pliku zewnętrznego podzestawu DTD.</param>
        <param name="internalSubset">Wewnętrznym podzestawie definicji DTD typu dokumentu lub <see langword="null" />.</param>
        <summary>Zwraca nowy <see cref="T:System.Xml.XmlDocumentType" /> obiektu.</summary>
        <returns>Nowe <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony węzeł będzie mieć przeanalizować <xref:System.Xml.XmlDocumentType.Entities%2A> i <xref:System.Xml.XmlDocumentType.Notations%2A> kolekcji.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły DocumentType są dozwolone tylko w węzłach dokumentu. Każdy <xref:System.Xml.XmlDocument> może mieć tylko jeden węzeł dokumentu. Węzeł DocumentType również należy wstawić przed elementem głównym `XmlDocument` (Jeśli dokument ma już element główny, nie można dodać węzła DocumentType).  
  
 Jeśli przekazanych parametrów nie łączyć do tworzenia prawidłowej `XmlDocumentType`, jest zgłaszany wyjątek.  
  
   
  
## Examples  
 Poniższy przykład tworzy węzeł DocumentType i dodaje go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda ma żądanie dziedziczenia. Pełne zaufanie jest wymagany do przesłonięcia <see langword="CreateDocumentType" /> metody.  Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu. Jeśli nazwa zawiera dwukropek, a następnie <see cref="P:System.Xml.XmlNode.Prefix" /> właściwość odzwierciedla część nazwy przed dwukropkiem i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwość odzwierciedla część nazwy po dwukropkiem. Kwalifikowana nazwa nie może zawierać of'xmlns prefiks.</param>
        <summary>Tworzy element o określonej nazwie.</summary>
        <returns>Nowe <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że wystąpienie zwracane implementuje `XmlElement` interfejsu, więc domyślne atrybuty, które zostałyby utworzone bezpośrednio na zwracanym obiekcie.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły elementów są dozwolone dokumentu i elementu węzłów i w węzłach EntityReference podczas EntityReference węzeł nie jest elementem podrzędnym Węzeł atrybutu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (qualifiedName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Kwalifikowana nazwa elementu. Jeśli nazwa zawiera dwukropek, a następnie <see cref="P:System.Xml.XmlNode.Prefix" /> właściwości będzie odzwierciedlać część nazwy przed dwukropkiem i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwości będzie odzwierciedlać część nazwy po dwukropkiem. Kwalifikowana nazwa nie może zawierać of'xmlns prefiks.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlElement" /> z nazwą kwalifikowaną i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy kod C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 wyniki w elemencie, który jest odpowiednikiem następującego tekstu XML.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły elementów są dozwolone dokumentu i elementu węzłów i w węzłach EntityReference podczas EntityReference węzeł nie jest elementem podrzędnym Węzeł atrybutu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks nowego elementu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne.</param>
        <param name="localName">Lokalna nazwa nowego elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw nowego elementu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne.</param>
        <summary>Tworzy element z określonym <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy kod C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 Tworzy element odpowiednikiem następującego tekstu XML:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły elementów są dozwolone dokumentu i elementu węzłów i w węzłach EntityReference podczas EntityReference znajduje się poza węzła atrybutu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład dodaje nowy element do istniejącego dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa odwołania do jednostki.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlEntityReference" /> o określonej nazwie.</summary>
        <returns>Nowe <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obiektem przywoływanym jest znany, lista podrzędna `XmlEntityReference` węzeł jest taki sam jak odpowiadającego wprowadzone <xref:System.Xml.XmlEntity> węzła.  
  
 Przestrzenie nazw używane w tekst zastępczy dla odwołania do jednostki są powiązane z chwili utworzenia obiektu nadrzędnego węzła odniesienia jednostki ustawiono wcześniej (na przykład, gdy węzeł odniesienia jednostki są wstawiane do dokumentu). Na przykład podane jednostki następujące:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 Jeśli należy wywołać `CreateEntityReference("a")` powrócisz jednego węzła EntityReference typu bez elementów podrzędnych. Jeśli Dołącz ten węzeł jako element podrzędny następującego węzła  
  
```  
<item xmlns="urn:1"/>  
```  
  
 następnie, w tym czasie wywołania metody <xref:System.Xml.XmlNode.AppendChild%2A>, ustawiono nadrzędnego węzła odniesienia nowo utworzonej jednostki i elementy podrzędne są rozwinięty w tym kontekście przestrzeni nazw. Węzeł elementu podrzędnego `b` będą miały taki sam identyfikator NamespaceURI `urn:1`. Węzły podrzędne odwołanie do jednostki pozostają takie same, nawet jeśli przenosisz odwołanie do jednostki, w miejsce w dokumencie, który ma inną domyślny kontekst nazw. To nie odbywa się dla istniejących węzłów odwołanie do jednostki Usuń i wstawić je lub dla obiekt odwołuje się do którego można sklonować z <xref:System.Xml.XmlDocument.CloneNode%2A>. Zdarza się tylko dla odwołania do nowo utworzonej jednostki.  
  
 Jeśli odpowiednia jednostka nie jest zdefiniowany w DocumentType po dodaniu węzła odwołanie do jednostki, ponieważ odwołanie do jednostki nie jest określony, jego tylko węzeł podrzędny będzie pusty tekst węzła.  
  
 Amp jednostek wbudowanych, lt, gt, apos i quot dozwolone są też i będą miały elementem podrzędnym tekstu z wartością odpowiedni znak rozwinięte.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły EntityReference są dozwolone tylko w obrębie elementu, atrybutu i EntityReference węzłów.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwa węzły odwołanie do jednostki i wstawia je do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa jest nieprawidłowa (na przykład nazwy, począwszy od '#' są nieprawidłowe.)</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania tego dokumentu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania tego dokumentu.</summary>
        <returns>
          <see cref="T:System.Xml.XPath.XPathNavigator" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> na przykład za pomocą tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <see cref="T:System.Xml.XmlNode" /> Ma Nawigatora wstępnie ustawiony na.</param>
        <summary>Tworzy <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania w tym dokumencie znajduje się na <see cref="T:System.Xml.XmlNode" /> określony.</summary>
        <returns>
          <see cref="T:System.Xml.XPath.XPathNavigator" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> na przykład za pomocą tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (nodeTypeString As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::String ^ nodeTypeString, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Wersja ciągu <see cref="T:System.Xml.XmlNodeType" /> nowego węzła. Ten parametr musi być jedną z wartości wymienionych w poniższej tabeli.</param>
        <param name="name">Kwalifikowana nazwa nowego węzła. Jeśli nazwa zawiera dwukropek, jest analizowana w <see cref="P:System.Xml.XmlNode.Prefix" /> i <see cref="P:System.Xml.XmlDocument.LocalName" /> składników.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw z nowego węzła.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> z typem określonym węźle <see cref="P:System.Xml.XmlDocument.Name" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `nodeTypeString` Parametr jest rozróżniana wielkość liter i musi być jedną z wartości w tabeli poniżej.  
  
|nodeTypeString|XmlNodeType|  
|--------------------|-----------------|  
|— atrybut|Atrybut|  
|cdatasection|CDATA|  
|komentarz|Komentarz|  
|dokument|dokument|  
|DocumentFragment|DocumentFragment|  
|Typ dokumentu|Typ dokumentu|  
|— element|Element|  
|Obiekt EntityReference|Obiekt EntityReference|  
|processinginstruction|ProcessingInstruction|  
|significantwhitespace|SignificantWhitespace|  
|tekst|Tekst|  
|Odstępu|Odstępu|  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 W poniższej tabeli przedstawiono jakie NodeType [wiersz] jest dozwolona wewnątrz innej NodeType [kolumna] zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||dokument|Typ dokumentu|XmlDeclaration|Element|Atrybut|Tekst|CDATA|Kod znaczników|Obiekt EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`DocumentType`|Tak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`XmlDeclaration`|Tak *|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`Element`|Tak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|tak ***|  
|`Attribute`|Brak|Brak|Brak|tak ***|Brak|Brak|Brak|Brak|Brak|  
|`Text`|Brak|Brak|Brak|Tak|Tak|Brak|Brak|Brak|Tak|  
|`CDATA`|Brak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|tak ***|  
|`Markup**`|Tak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|Brak|  
|`EntityReference`|Brak|Brak|Brak|Tak|Tak|Brak|Brak|Brak|Tak|  
  
 \* Węzeł XmlDeclaration musi być pierwszym elementem podrzędnym węzła dokumentu.  
  
 ** Znaczników zawiera węzły ProcessingInstruction i komentarz.  
  
 Element i CDATA węzłów są dozwolone tylko w węzłach EntityReference, gdy węzeł EntityReference nie jest elementem podrzędnym węzła atrybutu.  
  
 Atrybuty nie są elementami podrzędnymi węzeł elementu. Atrybuty znajdują się wewnątrz kolekcji atrybutów, który należy do węzła elementu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i wstawia go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano nazwy i <see langword="XmlNodeType" /> wymaga nazwy; lub <paramref name="nodeTypeString" /> nie jest jednym z poniższych ciągów.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see langword="XmlNodeType" /> Nowego węzła.</param>
        <param name="name">Kwalifikowana nazwa nowego węzła. Jeśli nazwa zawiera dwukropek, jest analizowana w <see cref="P:System.Xml.XmlNode.Prefix" /> i <see cref="P:System.Xml.XmlDocument.LocalName" /> składników.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw z nowego węzła.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> z określonym <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 W poniższej tabeli przedstawiono jakie NodeType [wiersz] jest dozwolona wewnątrz innej NodeType [kolumna] zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||dokument|Typ dokumentu|XmlDeclaration|Element|Atrybut|Tekst|CDATA|Kod znaczników|Obiekt EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`DocumentType`|Tak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`XmlDeclaration`|Tak *|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`Element`|Tak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|tak ***|  
|`Attribute`|Brak|Brak|Brak|tak ***|Brak|Brak|Brak|Brak|Brak|  
|`Text`|Brak|Brak|Brak|Tak|Tak|Brak|Brak|Brak|Tak|  
|`CDATA`|Brak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|tak ***|  
|`Markup**`|Tak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|Brak|  
|`EntityReference`|Brak|Brak|Brak|Tak|Tak|Brak|Brak|Brak|Tak|  
  
 \* Węzeł XmlDeclaration musi być pierwszym elementem podrzędnym węzła dokumentu.  
  
 ** Znaczników zawiera węzły ProcessingInstruction i komentarz.  
  
 Element i CDATA węzłów są dozwolone tylko w węzłach EntityReference, gdy węzeł EntityReference nie jest elementem podrzędnym węzła atrybutu.  
  
 Atrybuty nie są elementami podrzędnymi węzeł elementu. Atrybuty znajdują się wewnątrz kolekcji atrybutów, który należy do węzła elementu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i wstawia go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano nazwy i <see langword="XmlNodeType" /> wymaga nazwy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, prefix As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ prefix, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see langword="XmlNodeType" /> Nowego węzła.</param>
        <param name="prefix">Prefiks nowego węzła.</param>
        <param name="name">Lokalna nazwa nowego węzła.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw z nowego węzła.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> z określonym <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowe <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 W poniższej tabeli przedstawiono jakie NodeType [wiersz] jest dozwolona wewnątrz innej NodeType [kolumna] zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||dokument|Typ dokumentu|XmlDeclaration|Element|Atrybut|Tekst|CDATA|Kod znaczników|Obiekt EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`DocumentType`|Tak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`XmlDeclaration`|Tak *|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`Element`|Tak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|tak ***|  
|`Attribute`|Brak|Brak|Brak|tak ***|Brak|Brak|Brak|Brak|Brak|  
|`Text`|Brak|Brak|Brak|Tak|Tak|Brak|Brak|Brak|Tak|  
|`CDATA`|Brak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|tak ***|  
|`Markup**`|Tak|Brak|Brak|Tak|Brak|Brak|Brak|Brak|Brak|  
|`EntityReference`|Brak|Brak|Brak|Tak|Tak|Brak|Brak|Brak|Tak|  
  
 \* Węzeł XmlDeclaration musi być pierwszym elementem podrzędnym węzła dokumentu.  
  
 ** Znaczników zawiera węzły ProcessingInstruction i komentarz.  
  
 Element i CDATA węzłów są dozwolone tylko w węzłach EntityReference, gdy węzeł EntityReference nie jest elementem podrzędnym węzła atrybutu.  
  
 Atrybuty nie są elementami podrzędnymi węzeł elementu. Atrybuty znajdują się wewnątrz kolekcji atrybutów, który należy do węzła elementu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład dodaje nowy element do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano nazwy i <see langword="XmlNodeType" /> wymaga nazwy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateProcessingInstruction (target As String, data As String) As XmlProcessingInstruction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlProcessingInstruction ^ CreateProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Nazwa instrukcji przetwarzania.</param>
        <param name="data">Dane dla instrukcji przetwarzania.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlProcessingInstruction" /> z określoną nazwą i danych.</summary>
        <returns>Nowe <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły ProcessingInstruction są dozwolone tylko w obrębie dokumentu, Element i EntityReference węzłów, po EntityReference węzeł nie jest elementem podrzędnym z węzłem atrybutu.  
  
   
  
## Examples  
 Poniższy przykład tworzy węzeł ProcessingInstruction i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSignificantWhitespace (text As String) As XmlSignificantWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlSignificantWhitespace ^ CreateSignificantWhitespace(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg musi zawierać tylko następujące znaki &amp;#20; &amp;#10; &amp;#13; i &amp;#9;</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlSignificantWhitespace" /> węzła.</summary>
        <returns>Nowy <see langword="XmlSignificantWhitespace" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jeśli chcesz ręcznie format dokumentu jest używany.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
   
  
## Examples  
 Poniższy przykład umożliwia dodanie znaczący biały znak w dokumencie.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTextNode (text As String) As XmlText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlText ^ CreateTextNode(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst dla węzła tekstowego.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlText" /> określonym tekstem.</summary>
        <returns>Nowe <see langword="XmlText" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły tekstowe są dozwolone tylko w obrębie elementu, atrybutu i EntityReference węzłów.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWhitespace (text As String) As XmlWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlWhitespace ^ CreateWhitespace(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg musi zawierać tylko następujące znaki &amp;#20; &amp;#10; &amp;#13; i &amp;#9;</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlWhitespace" /> węzła.</summary>
        <returns>Nowy <see langword="XmlWhitespace" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jeśli chcesz ręcznie format dokumentu jest używany.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
   
  
## Examples  
 Poniższy przykład umożliwia dodanie biały znak w dokumencie.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateXmlDeclaration (version As String, encoding As String, standalone As String) As XmlDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDeclaration ^ CreateXmlDeclaration(System::String ^ version, System::String ^ encoding, System::String ^ standalone);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">Wersja musi być "1.0".</param>
        <param name="encoding">Wartość atrybutu kodowania. To kodowanie, które jest używane podczas zapisywania <see cref="T:System.Xml.XmlDocument" /> w pliku lub strumienia; w związku z tym należy ją ustawić na ciąg obsługiwane przez <see cref="T:System.Text.Encoding" /> klasy, w przeciwnym razie <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> zakończy się niepowodzeniem. Jeśli jest to <see langword="null" /> lub String.Empty, <see langword="Save" /> — metoda nie zapisuje atrybut kodowania w deklaracji XML i w związku z tym jest używane domyślne kodowanie UTF-8.  Uwaga: Jeśli <see langword="XmlDocument" /> są zapisywane albo <see cref="T:System.IO.TextWriter" /> lub <see cref="T:System.Xml.XmlTextWriter" />, ta wartość kodowania zostaną odrzucone. Zamiast tego kodowanie <see langword="TextWriter" /> lub <see langword="XmlTextWriter" /> jest używany. Dzięki temu, że XML zapisywane może zostać odczytany ponownie przy użyciu kodowania poprawne.</param>
        <param name="standalone">Wartość musi być albo "yes" lub "no". Jeśli jest to <see langword="null" /> lub String.Empty, <see langword="Save" /> — metoda nie zapisuje autonomicznego atrybutu deklaracji XML.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlDeclaration" /> węzła z określonymi wartościami.</summary>
        <returns>Nowe <see langword="XmlDeclaration" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty są widoczne jako specjalne właściwości na `XmlDeclaration` węzeł, a nie jako <xref:System.Xml.XmlAttribute> węzłów.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jednej z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) `XmlDeclaration` węzła musi być pierwszym węzłem w dokumencie.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład tworzy deklaracja XML i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartości <paramref name="version" /> lub <paramref name="standalone" /> są coś innych niż wymienione powyżej.</exception>
        <altmember cref="T:System.Xml.XmlDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentElement As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlElement ^ DocumentElement { System::Xml::XmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera głównego <see cref="T:System.Xml.XmlElement" /> dokumentu.</summary>
        <value>
          <see langword="XmlElement" /> Reprezentujący korzeń drzewa dokumentu XML. Jeśli główny nie istnieje, <see langword="null" /> jest zwracany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono element główny dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Dane wyjściowe:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DocumentType As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocumentType ^ DocumentType { System::Xml::XmlDocumentType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera węzeł zawierający deklaracji DOCTYPE.</summary>
        <value>
          <see cref="T:System.Xml.XmlNode" /> Zawierający DocumentType (deklaracji typu dokumentu).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` Może mieć tylko jeden element podrzędny o <xref:System.Xml.XmlNodeType> taki sam typ dokumentu.  
  
> [!NOTE]
>  Ta właściwość jest tylko do odczytu. Aby zmienić węzeł dokumentu, usuń istniejący węzeł, Utwórz nowy go przy użyciu <xref:System.Xml.XmlDocument.CreateDocumentType%2A> metody i dodać nowego węzła do dokumentu.  
  
   
  
## Examples  
 Poniższy przykład pobiera i wyświetla deklaracji typu dokumentu dla dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlDocumentType" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementById (elementId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ GetElementById(System::String ^ elementId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementId">Identyfikator atrybutu do dopasowania.</param>
        <summary>Pobiera <see cref="T:System.Xml.XmlElement" /> o określonym identyfikatorze.</summary>
        <returns>
          <see langword="XmlElement" /> o identyfikatorze pasującego lub <see langword="null" /> przypadku nieznalezienia Brak pasującego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dokument ma wiele elementów o identyfikatorze dopasowania, ta metoda zwraca pierwszy element dopasowania w dokumencie.  
  
> [!NOTE]
>  Implementacja DOM musi mieć informacje, który definiuje atrybutów, które mają identyfikator typu. Mimo że można zdefiniować atrybutów typu ID schematów XSD lub definicji DTD, ta wersja produktu obsługuje tylko określone w definicji DTD. Atrybutów o tej nazwie, które nie mają "ID" wpisz identyfikator, jeśli więc jest zdefiniowany w definicji DTD. Implementacje, gdzie jest nieznany czy atrybut typu ID powinna zwrócić `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `GetElementById` metody.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `ids.xml`, jak wejściowego.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetElementsByTagName">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich podrzędnych elementów pasujących do określonej nazwy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa do dopasowania. Jest dopasowywana <see langword="Name" /> właściwości pasujących węzła. Specjalna wartość "*" dopasowuje wszystkie tagi.</param>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich elementów podrzędnych, które pasują do określonego <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>
          <see cref="T:System.Xml.XmlNodeList" /> Zawierający listę wszystkich zgodne węzły. Jeśli zgodny żadnych węzłów <paramref name="name" />, zwracana kolekcja będzie pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Węzły są umieszczane w kolejności, w których może wystąpić w dokumencie.  
  
> [!NOTE]
>  Zaleca się, że używasz <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> lub <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> zamiast metody <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy `XmlDocument` obiektu i używa `GetElementsByTagName` — metoda i powstałe w ten sposób <xref:System.Xml.XmlNodeList> obiektu, aby wyświetlić wszystkie tytuły książek.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 W przykładzie użyto `books.xml` pliku jako dane wejściowe.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (localName As String, namespaceURI As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">LocalName do dopasowania. Specjalna wartość "*" dopasowuje wszystkie tagi.</param>
        <param name="namespaceURI">NamespaceURI do dopasowania.</param>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich elementów podrzędnych, które pasują do określonego <see cref="P:System.Xml.XmlDocument.LocalName" /> i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>
          <see cref="T:System.Xml.XmlNodeList" /> Zawierający listę wszystkich zgodne węzły. Jeśli żadnych węzłów odpowiada określonym <paramref name="localName" /> i <paramref name="namespaceURI" />, zwracana kolekcja będzie pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Węzły są umieszczane w kolejności, w których może wystąpić w drzewie dokumentu.  
  
> [!NOTE]
>  Zaleca się, że używasz <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> lub <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> zamiast metody <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Implementation As XmlImplementation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlImplementation ^ Implementation { System::Xml::XmlImplementation ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlImplementation" /> obiektu w bieżącym dokumencie.</summary>
        <value>
          <see langword="XmlImplementation" /> Obiektu w bieżącym dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` obiekty utworzone z tej samej `XmlImplementation` identyczny <xref:System.Xml.XmlNameTable>. Dzięki temu użytkownicy mogą porównania nazw atrybutów i elementów jako obiekty zamiast ciągów.  
  
 Mimo że `XmlDocument` obiekty współużytkują tego samego wdrożenia, aby przenieść węzłów z jednego dokumentu należy użyć <xref:System.Xml.XmlDocument.ImportNode%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową `XmlDocument` przy użyciu implementacji innego dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportNode (node As XmlNode, deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ImportNode(System::Xml::XmlNode ^ node, bool deep);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">Węzeł zostały zaimportowane.</param>
        <param name="deep">
          <see langword="true" /> do wykonania w klonowania głębokiego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Importuje węzła z innego dokumentu do bieżącego dokumentu.</summary>
        <returns>Importowany <see cref="T:System.Xml.XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony węzeł nie ma nadrzędnego. Węzeł źródłowy nie zostanie zmieniony lub usunięty z oryginalnego dokumentu; `ImportNode` tworzy kopię węzła źródłowego.  
  
 Importowanie węzła tworzy `XmlNode` obiektów należących do importowania dokumentu z <xref:System.Xml.XmlNode.Name%2A> i <xref:System.Xml.XmlNode.NodeType%2A> taki sam jak źródłowy. Nowy obiekt ma również atrybuty powiązane z przestrzeni nazw (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>, i <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 W zależności od typu węzła importowanych węzła i wartość `deep` parametru, dodatkowe informacje są kopiowane jako odpowiednie. Ta metoda próbuje dublowany zachowanie oczekiwane, jeśli fragment XML lub HTML źródła został skopiowany z jednego dokumentu do innego (rozpoznawanie, że w przypadku XML dwa dokumenty może mieć różne definicje DTD).  
  
 W poniższej tabeli opisano określone zachowanie dla każdego <xref:System.Xml.XmlNodeType>.  
  
|XmlNodeType|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|Atrybut|<xref:System.Xml.XmlAttribute.Specified%2A> Właściwość jest ustawiona na `true` na wygenerowany <xref:System.Xml.XmlAttribute>. Elementy podrzędne źródła `XmlAttribute` rekursywnie zaimportowane i wynikowy węzły są odbierane do utworzenia odpowiedniego poddrzewa.|`deep` Parametru nie ma zastosowania do `XmlAttribute` węzłów; zakres ich zawierają ich elementy podrzędne z nimi po zaimportowaniu.|  
|CData|Kopiuje węzła, w tym jego dane.|Kopiuje węzła, w tym jego dane.|  
|Komentarz|Kopiuje węzła, w tym jego dane.|Kopiuje węzła, w tym jego dane.|  
|DocumentFragment|Elementów podrzędnych węzła źródłowego są rekursywnie zaimportowane i wynikowy węzłów odbierane do utworzenia odpowiedniego poddrzewa.|Pusta <xref:System.Xml.XmlDocumentFragment> jest generowany.|  
|Typ dokumentu|Kopiuje węzła, w tym jego data.*|Kopiuje węzła, w tym jego data.*|  
|Element|Elementów podrzędnych elementu źródła i jego węzły określonego atrybutu są rekursywnie zaimportowane i wynikowy węzłów odbierane do utworzenia odpowiedniego poddrzewa.<br /><br /> Uwaga: Domyślne atrybuty nie są kopiowane. Jeśli importowany do dokumentu definiuje domyślne atrybuty dla tej nazwy elementu, te są przypisane.|Określony atrybut węzły elementu źródłowego zostały zaimportowane i wygenerowany `XmlAttribute` węzły są dołączone do wygenerowanej <xref:System.Xml.XmlElement>.<br /><br /> Uwaga: Domyślne atrybuty nie są kopiowane. Jeśli importowany do dokumentu definiuje domyślne atrybuty dla tej nazwy elementu, te są przypisane.|  
|Obiekt EntityReference|Ponieważ dokumenty źródłowy i docelowy mogą mieć jednostek określony inaczej, ta metoda tylko kopiuje <xref:System.Xml.XmlEntityReference> węzła. Tekst zastępczy nie jest włączony. Jeśli plik docelowy ma jednostki zdefiniowane, jego wartość jest przypisany.|Ponieważ dokumenty źródłowy i docelowy mogą mieć jednostek określony inaczej, ta metoda tylko kopiuje <xref:System.Xml.XmlEntityReference> węzła. Tekst zastępczy nie jest włączony. Jeśli plik docelowy ma jednostki zdefiniowane, jego wartość jest przypisany.|  
|ProcessingInstruction|Kopiuje wartości docelowej i danych z węzła zaimportowany.|Kopiuje wartości docelowej i danych z węzła zaimportowany.|  
|Tekst|Kopiuje węzła, w tym jego dane.|Kopiuje węzła, w tym jego dane.|  
|SignificantWhitespace|Kopiuje węzła, w tym jego dane.|Kopiuje węzła, w tym jego dane.|  
|Odstępu|Kopiuje węzła, w tym jego dane.|Kopiuje węzła, w tym jego dane.|  
|XmlDeclaration|Kopiuje wartości docelowej i danych z węzła zaimportowany.|Kopiuje wartości docelowej i danych z węzła zaimportowany.|  
|Wszystkie inne typy węzłów.|Nie można zaimportować typu węzła.|Nie można zaimportować typu węzła.|  
  
 * Mimo że można zaimportować węzłów dokumentu, dokument może mieć tylko jeden typ dokumentu. Jeśli dokument ma obecnie węzła DocumenType, należy usunąć przed dodaniem nowego.  
  
   
  
## Examples  
 Poniższy przykład importuje węzła książki z drugiego dokumentu XML do oryginalnego dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `books.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołanie tej metody dla typu węzła, którego nie można zaimportować.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText {  void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.InvalidOperationException" /> we wszystkich przypadkach.</summary>
        <value>Wartości węzła i wszystkich jego węzłów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest zaimplementowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znaczników reprezentującą elementy podrzędne bieżącego węzła.</summary>
        <value>Kod znaczników elementy podrzędne bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości zastępuje element podrzędny węzła przy użyciu analizowanej zawartości dany ciąg znaków. Analiza odbywa się w bieżącym kontekście przestrzeni nazw.  
  
 `InnerXml` Usuwa nadmiarowe przestrzeń nazw — deklaracje. Jako wynik wiele wycinanie i wklejanie operacje nie zwiększają rozmiar dokumentu z deklaracjami nadmiarowe przestrzeni nazw. Należy wziąć pod uwagę następujące dokumentu XSL:  
  
```xml  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 `InnerXml` Właściwość w węźle arkusza stylów zwraca następujący ciąg:  
  
```xml  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Zwróć uwagę, xmlns:xsl dodatkowe deklaracji przestrzeni nazw, który jest używany w celu zachowania tożsamości węzła. Jeśli ponownie wstawić ten wewnętrzny ciąg XML, wystąpi ponownie oryginalnego dokumentu. Innymi słowy `InnerXml` rozpoznaje xmlns:xsl deklaracji przestrzeni nazw jest nadmiarowa, biorąc pod uwagę, że element nadrzędny XSL: stylesheet już ma xmlns:xsl delcaration przestrzeni nazw i w związku z tym usuwa go.  
  
 Jeśli przeniesiesz `InnerXml` z dokumentu z obszaru nazw domyślny dokument z domyślnej przestrzeni nazw różni się nieco zachowanie. Rozważmy następujący ciąg XML:  
  
```xml  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml` Zwraca ciąg zwykły XML z nie deklaracji przestrzeni nazw:  
  
```xml  
<item>123</item>  
```  
  
 Jeśli ten ciąg jest następnie wstaw do dokumentu, który ma domyślny obszar nazw, takich jak następujące:  
  
```xml  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml` po analizie ciąg w kontekście i nowe węzły wybierz przestrzeń nazw urn: 1. Wynik wygląda następująco:  
  
```xml  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Teraz po na żądanie użytkownika `InnerXml` odzyskać następujące:  
  
```xml  
<item xmlns="urn:1">123</item>  
```  
  
 Jeśli chcesz jawnie wstawiony element, aby zachować fakt, że pochodzi z dokumentu, który miał bez przestrzeni nazw, należy ręcznie dodać xmlns = "" deklaracji i Wstaw wynikowy ciąg:  
  
```xml  
<item xmlns="">123</item>  
```  
  
 Net efekt wszystko, co to jest następujący:  
  
1.  Wycinanie i wklejanie `InnerXml` między dokumenty, które nie korzystają z przestrzeni nazw jest czysty i proste i nie tworzy nadmiarowość "xmlns" w Twojej ciągów.  
  
2.  `InnerXml` można również wycinanie i wklejanie między dokumenty, które mają więcej niż jeden obszar nazw (która jest arkusze stylów XSL).  
  
3.  deklaracje xmlns:XSL automatycznie wyświetlane w Twojej ciągów i znikają w Twojej hierarchii węzła.  
  
4.  W przypadku gdy jesteś przenoszenie `InnerXml` z dokumentu, który nie ma domyślnego obszaru nazw do dokumentu, który ma domyślnej przestrzeni nazw, nowe węzły pobierze nowy domyślny obszar nazw.  
  
 Jeśli `InnerXml` ustawiono tekstem zawierającym odwołań do jednostek, które nie są obecnie zdefiniowane w dokumencie, wynikowe drzewo będzie zawierało pusty EntityReference węzłów.  
  
 Ta właściwość jest rozszerzenie Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Kod XML określić, gdy ustawienie dla tej właściwości nie jest poprawnie sformułowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący węzeł jest tylko do odczytu. w przeciwnym razie <see langword="false" />. <see langword="XmlDocument" /> zawsze zwraca węzłów <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Węzeł tylko do odczytu jest jeden których atrybuty, właściwości lub podrzędnych nie można zmienić. Można usunąć węzła tylko do odczytu z drzewa i wstaw go w innym miejscu.  
  
 Ta właściwość jest rozszerzenie Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie `IsReadOnly` właściwości.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje określony dane XML z <see cref="T:System.IO.Stream" />, adres URL, <see cref="T:System.IO.TextReader" />, lub <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::Stream ^ inStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Strumień, zawierający można załadować dokumentu XML.</param>
        <summary>Ładuje dokumentu XML z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metody zawsze zachowuje znaczący biały znak. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy zachowana jest nieważny biały znak, będącą biały znak w zawartości elementu. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli sprawdzanie poprawności jest wykonywane, można utworzyć sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Ta metoda automatycznie wykrywa format ciągu wejściowego XML (na przykład UTF-8, ANSI i tak dalej). Jeśli aplikacja musi wiedzieć, który kodowanie jest używany do odczytu strumienia, należy rozważyć użycie <xref:System.Xml.XmlTextReader> do odczytu strumienia obiektu, a następnie użyj <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> właściwości w celu określenia kodowania. Jeśli musisz użyć <xref:System.Xml.XmlDocument> obiektu XML, można użyć <xref:System.Xml.XmlTextReader> obiekt, aby go utworzyć. Aby uzyskać więcej informacji, zobacz [odczytywania danych XML przy użyciu XPathDocument i XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Występuje błąd obciążenia lub analizy w pliku XML. W takim przypadku <see cref="T:System.IO.FileNotFoundException" /> jest wywoływane.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::TextReader ^ txtReader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">
          <see langword="TextReader" /> Używane do strumieniowego źródła danych XML do dokumentu.</param>
        <summary>Ładuje dokumentu XML z określonego <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metody zawsze zachowuje znaczący biały znak. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy zachowana jest nieważny biały znak, będącą biały znak w zawartości elementu. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli sprawdzanie poprawności jest wykonywane, można utworzyć sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.StringReader> klasy załadować ciągu danych XML do `XmlDocument` obiektu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Występuje błąd obciążenia lub analizy w pliku XML. W takim przypadku dokument pozostanie puste.</exception>
        <altmember cref="T:System.IO.StreamReader" />
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Adres URL pliku zawierającego dokument XML do załadowania. Adres URL może być lokalny plik lub adres HTTP URL (adres sieci Web).</param>
        <summary>Ładuje dokumentu XML z określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metody zawsze zachowuje znaczący biały znak. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy zachowana jest nieważny biały znak, będącą biały znak w zawartości elementu. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli sprawdzanie poprawności jest wykonywane, można utworzyć sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Występuje błąd obciążenia lub analizy w pliku XML. W takim przypadku <see cref="T:System.IO.FileNotFoundException" /> jest wywoływane.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="filename" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="filename" /> określony plik jest tylko do odczytu.  - lub - tej operacji nie jest obsługiwane na bieżącej platformie.  - lub - <paramref name="filename" /> określony katalog.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="filename" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="filename" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XmlReader" /> Używane do strumieniowego źródła danych XML do dokumentu.</param>
        <summary>Ładuje dokumentu XML z określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metody zawsze zachowuje znaczący biały znak. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy zachowana jest nieważny biały znak, będącą biały znak w zawartości elementu. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli czytnik jest w stanie początkowym (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial), `Load` zużywa całą zawartość czytnika danych i tworzy DOM z ich znalezienia.  
  
 Jeśli czytnik jest już ustawiony na jednego z węzłów przy głębokości "n", ta metoda ładuje ten węzeł i wszystkie kolejne elementy równorzędne do tagu końcowego, który zamyka głębokość "n". Ma to następujące wyniki.  
  
 Jeśli bieżącego węzła i jego elementów równorzędnych wyglądać następująco:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` zgłasza wyjątek, ponieważ dokument nie może mieć dwóch elementów głównego poziomu. Jeśli bieżącego węzła i jego elementów równorzędnych wyglądać następująco:  
  
```xml  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load` zakończy się powodzeniem, ale masz niekompletne drzewa modelu DOM, ponieważ nie istnieje żaden element poziomu głównego. Przed zapisaniem dokumentu, należy dodać element poziomu głównego, w przeciwnym razie <xref:System.Xml.XmlDocument.Save%2A> spowoduje zgłoszenie wyjątku.  
  
 Jeśli czytnik jest ustawiony na węzeł liścia, który jest nieprawidłowy dla poziomu głównego dokumentu, na przykład biały znak lub węzła atrybutu czytnik będzie kontynuowane do odczytu, dopóki nie zostanie on ustawiony na węźle, który może służyć do katalogu głównego. Dokument rozpoczyna się w tym momencie ładowania.  
  
 Jeśli sprawdzanie poprawności jest wykonywane, można utworzyć sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład załaduje ostatnim węźle książki `books.xml` pliku do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `books.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Występuje błąd obciążenia lub analizy w pliku XML. W takim przypadku dokument pozostanie puste.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadXml (xml As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadXml(System::String ^ xml);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Ciąg zawierający można załadować dokumentu XML.</param>
        <summary>Ładuje dokumentu XML z określonego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie `LoadXml` — metoda nie zachowa biały znak lub znaczący biały znak.  
  
 Ta metoda analizuje definicji DTD, ale nie DTD lub schemat sprawdzania poprawności. Jeśli sprawdzanie poprawności jest wykonywane, można utworzyć sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 Jeśli chcesz załadować z <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, lub <xref:System.Xml.XmlReader>, zamiast tej metody należy użyć metody obciążenia.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład załaduje XML do `XmlDocument` obiektu i zapisuje je w pliku.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Występuje błąd obciążenia lub analizy w pliku XML. W takim przypadku dokument pozostanie puste.</exception>
        <altmember cref="P:System.Xml.XmlDocument.PreserveWhitespace" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę lokalnego węzła.</summary>
        <value>Aby uzyskać <see langword="XmlDocument" /> węzłów, nazwa lokalna jest #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokalna nazwa zwracane jest zależna od <xref:System.Xml.XmlDocument.NodeType%2A> węzła. Aby wyświetlić tabelę opisującą lokalna nazwa dla każdego typu węzła zwracane, zobacz <xref:System.Xml.XmlNode.LocalName%2A> właściwości w <xref:System.Xml.XmlNode> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną nazwę węzła.</summary>
        <value>Aby uzyskać <see langword="XmlDocument" /> węzłów, nazwa jest #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona nazwa zależy od <xref:System.Xml.XmlDocument.NodeType%2A> węzła. Aby wyświetlić tabelę opisującą nazwa zwrócony dla każdego typu węzła, zobacz <xref:System.Xml.XmlNode.Name%2A> właściwości w <xref:System.Xml.XmlNode> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlNameTable" /> skojarzone z tą implementacją.</summary>
        <value>
          <see langword="XmlNameTable" /> Dzięki któremu można pobrać wersję atomized ciągu w tym dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `XmlDocument` obiekt ma <xref:System.Xml.NameTable> obiektu. Nazwy elementów i atrybutów są przechowywane w `NameTable` jako atomized ciągi. Oznacza to, że nawet jeśli odwołuje się do nazwy w dokumencie wielokrotnie jest on przechowywany tylko raz w `NameTable`. Na przykład, jeśli dokument ma wiele elementów o nazwie "Klient" `NameTable` zwraca tego samego obiektu, gdy odbiera żądanie dla tej nazwy. W związku z tym użytkownicy można napisać kod przy użyciu obiektu porównania te ciągi zamiast droższe porównywania ciągów.  
  
 Aby uzyskać więcej informacji na atomized ciągów, zobacz <xref:System.Xml.XmlNameTable>.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanged As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Xml.XmlNode.Value" /> węzła należące do tego dokumentu została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie dotyczy tylko węzły, które mają wartość.  
  
 Wszystkie węzły utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, są uwzględnione w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanging As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Xml.XmlNode.Value" /> węzeł należącą do tego dokumentu jest zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia użytkownikowi wykonaj dodatkowe sprawdzanie i, w razie potrzeby należy zgłosić wyjątek, aby zatrzymać operację. Jeśli wyjątek `XmlDocument` powróci do stanu pierwotnego. To zdarzenie dotyczy tylko węzły, które mają wartość.  
  
 Wszystkie węzły utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, są uwzględnione w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserted As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu została wsunięta do innego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie węzły utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, są uwzględnione w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserting As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu ma zostać wstawiony do innego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia użytkownikowi wykonaj dodatkowe sprawdzanie i, w razie potrzeby należy zgłosić wyjątek, aby zatrzymać operację. Jeśli wyjątek `XmlDocument` powróci do stanu pierwotnego.  
  
 Wszystkie węzły utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, są uwzględnione w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoved As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu została usunięta z jego elementu nadrzędnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie węzły utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, są uwzględnione w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoving As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu ma zostać usunięta z dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia użytkownikowi wykonaj dodatkowe sprawdzanie i, w razie potrzeby należy zgłosić wyjątek, aby zatrzymać operację. Jeśli wyjątek `XmlDocument` powróci do stanu pierwotnego.  
  
 Wszystkie węzły utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, są uwzględnione w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ bieżącego węzła.</summary>
        <value>Typ węzła. Aby uzyskać <see langword="XmlDocument" /> węzłów, ta wartość jest XmlNodeType.Document.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlDocument" /> do którego należy bieżący węzeł.</summary>
        <value>Aby uzyskać <see langword="XmlDocument" /> węzłów (<see cref="P:System.Xml.XmlDocument.NodeType" /> jest równe XmlNodeType.Document), ta właściwość zawsze zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera węzeł nadrzędny tego węzła (węzły, które mogą mieć elementów nadrzędnych).</summary>
        <value>Zawsze zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveWhitespace { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy chcesz zachować biały znak w zawartości elementu.</summary>
        <value>
          <see langword="true" /> Aby zachować biały znak w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa sposób obsługi biały znak podczas ładowania i Zapisz procesu.  
  
 Jeśli `PreserveWhitespace` jest `true` przed <xref:System.Xml.XmlDocument.Load%2A> lub <xref:System.Xml.XmlDocument.LoadXml%2A> jest wywoływana, białe węzły są konserwowane; w przeciwnym razie, jeśli ta właściwość jest `false`znaczący biały znak jest zachowywana, nie jest biały znak.  
  
 Jeśli `PreserveWhitespace` jest `true` przed <xref:System.Xml.XmlDocument.Save%2A> jest wywoływana, biały znak w dokumencie jest zachowanego w danych wyjściowych; w przeciwnym razie, jeśli ta właściwość jest `false`, `XmlDocument` wcięć automatycznie dane wyjściowe.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak usunąć biały znak z pliku.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `book.xml` jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadNode (reader As XmlReader) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReadNode(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Źródło XML</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> obiekt na podstawie informacji w <see cref="T:System.Xml.XmlReader" />. Czytnik musi być umieszczony w węźle lub atrybutu.</summary>
        <returns>Nowy <see langword="XmlNode" /> lub <see langword="null" /> Jeśli nie istnieją żadne więcej węzłów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odczytuje jedną `XmlNode` z danym czytnika i umieszcza na następny węzeł czytnika. Ta metoda tworzy typ `XmlNode` dopasowania <xref:System.Xml.XmlNode.NodeType%2A> , na którym aktualnie znajduje się czytnika. (Jeśli czytnik jest w stanie początkowym `ReadNode` przesuwa czytnik pierwszy węzeł i następnie działa w tym węźle.)  
  
 Jeśli czytnik znajduje się na początku elementu, `ReadNode` odczytuje wszystkie atrybuty i wszystkich podrzędnych węzłów, maksymalnie i, w tym do tagu końcowego bieżącego węzła. `XmlNode` Zwrócił zawiera poddrzewa reprezentujący wszystko do odczytu. Czytnik znajduje się bezpośrednio po tagu końcowego.  
  
 `ReadNode` Ponadto mogą odczytywać atrybuty, ale w takim przypadku go nie dojściu czytnik do następnego atrybutu. Dzięki temu można zapisać następującego kodu C#:  
  
```csharp  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode` korzystać z wartością atrybutu, co oznacza, że po wywołaniu `ReadNode` atrybutu <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `ReadNode` do utworzenia nowego węzła i wstawia nowy węzeł do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `cd.xml`, jak wejściowego.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Czytnik jest ustawiony dla typu węzła, który nie wymaga prawidłowego węzła modelu DOM (na przykład EndElement lub EndEntity).</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda ma żądanie dziedziczenia. Pełne zaufanie jest wymagany do przesłonięcia <see langword="ReadNode" /> metody.  Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).</para>
        </block>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dokument XML do określonej lokalizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (outStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::Stream ^ outStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">Strumień, do której chcesz zapisać.</param>
        <summary>Zapisuje dokument XML do określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biały znak są zachowywane tylko wtedy, gdy <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> ma ustawioną wartość `true`.  
  
 XmlDeclaration bieżącego `XmlDocument` obiektu Określa atrybut kodowania w zapisany dokument. Wartość atrybutu kodowania jest pobierana z <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> właściwości. Jeśli `XmlDocument` jest ma XmlDeclaration lub jeśli XmlDeclaration nie ma atrybutu kodowania, zapisany dokument nie będzie miał jedną albo.  
  
 Po zapisaniu dokumentu xmlns atrybuty są generowane w celu utrwalenia tożsamości węzła (lokalna nazwa + identyfikator URI przestrzeni nazw) poprawnie. Na przykład następujący kod C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generuje ten atrybut dane XML `<item xmls="urn:1"/>`.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Uwaga tylko <xref:System.Xml.XmlDocument.Save%2A> metody wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia tylko zagwarantować poprawnie sformułowanym fragmentem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie spowoduje poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see langword="TextWriter" /> , Do której ma zostać zapisany.</param>
        <summary>Zapisuje dokument XML do określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie na `TextWriter` Określa kodowanie jest zapisywany (kodowanie węzła XmlDeclaration zastępuje kodowanie `TextWriter`). Jeśli nie było żadnych kodowanie określone na `TextWriter`, `XmlDocument` zapisaniu bez atrybutu kodowania.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Uwaga tylko <xref:System.Xml.XmlDocument.Save%2A> metody wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia tylko zagwarantować poprawnie sformułowanym fragmentem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie spowoduje poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Lokalizacja pliku, w której chcesz zapisać plik.</param>
        <summary>Zapisuje dokument XML do określonego pliku. Jeśli określony plik istnieje, ta metoda zastępuje go.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biały znak są zachowywane w pliku danych wyjściowych, tylko gdy <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> ma ustawioną wartość `true`.  
  
 XmlDeclaration bieżącego `XmlDocument` obiektu Określa atrybut kodowania w zapisany dokument. Wartość atrybutu kodowania jest pobierana z <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> właściwości. Jeśli `XmlDocument` jest ma XmlDeclaration lub jeśli XmlDeclaration nie ma atrybutu kodowania, zapisany dokument nie będzie miał jedną albo.  
  
 Po zapisaniu dokumentu xmlns atrybuty są generowane w celu utrwalenia tożsamości węzła (lokalna nazwa + identyfikator URI przestrzeni nazw) poprawnie. Na przykład następujący kod C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generuje ten atrybut dane XML `<item xmls="urn:1"/>`.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Uwaga tylko <xref:System.Xml.XmlDocument.Save%2A> metody wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia tylko zagwarantować poprawnie sformułowanym fragmentem.  
  
   
  
## Examples  
 Poniższy przykład ładuje XML do obiektu XmlDocument, modyfikuje go i jest zapisywany w pliku o nazwie data.xml.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 Plik data.xml będzie zawierał następujące XML: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie spowoduje poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::Xml::XmlWriter ^ w);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">
          <see langword="XmlWriter" /> , Do której ma zostać zapisany.</param>
        <summary>Zapisuje dokument XML do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biały znak są zachowywane tylko wtedy, gdy <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> ma ustawioną wartość `true`.  
  
 Kodowanie na `XmlWriter` Określa kodowanie jest zapisywany (kodowanie węzła XmlDeclaration zastępuje kodowanie `XmlWriter`). Jeśli nie było żadnych kodowanie określone na `XmlWriter`, `XmlDocument` zapisaniu bez atrybutu kodowania.  
  
 Po zapisaniu dokumentu xmlns atrybuty są generowane w celu utrwalenia tożsamości węzła (LocalName + NamespaceURI) poprawnie. Na przykład następujący kod C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generuje ten atrybut dane XML:  
  
```xml  
<item  
    xmls="urn:1"/>  
```  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Uwaga tylko <xref:System.Xml.XmlDocument.Save%2A> metody wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia tylko zagwarantować poprawnie sformułowanym fragmentem.  
  
   
  
## Examples  
 Poniższy przykład załaduje XML do `XmlDocument` obiektu i zapisuje je w pliku.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie spowoduje poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca po-Schema-weryfikacji-typu Infoset (PSVI) węzła.</summary>
        <value>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> Obiekt reprezentujący PSVI węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawartość PSVI tej właściwości są ustawiane po sprawdzeniu poprawności węzła.  
  
 Ta właściwość jest rozszerzenie Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Xml.Schema.XmlSchemaSet" /> obiekt skojarzony z tym <see cref="T:System.Xml.XmlDocument" />.</summary>
        <value>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Obiektu zawierającego schematy języka definicji schematu XML (XSD) skojarzony z tym <see cref="T:System.Xml.XmlDocument" />; w przeciwnym razie wartość pustą <see cref="T:System.Xml.Schema.XmlSchemaSet" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schematy zawarte w <xref:System.Xml.Schema.XmlSchemaSet> obiekt skojarzony z <xref:System.Xml.XmlDocument> obiektu są używane do sprawdzania poprawności podczas <xref:System.Xml.XmlDocument.Validate%2A> metoda <xref:System.Xml.XmlDocument> jest wykonywana.  
  
 Gdy <xref:System.Xml.XmlDocument> obiekt został zainicjowany przy użyciu danych XML z <xref:System.Xml.XmlReader> obiektu <xref:System.Xml.Schema.XmlSchemaSet> obiektu są ładowane z <xref:System.Xml.XmlReaderSettings.Schemas%2A> właściwość <xref:System.Xml.XmlReader> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weryfikuje <see cref="T:System.Xml.XmlDocument" /> względem schematów języka definicji schematu XML (XSD) zawartych w <see cref="P:System.Xml.XmlDocument.Schemas" /> właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> Obiekt, który odbiera informacje o schemacie weryfikacji ostrzeżeń i błędów.</param>
        <summary>Weryfikuje <see cref="T:System.Xml.XmlDocument" /> względem schematów języka definicji schematu XML (XSD) zawartych w <see cref="P:System.Xml.XmlDocument.Schemas" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> Metoda sprawdza poprawność danych XML w <xref:System.Xml.XmlDocument> względem schematów zawartych w <xref:System.Xml.XmlDocument.Schemas%2A> właściwości. <xref:System.Xml.XmlDocument.Validate%2A> Metoda przeprowadza rozszerzeniu typu infoset. W szczególności po sprawdzeniu poprawności schematu wartości domyślne są stosowane wartości tekstowe są konwertowane na atomic wartości zgodnie z potrzebami i informacje o typie jest skojarzony z elementami zweryfikowanych informacji. Wynik jest wcześniej wyrażeniami bez typu drzewa podrzędnego XML w <xref:System.Xml.XmlDocument> zastąpione maszynowy poddrzewa.  
  
 Poniżej przedstawiono ważne uwagi, które należy wziąć pod uwagę przy użyciu <xref:System.Xml.XmlDocument.Validate%2A> metody.  
  
-   Wskazówki dotyczące lokalizacji schematu, takich jak `xsi:schemaLocation` lub `xsi:noNamespaceSchemaLocation` są ignorowane.  
  
-   Wbudowane schematy są ignorowane.  
  
-   Jeśli występują błędy sprawdzania poprawności schematu podczas sprawdzania poprawności <xref:System.Xml.XmlDocument> staje się częściowo zweryfikowane z niektóre węzły z informacjami o poprawny typ, a niektóre bez.  
  
-   Proces ten obejmuje sprawdzanie ograniczenia unikatowości i odwołania (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, i `xs:unique`).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Xml.XmlDocument.Validate%2A> metody. W przykładzie jest tworzony <xref:System.Xml.XmlDocument> zawierający skojarzoną używając schematu XSD <xref:System.Xml.XmlReaderSettings> i <xref:System.Xml.XmlReader> obiektów. W przykładzie następnie użyto <xref:System.Xml.XPath.XPathNavigator> klasy niepoprawnie zmodyfikować wartość typu elementu w dokumencie XML generowania błąd sprawdzania poprawności schematu.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 Przykład przyjmuje `contosoBooks.xml` i `contosoBooks.xsd` pliki jako dane wejściowe.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Wystąpiło zdarzenie sprawdzania poprawności schematu i nie <see cref="T:System.Xml.Schema.ValidationEventHandler" /> określono obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, System::Xml::XmlNode ^ nodeToValidate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> Obiekt, który odbiera informacje o schemacie weryfikacji ostrzeżeń i błędów.</param>
        <param name="nodeToValidate">
          <see cref="T:System.Xml.XmlNode" /> Utworzone na podstawie obiektu <see cref="T:System.Xml.XmlDocument" /> do sprawdzania poprawności.</param>
        <summary>Weryfikuje <see cref="T:System.Xml.XmlNode" /> obiektu określony względem schematów języka definicji schematu XML (XSD) w <see cref="P:System.Xml.XmlDocument.Schemas" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> Metoda sprawdza poprawność danych XML w <xref:System.Xml.XmlNode> obiektu względem schematów zawartych w <xref:System.Xml.XmlDocument.Schemas%2A> właściwości. <xref:System.Xml.XmlDocument.Validate%2A> Metoda przeprowadza rozszerzeniu typu infoset. W szczególności po sprawdzeniu poprawności schematu wartości domyślne są stosowane wartości tekstowe są konwertowane na atomic wartości zgodnie z potrzebami i informacje o typie jest skojarzony z elementami zweryfikowanych informacji. Wynik jest wcześniej wyrażeniami bez typu drzewa podrzędnego XML w <xref:System.Xml.XmlDocument> zastąpione maszynowy poddrzewa.  
  
 Poniżej przedstawiono ważne uwagi, które należy wziąć pod uwagę przy użyciu <xref:System.Xml.XmlDocument.Validate%2A> metody.  
  
-   Wskazówki dotyczące lokalizacji schematu, takich jak `xsi:schemaLocation` lub `xsi:noNamespaceSchemaLocation` są ignorowane.  
  
-   Wbudowane schematy są ignorowane.  
  
-   Jeśli występują błędy sprawdzania poprawności schematu podczas sprawdzania poprawności <xref:System.Xml.XmlDocument> staje się częściowo zweryfikowane z niektóre węzły z informacjami o poprawny typ, a niektóre bez.  
  
 Jeśli węzeł do zweryfikowania jest węzłem głównym, proces ten obejmuje sprawdzanie ograniczenia unikatowości i odwołania (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, i `xs:unique`); w przeciwnym razie unikatowości i odwołania ograniczenia są pomijane.  
  
   
  
## Examples  
 Przykład <xref:System.Xml.XmlDocument.Validate%2A> metody, zobacz <xref:System.Xml.XmlDocument.Validate%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Xml.XmlNode" /> Parametr obiektu nie został utworzony na podstawie <see cref="T:System.Xml.XmlDocument" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlNode" /> Parametr obiektu nie jest elementem, atrybut, fragment dokumentu lub węzła głównego.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Wystąpiło zdarzenie sprawdzania poprawności schematu i nie <see cref="T:System.Xml.Schema.ValidationEventHandler" /> określono obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteContentTo (xw As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteContentTo(System::Xml::XmlWriter ^ xw);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">
          <see langword="XmlWriter" /> , Do której ma zostać zapisany.</param>
        <summary>Zapisuje wszystkie elementy podrzędne elementu <see langword="XmlDocument" /> węzła do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jest funkcjonalnym odpowiednikiem <xref:System.Xml.XmlDocument.InnerXml%2A> właściwości.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Właściwość określa metodę kodowania, która jest zapisywany. Jeśli `Encoding` właściwość nie ma wartości `XmlDocument` jest zapisywany bez atrybutu kodowania.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dokumentu na ekranie.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">
          <see langword="XmlWriter" /> , Do której ma zostać zapisany.</param>
        <summary>Zapisuje <see langword="XmlDocument" /> węzła do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jest funkcjonalnym odpowiednikiem <xref:System.Xml.XmlNode.OuterXml%2A> właściwości.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Właściwość określa metodę kodowania, która jest zapisywany. Jeśli `Encoding` właściwość nie ma wartości `XmlDocument` jest zapisywany bez atrybutu kodowania.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dokumentu na ekranie.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zestawy <see cref="T:System.Xml.XmlResolver" /> do użycia w celu rozpoznawania zasobów zewnętrznych.</summary>
        <value>
          <see langword="XmlResolver" /> Do użycia.  W wersji 1.1 środowiska.NET Framework obiekt wywołujący musi być w pełni zaufany, aby określić <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlResolver` Można załadować definicji DTD lub rozwiń odwołań do jednostek. Przy użyciu <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> właściwości, można ustawić poświadczeń na `XmlResolver` dostęp do zasobów przechowywanych w zasobie bezpiecznej sieci.  
  
-   Jeśli dokument nie został załadowany przy użyciu <xref:System.Xml.XmlReader> (to znaczy, jeśli został załadowany, przy użyciu strumienia, plików i tak dalej) `XmlResolver` na `XmlDocument` zawsze jest używany.  
  
-   Jeśli dokument został załadowany z <xref:System.Xml.XmlTextReader>, program rozpoznawania nazw na `XmlTextReader` jest używany do rozpoznawania odwołań DTD w węźle dokumentu. Program rozpoznawania nazw na `XmlDocument` jest używany do zwiększenia żadnych odwołań do jednostek.  
  
-   Jeśli dokument został załadowany z <xref:System.Xml.XmlValidatingReader>, program rozpoznawania nazw na `XmlDocument` nie jest nigdy używane.  
  
-   Jeśli dokument został załadowany z klasy, która rozszerza `XmlReader` i `XmlReader` nie można rozpoznać jednostki (<xref:System.Xml.XmlReader.CanResolveEntity%2A> zwraca `false`), `XmlResolver` na `XmlDocument` jest używany do rozpoznawania odwołań w węźle dokumentu i rozwiń żadnych odwołań do jednostek.  
  
> [!NOTE]
>  Jeśli `XmlDocument` jest ładowane przy użyciu <xref:System.Xml.XmlReader> które `XmlResolver` ustawioną, `XmlResolver` na `XmlReader` nie jest buforowana przez `XmlDocument` po <xref:System.Xml.XmlDocument.Load%2A> zakończeniu.  
  
 Jeśli ta właściwość nie jest ustawiona, poziom zaufania aplikacji w wersji 1.1 środowiska.NET Framework określa zachowanie domyślne.  
  
 `Fully trusted code:` Dokument używa domyślnego <xref:System.Xml.XmlUrlResolver> bez poświadczeń użytkownika. Jeśli wymagane jest uwierzytelnienie dostępu do zasobu sieciowego, użyj `XmlResolver` właściwości w celu określenia `XmlResolver` niezbędne poświadczenia.  
  
 `Semi-trusted code:` `XmlResolver` Właściwość jest ustawiona na `null`. Nie można rozpoznać zasobów zewnętrznych.  
  
 Aby uzyskać więcej informacji na temat zabezpieczeń i `XmlResolver` właściwości, zobacz [rozpoznawania zasobów zewnętrznych](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Ta właściwość jest rozszerzenie Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład ładowania dokumentu XML, który zawiera odwołanie do pliku definicji DTD. `XmlResolver` Właściwość jest używana do ustawiania poświadczeń niezbędnych do uzyskania dostępu do zasobu sieciowego.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 W przykładzie użyto następujących plików danych jako dane wejściowe.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ta właściwość jest ustawiona na <see langword="null" /> i napotkano zewnętrzna definicja DTD lub jednostki.</exception>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
      </Docs>
    </Member>
  </Members>
</Type>
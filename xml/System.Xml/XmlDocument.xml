<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9f33dc0a4104d7a624a771aa91551418b68ca2d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37731871" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDocument&#xA;Inherits XmlNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDocument : System::Xml::XmlNode" />
  <TypeSignature Language="F#" Value="type XmlDocument = class&#xA;    inherit XmlNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje dokumentu XML. Ta klasa służy do ładowania, sprawdzanie poprawności, Edytuj, dodać i umieść XML w dokumencie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a> <xref:System.Xml.XmlDocument> Klasa znajduje się w pamięci reprezentacja dokumentu XML. Implementuje W3C [XML Document Object Model (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md) poziomu 1 Core i Core DOM poziomu 2.  
  
 *DOM* oznacza *model obiektu dokumentu*. Aby dowiedzieć się więcej o tym, zobacz [XML Document Object Model (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 Możesz załadować XML do modelu DOM przy użyciu <xref:System.Xml.XmlDocument> klasy, a następnie programowo odczytu, modyfikowania i usuwania XML w dokumencie.  
  
 Jeśli chcesz pry Otwórz <xref:System.Xml.XmlDocument> klasy i zobacz, jak jest zaimplementowane, zobacz [źródło odwołania](https://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Zadania  
  
-   [Ładowania XML document object model](#Load)  
  
-   [Sprawdzić jego poprawność schematu](#Validation)  
  
-   [Przejdź w drzewie dokumentu](#Navigate)  
  
-   [Znajdź węzły](#Find)  
  
-   [Upravit uzly](#Edit)  
  
-   [Dodawanie węzłów](#Add)  
  
-   [Usuwanie węzłów](#Remove)  
  
-   [Położenie węzłów](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Ładowania XML document object model  
 Uruchom za pomocą dokumentu XML, podobny do poniższego. Konieczne jest kilku książek w kolekcji. Ale zawiera podstawowe czynności, które znajdziesz w dokumentach XML; przestrzeń nazw, elementy, które reprezentują dane i atrybuty, które opisują dane.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 Następnie załaduj te dane do modelu DOM, dzięki czemu możesz pracować z nim w pamięci. Najpopularniejszym sposobem wykonania tych czynności jest odwołuje się do pliku na komputerze lokalnym lub w sieci.  
  
 W tym przykładzie ładuje XML z pliku. Jeśli plik nie istnieje, po prostu generuje niektóre XML i ładuje, który.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [wczytywanie dokumentu XML do modelu DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Sprawdzić jego poprawność schematu  
 Zacznij od schematu XML, podobny do tego. Ten schemat definiuje typy danych w pliku XML i atrybutów, które są wymagane.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Utwórz <xref:System.Xml.XmlReader> obiektu przy użyciu schematu, a następnie załadować ten obiekt do modelu DOM. Tworzenie procedury obsługi zdarzeń, który jest wykonywany, gdy kod próbuje zmodyfikować pliku XML w sposób, który narusza zasady schematu.  
  
 Te bloki kodu pokazują metody pomocnika, które to wszystko zrobić.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [Weryfikowanie dokumentu XML w modelu DOM](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Przejdź w drzewie dokumentu  
 Właściwości można użyć do poruszania się w dokumencie XML. Jednak przed użyciem dowolnego z nich szybko Omówmy kilka warunków. Dokument składa się z węzłów. Każdy węzeł ma jako pojedynczej *nadrzędnego* węzeł bezpośrednio znad niej. Tylko węzeł, który nie ma węzła nadrzędnego jest głównym dokumentu, ponieważ jest węzeł najwyższego poziomu. Większość węzłów może mieć *podrzędnych* węzły, które są węzłami bezpośrednio poniżej. Węzły, które znajdują się na tym samym poziomie są *elementów równorzędnych*.  
  
 Poniższe przykłady pokazują, jak uzyskać węzeł główny, przejdź do pierwszy węzeł podrzędny węzła głównego, dostępu do żadnego z jego węzłów podrzędnych, wrócić do węzła nadrzędnego i przejdź węzłów elementów równorzędnych.  
  
 **Rozpocznij z węzła głównego.**  
  
 W tym przykładzie pobiera węzła głównego, a następnie używa tego węzła, aby wyprowadzić zawartość dokumentu w konsoli.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Pobieranie węzłów podrzędnych**  
  
 W tym przykładzie przechodzi pierwszy węzeł podrzędny węzła głównego i następnie iterację przez węzły podrzędne tego węzła, jeśli takie istnieją.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Wróć do węzła nadrzędnego**  
  
 Użyj <xref:System.Xml.XmlDocument.ParentNode%2A> właściwości.  
  
 **Zapoznaj się z ostatnim węzeł podrzędny**  
  
 Ten przykład Przepisuje ceny książki do konsoli (jest to ostatni węzeł podrzędny węzła książki).  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Przejdź do przodu dla elementów równorzędnych**  
  
 W tym przykładzie przenosi do przodu książki książki. Książki węzły są powiązane ze sobą.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Przejdź wstecz różnych elementów równorzędnych**  
  
 W tym przykładzie Przechodzi wstecz z książki do książki.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Znajdź węzły  
 Najpopularniejszym sposobem znalezienia jeden lub więcej węzłów danych jest użycie ciągu kwerendy XPath, ale istnieją również metody, które nie wymagają jednego.  
  
 **Pobieranie pojedynczego węzła**  
  
 W tym przykładzie lokalizuje książki przy użyciu numer ISBN.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 Ciąg używany w tym przykładzie jest zapytanie Xpath. Można znaleźć więcej przykładów dotyczących ich w tym miejscu: [przykłady XPath](https://msdn.microsoft.com/library/ms256086.aspx).  
  
 Można również użyć <xref:System.Xml.XmlDocument.GetElementById%2A> można pobrać węzłów. Aby użyć tej metody, należy określić identyfikatory w deklaracjach definicji typu dokumentu w pliku XML.  
  
 Po otrzymaniu węzeł otrzymasz wartości atrybutów i węzłów podrzędnych. Ten przykład robi to za pomocą węzła książki.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Pobierz kolekcję węzłów**  
  
 W tym przykładzie wybiera wszystkie książki, gdzie jest nazwisko autora **Austen**, a następnie zmienia ceny te książek.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Możesz także uzyskać kolekcję węzłów przy użyciu nazwy węzła. Na przykład w tym przykładzie pobiera zbiór wszystkich tytułów książek.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [Wybierz węzły za pomocą nawigacji XPath](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Upravit uzly  
 W tym przykładzie edytuje węzła książki i jego atrybuty.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Dowiedz się więcej:** [modyfikowanie węzłów, zawartości i wartości w dokumencie XML](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Dodawanie węzłów  
 Aby dodać węzeł, użyj <xref:System.Xml.XmlDocument.CreateElement%2A> metody lub <xref:System.Xml.XmlDocument.CreateNode%2A> metody.  
  
 Aby dodać węzeł danych, takich jak książki, użyj <xref:System.Xml.XmlDocument.CreateElement%2A> metody.  
  
 Dla każdego typu węzła takiego jak Użyj komentarza, węzeł odstępu lub węzeł CDATA <xref:System.Xml.XmlDocument.CreateNode%2A> metody.  
  
 W tym przykładzie tworzy węzeł książki, dodaje attrubutes do tego węzła i następnie dodaje ten węzeł w dokumencie.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [Wstawianie węzłów do dokumentu XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Usuwanie węzłów  
 Aby usunąć węzeł, użyj <xref:System.Xml.XmlNode.RemoveChild%2A> metody.  
  
 W tym przykładzie usuwa książki z dokumentu, a wszystkie białe znaki, który pojawia się tuż przed węzła książki.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Dowiedz się więcej:** [usuwanie węzłów, zawartości i wartości z dokumentu XML](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Położenie węzłów  
 Można wybrać, którego węzła pojawią się w dokumencie za pomocą <xref:System.Xml.XmlNode.InsertBefore%2A> i <xref:System.Xml.XmlNode.InsertAfter%2A> metody.  
  
 W tym przykładzie przedstawiono dwie metody pomocnika. Jeden z nich przenosi wyższe węzła na liście. Druga przenosi niższych węźle.  
  
 Tych metod można użyć w aplikacji, która umożliwia użytkownikom przenoszenie książki w górę i w dół na liście książki. Gdy użytkownik wybierze książki i naciska klawisz w górę lub w dół przycisku, kod można wywoływać metod, takich jak te pozycja odpowiedniego węzła książki, przed lub po innych węzłów książki do.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Pełny przykład:** [manipulowanie XML w pamięci przy użyciu obiektu XmlDocument klasy i inne powiązane typy](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.XmlNodeChangedEventHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDocument" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.XmlDocument" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Oto przykład weryfikacji czas ładowania. Weryfikowanie definition (DTD) typu dokumentu <xref:System.Xml.XmlReader> jest przekazywany do <xref:System.Xml.XmlDocument.Load%2A> metody i <xref:System.Xml.Schema.ValidationEventHandler> znajduje się w celu powiadomienia użytkowników o wszelkie błędy sprawdzania poprawności. W tym przykładzie zostanie znaleziony błąd sprawdzania poprawności, ale dokument jest nadal ładowany. Alternatywnie można zdefiniować, sprawdzanie poprawności <xref:System.Xml.XmlReader> zgłoszenie wyjątku i Zatrzymaj proces ładowania, gdy błąd sprawdzania poprawności zostanie znaleziony, nie określając <xref:System.Xml.Schema.ValidationEventHandler>. Aby uzyskać więcej informacji o weryfikacji danych XML, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 W przykładzie użyto `bookDTD.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlDocument.Load(System.String)" />
        <altmember cref="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New (imp As XmlImplementation)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; XmlDocument(System::Xml::XmlImplementation ^ imp);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlImplementation -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument imp" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">
          <see langword="XmlImplementation" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlDocument" /> klasy z określonym <see cref="T:System.Xml.XmlImplementation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlNameTable -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">
          <see langword="XmlNameTable" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlDocument" /> klasy z określonym <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowy identyfikator URI bieżącego węzła.</summary>
        <value>Lokalizacja, z którego został załadowany węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sieciowych dokumentu XML składa się z fragmentów dane zagregowane, przy użyciu różnych mechanizmów włączenia standard W3C, dlatego zawiera węzły, które pochodzą z różnych miejsc. `BaseURI` Informujący o tym, skąd pochodzą te węzły.  
  
 W przypadku węzłów dokumentu `BaseURI` Zwraca lokalizację dokumentu XML. Na przykład jeśli `XmlDocument` został załadowany za pomocą następujących dokumentów wywołania. Obciążenia ("http://server/mydata.xml"), `BaseURI` dla dokumentu jest węzeł http://server/mydata.xml. Jednak jeśli <xref:System.Xml.XmlDocument.Load%2A> metody jest przekierowywane przez serwer pod inny identyfikator URI `BaseURI` zwraca oryginalny identyfikator URI przekazywany do `Load` metody.  
  
 Ta właściwość jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Aby uzyskać dodatkowe informacje na temat `BaseURI` i zobacz, jak działa przy użyciu innych typów węzła <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">
          <see langword="true" /> rekursywnie Klonuj poddrzewo w określonym węźle; <see langword="false" /> sklonować tylko węzeł.</param>
        <summary>Tworzy duplikat tego węzła.</summary>
        <returns>Sklonowany <see langword="XmlDocument" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy jako konstruktora kopiującego dla węzłów. Sklonowany węzeł nie ma elementu nadrzędnego (<xref:System.Xml.XmlNode.ParentNode%2A> zwraca `null`).  
  
 Jeśli `deep` jest `true`, sklonowany węzeł zawiera wszystkie węzły podrzędne, w przeciwnym razie tylko `XmlDocument` węzeł został sklonowany. Zobacz <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> metodę, aby zobaczyć, jak metoda ta działa w ramach innych typów węzłów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje różnicę między klonowania szczegółowe i skrócona.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> o określonej nazwie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (name As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu. Jeśli nazwa zawiera dwukropek, <see cref="P:System.Xml.XmlNode.Prefix" /> właściwość odzwierciedla części nazwy poprzedzających z pierwszym dwukropkiem i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwość odzwierciedla części nazwy zgodnie z pierwszym dwukropkiem. <see cref="P:System.Xml.XmlNode.NamespaceURI" /> Pozostanie puste, chyba że prefiks jest rozpoznany prefiks wbudowanych, takich jak xmlns. W tym przypadku <see langword="NamespaceURI" /> ma wartość http://www.w3.org/2000/xmlns/.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> z określonym <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>Nowy <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Mogą być dodawane do <xref:System.Xml.XmlElement> przy użyciu <xref:System.Xml.XmlElement.SetAttributeNode%2A> metody.  
  
   
  
## Examples  
 Następujące tworzy atrybut i dodaje go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (qualifiedName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Kwalifikowana nazwa atrybutu. Jeśli nazwa zawiera dwukropek, a następnie <see cref="P:System.Xml.XmlNode.Prefix" /> właściwość będzie odzwierciedlać części nazwy poprzedzający dwukropek i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwość będzie odzwierciedlać część nazwy po dwukropku.</param>
        <param name="namespaceURI">Jego identyfikator namespaceURI atrybutu. Jeśli kwalifikowana nazwa obejmuje prefiks xmlns, a następnie ten parametr musi być http://www.w3.org/2000/xmlns/.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> z określoną nazwą kwalifikowaną i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Mogą być dodawane do <xref:System.Xml.XmlElement> przy użyciu <xref:System.Xml.XmlElement.SetAttributeNode%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks atrybutu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne.</param>
        <param name="localName">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne. Jeśli <c>prefiks</c> jest xmlns, a następnie ten parametr musi być http://www.w3.org/2000/xmlns/; w przeciwnym razie jest zgłaszany wyjątek.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlAttribute" /> z określonym <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Mogą być dodawane do <xref:System.Xml.XmlElement> przy użyciu <xref:System.Xml.XmlElement.SetAttributeNode%2A> metody.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateCDataSection (data As String) As XmlCDataSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlCDataSection ^ CreateCDataSection(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateCDataSection : string -&gt; System.Xml.XmlCDataSection&#xA;override this.CreateCDataSection : string -&gt; System.Xml.XmlCDataSection" Usage="xmlDocument.CreateCDataSection data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Zawartość nowego <see langword="XmlCDataSection" />.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlCDataSection" /> zawierający określone dane.</summary>
        <returns>Nowy <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) CDataSection węzły są dozwolone w ramach węzłów elementów i w węzłach EntityReference podczas węzeł obiektu EntityReference nie jest elementem podrzędnym węzła atrybutu .  
  
   
  
## Examples  
 Poniższy przykład tworzy węzeł CDATA i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateComment (data As String) As XmlComment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlComment ^ CreateComment(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateComment : string -&gt; System.Xml.XmlComment&#xA;override this.CreateComment : string -&gt; System.Xml.XmlComment" Usage="xmlDocument.CreateComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Zawartość nowego <see langword="XmlComment" />.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlComment" /> zawierający określone dane.</summary>
        <returns>Nowy <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły komentarza są dozwolone tylko w ramach węzłów dokumentu, Element i EntityReference, gdy węzeł obiektu EntityReference nie jest elementem podrzędnym atrybutu węzeł.  
  
   
  
## Examples  
 Poniższy przykład tworzy komentarz i dodaje go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDefaultAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XmlAttribute ^ CreateDefaultAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateDefaultAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks atrybutu (jeśli istnieje).</param>
        <param name="localName">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu (jeśli istnieje).</param>
        <summary>Tworzy domyślnego atrybutu z określonego prefiksu i lokalna nazwa identyfikatora URI obszaru nazw.</summary>
        <returns>Nowy <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentFragment () As XmlDocumentFragment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentFragment ^ CreateDocumentFragment();" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment&#xA;override this.CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment" Usage="xmlDocument.CreateDocumentFragment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>Nowy <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można wstawić DocumentFragment węzłów do dokumentu. Jednak może wstawiać elementy podrzędne węzła DocumentFragment do dokumentu.  
  
   
  
## Examples  
 Poniższy przykład dodaje nowe węzły w dokumencie XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentType (name As String, publicId As String, systemId As String, internalSubset As String) As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentType ^ CreateDocumentType(System::String ^ name, System::String ^ publicId, System::String ^ systemId, System::String ^ internalSubset);" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType&#xA;override this.CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType" Usage="xmlDocument.CreateDocumentType (name, publicId, systemId, internalSubset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="publicId" Type="System.String" />
        <Parameter Name="systemId" Type="System.String" />
        <Parameter Name="internalSubset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa typu dokumentu.</param>
        <param name="publicId">Identyfikator publiczny używanego typu dokumentu lub <see langword="null" />. Można określić publicznego identyfikatora URI oraz identyfikator systemu do identyfikowania lokalizacji zewnętrznego podzestawu DTD.</param>
        <param name="systemId">Identyfikator systemu używanego typu dokumentu lub <see langword="null" />. Określa adres URL lokalizacji pliku zewnętrznego podzestawu DTD.</param>
        <param name="internalSubset">Wewnętrzny podzbiór DTD używanego typu dokumentu lub <see langword="null" />.</param>
        <summary>Zwraca nowy <see cref="T:System.Xml.XmlDocumentType" /> obiektu.</summary>
        <returns>Nowy <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracany węzłów będzie mieć przeanalizować <xref:System.Xml.XmlDocumentType.Entities%2A> i <xref:System.Xml.XmlDocumentType.Notations%2A> kolekcji.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) typ węzły są dozwolone tylko w ramach węzłów dokumentu. Każdy <xref:System.Xml.XmlDocument> może mieć tylko jeden typ węzła. Węzeł DocumentType również należy wstawić przed elementem głównym `XmlDocument` (Jeśli dokument ma już element główny, nie można dodać węzła typu dokumentu).  
  
 Jeśli przekazanych parametrów nie można tworzyć prawidłową `XmlDocumentType`, zgłaszany jest wyjątek.  
  
   
  
## Examples  
 Poniższy przykład tworzy węzeł DocumentType i dodaje go do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda ma dziedziczenia. Pełne zaufanie jest wymagany do zastąpienia <see langword="CreateDocumentType" /> metody.  Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu. Jeśli nazwa zawiera dwukropek, a następnie <see cref="P:System.Xml.XmlNode.Prefix" /> właściwość odzwierciedla części nazwy poprzedzający dwukropek i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwość odzwierciedla część nazwy po dwukropku. Kwalifikowana nazwa nie może zawierać of'xmlns prefiks.</param>
        <summary>Tworzy element o określonej nazwie.</summary>
        <returns>Nowy <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że wystąpienie zwrócone implementuje `XmlElement` interfejsu, dzięki czemu atrybuty domyślne, które zostałyby utworzone bezpośrednio na zwracanym obiekcie.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzłów elementów są dozwolone w obrębie dokumentu i elementu węzłów i w węzłach obiektu EntityReference podczas węzeł obiektu EntityReference nie jest elementem podrzędnym Węzeł atrybutu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (qualifiedName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Kwalifikowana nazwa elementu. Jeśli nazwa zawiera dwukropek, a następnie <see cref="P:System.Xml.XmlNode.Prefix" /> właściwość będzie odzwierciedlać części nazwy poprzedzający dwukropek i <see cref="P:System.Xml.XmlDocument.LocalName" /> właściwość będzie odzwierciedlać część nazwy po dwukropku. Kwalifikowana nazwa nie może zawierać of'xmlns prefiks.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlElement" /> o kwalifikowanej nazwie i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy kod C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 wyniki w elemencie, który jest odpowiednikiem następującego tekstu XML.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzłów elementów są dozwolone w obrębie dokumentu i elementu węzłów i w węzłach obiektu EntityReference podczas węzeł obiektu EntityReference nie jest elementem podrzędnym Węzeł atrybutu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateElement : string * string * string -&gt; System.Xml.XmlElement&#xA;override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks nowego elementu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne.</param>
        <param name="localName">Lokalna nazwa nowego elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw nowego elementu (jeśli istnieje). String.Empty i <see langword="null" /> są równoważne.</param>
        <summary>Tworzy element z określonym <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy kod C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 Tworzy element jest odpowiednikiem następującego tekstu XML:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzłów elementów są dozwolone w obrębie dokumentu i elementu węzłów i w węzłach obiektu EntityReference podczas obiekt EntityReference znajduje się poza węzeł atrybutu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład dodaje nowy element do istniejącego dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityReference : string -&gt; System.Xml.XmlEntityReference&#xA;override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa odwołania do jednostki.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlEntityReference" /> o określonej nazwie.</summary>
        <returns>Nowy <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jednostka jest znana, listy podrzędnej `XmlEntityReference` węzła składa się taka sama jak odpowiadającego <xref:System.Xml.XmlEntity> węzła.  
  
 Przestrzenie nazw używane w tekst zastępczy dla odwołania do jednostki są powiązane w czasie, najpierw ustawiono element nadrzędny węzła odwołania jednostki, (na przykład, gdy węzeł odwołania jednostki są wstawiane do dokumentu). Na przykład biorąc pod uwagę następujące jednostki:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 Jeśli wywołasz `CreateEntityReference("a")` wrócisz jeden węzeł obiektu EntityReference typu bez elementów podrzędnych. Jeśli ten węzeł zostanie dodany jako element podrzędny następującego węzła  
  
```  
<item xmlns="urn:1"/>  
```  
  
 następnie podczas wywoływania <xref:System.Xml.XmlNode.AppendChild%2A>ustawiono element nadrzędny węzła odwołanie do nowo utworzonej jednostki i elementy podrzędne zostaną rozwinięte w tym kontekście przestrzeni nazw. Węzeł podrzędny element `b` będą miały równych NamespaceURI `urn:1`. Węzły podrzędne odwołania do jednostki pozostają takie same, nawet wtedy, gdy przeniesiesz odwołanie do jednostki w miejscu w dokumencie, który ma inny domyślny kontekst nazw. Nie jest to realizowane dla istniejących węzłów odwołanie do jednostki możesz usunąć i umieść je lub dla jednostek odwołuje się, że można sklonować przy użyciu <xref:System.Xml.XmlDocument.CloneNode%2A>. Zdarza się tylko dla odwołań do nowo utworzonej jednostki.  
  
 Jeśli odpowiednia jednostka nie jest zdefiniowany w DocumentType po dodaniu węzła odwołania jednostki, ponieważ odwołanie do jednostki nie jest zdefiniowana, jej tylko węzeł podrzędny będzie pusty węzeł tekstowy.  
  
 Amp wbudowanych jednostek, lt, gt, apos i quot są również dozwolone i będzie miał węzeł tekstowy podrzędne o wartość odpowiedniego znaku rozwinięty.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) EntityReference węzły są dozwolone tylko w ramach węzłów elementów, atrybutów i EntityReference.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwa węzły odwołania jednostki i wstawia je do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa jest nieprawidłowa (na przykład nazwy rozpoczynające się znakiem "#" są nieprawidłowe.)</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania w tym dokumencie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania w tym dokumencie.</summary>
        <returns>
          <see cref="T:System.Xml.XPath.XPathNavigator" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> na przykład przy użyciu tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <see cref="T:System.Xml.XmlNode" /> Ma Nawigator wstępnie umieszczone na.</param>
        <summary>Tworzy <see cref="T:System.Xml.XPath.XPathNavigator" /> obiektu do nawigowania w tym dokumencie umieszczony na <see cref="T:System.Xml.XmlNode" /> określony.</summary>
        <returns>
          <see cref="T:System.Xml.XPath.XPathNavigator" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> na przykład przy użyciu tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (nodeTypeString As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::String ^ nodeTypeString, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (nodeTypeString, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Ciąg wersji <see cref="T:System.Xml.XmlNodeType" /> nowego węzła. Ten parametr musi być jedna z wartości wymienionych w poniższej tabeli.</param>
        <param name="name">Kwalifikowana nazwa nowego węzła. Jeśli nazwa zawiera dwukropka, jest przekształcany do <see cref="P:System.Xml.XmlNode.Prefix" /> i <see cref="P:System.Xml.XmlDocument.LocalName" /> składników.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw nowego węzła.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> z typem określonego węzła <see cref="P:System.Xml.XmlDocument.Name" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `nodeTypeString` Parametru jest uwzględniana wielkość liter i musi mieć jedną z wartości w tabeli poniżej.  
  
|nodeTypeString|XmlNodeType|  
|--------------------|-----------------|  
|— atrybut|Atrybut|  
|cdatasection|CDATA|  
|komentarz|Komentarz|  
|dokument|dokument|  
|DocumentFragment|DocumentFragment|  
|Typ|Typ|  
|— element|Element|  
|Obiekt EntityReference|Obiekt EntityReference|  
|processinginstruction|ProcessingInstruction|  
|significantwhitespace|SignificantWhitespace|  
|tekst|Tekst|  
|białe znaki|Białe znaki|  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 W poniższej tabeli przedstawiono jakie NodeType [wiersz] jest dozwolona wewnątrz innej NodeType [kolumna] zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||dokument|Typ|XmlDeclaration|Element|Atrybut|Tekst|CDATA|Kod znaczników|Obiekt EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`DocumentType`|tak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`XmlDeclaration`|tak *|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`Element`|tak|Brak|Brak|tak|Brak|Brak|Brak|Brak|tak ***|  
|`Attribute`|Brak|Brak|Brak|tak ***|Brak|Brak|Brak|Brak|Brak|  
|`Text`|Brak|Brak|Brak|tak|tak|Brak|Brak|Brak|tak|  
|`CDATA`|Brak|Brak|Brak|tak|Brak|Brak|Brak|Brak|tak ***|  
|`Markup**`|tak|Brak|Brak|tak|Brak|Brak|Brak|Brak|Brak|  
|`EntityReference`|Brak|Brak|Brak|tak|tak|Brak|Brak|Brak|tak|  
  
 \* Węzeł XmlDeclaration musi być pierwszym elementem podrzędnym węzła dokumentu.  
  
 ** Znaczników zawiera węzły ProcessingInstruction i komentarz.  
  
 Element i CDATA węzły są dozwolone tylko w węzły EntityReference, gdy węzeł obiektu EntityReference nie jest elementem podrzędnym węzła atrybutu.  
  
 Atrybuty nie są elementy podrzędne węzła elementu. Atrybuty są zawarte wewnątrz kolekcji atrybutów, którego należy węzeł elementu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i wstawia go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano nazwy i <see langword="XmlNodeType" /> wymaga nazwy; lub <paramref name="nodeTypeString" /> nie jest jednym z ciągów wymienionych poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see langword="XmlNodeType" /> Nowego węzła.</param>
        <param name="name">Kwalifikowana nazwa nowego węzła. Jeśli nazwa zawiera dwukropek, a następnie jest przekształcany do <see cref="P:System.Xml.XmlNode.Prefix" /> i <see cref="P:System.Xml.XmlDocument.LocalName" /> składników.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw nowego węzła.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> z określonym <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 W poniższej tabeli przedstawiono jakie NodeType [wiersz] jest dozwolona wewnątrz innej NodeType [kolumna] zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||dokument|Typ|XmlDeclaration|Element|Atrybut|Tekst|CDATA|Kod znaczników|Obiekt EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`DocumentType`|tak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`XmlDeclaration`|tak *|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`Element`|tak|Brak|Brak|tak|Brak|Brak|Brak|Brak|tak ***|  
|`Attribute`|Brak|Brak|Brak|tak ***|Brak|Brak|Brak|Brak|Brak|  
|`Text`|Brak|Brak|Brak|tak|tak|Brak|Brak|Brak|tak|  
|`CDATA`|Brak|Brak|Brak|tak|Brak|Brak|Brak|Brak|tak ***|  
|`Markup**`|tak|Brak|Brak|tak|Brak|Brak|Brak|Brak|Brak|  
|`EntityReference`|Brak|Brak|Brak|tak|tak|Brak|Brak|Brak|tak|  
  
 \* Węzeł XmlDeclaration musi być pierwszym elementem podrzędnym węzła dokumentu.  
  
 ** Znaczników zawiera węzły ProcessingInstruction i komentarz.  
  
 Element i CDATA węzły są dozwolone tylko w węzły EntityReference, gdy węzeł obiektu EntityReference nie jest elementem podrzędnym węzła atrybutu.  
  
 Atrybuty nie są elementy podrzędne węzła elementu. Atrybuty są zawarte wewnątrz kolekcji atrybutów, którego należy węzeł elementu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i wstawia je do dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano nazwy i <see langword="XmlNodeType" /> wymaga nazwy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, prefix As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ prefix, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, prefix, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see langword="XmlNodeType" /> Nowego węzła.</param>
        <param name="prefix">Prefiks nowego węzła.</param>
        <param name="name">Lokalna nazwa nowego węzła.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw nowego węzła.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> z określonym <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" />, i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nowy <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 W poniższej tabeli przedstawiono jakie NodeType [wiersz] jest dozwolona wewnątrz innej NodeType [kolumna] zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||dokument|Typ|XmlDeclaration|Element|Atrybut|Tekst|CDATA|Kod znaczników|Obiekt EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`DocumentType`|tak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`XmlDeclaration`|tak *|Brak|Brak|Brak|Brak|Brak|Brak|Brak|Brak|  
|`Element`|tak|Brak|Brak|tak|Brak|Brak|Brak|Brak|tak ***|  
|`Attribute`|Brak|Brak|Brak|tak ***|Brak|Brak|Brak|Brak|Brak|  
|`Text`|Brak|Brak|Brak|tak|tak|Brak|Brak|Brak|tak|  
|`CDATA`|Brak|Brak|Brak|tak|Brak|Brak|Brak|Brak|tak ***|  
|`Markup**`|tak|Brak|Brak|tak|Brak|Brak|Brak|Brak|Brak|  
|`EntityReference`|Brak|Brak|Brak|tak|tak|Brak|Brak|Brak|tak|  
  
 \* Węzeł XmlDeclaration musi być pierwszym elementem podrzędnym węzła dokumentu.  
  
 ** Znaczników zawiera węzły ProcessingInstruction i komentarz.  
  
 Element i CDATA węzły są dozwolone tylko w węzły EntityReference, gdy węzeł obiektu EntityReference nie jest elementem podrzędnym węzła atrybutu.  
  
 Atrybuty nie są elementy podrzędne węzła elementu. Atrybuty są zawarte wewnątrz kolekcji atrybutów, który należy do węzła elementu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład dodaje nowy element do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano nazwy i <see langword="XmlNodeType" /> wymaga nazwy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateProcessingInstruction (target As String, data As String) As XmlProcessingInstruction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlProcessingInstruction ^ CreateProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction&#xA;override this.CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction" Usage="xmlDocument.CreateProcessingInstruction (target, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Nazwa instrukcji przetwarzania.</param>
        <param name="data">Dane dla instrukcji przetwarzania.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlProcessingInstruction" /> o określonej nazwie i danych.</summary>
        <returns>Nowy <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) ProcessingInstruction węzły są dozwolone tylko w ramach węzłów dokumentu, Element i EntityReference, po węźle EntityReference nie jest elementem podrzędnym z węzłem atrybutu.  
  
   
  
## Examples  
 Poniższy przykład tworzy węzeł ProcessingInstruction i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSignificantWhitespace (text As String) As XmlSignificantWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlSignificantWhitespace ^ CreateSignificantWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace&#xA;override this.CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace" Usage="xmlDocument.CreateSignificantWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg może zawierać tylko następujące znaki &amp;#20; &amp;#10; &amp;#13; i &amp;#9.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlSignificantWhitespace" /> węzła.</summary>
        <returns>Nowy <see langword="XmlSignificantWhitespace" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jest używany, gdy użytkownik chce ręcznie formatowania dokumentu.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
   
  
## Examples  
 Poniższy przykład dodaje istotnych białych do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTextNode (text As String) As XmlText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlText ^ CreateTextNode(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateTextNode : string -&gt; System.Xml.XmlText&#xA;override this.CreateTextNode : string -&gt; System.Xml.XmlText" Usage="xmlDocument.CreateTextNode text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst dla węzła tekstowego.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlText" /> określonym tekstem.</summary>
        <returns>Nowy <see langword="XmlText" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) węzły tekstowe są dozwolone tylko w ramach węzłów elementów, atrybutów i EntityReference.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy element i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWhitespace (text As String) As XmlWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlWhitespace ^ CreateWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateWhitespace : string -&gt; System.Xml.XmlWhitespace&#xA;override this.CreateWhitespace : string -&gt; System.Xml.XmlWhitespace" Usage="xmlDocument.CreateWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg może zawierać tylko następujące znaki &amp;#20; &amp;#10; &amp;#13; i &amp;#9.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlWhitespace" /> węzła.</summary>
        <returns>Nowy <see langword="XmlWhitespace" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jest używany, gdy użytkownik chce ręcznie formatowania dokumentu.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
   
  
## Examples  
 Poniższy przykład dodaje biały znak w dokumencie.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateXmlDeclaration (version As String, encoding As String, standalone As String) As XmlDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDeclaration ^ CreateXmlDeclaration(System::String ^ version, System::String ^ encoding, System::String ^ standalone);" />
      <MemberSignature Language="F#" Value="abstract member CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration&#xA;override this.CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration" Usage="xmlDocument.CreateXmlDeclaration (version, encoding, standalone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">Wersja musi być "1.0".</param>
        <param name="encoding">Wartość atrybutu kodowania. Jest to, kodowania, która jest używana podczas zapisywania <see cref="T:System.Xml.XmlDocument" /> do pliku lub strumienia; w związku z tym, jego musi być równa ciągu obsługiwany przez <see cref="T:System.Text.Encoding" /> klasy, w przeciwnym razie <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> zakończy się niepowodzeniem. Jeśli jest to <see langword="null" /> lub String.Empty, <see langword="Save" /> metody nie zapisuje atrybut kodowania w deklaracji XML i w związku z tym domyślnego kodowania UTF-8, jest używany.  Uwaga: Jeśli <see langword="XmlDocument" /> są zapisywane do jednej <see cref="T:System.IO.TextWriter" /> lub <see cref="T:System.Xml.XmlTextWriter" />, ta wartość kodowania jest odrzucany. Zamiast tego kodowanie <see langword="TextWriter" /> lub <see langword="XmlTextWriter" /> jest używany. Daje to gwarancję, że XML napisanych może zostać odczytany ponownie przy użyciu kodowania poprawne.</param>
        <param name="standalone">Wartość musi mieć wartość "yes" lub "no". Jeśli jest to <see langword="null" /> lub String.Empty, <see langword="Save" /> metody nie zapisuje atrybut autonomiczny w deklaracji XML.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlDeclaration" /> węzła z określonymi wartościami.</summary>
        <returns>Nowy <see langword="XmlDeclaration" /> węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty są widoczne jako specjalne właściwości na `XmlDeclaration` węzła, a nie jako <xref:System.Xml.XmlAttribute> węzłów.  
  
 Mimo że ta metoda tworzy nowy obiekt w kontekście dokumentu, nie automatycznie dodaje nowy obiekt w drzewie dokumentu. Aby dodać nowy obiekt, należy jawnie wywołać jedną z metod wstawiania węzła.  
  
 Zgodnie z zaleceniem W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) `XmlDeclaration` węzeł musi być pierwszym węzłem dokumentu.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład tworzy deklaracji XML i dodaje go do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartości <paramref name="version" /> lub <paramref name="standalone" /> są inne niż te wymienione powyżej.</exception>
        <altmember cref="T:System.Xml.XmlDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentElement As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlElement ^ DocumentElement { System::Xml::XmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentElement : System.Xml.XmlElement" Usage="System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera główny <see cref="T:System.Xml.XmlElement" /> dla dokumentu.</summary>
        <value>
          <see langword="XmlElement" /> Reprezentujący katalogu głównego drzewa dokumentu XML. Jeśli istnieje nie katalogu głównego, <see langword="null" /> jest zwracana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla element główny dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Dane wyjściowe:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DocumentType As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocumentType ^ DocumentType { System::Xml::XmlDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.XmlDocumentType" Usage="System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera węzeł zawierający deklaracji DOCTYPE.</summary>
        <value>
          <see cref="T:System.Xml.XmlNode" /> Zawierający typ (deklaracja DOCTYPE).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` Może mieć tylko jeden podrzędny z <xref:System.Xml.XmlNodeType> równa typu dokumentu.  
  
> [!NOTE]
>  Ta właściwość jest tylko do odczytu. Aby zmienić typ węzła, usuń istniejący węzeł, Utwórz nowy ją przy użyciu <xref:System.Xml.XmlDocument.CreateDocumentType%2A> metodę i Dodaj nowy węzeł w dokumencie.  
  
   
  
## Examples  
 Poniższy przykład pobiera i wyświetla deklaracji DOCTYPE dla dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlDocumentType" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementById (elementId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ GetElementById(System::String ^ elementId);" />
      <MemberSignature Language="F#" Value="abstract member GetElementById : string -&gt; System.Xml.XmlElement&#xA;override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.GetElementById elementId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementId">Identyfikator atrybutu do dopasowania.</param>
        <summary>Pobiera <see cref="T:System.Xml.XmlElement" /> o określonym identyfikatorze.</summary>
        <returns>
          <see langword="XmlElement" /> Identyfikatorem pasującego lub <see langword="null" /> Jeśli zostanie znaleziony żaden element dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dokument ma wiele elementów o identyfikatorze dopasowania, ta metoda zwraca pierwszy pasujący element w dokumencie.  
  
> [!NOTE]
>  Implementacja modelu DOM jest posiadanie informacji, który definiuje atrybutów, które mają identyfikator typu. Chociaż można zdefiniować atrybutów typu ID schematy XSD lub pliki DTD, ta wersja produktu obsługuje tylko określone w definicji DTD. Atrybuty o nazwie, które nie mają "ID" wpisz identyfikator, chyba że tak zdefiniowana w DTD. Implementacje, w których jest nieznany czy atrybuty są typu ID powinna zwrócić `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `GetElementById` metody.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `ids.xml`, jako danych wejściowych.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetElementsByTagName">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich elementów podrzędnych, które odpowiadają określonej nazwie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa do dopasowania. Jest dopasowywana <see langword="Name" /> właściwości pasujących węzła. Specjalna wartość "*" pasuje do wszystkich tagów.</param>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich elementów podrzędnych, które odpowiadają określonej <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>
          <see cref="T:System.Xml.XmlNodeList" /> Zawierającego listę wszystkie pasujące węzły. Jeśli węzły nie są zgodne <paramref name="name" />, zwrócona kolekcja będzie pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Węzły są umieszczane w kolejności, w których może wystąpić w dokumencie.  
  
> [!NOTE]
>  Zaleca się, że używasz <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> lub <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> zamiast metody <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy `XmlDocument` obiektu i zastosowań `GetElementsByTagName` metody i wynikowy <xref:System.Xml.XmlNodeList> obiektu do wyświetlenia wszystkich tytułów książek.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 W przykładzie użyto `books.xml` pliku jako dane wejściowe.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (localName As String, namespaceURI As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">LocalName do dopasowania. Specjalna wartość "*" pasuje do wszystkich tagów.</param>
        <param name="namespaceURI">Jego identyfikator NamespaceURI do dopasowania.</param>
        <summary>Zwraca <see cref="T:System.Xml.XmlNodeList" /> zawierający listę wszystkich elementów podrzędnych, które odpowiadają określonej <see cref="P:System.Xml.XmlDocument.LocalName" /> i <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>
          <see cref="T:System.Xml.XmlNodeList" /> Zawierającego listę wszystkie pasujące węzły. Jeśli węzły nie różnią się od określonej <paramref name="localName" /> i <paramref name="namespaceURI" />, zwrócona kolekcja będzie pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Węzły są umieszczane w kolejności, w których może wystąpić w drzewie dokumentu.  
  
> [!NOTE]
>  Zaleca się, że używasz <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> lub <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> zamiast metody <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Implementation As XmlImplementation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlImplementation ^ Implementation { System::Xml::XmlImplementation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Implementation : System.Xml.XmlImplementation" Usage="System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlImplementation" /> obiektu dla bieżącego dokumentu.</summary>
        <value>
          <see langword="XmlImplementation" /> Obiektu dla bieżącego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` obiekty utworzone z tej samej `XmlImplementation` współużytkować ten sam <xref:System.Xml.XmlNameTable>. Dzięki temu użytkownikowi porównywania nazw atrybutu i elementu jako obiekty, a nie ciągi.  
  
 Mimo że `XmlDocument` obiekty współużytkują tego samego wdrożenia, aby przenieść węzły z jednego dokumentu należy użyć <xref:System.Xml.XmlDocument.ImportNode%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy `XmlDocument` przy użyciu implementacji w innym dokumencie.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportNode (node As XmlNode, deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ImportNode(System::Xml::XmlNode ^ node, bool deep);" />
      <MemberSignature Language="F#" Value="abstract member ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode&#xA;override this.ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.ImportNode (node, deep)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">Węzeł, który zostały zaimportowane.</param>
        <param name="deep">
          <see langword="true" /> Aby wykonać głębokie klonowania; w przeciwnym razie <see langword="false" />.</param>
        <summary>Importuje węzła z innego dokumentu do bieżącego dokumentu.</summary>
        <returns>Zaimportowanych <see cref="T:System.Xml.XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone węzeł ma Brak elementu nadrzędnego. Węzeł źródłowy nie jest zmieniony lub usunięty z oryginalnym dokumencie. `ImportNode` tworzy kopię węzeł źródłowy.  
  
 Importowanie węzła tworzy `XmlNode` obiektów należących do importowania dokumentu za pomocą <xref:System.Xml.XmlNode.Name%2A> i <xref:System.Xml.XmlNode.NodeType%2A> taka sama jak węzeł źródłowy. Nowy obiekt ma również atrybuty powiązane z przestrzeni nazw (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>, i <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 W zależności od typu węzła importowanych węzła i wartość `deep` parametru, dodatkowe informacje są kopiowane odpowiednio. Ta metoda próbuje dublowanie zachowanie oczekiwane, jeśli fragment XML lub HTML źródła został skopiowany z jednego dokumentu do innego (rozpoznawaniu, w tym przypadku XML dwa dokumenty może mieć różne pliki DTD).  
  
 W poniższej tabeli opisano określone zachowanie dla każdego <xref:System.Xml.XmlNodeType>.  
  
|XmlNodeType|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|Atrybut|<xref:System.Xml.XmlAttribute.Specified%2A> Właściwość jest ustawiona na `true` w wygenerowanym <xref:System.Xml.XmlAttribute>. Elementy podrzędne źródło `XmlAttribute` rekursywnie zaimportowany i wynikowy węzły są odbierane w celu utworzenia odpowiedniego poddrzewo.|`deep` Parametru nie ma zastosowania do `XmlAttribute` węzłów; zakres ich zawierają ich elementy podrzędne z nimi po zaimportowaniu.|  
|CData|Kopiuje węzła, w tym jego danych.|Kopiuje węzła, w tym jego danych.|  
|Komentarz|Kopiuje węzła, w tym jego danych.|Kopiuje węzła, w tym jego danych.|  
|DocumentFragment|Elementy podrzędne węzła źródłowego są rekursywnie zaimportowany i wynikowy węzły ponownie w celu utworzenia odpowiednich poddrzewa.|Pusta <xref:System.Xml.XmlDocumentFragment> jest generowany.|  
|Typ|Kopiuje węzła, w tym jego data.*|Kopiuje węzła, w tym jego data.*|  
|Element|Elementy podrzędne elementu źródłowego i jego węzły określonego atrybutu są rekursywnie zaimportowane i wynikowy węzły ponownie w celu utworzenia odpowiednich poddrzewa.<br /><br /> Uwaga: Atrybuty domyślne nie są kopiowane. Jeśli dokument, zostaną zaimportowane do definiuje atrybutów domyślnych dla tej nazwy elementu, te są przypisywane.|Określony atrybut węzłów elementu źródłowego są importowane i generowane `XmlAttribute` węzły są dołączone do wygenerowanej <xref:System.Xml.XmlElement>.<br /><br /> Uwaga: Atrybuty domyślne nie są kopiowane. Jeśli dokument, zostaną zaimportowane do definiuje atrybutów domyślnych dla tej nazwy elementu, te są przypisywane.|  
|Obiekt EntityReference|Ponieważ dokumentów źródłowych i docelowych może mieć jednostki zdefiniowanych inaczej, ta metoda tylko kopiuje <xref:System.Xml.XmlEntityReference> węzła. Tekst zastępczy nie jest włączony. Jeśli plik docelowy zawiera jednostki zdefiniowane, jego wartość zostanie przypisany.|Ponieważ dokumentów źródłowych i docelowych może mieć jednostki zdefiniowanych inaczej, ta metoda tylko kopiuje <xref:System.Xml.XmlEntityReference> węzła. Tekst zastępczy nie jest włączony. Jeśli plik docelowy zawiera jednostki zdefiniowane, jego wartość zostanie przypisany.|  
|ProcessingInstruction|Kopiuje wartości docelowej i danych z zaimportowanych węzła.|Kopiuje wartości docelowej i danych z zaimportowanych węzła.|  
|Tekst|Kopiuje węzła, w tym jego danych.|Kopiuje węzła, w tym jego danych.|  
|SignificantWhitespace|Kopiuje węzła, w tym jego danych.|Kopiuje węzła, w tym jego danych.|  
|Białe znaki|Kopiuje węzła, w tym jego danych.|Kopiuje węzła, w tym jego danych.|  
|XmlDeclaration|Kopiuje wartości docelowej i danych z zaimportowanych węzła.|Kopiuje wartości docelowej i danych z zaimportowanych węzła.|  
|Inne typy węzłów.|Nie można zaimportować te typy węzłów.|Nie można zaimportować te typy węzłów.|  
  
 * Mimo że można zaimportować węzłów typu dokumentu, dokument może mieć tylko jeden typ. Jeśli dokument ma obecnie węzła DocumenType, należy usunąć przed dodaniem nowego bloku.  
  
   
  
## Examples  
 Poniższy przykład importuje węzła książki z drugiego dokumentu XML do oryginalnego dokumentu XML.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `books.xml`, jako danych wejściowych.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołanie tej metody dla typu węzła, który nie może zostać zaimportowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText {  void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string" Usage="System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza <see cref="T:System.InvalidOperationException" /> we wszystkich przypadkach.</summary>
        <value>Wartości węzła i wszystkich jego węzłów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest zaimplementowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znaczników reprezentującą elementy podrzędne bieżącego węzła.</summary>
        <value>Kod znaczników elementu podrzędnego bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości jest zastępowany elementy podrzędne węzła przeanalizowany zawartość podanego ciągu. Analiza odbywa się w bieżącym kontekście przestrzeni nazw.  
  
 `InnerXml` Usuwa deklaracje przestrzeni nazw nadmiarowe. Jako wynik liczne wycinanie i wklejanie operacje zwiększa rozmiar dokumentu za pomocą deklaracje przestrzeni nazw nadmiarowe. Należy wziąć pod uwagę następujący dokument XSL:  
  
```xml  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 `InnerXml` Właściwość w węźle arkusza stylów zwraca następujący ciąg:  
  
```xml  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Zwróć uwagę, dodatkowe xmlns:xsl deklarację przestrzeni nazw, które jest używane w celu zachowania tożsamości węzła. Jeśli ponownie włóż ten wewnętrzny ciągu XML, zostanie wyświetlony ponownie oryginalnego dokumentu. Innymi słowy `InnerXml` rozpoznaje xmlns:xsl deklarację przestrzeni nazw jest nadmiarowa, biorąc pod uwagę, że elementu Stylesheet nadrzędnego już ma xmlns:xsl delcaration przestrzeni nazw i w związku z tym powoduje jej usunięcie.  
  
 Jeśli przeniesiesz `InnerXml` z dokumentu nie domyślna przestrzeń nazw w dokumencie przy użyciu domyślnej przestrzeni nazw, zachowanie jest nieco inny. Należy wziąć pod uwagę następujący ciąg XML:  
  
```xml  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml` Zwraca zwykły ciąg znaków XML za pomocą nie deklaracji przestrzeni nazw:  
  
```xml  
<item>123</item>  
```  
  
 Jeśli ten ciąg jest następnie wstaw do dokumentu, który ma domyślny obszar nazw, takich jak następujące:  
  
```xml  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml` analizuje ciąg w kontekście i nowe węzły przejmą przestrzeni nazw urn: 1. Wynik wygląda następująco:  
  
```xml  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Teraz gdy poprosisz o `InnerXml` wrócić następujące czynności:  
  
```xml  
<item xmlns="urn:1">123</item>  
```  
  
 Jeśli chcesz jawnie wstawiony element, aby zachować fakt, że pochodzi od dokumentu, który miał żadnej przestrzeni nazw, należy ręcznie dodać xmlns = "" deklarację i Wstaw wynikowy ciąg:  
  
```xml  
<item xmlns="">123</item>  
```  
  
 Sieci skutków wszystko, co to jest następująca:  
  
1.  Wycinanie i wklejanie `InnerXml` tych dokumentów, które nie korzystają z przestrzeni nazw jest prosty i przejrzysty i nie powoduje utworzenia "xmlns" nadmiarowości w Twoimi ciągami.  
  
2.  `InnerXml` można również wycinanie i wklejanie między dokumentami, które mają więcej niż jeden obszar nazw (czyli arkuszy stylów XSL).  
  
3.  deklaracje xmlns:XSL automatycznie wyświetlane w Twoimi ciągami i znikają w swojej hierarchii węzła.  
  
4.  W przypadku, gdzie jesteś, przenoszenie `InnerXml` z dokumentu, który ma domyślny obszar nazw do dokumentu, który ma domyślny obszar nazw, nowe węzły przejmą nowy domyślny obszar nazw.  
  
 Jeśli `InnerXml` ustawiono tekstem zawierającym odwołania do jednostek, które nie są obecnie zdefiniowane w dokumencie, wynikowe drzewo będzie zawierało pusty obiekt EntityReference węzłów.  
  
 Ta właściwość jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Kod XML określony, gdy ustawienie tej właściwości nie jest poprawnie sformułowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżącego węzła jest tylko do odczytu. w przeciwnym razie <see langword="false" />. <see langword="XmlDocument" /> węzły zawsze zwracają <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Węzeł tylko do odczytu jest jeden, którego właściwości, atrybutów lub elementów podrzędnych nie można zmienić. Można usunąć węzeł tylko do odczytu z drzewa i Wstaw gdzie indziej.  
  
 Ta właściwość jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `IsReadOnly` właściwości.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje określone dane XML z <see cref="T:System.IO.Stream" />, adres URL, <see cref="T:System.IO.TextReader" />, lub <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.Stream -&gt; unit&#xA;override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Strumień zawiera dokument XML do załadowania.</param>
        <summary>Ładuje dokumentu XML z określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metoda zawsze zachowuje istotnych białych. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy nieważny biały znak, który jest biały znak w zawartości elementu, są zachowywane. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli chcesz, aby sprawdzanie poprawności jest wykonywane, można utworzyć, sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Ta metoda jest automatycznie wykrywa format ciągu danych wejściowych XML (na przykład, UTF-8, ANSI i tak dalej). Jeśli aplikacja wymaga dowiedzieć się, kodowania, która służy do odczytywania strumienia, należy wziąć pod uwagę przy użyciu <xref:System.Xml.XmlTextReader> obiektu można odczytać strumienia, a następnie użyj <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> właściwości, aby określić kodowanie. Jeśli musisz użyć <xref:System.Xml.XmlDocument> obiekt, aby pracować z danymi XML, można użyć <xref:System.Xml.XmlTextReader> obiektu, aby go utworzyć. Aby uzyskać więcej informacji, zobacz [odczytywania danych XML przy użyciu klas XPathDocument i XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Istnieje błąd ładowania lub analizowania w pliku XML. W tym przypadku <see cref="T:System.IO.FileNotFoundException" /> jest wywoływane.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.TextReader -&gt; unit&#xA;override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">
          <see langword="TextReader" /> Używane do strumieniowego źródła danych XML do dokumentu.</param>
        <summary>Ładuje dokumentu XML z określonego <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metoda zawsze zachowuje istotnych białych. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy nieważny biały znak, który jest biały znak w zawartości elementu, są zachowywane. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli chcesz, aby sprawdzanie poprawności jest wykonywane, można utworzyć, sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.StringReader> klasy, aby załadować ciągu danych XML do `XmlDocument` obiektu.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Istnieje błąd ładowania lub analizowania w pliku XML. W tym przypadku dokument pozostanie puste.</exception>
        <altmember cref="T:System.IO.StreamReader" />
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; unit&#xA;override this.Load : string -&gt; unit" Usage="xmlDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Adres URL pliku zawierającego dokumentu XML do załadowania. Adres URL może być w lokalnym pliku lub adres HTTP URL (adres sieci Web).</param>
        <summary>Ładuje dokumentu XML z określonego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metoda zawsze zachowuje istotnych białych. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy nieważny biały znak, który jest biały znak w zawartości elementu, są zachowywane. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli chcesz, aby sprawdzanie poprawności jest wykonywane, można utworzyć, sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Istnieje błąd ładowania lub analizowania w pliku XML. W tym przypadku <see cref="T:System.IO.FileNotFoundException" /> jest wywoływane.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="filename" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="filename" /> określony plik, który jest tylko do odczytu.  - lub - ta operacja nie jest obsługiwana na bieżącej platformie.  - lub - <paramref name="filename" /> określony katalog.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="filename" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="filename" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Xml.XmlReader -&gt; unit&#xA;override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XmlReader" /> Używane do strumieniowego źródła danych XML do dokumentu.</param>
        <summary>Ładuje dokumentu XML z określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Metoda zawsze zachowuje istotnych białych. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Właściwość określa, czy nieważny biały znak, który jest biały znak w zawartości elementu, są zachowywane. Wartość domyślna to `false`; biały znak w zawartości elementu nie są zachowywane.  
  
 Jeśli czytnik jest w stanie początkowym (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial), `Load` wykorzystuje całą zawartość czytelnika i tworzy DOM w LICZBIE od tego, co znajduje.  
  
 Jeśli czytnik jest już umieszczony na jednego z węzłów na głębokości "n", ta metoda ładuje ten węzeł i wszystkie kolejne elementy równorzędne do tagu końcowego, który zamyka głębokość "n". Ma to następujące wyniki.  
  
 Jeśli bieżącego węzła i jego elementów równorzędnych wyglądać następująco:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` zgłasza wyjątek, ponieważ dokument nie może mieć dwóch elementów głównego poziomu. Jeśli bieżącego węzła i jego elementów równorzędnych wyglądać następująco:  
  
```xml  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load` zakończy się powodzeniem, ale masz niekompletne drzewa DOM, ponieważ nie ma żadnego elementu poziomu głównego. Przed zapisaniem dokumentu należy dodać element poziomu głównego, w przeciwnym razie <xref:System.Xml.XmlDocument.Save%2A> spowoduje zgłoszenie wyjątku.  
  
 Jeśli czytnik jest umieszczony na węzeł liścia, który jest nieprawidłowy na głównym poziomie dokumentu, na przykład biały znak lub węzeł atrybutu czytnik w dalszym ciągu odczytu, dopóki nie zostanie on ustawiony na węzeł, który może służyć do katalogu głównego. Dokument rozpoczyna się, w tym momencie ładowania.  
  
 Jeśli chcesz, aby sprawdzanie poprawności jest wykonywane, można utworzyć, sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład załaduje ostatniego węzła książki `books.xml` pliku w dokumencie XML.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `books.xml`, jako danych wejściowych.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Istnieje błąd ładowania lub analizowania w pliku XML. W tym przypadku dokument pozostanie puste.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadXml (xml As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadXml(System::String ^ xml);" />
      <MemberSignature Language="F#" Value="abstract member LoadXml : string -&gt; unit&#xA;override this.LoadXml : string -&gt; unit" Usage="xmlDocument.LoadXml xml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Ciąg zawierający dokument XML, który mógł zostać załadowany.</param>
        <summary>Ładuje dokumentu XML z określonego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie `LoadXml` metody nie zachowuje biały znak lub biały znak znaczące.  
  
 Ta metoda analizuje pliki DTD, ale nie wykonuje sprawdzanie poprawności DTD lub schematu. Jeśli chcesz, aby sprawdzanie poprawności jest wykonywane, można utworzyć, sprawdzanie poprawności <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReaderSettings> klasy i <xref:System.Xml.XmlReader.Create%2A> metody. Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 Jeśli chcesz załadować z <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, lub <xref:System.Xml.XmlReader>, zamiast tej metody należy użyć metody obciążenia.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład załaduje XML `XmlDocument` obiektu i zapisuje ją w pliku.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Istnieje błąd ładowania lub analizowania w pliku XML. W tym przypadku dokument pozostanie puste.</exception>
        <altmember cref="P:System.Xml.XmlDocument.PreserveWhitespace" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę lokalnego węzła.</summary>
        <value>Aby uzyskać <see langword="XmlDocument" /> węzłów i lokalna nazwa jest #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokalna nazwa, zwracana jest zależna od <xref:System.Xml.XmlDocument.NodeType%2A> węzła. Aby wyświetlić tabelę opisującą lokalna nazwa zwracane dla każdego typu węzła, zobacz <xref:System.Xml.XmlNode.LocalName%2A> właściwość <xref:System.Xml.XmlNode> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną nazwę węzła.</summary>
        <value>Aby uzyskać <see langword="XmlDocument" /> węzłów, nazwa jest #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa, zwracana jest zależna od <xref:System.Xml.XmlDocument.NodeType%2A> węzła. Aby wyświetlić tabelę opisującą nazwy dla każdego typu węzła, zobacz <xref:System.Xml.XmlNode.Name%2A> właściwość <xref:System.Xml.XmlNode> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlNameTable" /> skojarzone z tej implementacji.</summary>
        <value>
          <see langword="XmlNameTable" /> Umożliwiając rozproszone obiekty wersję ciągu w obrębie dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy `XmlDocument` obiekt ma <xref:System.Xml.NameTable> obiektu. Nazwy elementów i atrybutów są przechowywane w `NameTable` jako łańcuchy rozproszone obiekty. Oznacza to, że nawet wtedy, gdy nazwa jest przywoływany w dokumencie wielokrotnie jest on przechowywany tylko jeden raz w `NameTable`. Na przykład, jeśli dokument ma wiele elementów o nazwie "Klient" `NameTable` zwraca ten sam obiekt po każdym odebraniu żądania dla tej nazwy. W rezultacie użytkownicy mogą zapisywać kodu za pomocą obiektu porównania na te ciągi, a nie na bardziej kosztowne porównania ciągów.  
  
 Aby uzyskać więcej informacji na temat ciągów rozproszone obiekty, zobacz <xref:System.Xml.XmlNameTable>.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanged As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanged;" />
      <MemberSignature Language="F#" Value="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Xml.XmlNode.Value" /> węzła należące do tego dokumentu została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie dotyczy tylko węzły, które mają wartość.  
  
 Wszystkie węzły, utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, znajdują się w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanging As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanging;" />
      <MemberSignature Language="F#" Value="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Xml.XmlNode.Value" /> węzła należące do tego dokumentu jest zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia użytkownikowi dodatkowe sprawdzanie i, jeśli to konieczne, należy zgłosić wyjątek, aby zatrzymać operację. Jeśli wyjątek jest zgłaszany `XmlDocument` powraca do stanu pierwotnego. To zdarzenie dotyczy tylko węzły, które mają wartość.  
  
 Wszystkie węzły, utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, znajdują się w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserted As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserted;" />
      <MemberSignature Language="F#" Value="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu, został wstawiony do innego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie węzły, utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, znajdują się w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserting As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserting;" />
      <MemberSignature Language="F#" Value="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu ma zostać wstawiony do innego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia użytkownikowi dodatkowe sprawdzanie i, jeśli to konieczne, należy zgłosić wyjątek, aby zatrzymać operację. Jeśli wyjątek jest zgłaszany `XmlDocument` powraca do stanu pierwotnego.  
  
 Wszystkie węzły, utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, znajdują się w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoved As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoved;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu została usunięta z jego elementu nadrzędnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie węzły, utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, znajdują się w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoving As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoving;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy węzeł należących do tego dokumentu zostanie usunięty z dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia użytkownikowi dodatkowe sprawdzanie i, jeśli to konieczne, należy zgłosić wyjątek, aby zatrzymać operację. Jeśli wyjątek jest zgłaszany `XmlDocument` powraca do stanu pierwotnego.  
  
 Wszystkie węzły, utworzone przez tego dokumentu, czy zostały wstawione do dokumentu, znajdują się w tym zdarzeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ bieżącego węzła.</summary>
        <value>Typ węzła. Aby uzyskać <see langword="XmlDocument" /> węzłów, ta wartość jest XmlNodeType.Document.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlDocument" /> do którego należy bieżący węzeł.</summary>
        <value>Aby uzyskać <see langword="XmlDocument" /> węzłów (<see cref="P:System.Xml.XmlDocument.NodeType" /> jest równa XmlNodeType.Document), właściwość ta zwraca zawsze <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera węzeł nadrzędny tego węzła (węzły, które mogą mieć elementów nadrzędnych).</summary>
        <value>Zawsze zwraca <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveWhitespace : bool with get, set" Usage="System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy chcesz zachować biały znak w zawartości elementu.</summary>
        <value>
          <see langword="true" /> Aby zachować biały w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa sposób obsługi biały znak podczas ładowania i Zapisz procesu.  
  
 Jeśli `PreserveWhitespace` jest `true` przed <xref:System.Xml.XmlDocument.Load%2A> lub <xref:System.Xml.XmlDocument.LoadXml%2A> jest wywoływana, biały znak węzły są zachowanych; w przeciwnym razie, jeśli ta właściwość jest `false`istotnych białych są zachowywane, biały znak nie jest.  
  
 Jeśli `PreserveWhitespace` jest `true` przed <xref:System.Xml.XmlDocument.Save%2A> jest wywoływana, biały znak w dokumencie jest konserwowane w danych wyjściowych; w przeciwnym razie, jeśli ta właściwość jest `false`, `XmlDocument` automatycznie wcięcia danych wyjściowych.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak usunąć biały znak z pliku.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `book.xml` jako dane wejściowe.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadNode (reader As XmlReader) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReadNode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode&#xA;override this.ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode" Usage="xmlDocument.ReadNode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Źródło XML</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlNode" /> obiektu na podstawie informacji w <see cref="T:System.Xml.XmlReader" />. Czytnik musi znajdować się na węźle lub atrybutu.</summary>
        <returns>Nowy <see langword="XmlNode" /> lub <see langword="null" /> Jeśli istnieje nie kolejnych węzłów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odczytuje jeden `XmlNode` z danego czytnika i umieszcza czytelnika na kolejnego węzła. Ta metoda tworzy typ `XmlNode` dopasowania <xref:System.Xml.XmlNode.NodeType%2A> na której czytnik jest obecnie umieszczony. (Jeśli czytnik jest w stanie początkowym `ReadNode` prowadzi czytnik w pierwszym węźle, a następnie działa w tym węźle.)  
  
 Jeśli czytnik jest umieszczony na początku elementu, `ReadNode` odczytuje wszystkie atrybuty i wszystkich podrzędnych węzłów do i łącznie z tagu końcowego bieżącego węzła. `XmlNode` Zwrócił zawiera poddrzewie reprezentujący wszystko odczytu. Czytnik jest umieszczony natychmiast po tagu końcowego.  
  
 `ReadNode` Ponadto mogą odczytywać atrybuty, ale w tym przypadku go nie rozwijaj czytnik atrybutowi dalej. Dzięki temu można napisać następujący kod C#:  
  
```csharp  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode` Używanie wartości atrybutu, co oznacza, że po wywołaniu `ReadNode` atrybutu <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `ReadNode` do utworzenia nowego węzła i wstawia nowy węzeł do dokumentu.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 W przykładzie użyto pliku `cd.xml`, jako danych wejściowych.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Czytnik jest umieszczony na typ węzła, który nie przekłada się na nieprawidłowy węzeł modelu DOM (na przykład EndElement lub EndEntity).</exception>
        <block subset="none" type="overrides">
          <para>Ta metoda ma dziedziczenia. Pełne zaufanie jest wymagany do zastąpienia <see langword="ReadNode" /> metody.  Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).</para>
        </block>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dokument XML do określonej lokalizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (outStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::Stream ^ outStream);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.Stream -&gt; unit&#xA;override this.Save : System.IO.Stream -&gt; unit" Usage="xmlDocument.Save outStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">Strumień, do której chcesz zapisać.</param>
        <summary>Zapisuje dokument XML do określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biały znak jest zachowywany tylko wtedy, gdy <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> ustawiono `true`.  
  
 XmlDeclaration bieżącego `XmlDocument` obiektu Określa atrybut kodowania w zapisany dokument. Wartość atrybutu kodowania jest pobierana z <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> właściwości. Jeśli `XmlDocument` jest ma XmlDeclaration lub jeśli XmlDeclaration nie ma atrybutu kodowania, zapisany dokument nie będzie miał jedną albo.  
  
 Po zapisaniu dokumentu xmlns atrybuty są generowane poprawnie utrwalenia tożsamości węzła (lokalna nazwa i identyfikator URI przestrzeni nazw). Na przykład, poniższy kod C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 Ten atrybut dane XML generuje `<item xmls="urn:1"/>`.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Pamiętaj, że tylko <xref:System.Xml.XmlDocument.Save%2A> metoda wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia gwarantuje tylko fragment poprawnie sformułowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie powodują poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.TextWriter -&gt; unit&#xA;override this.Save : System.IO.TextWriter -&gt; unit" Usage="xmlDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see langword="TextWriter" /> Do której ma zostać zapisany.</param>
        <summary>Zapisuje dokument XML do określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie na `TextWriter` Określa kodowanie, który jest zapisywany (kodowanie węzła XmlDeclaration zostaje zastąpiona przez kodowanie `TextWriter`). Jeśli nie było żadnych kodowaniem określonym na `TextWriter`, `XmlDocument` są zapisywane bez atrybutu kodowania.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Pamiętaj, że tylko <xref:System.Xml.XmlDocument.Save%2A> metoda wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia gwarantuje tylko fragment poprawnie sformułowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie powodują poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Save : string -&gt; unit&#xA;override this.Save : string -&gt; unit" Usage="xmlDocument.Save filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Lokalizacja pliku, w którym chcesz zapisać plik.</param>
        <summary>Zapisuje dokument XML do określonego pliku. Jeśli określony plik istnieje, ta metoda zastępuje go.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biały znak jest zachowywana w danych wyjściowych plików tylko wtedy, gdy <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> ustawiono `true`.  
  
 XmlDeclaration bieżącego `XmlDocument` obiektu Określa atrybut kodowania w zapisany dokument. Wartość atrybutu kodowania jest pobierana z <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> właściwości. Jeśli `XmlDocument` jest ma XmlDeclaration lub jeśli XmlDeclaration nie ma atrybutu kodowania, zapisany dokument nie będzie miał jedną albo.  
  
 Po zapisaniu dokumentu xmlns atrybuty są generowane poprawnie utrwalenia tożsamości węzła (lokalna nazwa i identyfikator URI przestrzeni nazw). Na przykład, poniższy kod C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 Ten atrybut dane XML generuje `<item xmls="urn:1"/>`.  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Pamiętaj, że tylko <xref:System.Xml.XmlDocument.Save%2A> metoda wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia gwarantuje tylko fragment poprawnie sformułowany.  
  
   
  
## Examples  
 Poniższy przykład ładuje XML do obiektu XmlDocument, modyfikuje je i zapisuje go w pliku o nazwie data.xml.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 Plik data.xml będzie zawierać następujący kod XML: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie powodują poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Xml.XmlWriter -&gt; unit&#xA;override this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.Save w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">
          <see langword="XmlWriter" /> Do której ma zostać zapisany.</param>
        <summary>Zapisuje dokument XML do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Biały znak jest zachowywany tylko wtedy, gdy <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> ustawiono `true`.  
  
 Kodowanie na `XmlWriter` Określa kodowanie, który jest zapisywany (kodowanie węzła XmlDeclaration zostaje zastąpiona przez kodowanie `XmlWriter`). Jeśli nie było żadnych kodowaniem określonym na `XmlWriter`, `XmlDocument` są zapisywane bez atrybutu kodowania.  
  
 Po zapisaniu dokumentu xmlns atrybuty są generowane poprawnie utrwalenia tożsamości węzła (LocalName + NamespaceURI). Na przykład, poniższy kod C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generuje ten atrybut dane XML:  
  
```xml  
<item  
    xmls="urn:1"/>  
```  
  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 Pamiętaj, że tylko <xref:System.Xml.XmlDocument.Save%2A> metoda wymusza poprawnie sformułowany dokument XML. Wszystkie inne `Save` przeciążenia gwarantuje tylko fragment poprawnie sformułowany.  
  
   
  
## Examples  
 Poniższy przykład załaduje XML `XmlDocument` obiektu i zapisuje ją w pliku.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Operacja nie powodują poprawnie sformułowany dokument XML (na przykład nie dokumentu elementu lub zduplikowane XML deklaracje).</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca odniesienie-Schema-weryfikacji — zestaw informacji (PSVI) węzła.</summary>
        <value>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> Obiekt reprezentujący PSVI węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawartość PSVI tej właściwości ustawiono po sprawdzeniu poprawności węzła.  
  
 Ta właściwość jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Xml.Schema.XmlSchemaSet" /> obiekt skojarzony z tym <see cref="T:System.Xml.XmlDocument" />.</summary>
        <value>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Obiekt, który zawiera schematy języka definicji schematu XML (XSD) skojarzony z tym <see cref="T:System.Xml.XmlDocument" />; w przeciwnym razie pusty <see cref="T:System.Xml.Schema.XmlSchemaSet" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schematy zawarte w <xref:System.Xml.Schema.XmlSchemaSet> obiekt skojarzony z <xref:System.Xml.XmlDocument> obiektu są używane do sprawdzania poprawności podczas <xref:System.Xml.XmlDocument.Validate%2A> metody <xref:System.Xml.XmlDocument> jest wykonywany.  
  
 Gdy <xref:System.Xml.XmlDocument> obiekt jest inicjowany z danymi XML z <xref:System.Xml.XmlReader> obiektu, <xref:System.Xml.Schema.XmlSchemaSet> obiektów jest ładowany z <xref:System.Xml.XmlReaderSettings.Schemas%2A> właściwość <xref:System.Xml.XmlReader> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza poprawność <see cref="T:System.Xml.XmlDocument" /> względem schematów języka definicji schematu XML (XSD) zawartych w <see cref="P:System.Xml.XmlDocument.Schemas" /> właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="xmlDocument.Validate validationEventHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> Obiekt, który odbiera informacji na temat schematu Walidacja ostrzeżeń i błędów.</param>
        <summary>Sprawdza poprawność <see cref="T:System.Xml.XmlDocument" /> względem schematów języka definicji schematu XML (XSD) zawartych w <see cref="P:System.Xml.XmlDocument.Schemas" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> Metoda sprawdza poprawność danych XML w <xref:System.Xml.XmlDocument> względem schematów zawarte w <xref:System.Xml.XmlDocument.Schemas%2A> właściwości. <xref:System.Xml.XmlDocument.Validate%2A> Metoda wykonuje rozszerzeniu zestaw informacji. W szczególności po pomyślnej weryfikacji, wartości domyślne schematu są stosowane wartości tekstowe są konwertowane na niepodzielne wartości zgodnie z potrzebami i informacje o typie jest skojarzone z elementami zweryfikowanych informacji. Wynik jest niezaznaczone wpisanych podrzędne drzewa XML w <xref:System.Xml.XmlDocument> zastąpione wpisane poddrzewa.  
  
 Poniżej przedstawiono ważne uwagi, które należy wziąć pod uwagę podczas korzystania <xref:System.Xml.XmlDocument.Validate%2A> metody.  
  
-   Wskazówki dotyczące lokalizacji schematu, takie jak `xsi:schemaLocation` lub `xsi:noNamespaceSchemaLocation` są ignorowane.  
  
-   Wbudowane schematy są ignorowane.  
  
-   Jeśli wystąpią błędy sprawdzania poprawności schematu, podczas sprawdzania poprawności <xref:System.Xml.XmlDocument> staje się częściowo sprawdzona niektóre węzły z informacjami o poprawnego typu, a inne nie.  
  
-   Proces ten obejmuje sprawdzanie ograniczenia unikatowości i odwołania (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, i `xs:unique`).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób używania metody <xref:System.Xml.XmlDocument.Validate%2A> metody. W przykładzie jest tworzony <xref:System.Xml.XmlDocument> zawiera skojarzone XSD przy użyciu schematu <xref:System.Xml.XmlReaderSettings> i <xref:System.Xml.XmlReader> obiektów. Następnie w przykładzie <xref:System.Xml.XPath.XPathNavigator> klasy do modyfikowania błędnie wpisane wartości elementu w dokumencie XML, generuje błąd walidacji schematu.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 Przykład przyjmuje `contosoBooks.xml` i `contosoBooks.xsd` pliki jako dane wejściowe.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Wystąpiło zdarzenie sprawdzania poprawności schematu i nie <see cref="T:System.Xml.Schema.ValidationEventHandler" /> został określony obiekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, System::Xml::XmlNode ^ nodeToValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler * System.Xml.XmlNode -&gt; unit" Usage="xmlDocument.Validate (validationEventHandler, nodeToValidate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> Obiekt, który odbiera informacji na temat schematu Walidacja ostrzeżeń i błędów.</param>
        <param name="nodeToValidate">
          <see cref="T:System.Xml.XmlNode" /> Obiektu utworzonego na podstawie <see cref="T:System.Xml.XmlDocument" /> do sprawdzania poprawności.</param>
        <summary>Sprawdza poprawność <see cref="T:System.Xml.XmlNode" /> obiekt określony względem schematów języka definicji schematu XML (XSD) w <see cref="P:System.Xml.XmlDocument.Schemas" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> Metoda sprawdza poprawność danych XML w <xref:System.Xml.XmlNode> obiektu względem schematów zawarte w <xref:System.Xml.XmlDocument.Schemas%2A> właściwości. <xref:System.Xml.XmlDocument.Validate%2A> Metoda wykonuje rozszerzeniu zestaw informacji. W szczególności po pomyślnej weryfikacji, wartości domyślne schematu są stosowane wartości tekstowe są konwertowane na niepodzielne wartości zgodnie z potrzebami i informacje o typie jest skojarzone z elementami zweryfikowanych informacji. Wynik jest niezaznaczone wpisanych podrzędne drzewa XML w <xref:System.Xml.XmlDocument> zastąpione wpisane poddrzewa.  
  
 Poniżej przedstawiono ważne uwagi, które należy wziąć pod uwagę podczas korzystania <xref:System.Xml.XmlDocument.Validate%2A> metody.  
  
-   Wskazówki dotyczące lokalizacji schematu, takie jak `xsi:schemaLocation` lub `xsi:noNamespaceSchemaLocation` są ignorowane.  
  
-   Wbudowane schematy są ignorowane.  
  
-   Jeśli wystąpią błędy sprawdzania poprawności schematu, podczas sprawdzania poprawności <xref:System.Xml.XmlDocument> staje się częściowo sprawdzona niektóre węzły z informacjami o poprawnego typu, a inne nie.  
  
 Jeśli węzeł do zweryfikowania jest węzłem głównym, proces ten obejmuje sprawdzanie ograniczenia unikatowości i odwołania (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, i `xs:unique`); w przeciwnym razie unikatowości i dokumentacja ograniczenia są pomijane.  
  
   
  
## Examples  
 Na przykład <xref:System.Xml.XmlDocument.Validate%2A> metody, zobacz <xref:System.Xml.XmlDocument.Validate%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Xml.XmlNode" /> Parametr obiektu nie został utworzony na podstawie <see cref="T:System.Xml.XmlDocument" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlNode" /> Parametr obiektu nie jest element, atrybut, fragment dokumentu lub węzeł główny.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Wystąpiło zdarzenie sprawdzania poprawności schematu i nie <see cref="T:System.Xml.Schema.ValidationEventHandler" /> został określony obiekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteContentTo (xw As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteContentTo(System::Xml::XmlWriter ^ xw);" />
      <MemberSignature Language="F#" Value="override this.WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteContentTo xw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">
          <see langword="XmlWriter" /> Do której ma zostać zapisany.</param>
        <summary>Zapisuje wszystkie obiekty podrzędne danego <see langword="XmlDocument" /> węzła do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jest funkcjonalnym odpowiednikiem <xref:System.Xml.XmlDocument.InnerXml%2A> właściwości.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Właściwość określa kodowanie, który jest zapisywany. Jeśli `Encoding` właściwość nie ma wartości, `XmlDocument` jest zapisywany bez atrybutu kodowania.  
  
   
  
## Examples  
 Poniższy przykład wyświetla dokument na ekranie.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">
          <see langword="XmlWriter" /> Do której ma zostać zapisany.</param>
        <summary>Zapisuje <see langword="XmlDocument" /> węzła do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object). Jest funkcjonalnym odpowiednikiem <xref:System.Xml.XmlNode.OuterXml%2A> właściwości.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Właściwość określa kodowanie, który jest zapisywany. Jeśli `Encoding` właściwość nie ma wartości, `XmlDocument` jest zapisywany bez atrybutu kodowania.  
  
   
  
## Examples  
 Poniższy przykład wyświetla dokument na ekranie.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zestawy <see cref="T:System.Xml.XmlResolver" /> do użycia w celu rozpoznawania zasobów zewnętrznych.</summary>
        <value>
          <see langword="XmlResolver" /> Do użycia.  W wersji 1.1 platformy.NET Framework, obiekt wywołujący musi być w pełni zaufany, aby określić <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlResolver` Może służyć do ładowania definicji DTD lub rozwiń odwołań do jednostek. Za pomocą <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> właściwości można ustawić poświadczenia na `XmlResolver` uzyskują dostęp do zasobów przechowywanych w zasobie bezpiecznej sieci.  
  
-   Jeśli dokument nie został załadowany za pomocą <xref:System.Xml.XmlReader> (to znaczy, jeśli został załadowany, przy użyciu strumienia, plików i tak dalej) `XmlResolver` na `XmlDocument` jest zawsze używana.  
  
-   Jeśli dokument został załadowany z <xref:System.Xml.XmlTextReader>, rozpoznawania nazw w `XmlTextReader` jest używany do rozpoznawania odwołań DTD w węźle typu dokumentu. Program rozpoznawania nazw w `XmlDocument` jest używany, aby rozwinąć wszystkie odwołania do jednostki.  
  
-   Jeśli dokument został załadowany z <xref:System.Xml.XmlValidatingReader>, rozpoznawania nazw na `XmlDocument` nie jest nigdy używane.  
  
-   Jeśli dokument został załadowany z klasą, która rozszerza `XmlReader` i `XmlReader` nie można rozpoznać jednostki (<xref:System.Xml.XmlReader.CanResolveEntity%2A> zwraca `false`), `XmlResolver` na `XmlDocument` jest używany do rozpoznawania odwołań w węźle DocumentType i rozwiń wszystkie odwołania do jednostki.  
  
> [!NOTE]
>  Jeśli `XmlDocument` jest ładowany za pomocą <xref:System.Xml.XmlReader> który miał `XmlResolver` , ustaw `XmlResolver` na `XmlReader` nie jest buforowana przez `XmlDocument` po <xref:System.Xml.XmlDocument.Load%2A> kończy.  
  
 Jeśli ta właściwość nie jest ustawiona, poziom zaufania aplikacji w wersji 1.1 platformy.NET Framework określa zachowanie domyślne.  
  
 `Fully trusted code:` Dokument używa domyślnego <xref:System.Xml.XmlUrlResolver> bez poświadczeń użytkownika. Jeśli uwierzytelnianie jest wymagane do dostępu do zasobu sieciowego, należy użyć `XmlResolver` właściwości w celu określenia `XmlResolver` niezbędne poświadczenia.  
  
 `Semi-trusted code:` `XmlResolver` Właściwość jest ustawiona na `null`. Zasoby zewnętrzne nie są rozpoznawane.  
  
 Aby uzyskać więcej informacji o zabezpieczeniach i `XmlResolver` właściwości, zobacz [rozpoznawanie zasobów zewnętrznych](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Ta właściwość jest rozszerzeniem firmy Microsoft do modelu DOM (Document Object).  
  
   
  
## Examples  
 Poniższy przykład ładuje dokumentu XML, który zawiera odwołanie do pliku definicji DTD. `XmlResolver` Właściwość jest używana do ustawiania poświadczeń niezbędnych do uzyskania dostępu do zasobu sieciowego.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 W przykładzie użyto następujących plików danych jako dane wejściowe.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ta właściwość jest ustawiona <see langword="null" /> i napotkano zewnętrzna definicja DTD lub jednostki.</exception>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
      </Docs>
    </Member>
  </Members>
</Type>
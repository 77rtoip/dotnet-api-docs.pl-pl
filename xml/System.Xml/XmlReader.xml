<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db74cfa4756c2f3e5dfe7de06630b8879e8764e9" /><Meta Name="ms.sourcegitcommit" Value="35aacaa30ef9e16e0ad8ab336c8005724a13199c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/13/2019" /><Meta Name="ms.locfileid" Value="56222507" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje czytnik, która zapewnia szybki i niebuforowany, dostęp tylko do przodu do danych XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> zapewnia dostęp tylko do przodu, tylko do odczytu do danych XML w dokumencie lub strumienia. Ta klasa jest zgodny z W3C [języka XML (Extensible Markup) 1.0 (wydanie czwarte)](https://www.w3.org/TR/2006/REC-xml-20060816/) i [przestrzeni nazw w XML 1.0 (wydanie trzecie)](https://www.w3.org/TR/REC-xml-names/) zalecenia.  
  
 <xref:System.Xml.XmlReader> metody pozwalają na przenoszenie danych XML i odczytywać zawartość węzła. Właściwości klasy odzwierciedlają wartości z bieżącego węzła, który jest, gdy czytnik jest umieszczony. <xref:System.Xml.XmlReader.ReadState%2A> Wartość właściwości wskazuje bieżący stan odczytującego XML. Na przykład właściwość jest równa <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> przez <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> metody i <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> przez <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> metody. <xref:System.Xml.XmlReader> udostępnia również sprawdza zgodność danych i weryfikacji względem DTD lub schematu.  
  
 <xref:System.Xml.XmlReader> używa modelu ściągania do pobierania danych. Ten model:  
  
-   Upraszcza zarządzanie stanem fizycznych, góra dół uściślenia procedurach.  
  
-   Obsługuje wiele strumieni danych wejściowych i warstw.  
  
-   Umożliwia klientowi dać analizator buforu, w którym ciąg bezpośrednio są zapisywane i tym samym pozwala uniknąć konieczności kopiowania dodatkowych parametrów.  
  
-   Obsługuje przetwarzanie selektywnego. Klient może pominąć elementy i przetworzyć te, które mają znaczenie w odniesieniu do aplikacji. Można również ustawić właściwości z wyprzedzeniem, aby zarządzać przetwarzaniu strumień XML (na przykład normalizacji).  
  
 W tej sekcji:  
  
 [Tworzenie czytnika XML](#xmlreader_create)   
 [Sprawdzanie poprawności danych XML](#xmlreader_validate)   
 [Zgodność danych](#xmlreader_data)   
 [Nawigować przez węzły](#xmlreader_nodes)   
 [Elementy XML odczytu](#xmlreader_elements)   
 [Atrybuty XML odczytu](#xmlreader_attributes)   
 [Zawartość XML do odczytu](#xmlreader_content)   
 [Konwertowanie na typy CLR](#xmlreader_clr)   
 [Programowanie asynchroniczne](#xmlreader_async)   
 [Zagadnienia dotyczące bezpieczeństwa](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Tworzenie czytnika XML  
 Użyj <xref:System.Xml.XmlReader.Create%2A> metodę w celu utworzenia <xref:System.Xml.XmlReader> wystąpienia.  
  
 Mimo że program .NET Framework oferuje konkretnych implementacji <xref:System.Xml.XmlReader> klasy, takie jak <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>i <xref:System.Xml.XmlValidatingReader> klas, zalecamy użycie klas wyspecjalizowanych tylko w następujących scenariuszach:  
  
-   Jeśli chcesz odczytać poddrzewo modelu DOM języka XML z <xref:System.Xml.XmlNode> obiektu, należy użyć <xref:System.Xml.XmlNodeReader> klasy. (Jednak ta klasa nie obsługuje sprawdzanie poprawności DTD lub schematu).  
  
-   Jeśli należy rozwinąć jednostek na żądanie, nie chcesz tekstu zawartości znormalizowane lub nie chcesz domyślne atrybuty zwracane, użyj <xref:System.Xml.XmlTextReader> klasy.  
  
 Aby określić zestaw funkcji, które chcesz włączyć na odczytującego XML, należy przekazać <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiekt <xref:System.Xml.XmlReader.Create%2A> metody. Można użyć pojedynczego <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiektu do utworzenia wielu elementów odczytujących z taką samą funkcjonalność lub zmodyfikować <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiektu do utworzenia nowego czytnika, z innym zestawem funkcji. Można również łatwe dodawanie funkcji do istniejącej czytnika.  
  
 Jeśli nie używasz <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiektu, używane są ustawienia domyślne. Zobacz <xref:System.Xml.XmlReader.Create%2A> odwołanie do strony, aby uzyskać szczegółowe informacje.  
  
 <xref:System.Xml.XmlReader> zgłasza <xref:System.Xml.XmlException> XML błędy analizy. Stan czytnika nie jest przewidywalne, po wyjątku. Na przykład typ węzła zgłoszonych może być inny niż typ węzła rzeczywiste bieżącego węzła. Użyj <xref:System.Xml.XmlReader.ReadState%2A> właściwość do sprawdzenia, czy czytnik jest w stanie błąd.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Sprawdzanie poprawności danych XML  
 Aby zdefiniować strukturę dokumentu XML i jej relacje elementu, typów danych oraz ograniczenia zawartości, należy użyć definicji typu dokumentu (DTD) lub schematu języka (XSD) definicji schematu XML. Dokument XML jest uznawany za być poprawnie sformułowany, jeśli dana jednostka spełnia wszystkie wymagania syntaktycznych zdefiniowane przez [zalecenia 1.0 W3C XML](https://www.w3.org/TR/2006/REC-xml-20060816/). Uznaje się nieprawidłowy, gdy jest poprawnie sformułowany i również jest zgodny ze związanych z ograniczeniami zdefiniowanymi przez jego DTD lub schematu. (Zobacz [W3C XML schematu część 1: Struktury](https://www.w3.org/TR/xmlschema-1/) i [W3C XML schematu część 2: Typy danych](https://www.w3.org/TR/xmlschema-2/) zalecenia.) W związku z tym mimo że wszystkie ważne dokumenty XML są poprawnie sformułowane, nie wszystkie poprawnie sformułowany dokumentów XML są prawidłowe.  
  
 Można sprawdzić poprawność danych według definicji DTD, wbudowanego schematu XSD lub schematu XSD przechowywane w <xref:System.Xml.Schema.XmlSchemaSet> obiektu (pamięć podręczna); te scenariusze są opisane na <xref:System.Xml.XmlReader.Create%2A> odwołania do stron. <xref:System.Xml.XmlReader> nie obsługuje sprawdzanie poprawności schematu danych XML (XDR).  
  
 Użyj następujących ustawień na <xref:System.Xml.XmlReaderSettings> klasy w celu określenia jakiego rodzaju sprawdzania poprawności, ewentualnie <xref:System.Xml.XmlReader> wystąpienie obsługuje.  
  
|Użyj tego <xref:System.Xml.XmlReaderSettings> elementu członkowskiego|Aby określić|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> Właściwość|Określa, czy zezwolić na przetwarzanie elementu DTD. Wartość domyślna to nie zezwala na przetwarzanie elementu DTD.|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Właściwość|Czy czytnik powinien sprawdzić poprawność danych i jakiego rodzaju sprawdzania poprawności, aby wykonać (DTD lub schematu). Wartość domyślna to nie nastąpi sprawdzanie poprawności danych.|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler> Zdarzenia|Program obsługi zdarzeń do odbierania informacji na temat zdarzenia sprawdzania poprawności. Jeśli program obsługi zdarzeń nie zostanie podany, <xref:System.Xml.XmlException> jest zgłaszany w przypadku pierwszego błędu walidacji.|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> Właściwość|Dodatkowe sprawdzenie poprawności opcji za pomocą <xref:System.Xml.Schema.XmlSchemaValidationFlags> elementów członkowskich wyliczenia:<br /><br /> -   `AllowXmlAttributes`— Zezwalaj na atrybutów XML (`xml:*`) w dokumentach wystąpienia nawet wtedy, gdy nie są one definiowane w schemacie. Atrybuty są prawidłowe, na podstawie ich typu danych. Zobacz <xref:System.Xml.Schema.XmlSchemaValidationFlags> odwołanie do strony ustawienia do użycia w określonych scenariuszach. (Domyślnie wyłączone.)<br />-   `ProcessIdentityConstraints` --Przetwarzania ograniczenia tożsamości (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) wystąpił podczas sprawdzania poprawności. (Opcja domyślna).<br />-   `ProcessSchemaLocation` --Przetwarzania schematów określony przez `xsi:schemaLocation` lub `xsi:noNamespaceSchemaLocation` atrybutu. (Opcja domyślna).<br />-   `ProcessInlineSchema`--Przetworzyć wbudowane schematów XML podczas sprawdzania poprawności. (Domyślnie wyłączone.)<br />-   `ReportValidationWarnings`--Zgłaszać zdarzenia, jeśli wystąpi Ostrzeżenie sprawdzania poprawności. Zazwyczaj jest wyświetlane ostrzeżenie, gdy nie ma DTD lub schematu XML do sprawdzania poprawności określonego elementu lub atrybutu względem. <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> Jest używana na potrzeby powiadomień. (Domyślnie wyłączone.)|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<xref:System.Xml.Schema.XmlSchemaSet> Do użycia w celu weryfikacji.|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Właściwość|<xref:System.Xml.XmlResolver> Rozpoznawanie i uzyskiwania dostępu do zasobów zewnętrznych. Może to obejmować podmiotów zewnętrznych, takich jak DTD i schematy i wszystkie `xs:include` lub `xs:import` elementów znajdujących się w nim schemat XML. Jeśli nie określisz <xref:System.Xml.XmlResolver>, <xref:System.Xml.XmlReader> używa domyślnego <xref:System.Xml.XmlUrlResolver> bez poświadczeń użytkownika.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Zgodność danych  
 Czytelnicy XML, które są tworzone przez <xref:System.Xml.XmlReader.Create%2A> metoda spełniać następujące wymagania zgodności domyślnie:  
  
-   Nowe wiersze, a wartość atrybutu są znormalizowane zgodnie z W3C [XML 1.0 zalecenie](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Wszystkie jednostki zostaną automatycznie rozwinięte.  
  
-   Atrybuty domyślne zadeklarowanej w definicji typu dokumentu zawsze są dodawane, nawet wtedy, gdy czytnik nie weryfikuje.  
  
-   Deklaracja XML prefiksu mapowany na poprawną przestrzeń nazw XML identyfikatora URI jest dozwolona.  
  
-   Nazw w notacji w jednym `NotationType` atrybutu deklaracji i `NmTokens` w jednym `Enumeration` różniące się od deklaracji atrybutu.  
  
 Te <xref:System.Xml.XmlReaderSettings> właściwości, aby określić typ zgodność sprawdza, czy użytkownik ma mieć możliwość:  
  
|Użyj tego <xref:System.Xml.XmlReaderSettings> właściwości|Zadanie|Domyślny|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> Właściwość|Włączanie lub wyłączanie sprawdza, czy następujące czynności:<br /><br /> -Znaków są w zakresie prawne znaków XML, zgodnie z definicją [2,2 znaków](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) sekcji zalecenia 1.0 W3C XML.<br />— Wszystkie nazwy XML są prawidłowe, zgodnie z definicją [2.3 typowe konstrukcje składni](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) sekcji zalecenia 1.0 W3C XML.<br /><br /> Jeśli ta właściwość jest równa `true` (ustawienie domyślne), <xref:System.Xml.XmlException> wyjątek jest generowany, jeśli plik XML zawiera niedozwolone znaki lub nieprawidłowych nazw XML (na przykład nazwę elementu rozpoczyna się od numeru).|Znak i sprawdzanie nazw jest włączona.<br /><br /> Ustawienie <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> do `false` wyłącza znak sprawdzanie odwołania do jednostki znaku. Jeśli czytnik jest przetwarzanie danych tekstowych, zawsze sprawdza to, że nazwy XML są prawidłowe, niezależnie od tego ustawienia. **Uwaga:**  XML 1.0 zalecenie wymaga zgodność na poziomie dokumentu, gdy obecny jest DTD. W związku z tym Jeśli czytnik jest skonfigurowany do obsługi <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, ale dane XML zawierają definicji typu dokumentu (DTD), <xref:System.Xml.XmlException> zgłaszany.|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> Właściwość|Wybierz poziom zgodności, aby wymusić:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Jest zgodny z regułami dotyczącymi [poprawnie sformułowany dokument XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Jest zgodny z regułami dotyczącymi fragmentu poprawnie sformułowany dokument, które mogą być używane jako [zewnętrzne przeanalizowana jednostka](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Jest zgodna z poziomu przez czytnik.<br /><br /> Jeśli dane nie znajduje się w zgodność, <xref:System.Xml.XmlException> wyjątku.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Nawigować przez węzły  
 Bieżący węzeł jest węzłem XML aktualnie znajduje odczytującego XML. Wszystkie <xref:System.Xml.XmlReader> metody wykonywania operacji w odniesieniu do tego węzła i wszystkich <xref:System.Xml.XmlReader> właściwości odzwierciedlają wartości z bieżącego węzła.  
  
 Poniższych metod można ułatwić nawigować przez węzły i analizowania danych.  
  
|Użyj tego <xref:System.Xml.XmlReaderSettings> — metoda|Zadanie|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Przeczytaj pierwszego węzła i przechodzić przez jeden węzeł strumienia w czasie. Takie połączenia są zazwyczaj wykonywane wewnątrz `while` pętli.<br /><br /> Użyj <xref:System.Xml.XmlReader.NodeType%2A> właściwości, które można pobrać typu (na przykład atrybut, komentarza, elementu i tak dalej) bieżącego węzła.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Pomiń elementy podrzędne bieżącego węzła i przejść do kolejnego węzła.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> i <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Pomiń-content węzłów i przenieść do następnego węzła zawartości lub koniec pliku.<br /><br /> Węzły non-content obejmują <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, i <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Zawartość, węzły zawierają tekst inny niż biały, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , i <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Odczyt elementu i jego elementów podrzędnych i zwracają nową <xref:System.Xml.XmlReader> wystąpienia jest równa <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Ta metoda jest przydatna podczas tworzenia granice wokół elementów XML; na przykład jeśli chcesz przekazać dane do innego składnika do przetwarzania i chcesz ograniczyć ilość danych składnika można uzyskać dostęp.|  
  
 Zobacz <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> odwołania do stron na przykład nawigować przez jeden węzeł strumienia tekstu w danym momencie i wyświetlanie typ każdego węzła.  
  
 W poniższych sekcjach opisano, jak można znaleźć konkretne typy danych, takich jak elementy, atrybuty i wpisanych danych.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Elementy XML odczytu  
 W poniższej tabeli przedstawiono metody i właściwości, <xref:System.Xml.XmlReader> klasa udostępnia do przetwarzania elementów. Po <xref:System.Xml.XmlReader> jest umieszczony w elemencie właściwości węzła, takich jak <xref:System.Xml.XmlReader.Name%2A>, odzwierciedlają wartości elementu. Oprócz elementów członkowskich opisane poniżej, właściwości i metod ogólnych <xref:System.Xml.XmlReader> klasy może również służyć do przetwarzania elementów. Na przykład, można użyć <xref:System.Xml.XmlReader.ReadInnerXml%2A> metodę w celu odczytania zawartości elementu.  
  
> [!NOTE]
>  W sekcji 3.1 [zalecenia 1.0 W3C XML](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) definicje początkowe znaczniki, zakończyć tagi i tagi pustego elementu.  
  
|Użyj tego <xref:System.Xml.XmlReader> elementu członkowskiego|Zadanie|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A> — Metoda|Sprawdź, czy bieżącego węzła jest tag początkowy, czy tag pusty element.|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A> — Metoda|Sprawdź, czy bieżący węzeł jest elementem oraz Rozwijaj czytnik do kolejnego węzła (wywołania <xref:System.Xml.XmlReader.IsStartElement%2A> następuje <xref:System.Xml.XmlReader.Read%2A>).|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A> — Metoda|Sprawdź, czy bieżący węzeł jest tagu końcowego i przejdź proces czytający do kolejnego węzła.|  
|<xref:System.Xml.XmlReader.ReadElementString%2A> — Metoda|Przeczytaj element tekstowy.|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A> — Metoda|Czytnik XML należy przejść do następnego elementu podrzędnym (podrzędne), która ma określoną nazwę.|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A> — Metoda|Wcześniejsze odczytującego XML, aby następny element równorzędny, która ma określoną nazwę.|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A> Właściwość|Sprawdź, czy bieżący element ma tag końcowy elementu. Na przykład:<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> jest `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> jest `false`, chociaż zawartość elementu jest pusta.)|  
  
 Na przykład odczytywanie zawartości tekstowej elementów zobacz <xref:System.Xml.XmlReader.ReadString%2A> metody. Poniższy przykład przetwarza elementy przy użyciu `while` pętli.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Atrybuty XML odczytu  
 Atrybuty XML znajdują się najczęściej w przypadku elementów, ale również mają zezwolenie na deklaracji XML i węzłów typu dokumentu.  
  
 Ustawiony węzeł elementu <xref:System.Xml.XmlReader.MoveToAttribute%2A> metoda umożliwia przejście do listy atrybutów elementu. Należy pamiętać, że po <xref:System.Xml.XmlReader.MoveToAttribute%2A> została wywołana, — właściwości węzła takich jak <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, i <xref:System.Xml.XmlReader.Prefix%2A> odzwierciedlają właściwości tego atrybutu, należy nie właściwości elementu atrybutu.  
  
 <xref:System.Xml.XmlReader> Klasa udostępnia te metody i właściwości, aby odczytywać i przetwarzać atrybutów elementów.  
  
|Użyj tego <xref:System.Xml.XmlReader> elementu członkowskiego|Zadanie|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A> Właściwość|Sprawdź, czy bieżący węzeł ma żadnych atrybutów.|  
|<xref:System.Xml.XmlReader.AttributeCount%2A> Właściwość|Pobieranie liczby atrybutów dla bieżącego elementu.|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> — Metoda|Przenieś do pierwszego atrybutu w elemencie.|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A> — Metoda|Przenieś do następnego atrybutu w elemencie.|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A> — Metoda|Przejście do określonego atrybutu.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> Metoda lub <xref:System.Xml.XmlReader.Item%2A> właściwości|Pobiera wartość określonego atrybutu.|  
|<xref:System.Xml.XmlReader.IsDefault%2A> Właściwość|Sprawdź, czy bieżącego węzła jest atrybut, który został wygenerowany z wartości domyślnej zdefiniowanej w DTD lub schematu.|  
|<xref:System.Xml.XmlReader.MoveToElement%2A> — Metoda|Przenieś do elementu, który jest właścicielem bieżący atrybut. Użyj tej metody, aby zwrócić do elementu po przejściu przez jego atrybuty.|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A> — Metoda|Przeanalizuj wartość atrybutu do co najmniej jeden `Text`, `EntityReference`, lub `EndEntity` węzłów.|  
  
 Jedną z ogólnych <xref:System.Xml.XmlReader> metody i właściwości można również Przetwarzaj atrybutów. Na przykład po <xref:System.Xml.XmlReader> jest umieszczony w atrybucie <xref:System.Xml.XmlReader.Name%2A> i <xref:System.Xml.XmlReader.Value%2A> właściwości odzwierciedlają wartości atrybutu. Można również użyć żadnej zawartości `Read` metody w celu uzyskania wartość atrybutu.  
  
 W tym przykładzie użyto <xref:System.Xml.XmlReader.AttributeCount%2A> właściwości, aby przejść przez wszystkie atrybuty w elemencie.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 W tym przykładzie użyto <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> method in Class metoda `while` pętli, aby poruszać się po atrybutów.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Odczyt atrybutów w węzłach deklaracji XML**  
  
 Gdy czytnik XML znajduje się w węźle deklaracji XML <xref:System.Xml.XmlReader.Value%2A> właściwość zwraca wersji, autonomicznej i kodowania informacji jako pojedynczy ciąg. <xref:System.Xml.XmlReader> obiekty utworzone przez <xref:System.Xml.XmlReader.Create%2A> metody <xref:System.Xml.XmlTextReader> klasy, a <xref:System.Xml.XmlValidatingReader> klasy udostępnienia wersji, autonomicznej i kodowania elementów jako atrybuty.  
  
 **Odczyt atrybutów w węzłach typu dokumentu**  
  
 Gdy czytnik XML znajduje się w węźle typu dokumentu <xref:System.Xml.XmlReader.GetAttribute%2A> metody i <xref:System.Xml.XmlReader.Item%2A> właściwość może służyć do zwracania wartości literałów SYSTEM i publiczne. Na przykład, wywołanie `reader.GetAttribute("PUBLIC")` zwraca wartość publicznego.  
  
 **Odczytywanie atrybutów dotyczących przetwarzania instrukcji węzłów**  
  
 Gdy <xref:System.Xml.XmlReader> jest ustawiony na węzeł przetwarzania instrukcji <xref:System.Xml.XmlReader.Value%2A> właściwość zwraca zawartości całego tekstu. Elementy w węźle instrukcji przetwarzania nie są traktowane jako atrybuty. Nie można odczytać z <xref:System.Xml.XmlReader.GetAttribute%2A> lub <xref:System.Xml.XmlReader.MoveToAttribute%2A> metody.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Zawartość XML do odczytu  
 Klasa XMLReader obejmuje następujące elementy członkowskie, które odczyt zawartości z pliku XML i zwraca zawartość jako wartości ciągu. (Aby zwrócić typy CLR, zobacz [następnej sekcji](#xmlreader_clr).)  
  
|Użyj tego <xref:System.Xml.XmlReader> elementu członkowskiego|Zadanie|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A> Właściwość|Pobierz zawartość tekstu dla bieżącego węzła. Wartość zwracana jest zależna od typu węzła zobacz <xref:System.Xml.XmlReader.Value%2A> odwołanie do strony, aby uzyskać szczegółowe informacje.|  
|<xref:System.Xml.XmlReader.ReadString%2A> — Metoda|Pobierz zawartość węzła element lub tekst jako ciąg. Ta metoda zatrzymuje się na przetwarzanie instrukcji i komentarze.<br /><br /> Szczegółowe informacje na temat jak ta metoda obsługuje typy określonego węzła, <xref:System.Xml.XmlReader.ReadString%2A> odwołania do stron.|  
|<xref:System.Xml.XmlReader.ReadInnerXml%2A> i <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> metody|Pobierz całą zawartość bieżącego węzła, w tym znaczników, z wyłączeniem tagiem początkowym i końcowym. Na przykład:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> Zwraca:<br /><br /> `this<child id="123"/>`|  
|<xref:System.Xml.XmlReader.ReadOuterXml%2A> i <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> metody|Pobierz całą zawartość bieżącego węzła i jego elementy podrzędne, włączając tagi znaczników i rozpoczęcia/zakończenia. Na przykład:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> Zwraca:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Konwertowanie na typy CLR  
 Można użyć elementów członkowskich <xref:System.Xml.XmlReader> klasy (wymienione w poniższej tabeli) do odczytywania danych XML i wartości zwracane jako wspólny język typów środowiska wykonawczego (języka wspólnego CLR), zamiast ciągów. Te elementy członkowskie pozwalają uzyskać wartości w reprezentacji, który jest najbardziej odpowiednie dla Twojego zadania kodowania, bez konieczności ręcznie analizowanie i konwertowanie wartości ciągu.  
  
-   **ReadElementContentAs** metody można wywołać tylko w ramach typów węzłów elementów. Te metody nie można używać w przypadku elementów, które zawierają elementy podrzędne lub zawartość mieszana. Po wywołaniu <xref:System.Xml.XmlReader> obiektu odczytuje tagu początkowego odczytuje zawartość elementu i przenosi poza końcowym tagu elementu. Instrukcje przetwarzania i komentarze są ignorowane i jednostek zostaną rozwinięte.  
  
-   **ReadContentAs** metody odczytu zawartości tekstowej w bieżącym położeniu czytnika i jeśli w danych XML nie ma żadnych schematów ani danych skojarzonych z nim, informacje o typie konwertowanie zawartości tekstowej na żądany typ zwracany. Tekst, biały znak, istotnych białych i CDATA sekcje są łączone. Komentarze i instrukcje przetwarzania są pomijane, a odwołania do jednostek są automatycznie rozwiązany.  
  
 <xref:System.Xml.XmlReader> Klasa używa reguł zdefiniowanych [część 2 W3C XML schematu: Typy danych](https://www.w3.org/TR/xmlschema-2/) zalecenia.  
  
|Użyj tego <xref:System.Xml.XmlReader> — metoda|Aby powrócić do tego typu CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> i <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|Typ, określ za pomocą `returnType` parametru|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> i <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|Najbardziej odpowiedniego typu, określony przez <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> właściwości. Zobacz [Obsługa typu w ramach klas zestawu System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) Aby uzyskać informacje dotyczące mapowania.|  
  
 Jeśli elementu nie można łatwo przekonwertować na typ CLR ze względu na jego format, można użyć mapowanie schematu, aby zapewnić pomyślne konwersji. W poniższym przykładzie użyto pliku XSD, aby przekonwertować `hire-date` elementu `xs:date` typu, a następnie używa <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> metody w celu zwrócenia elementu jako <xref:System.DateTime> obiektu.  
  
 **Dane wejściowe (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Schemat (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Kod:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Dane wyjściowe:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Programowanie asynchroniczne  
 Większość <xref:System.Xml.XmlReader> metody mają asynchronicznego ich odpowiedniki, które mają "Async" na końcu nazwy metody. Na przykład asynchronicznego odpowiednik <xref:System.Xml.XmlReader.ReadContentAsObject%2A> jest <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Za pomocą wywołania metody asynchronicznej można używać następujących metod:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 W poniższych sekcjach opisano asynchronicznego użycia dla metod, które nie mają odpowiedniki asynchronicznego.  
  
 **Metoda ReadStartElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **Metoda ReadEndElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **Metoda ReadToNextSibling**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **Metoda ReadToFollowing**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **Metoda ReadToDescendant**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Zagadnienia dotyczące bezpieczeństwa  
 Rozważ następujące opcje podczas pracy z <xref:System.Xml.XmlReader> klasy:  
  
-   Wyjątków zgłaszanych przez <xref:System.Xml.XmlReader> może ujawnić informacje o ścieżce, która może nie być przetwarzane do swojej aplikacji. Aplikacja musi przechwytywać wyjątki i odpowiednio je przetwarzać.  
  
-   Nie należy włączać przetwarzanie elementu DTD, czy też obawiasz typu "odmowa" problemy z usługą, czy w przypadku rozwiązywania problemów związanych z niezaufanego źródła. Przetwarzanie elementu DTD jest domyślnie wyłączona dla <xref:System.Xml.XmlReader> obiekty utworzone przez <xref:System.Xml.XmlReader.Create%2A> metody.  
  
     Jeśli masz przetwarzanie elementu DTD, włączone, możesz użyć <xref:System.Xml.XmlSecureResolver> do ograniczania zasobów, <xref:System.Xml.XmlReader> można uzyskać dostęp. Istnieje również możliwość projektowania aplikacji tak, aby przetwarzania XML jest pamięć i ograniczonego czasu. Na przykład można skonfigurować limitów czasu w aplikacji ASP.NET.  
  
-   Dane XML mogą zawierać odwołania do zasobów zewnętrznych, takich jak plik schematu. Domyślnie zasoby zewnętrzne są rozwiązywane za pomocą <xref:System.Xml.XmlUrlResolver> obiektu bez poświadczeń użytkownika. Zabezpiecza ją, wykonując jedną z następujących czynności:  
  
    -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
  
    -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwość `null`.  
  
-   <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> i <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> flagi weryfikacji <xref:System.Xml.XmlReaderSettings> obiektu nie są domyślnie. Pomaga to chronić <xref:System.Xml.XmlReader> przed atakami schematu podczas przetwarzania danych XML z niezaufanego źródła. Gdy te flagi są ustawiane, <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> z <xref:System.Xml.XmlReaderSettings> obiekt jest używany do rozpoznawania lokalizacji schemat w dokumencie wystąpienia w <xref:System.Xml.XmlReader>. Jeśli <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość jest ustawiona na `null`, lokalizacji schematu nie są rozwiązane nawet wtedy, gdy <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> i <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> ustawiono flagi weryfikacji.  
  
     Dodany podczas weryfikacji schematów dodać nowe typy i zmienić wynik sprawdzania poprawności dokumentu weryfikowana. W rezultacie Schematy zewnętrzne mają zostać rozwiązane z zaufanych źródeł.  
  
     Zaleca się wyłączenie <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> Flaga podczas sprawdzania poprawności niezaufanych, dużych dokumentów XML w scenariuszach wysokiej dostępności ze schematem, który ma ograniczenia tożsamości przez dużą część dokumentu. Ta flaga jest włączona domyślnie.  
  
-   Dane XML może zawierać dużej liczby atrybutów, deklaracje przestrzeni nazw, elementy zagnieżdżone i tak dalej wymagające znaczną ilość czasu przetwarzania. Aby ograniczyć rozmiar danych wejściowych, które są wysyłane do <xref:System.Xml.XmlReader>, możesz:  
  
    -   Limit rozmiaru dokumentu, ustawiając <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> właściwości.  
  
    -   Ogranicz liczbę znaków, które wynikają z rozwijanie jednostek, ustawiając <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> właściwości.  
  
    -   Utwórz niestandardową `IStream` implementację <xref:System.Xml.XmlReader>.  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A> Metoda może służyć do obsługi dużych strumieni danych. Ta metoda odczytuje niewielką liczbę znaków w czasie, zamiast przydzielać pojedynczego ciągu dla wartości całkowitej.  
  
-   Podczas odczytu dokumentu XML z dużą liczbą unikatowych nazw lokalnych, przestrzenie nazw i prefiksy, może wystąpić problem. Jeśli używasz klasy, która pochodzi od klasy <xref:System.Xml.XmlReader>, można wywołać <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, lub <xref:System.Xml.XmlReader.NamespaceURI%2A> właściwości dla każdego elementu zwróconym ciągu zostanie dodany do <xref:System.Xml.NameTable>. Kolekcja posiadaniu <xref:System.Xml.NameTable> nigdy nie zmniejsza rozmiar, tworzenia przeciek pamięci wirtualnej uchwytów ciągu. Jeden środki zaradcze dla tego ma dziedziczyć <xref:System.Xml.NameTable> klasy i wymuszanie przydziałów maksymalny rozmiar. (Nie istnieje sposób, aby uniemożliwić korzystanie z <xref:System.Xml.NameTable>, lub aby przełączyć <xref:System.Xml.NameTable> gdy jest pełny). Ograniczenia innego jest Unikaj używania właściwości wymienionych i zamiast tego użyć <xref:System.Xml.XmlReader.MoveToAttribute%2A> metody z <xref:System.Xml.XmlReader.IsStartElement%2A> metoda gdzie to możliwe; tych metod nie zwracać ciągi, a więc uniknąć tego problemu z przepełnienie <xref:System.Xml.NameTable> kolekcji.  
  
-   <xref:System.Xml.XmlReaderSettings> obiekty mogą zawierać poufne informacje, takie jak poświadczenia użytkownika. Wystarczą niezaufany składnik <xref:System.Xml.XmlReaderSettings> obiekt i jego poświadczenia użytkownika, aby utworzyć <xref:System.Xml.XmlReader> obiektów, które można odczytać danych. Należy zachować ostrożność podczas buforowania <xref:System.Xml.XmlReaderSettings> obiektów, lub podczas przekazywania <xref:System.Xml.XmlReaderSettings> obiekt z jednego składnika.  
  
-   Nie są akceptowane składniki pomocnicze, takie jak <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, i <xref:System.Xml.XmlResolver> obiektów z niezaufanego źródła.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak przeanalizować kodu XML za pomocą asynchronicznego interfejsu API.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md">Dokumenty i dane XML</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlReader" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez Konstruktory klasy pochodnej do zainicjowania stanu, w tym typie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej pobiera liczby atrybutów w bieżącym węźle.</summary>
        <value>Liczba atrybutów w bieżącym węźle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do `Element`, `DocumentType` i `XmlDeclaration` tylko węzłów. (Inne typy węzłów nie mają atrybutów).  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera podstawowy identyfikator URI bieżącego węzła.</summary>
        <value>Podstawowy identyfikator URI bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sieciowych dokumentu XML składa się z fragmentów dane zagregowane, przy użyciu różnych mechanizmów włączenia standard W3C, dlatego zawiera węzły, które pochodzą z różnych miejsc. Jednostki DTD są na przykład, ale nie jest ograniczone do elementów DTD. Podstawowy identyfikator URI informuje, skąd pochodzą te węzły. Czy nie podstawowy identyfikator URI dla węzłów, są zwracane (na przykład one zostały przeanalizować ciągu w pamięci), `String.Empty` jest zwracana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Xml.XmlReader" /> implementuje zawartość binarna odczytu metod.</summary>
        <value><see langword="true" /> Jeśli binarne zawartości metody odczytu są implementowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawartość binarna odczytu metody obejmują <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, i <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> metody. Jeśli ta właściwość zwraca `false` <xref:System.NotSupportedException> jest zwracany, jeśli dowolne dane binarne do odczytu nosi nazwę metody.  
  
 Wszystkich implementacjach Microsoft .NET Framework <xref:System.Xml.XmlReader> klasy zwrócenia `true` dla tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Xml.XmlReader" /> implementuje <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> metody.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Xml.XmlReader" /> implementuje <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> metoda; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Analizowanie tekstu <xref:System.Xml.XmlReader> obiektów, które zostały utworzone przy użyciu statycznych <xref:System.Xml.XmlReader.Create%2A> zawsze zwrotu metody `true`. Inne implementacje platformy Microsoft .NET Framework z <xref:System.Xml.XmlReader> klasy, łącznie z <xref:System.Xml.XmlTextReader> klas, zwracać `false`.  
  
 Jeśli ta właściwość zwraca `false` <xref:System.NotSupportedException> jest zwracana, gdy <xref:System.Xml.XmlReader.ReadValueChunk%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten czytnik można przeanalizować i rozpoznać jednostki.</summary>
        <value><see langword="true" /> Jeśli czytnik można przeanalizować i rozpoznać jednostki; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość ta zwraca zawsze `false` implementacji <xref:System.Xml.XmlReader> nie obsługują informacji DTD. W takim przypadku wywołanie <xref:System.Xml.XmlReader.ResolveEntity%2A> zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zmienia <see cref="P:System.Xml.XmlReader.ReadState" /> do <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda również zwalnia wszystkie zasoby utrzymywane podczas czytania. Jeśli <xref:System.Xml.XmlReader.Close%2A> została już wywołana, jest wykonywana żadna akcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość <xref:System.Xml.XmlReader.Create%2A> przeciążenia zawierają `settings` parametr, który akceptuje <xref:System.Xml.XmlReaderSettings> obiektu. Można użyć tego obiektu w celu:  
  
-   Określ, które funkcje mają być obsługiwane w systemie <xref:System.Xml.XmlReader> obiektu.  
  
-   Ponowne użycie <xref:System.Xml.XmlReaderSettings> obiektu do utworzenia wielu czytników. Do utworzenia wielu elementów odczytujących z taką samą funkcjonalność, można użyć tych samych ustawień. Ewentualnie można zmodyfikować ustawienia na <xref:System.Xml.XmlReaderSettings> wystąpienia i tworzenie nowego czytnika z innym zestawem funkcji.  
  
-   Dodawanie funkcji do istniejącej odczytującego XML. <xref:System.Xml.XmlReader.Create%2A> Metoda może akceptować innego <xref:System.Xml.XmlReader> obiektu. Podstawowe <xref:System.Xml.XmlReader> obiekt może być czytnik zdefiniowanych przez użytkownika <xref:System.Xml.XmlTextReader> obiektu lub innym <xref:System.Xml.XmlReader> wystąpienie, które chcesz dodać dodatkowych funkcji.  
  
-   Umożliwiają pełne wykorzystywanie zalet funkcje, takie jak lepsza sprawdzanie zgodności oraz zgodność w celu [XML 1.0 (wydanie czwarte)](https://www.w3.org/TR/2006/REC-xml-20060816/) zalecenia, które są dostępne tylko na <xref:System.Xml.XmlReader> obiekty utworzone przez statyczną <xref:System.Xml.XmlReader.Create%2A> metody.  
  
> [!NOTE]
>  Mimo że program .NET Framework zawiera konkretnych implementacji <xref:System.Xml.XmlReader> klasy, takie jak <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>i <xref:System.Xml.XmlValidatingReader> klas, zaleca się utworzenie <xref:System.Xml.XmlReader> wystąpień przy użyciu <xref:System.Xml.XmlReader.Create%2A> Metoda.  
  
## <a name="default-settings"></a>Ustawienia domyślne  
 Jeśli używasz <xref:System.Xml.XmlReader.Create%2A> przeciążenia, które nie akceptuje <xref:System.Xml.XmlReaderSettings> obiektu, stosowane są następujące domyślne ustawienia czytnika:  
  
|Ustawienie|Domyślny|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Pusta <xref:System.Xml.Schema.XmlSchemaSet> obiektu|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> Włączone|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Nowy <xref:System.Xml.XmlUrlResolver> obiektu.  Począwszy od programu .NET Framework 4.5.2, to ustawienie ma wartość domyślną `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Ustawienia dla typowych scenariuszy  
 Poniżej przedstawiono <xref:System.Xml.XmlReaderSettings> właściwości, należy ustawić dla niektórych typowych scenariuszy czytnika XML.  
  
|Wymaganie|Zestaw|  
|-----------------|---------|  
|Dane muszą być poprawnie sformułowany dokument XML.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> Aby <xref:System.Xml.ConformanceLevel.Document>.|  
|Dane muszą być poprawnie sformułowany jednostki XML przeanalizować.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> Aby <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Data, musi być weryfikowany pod kątem DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> Aby <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.DTD>.|  
|Względem schematu XML, można sprawdzić poprawności danych.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> Aby <xref:System.Xml.Schema.XmlSchemaSet> do użycia w celu weryfikacji. Należy pamiętać, że <xref:System.Xml.XmlReader> nie obsługuje sprawdzanie poprawności schematu danych XML (XDR).|  
|Data, musi być weryfikowany pod kątem wbudowanego schematu XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> Aby <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Obsługa typu.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> Aby <xref:System.Xml.Schema.XmlSchemaSet> do użycia.|  
  
 <xref:System.Xml.XmlReader> nie obsługuje sprawdzanie poprawności schematu danych XML (XDR).  
  
## <a name="asynchronous-programming"></a>Programowanie asynchroniczne  
 W trybie synchronicznym <xref:System.Xml.XmlReader.Create%2A> metoda odczytuje pierwszego fragmentu danych z bufora czytnik plików, strumienia lub tekstu. W przypadku niepowodzenia operacji We/Wy, to zgłosić wyjątek. W trybie asynchronicznym pierwszej operacji We/Wy występuje za pomocą operacji odczytu, więc wyjątki zostanie wygenerowany po wystąpieniu operacji odczytu.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące bezpieczeństwa  
 Domyślnie <xref:System.Xml.XmlReader> używa <xref:System.Xml.XmlUrlResolver> obiektu przy użyciu poświadczeń użytkownika, nie można otworzyć zasobów. Oznacza to, że, domyślnie odczytującego XML mają dostęp do dowolnej lokalizacji, która nie wymaga poświadczeń. Użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości do kontrolowania dostępu do zasobów:  
  
-   Ustaw <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> do <xref:System.Xml.XmlSecureResolver> celem jest ograniczenie zasobów, które mogą uzyskiwać dostęp do modułu odczytującego XML.  
  
 —lub—  
  
-   Ustaw <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> do `null` aby uniemożliwić otwarcie dowolnych zasobów zewnętrznych odczytującego XML.  
  
   
  
## Examples  
 Ten przykład tworzy odczytującego XML, paski nieważny biały znak, który usuwa komentarze i wykonuje sprawdzanie zgodności na poziomie fragmentu.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 W poniższym przykładzie użyto <xref:System.Xml.XmlUrlResolver> przy użyciu domyślnych poświadczeń do uzyskania dostępu do pliku.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 Poniższy kod opakowuje wystąpienia czytnika, w ramach innego czytnika.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 W tym przykładzie tworzy powiązanie odbiorcy, aby dodać sprawdzanie poprawności schematu DTD i XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  
  
<see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty strumienia szukasz znacznika kolejności bajtów lub inne znaki kodowania. Gdy zostanie uznane za kodowanie, kodowanie jest używany do kontynuowania odczytu strumienia, a następnie kontynuuje przetwarzanie, analizowanie danych wejściowych jako strumień znaków (Unicode).</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> z ustawieniami domyślnymi przy użyciu określonego strumienia.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings> Obiektu przy użyciu ustawień domyślnych służy do tworzenia czytnika. Jeśli chcesz określić funkcje do obsługi na utworzonej czytnika, użyj przeciążenia, które przyjmuje <xref:System.Xml.XmlReaderSettings> obiektu jako jeden z argumentów i przekazać <xref:System.Xml.XmlReaderSettings> obiektu z prawidłowymi ustawieniami.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy określić <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiekt, który odczytuje z <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> Nie ma wystarczających uprawnień do uzyskania dostępu do lokalizacji w danych XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumienia znaków Unicode, więc kodowaniem określonym w deklaracji XML nie jest używany przez czytnik XML do zdekodowania strumienia danych.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu czytnika określony tekst.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings> Obiektu przy użyciu ustawień domyślnych służy do tworzenia czytnika. Jeśli chcesz określić funkcje do obsługi na utworzonej czytnika, użyj przeciążenia, które przyjmuje <xref:System.Xml.XmlReaderSettings> obiektu jako jeden z argumentów i przekazać <xref:System.Xml.XmlReaderSettings> obiektu z prawidłowymi ustawieniami.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy określić <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.StringReader> klasy do odczytywania ciągu XML.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">Identyfikator URI dla pliku, który zawiera dane XML. <see cref="T:System.Xml.XmlUrlResolver" /> Klasa jest używana, aby przekonwertować ścieżkę na reprezentację w postaci kanonicznej danych.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego identyfikatora URI.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings> Obiektu przy użyciu ustawień domyślnych służy do tworzenia czytnika. Jeśli chcesz określić funkcje do obsługi na utworzonej czytnika, użyj przeciążenia, które przyjmuje <xref:System.Xml.XmlReaderSettings> obiektu jako jeden z argumentów i przekazać <xref:System.Xml.XmlReaderSettings> obiektu z prawidłowymi ustawieniami.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy określić <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiekt, który odczytuje plik danych XML określony przez identyfikator URI.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputUri" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> Nie ma wystarczających uprawnień do uzyskania dostępu do lokalizacji w danych XML.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik identyfikowane przez identyfikator URI nie istnieje.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Format identyfikatora URI jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  
  
<see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty strumienia szukasz znacznika kolejności bajtów lub inne znaki kodowania. Gdy zostanie uznane za kodowanie, kodowanie jest używany do kontynuowania odczytu strumienia, a następnie kontynuuje przetwarzanie, analizowanie danych wejściowych jako strumień znaków (Unicode).</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia określonego strumienia i ustawieniami.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumienia znaków Unicode, więc kodowaniem określonym w deklaracji XML nie jest używany przez czytnik XML do zdekodowania strumienia danych.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" />. Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu czytnika określony tekst i ustawień.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">Identyfikator URI pliku zawierającego dane XML. <see cref="T:System.Xml.XmlResolver" /> Obiekt <see cref="T:System.Xml.XmlReaderSettings" /> obiekt jest używany, aby przekonwertować ścieżkę na reprezentację w postaci kanonicznej danych. Jeśli <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> jest <see langword="null" />, nowy <see cref="T:System.Xml.XmlUrlResolver" /> obiekt jest używany.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego identyfikatora URI i ustawień.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Oznacza to, że <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do dowolnej lokalizacji, które nie wymaga uwierzytelniania. Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Możliwe jest ograniczenie zasobów, <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiekt, który obsługuje sprawdzanie poprawności definicji (DTD) typu dokumentu.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputUri" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku określonego przez identyfikator URI.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Format identyfikatora URI jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">Obiekt, który ma być używany jako podstawowy odczytującego XML.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia.  
  
Poziom zgodności <see cref="T:System.Xml.XmlReaderSettings" /> obiektu, albo musi odpowiadać stopień zgodności ze standardem czytnika podstawowego, lub musi być ustawione na <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego czytnika XML i ustawień.</summary>
        <returns>Obiekt, który jest otoczony wokół określonego <see cref="T:System.Xml.XmlReader" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Dodaj dodatkowe funkcje do podstawowej <xref:System.Xml.XmlReader> obiektu. Podstawowe <xref:System.Xml.XmlReader> obiekt może być inny <xref:System.Xml.XmlReader> obiekt utworzony przez <xref:System.Xml.XmlReader.Create%2A> metody lub <xref:System.Xml.XmlReader> obiekt utworzony przy użyciu jednej z konkretami <xref:System.Xml.XmlReader> implementacji.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak schemat.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy określić <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy, sprawdzanie poprawności <xref:System.Xml.XmlReader> obiekt, który otacza <xref:System.Xml.XmlNodeReader> obiektu.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeśli <see cref="T:System.Xml.XmlReaderSettings" /> obiektu określa poziom zgodności, który nie jest spójna z poziomem zgodności czytnika podstawowego.  
  
—lub— 
Podstawowe <see cref="T:System.Xml.XmlReader" /> znajduje się w <see cref="F:System.Xml.ReadState.Error" /> lub <see cref="F:System.Xml.ReadState.Closed" /> stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  
  
<see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty strumienia szukasz znacznika kolejności bajtów lub inne znaki kodowania. Gdy zostanie uznane za kodowanie, kodowanie jest używany do kontynuowania odczytu strumienia, a następnie kontynuuje przetwarzanie, analizowanie danych wejściowych jako strumień znaków (Unicode).</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="baseUri">Podstawowy identyfikator URI dla jednostki lub odczytu dokumentu. Ta wartość może być <see langword="null" />.  
  
 **Uwaga dotycząca zabezpieczeń** podstawowy identyfikator URI jest używany do rozpoznawania względny identyfikator URI dokumentu XML. Nie używaj podstawowego identyfikatora URI z niezaufanego źródła.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> przy użyciu określonego strumienia, podstawowy identyfikator URI i ustawień.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  
  
<see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty strumienia szukasz znacznika kolejności bajtów lub inne znaki kodowania. Gdy zostanie uznane za kodowanie, kodowanie jest używany do kontynuowania odczytu strumienia, a następnie kontynuuje przetwarzanie, analizowanie danych wejściowych jako strumień znaków (Unicode).</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="inputContext">Informacje o kontekście wymaganych do analizy fragmentu XML. Może zawierać informacje o kontekście <see cref="T:System.Xml.XmlNameTable" /> do użycia, kodowanie, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c> i <c>XML: Space</c> zakres, bazowy identyfikator URI i definicji typu dokumentu.  
  
Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> przy użyciu określonego strumienia, ustawieniami i kontekstem informacje do analizy.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumienia znaków Unicode, więc kodowaniem określonym w deklaracji XML nie jest używany przez <see cref="T:System.Xml.XmlReader" /> zdekodować strumienia danych.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="baseUri">Podstawowy identyfikator URI dla jednostki lub odczytu dokumentu. Ta wartość może być <see langword="null" />.  
  
 **Uwaga dotycząca zabezpieczeń** podstawowy identyfikator URI jest używany do rozpoznawania względny identyfikator URI dokumentu XML. Nie używaj podstawowego identyfikatora URI z niezaufanego źródła.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu czytnika określonego tekstu, ustawienia i bazowy identyfikator URI.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumienia znaków Unicode, więc kodowaniem określonym w deklaracji XML nie jest używany przez czytnik XML do zdekodowania strumienia danych.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="inputContext">Informacje o kontekście wymaganych do analizy fragmentu XML. Może zawierać informacje o kontekście <see cref="T:System.Xml.XmlNameTable" /> do użycia, kodowanie, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c> i <c>XML: Space</c> zakres, bazowy identyfikator URI i definicji typu dokumentu.  
  
Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu informacji o czytnika, ustawieniami i kontekstem określony tekst do analizy.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Używasz jednej z następujących metod do kontrolowania zasobów, które <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiekt, który odczytuje XML fragment.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> i <see cref="P:System.Xml.XmlParserContext.NameTable" /> obie właściwości zawierają wartości. (Tylko jeden z tych <see langword="NameTable" /> właściwości można ustawić i używane).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">Identyfikator URI pliku zawierającego dane XML. <see cref="T:System.Xml.XmlResolver" /> Obiekt <see cref="T:System.Xml.XmlReaderSettings" /> obiekt jest używany, aby przekonwertować ścieżkę na reprezentację w postaci kanonicznej danych. Jeśli <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> jest <see langword="null" />, nowy <see cref="T:System.Xml.XmlUrlResolver" /> obiekt jest używany.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="inputContext">Informacje o kontekście wymaganych do analizy fragmentu XML. Może zawierać informacje o kontekście <see cref="T:System.Xml.XmlNameTable" /> do użycia, kodowanie, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c> i <c>XML: Space</c> zakres, bazowy identyfikator URI i definicji typu dokumentu.  
  
Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego identyfikatora URI, ustawieniami i kontekstem informacje do analizy.</summary>
        <returns>Obiekt, który jest używany do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak definicja typu dokumentu (DTD), jednostki, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, Brak domyślnych <xref:System.Xml.XmlUrlResolver> podano. Jeśli rozwiązanie jest przeznaczony dla .NET Framework 4.5.2 lub nowszej wersji, należy określić <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Oznacza to, że <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do dowolnej lokalizacji, które nie wymaga uwierzytelniania. Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Możliwe jest ograniczenie zasobów, <xref:System.Xml.XmlReader> dostęp można uzyskać przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość <xref:System.Xml.XmlSecureResolver> obiektu.  
  
 Utworzony <xref:System.Xml.XmlReader> obiekt rozwija odwołań do jednostek i wykonuje normalizacji XML znaków nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see langword="inputUri" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> Nie ma wystarczających uprawnień do uzyskania dostępu do lokalizacji w danych XML.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> i <see cref="P:System.Xml.XmlParserContext.NameTable" /> obie właściwości zawierają wartości. (Tylko jeden z tych <see langword="NameTable" /> właściwości można ustawić i używane).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku określonego przez identyfikator URI.</exception>
        <exception cref="T:System.UriFormatException">Format identyfikatora URI jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera głębokość bieżącego węzła, w dokumencie XML.</summary>
        <value>Głębokość bieżącego węzła w dokumencie XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.Depth%2A> (w `XmlTextReader` klasy) na przykład za pomocą tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Xml.XmlReader" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Xml.XmlReader" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Xml.XmlReader" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy czytnik jest umieszczony na końcu strumienia.</summary>
        <value><see langword="true" /> Jeśli czytnik jest umieszczony na końcu strumienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks ten atrybut. Jest to indeks zaczynający się od zera. (Pierwszy atrybut ma indeks 0).</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonym indeksem.</summary>
        <returns>Wartość określonego atrybutu. Ta metoda nie powoduje przeniesienia czytelnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu trzeciego.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i" /> jest poza zakresem. Musi być nieujemną i mniejszą niż rozmiar kolekcji atrybutów.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, lub wartość jest <see langword="String.Empty" />, <see langword="null" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie powoduje przeniesienia czytelnika.  
  
 Jeśli czytnik jest umieszczony na `DocumentType` węzła, Metoda ta może służyć do Pobierz PUBLICZNY i systemu literały, na przykład `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, lub wartość jest <see langword="String.Empty" />, <see langword="null" /> jest zwracana. Ta metoda nie powoduje przeniesienia czytelnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujący kod XML zawiera atrybut w określonej przestrzeni nazw:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Można wyszukać `dt:type` atrybutu przy użyciu jednego argumentu (prefiksu i lokalna nazwa) lub dwóch argumentów (lokalna nazwa i identyfikator URI przestrzeni nazw):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Do wyszukiwania `xmlns:dt` atrybutu, użyj jednej z następujących argumentów:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Można również uzyskać te informacje przy użyciu <xref:System.Xml.XmlReader.Prefix%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie pobiera wartość bieżącego węzła.</summary>
        <returns>Wartość bieżącego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku".

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jakiekolwiek atrybuty bieżącego węzła.</summary>
        <value><see langword="true" /> Jeśli bieżący węzeł atrybutów, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący węzeł może mieć <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value><see langword="true" /> Jeśli węzeł, na którym czytnik jest obecnie umieszczony może mieć <see langword="Value" />; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, węzeł ma wartość <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono typy węzłów, które mają wartość do zwrócenia.  
  
|Typ węzła|Wartość|  
|---------------|-----------|  
|`Attribute`|Wartość atrybutu.|  
|`CDATA`|Zawartość sekcji CDATA.|  
|`Comment`|Treść komentarza.|  
|`DocumentType`|Wewnętrzny podzbiór.|  
|`ProcessingInstruction`|Całej zawartości, z wyłączeniem element docelowy.|  
|`SignificantWhitespace`|Odstępy między znaczników w modelu zawartości mieszanej.|  
|`Text`|Zawartość węzła tekstowego.|  
|`Whitespace`|Odstępy między znaczników.|  
|`XmlDeclaration`|Zawartość deklaracji.|  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.HasValue%2A> (w `XmlTextReader` klasy) dla próbki, przy użyciu tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego węzła jest atrybut, który został wygenerowany z wartości domyślnej zdefiniowanej w DTD lub schematu.</summary>
        <value><see langword="true" /> Jeśli bieżącego węzła jest atrybutem, którego wartość została wygenerowana na podstawie wartości domyślnej zdefiniowanej w DTD lub schematu; <see langword="false" /> Jeśli jawnie ustawiono wartość atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` zawsze zwraca `false` implementacji `XmlReader` które nie obsługują schemat lub DTD informacji. Ta właściwość dotyczy tylko węzeł atrybutu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty dla elementu głównego.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 W przykładzie użyto następujące pliki jako dane wejściowe.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący węzeł jest elementem pustym (na przykład <c>&lt;MyElement /&gt;</c>).</summary>
        <value><see langword="true" /> Jeśli bieżący węzeł jest elementem (<see cref="P:System.Xml.XmlReader.NodeType" /> jest równa <see langword="XmlNodeType.Element" />) który kończy się <c>/ &gt;</c>; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie różnicy między następujące czynności:  
  
 `<item num="123"/>` (`IsEmptyElement` jest `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` jest `false`, chociaż zawartość elementu jest pusta).  
  
 Odpowiedni `EndElement` węzeł nie jest generowana dla pustych elementów.  
  
 Jeżeli domyślnej zawartości został dodany do elementu z powodu Walidacja schematu `IsEmptyElement` nadal zwraca `true`. Go nie ma żadnego wpływu na informację, czy element ma wartość domyślną. Innymi słowy `IsEmptyElement` po prostu raporty informację określającą, czy element w dokumencie źródłowym były końcowym tagu elementu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość tekstu dla każdego elementu.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 W przykładzie użyto pliku `elems.xml`, jako danych wejściowych.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Nazwa do sprawdzania poprawności.</param>
        <summary>Zwraca wartość wskazującą, czy argument ciągu jest prawidłową nazwą XML.</summary>
        <returns><see langword="true" /> Jeśli nazwa jest prawidłowa; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [zalecenia 1.0 W3C XML](https://go.microsoft.com/fwlink/?LinkId=49863) do określenia, czy nazwa jest prawidłowa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Token nazwy do sprawdzania poprawności.</param>
        <summary>Zwraca wartość wskazującą, czy argument ciągu jest prawidłowy token nazwy XML.</summary>
        <returns><see langword="true" /> Jeśli jest to token prawidłową nazwę; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [zalecenia 1.0 W3C XML](https://go.microsoft.com/fwlink/?LinkId=49863) do ustalenia, czy nazwa tokenu jest nieprawidłowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> Wartość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest tagu początkowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołania <see cref="M:System.Xml.XmlReader.MoveToContent" /> i sprawdza, czy bieżącego węzła zawartości jest tag początkowy lub pustego elementu tagu.</summary>
        <returns><see langword="true" /> Jeśli <see cref="M:System.Xml.XmlReader.MoveToContent" /> znajdzie tag początkowy lub tagu pustego elementu; <see langword="false" /> Jeśli inny niż typ węzła <see langword="XmlNodeType.Element" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pomija biały znak, komentarze i instrukcje przetwarzania do momentu czytnik jest umieszczony w węźle zawartości. Metoda następnie sprawdza, czy bieżący węzeł jest elementem.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość tekstu dla każdego elementu.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 W przykładzie użyto pliku `elems.xml`, jako danych wejściowych.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg dopasowywane <see langword="Name" /> właściwość znalezionego elementu.</param>
        <summary>Wywołania <see cref="M:System.Xml.XmlReader.MoveToContent" /> i testy, jeśli tag początkowy lub tagu pustego elementu bieżącego węzła zawartości i <see cref="P:System.Xml.XmlReader.Name" /> właściwość znalezionego elementu odpowiada podany argument.</summary>
        <returns><see langword="true" /> Jeśli węzeł wynikowy jest elementem i <see langword="Name" /> właściwość pasuje do określonego ciągu. <see langword="false" /> Jeśli typ węzła innego niż <see langword="XmlNodeType.Element" /> został znaleziony lub, jeśli element <see langword="Name" /> właściwość jest niezgodna z określonego ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pomija biały znak, komentarze i instrukcje przetwarzania do momentu czytnik jest umieszczony w węźle zawartości. Metoda następnie sprawdza, czy bieżący węzeł jest elementem.  
  
   
  
## Examples  
 Poniższy przykład wyświetla każdy element ceny.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Ciąg, który ma być przeprowadzane dopasowanie <see langword="LocalName" /> właściwość znalezionego elementu.</param>
        <param name="ns">Ciąg, który ma być przeprowadzane dopasowanie <see langword="NamespaceURI" /> właściwość znalezionego elementu.</param>
        <summary>Wywołania <see cref="M:System.Xml.XmlReader.MoveToContent" /> i testy, jeśli tag początkowy lub tagu pustego elementu bieżącego węzła zawartości i <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> właściwości znalezionego elementu odpowiada danym ciągów.</summary>
        <returns><see langword="true" /> Jeśli węzeł wynikowy jest elementem. <see langword="false" /> Jeśli typ węzła innego niż <see langword="XmlNodeType.Element" /> został znaleziony lub jeśli <see langword="LocalName" /> i <see langword="NamespaceURI" /> właściwości elementu nie są zgodne z określonych ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pomija biały znak, komentarze i instrukcje przetwarzania do momentu czytnik jest umieszczony w węźle zawartości. Metoda następnie sprawdza, czy bieżący węzeł jest elementem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks ten atrybut.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonym indeksem.</summary>
        <value>Wartość określonego atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powoduje przeniesienia czytelnika.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <value>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powoduje przeniesienia czytelnika.  
  
 Jeśli czytnik jest umieszczony na `DocumentType` węzła, Metoda ta może służyć do Pobierz PUBLICZNY i systemu literały, na przykład `reader["PUBLIC"]`  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <value>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powoduje przeniesienia czytelnika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera lokalna nazwa bieżącego węzła.</summary>
        <value>Nazwa bieżącego węzła z prefiksem usunięte. Na przykład <see langword="LocalName" /> jest <see langword="book" /> elementu <c>&lt;bk:book&gt;</c>.  
  
Dla typów węzłów, które nie mają nazwę (np. <see langword="Text" />, <see langword="Comment" />i tak dalej), ta właściwość zwraca <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla nazwę lokalną każdy węzeł i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 W przykładzie użyto pliku book2.xml, jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks, którego identyfikator URI przestrzeni nazw mają być rozpoznane. Aby dopasować domyślny obszar nazw, należy przekazać pusty ciąg.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, rozpoznaje prefiksu przestrzeni nazw, w zakresie bieżącego elementu.</summary>
        <returns>Identyfikator URI przestrzeni nazw, do którego mapuje prefiks lub <see langword="null" /> Jeśli żadnego dopasowania prefiksu zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższym ciągu XML, jeśli czytnik jest umieszczony na `href` atrybutu prefiks `a` został rozwiązany przez wywołanie metody `reader.LookupNamespace("a")`. Ciąg zwracany jest `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przechodzi do określonego atrybutu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks ten atrybut.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przenosi się do atrybutu z określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr ma wartość ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przenosi się do atrybutu z określonego <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns><see langword="true" /> Jeśli ten atrybut zostanie odnaleziony; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, nie zmienia pozycji czytelnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, i <xref:System.Xml.XmlReader.Prefix%2A> właściwości odzwierciedlają właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa atrybutu.</param>
        <param name="ns">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przenosi się do atrybutu z określonego <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns><see langword="true" /> Jeśli ten atrybut zostanie odnaleziony; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, nie zmienia pozycji czytelnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, i <xref:System.Xml.XmlReader.Prefix%2A> właściwości odzwierciedlają właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Obie wartości parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy zawartość bieżącego węzła (tekst inny niż biały <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" />, lub <see langword="EndEntity" />) węzła. Jeśli węzeł nie jest węzłem zawartości, czytnik pomija dalej do kolejnego węzła zawartości lub koniec pliku. Nakłada się na węzłach następującego typu: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" />, lub <see langword="SignificantWhitespace" />.</summary>
        <returns><see cref="P:System.Xml.XmlReader.NodeType" /> Bieżącego węzła znalezione przez metodę lub <see langword="XmlNodeType.None" /> Jeśli czytnik osiągnął koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący węzeł jest węzłem atrybutu, ta metoda przechodzi proces czytający do elementu, który jest właścicielem atrybutu.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Jest to przydatne, gdy chcesz napisać kod, który można pominąć losowe znaczników XML bez przerywania. Załóżmy na przykład, poniższy kod:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Ten kod może obsługiwać następujące dane wejściowe bez przerywania:  
  
```xml  
<price>123.4</price>  
```  
  
 and  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 and  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 and  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie sprawdza, czy bieżący węzeł jest węzłem zawartości. Jeśli węzeł nie jest węzłem zawartości, czytnik pomija dalej do kolejnego węzła zawartości lub koniec pliku.</summary>
        <returns><see cref="P:System.Xml.XmlReader.NodeType" /> Bieżącego węzła znalezione przez metodę lub <see langword="XmlNodeType.None" /> Jeśli czytnik osiągnął koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.MoveToContent%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przenosi się do elementu, który zawiera bieżący węzeł atrybutów.</summary>
        <returns><see langword="true" /> Jeśli czytnik jest umieszczony na atrybut (czytnik przenosi się do elementu, który jest właścicielem atrybutu); <see langword="false" /> Jeśli czytnik nie został ustawiony na atrybut (pozycja czytnik nie zmieniać).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zwrócić do elementu po przejściu przez jego atrybuty. Ta metoda przechodzi czytnik do jednej z następujących typów węzłów: `Element`, `DocumentType`, lub `XmlDeclaration`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przenosi do pierwszego atrybutu.</summary>
        <returns><see langword="true" /> Jeśli istnieje atrybut (czytnik przenosi do pierwszego atrybutu); w przeciwnym razie <see langword="false" /> (pozycja czytnik nie zmieniać).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera wartość pierwszego atrybutu.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przechodzi do następnego atrybutu.</summary>
        <returns><see langword="true" /> w przypadku atrybutu dalej; <see langword="false" /> przypadku żadnych więcej atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący węzeł jest węzłem elementu, ta metoda jest odpowiednikiem <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Jeśli `MoveToNextAttribute` zwraca `true`, proces czytający przechodzi do atrybutu dalej; w przeciwnym razie nie zmienia pozycji czytnika.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera kwalifikowaną nazwę bieżącego węzła.</summary>
        <value>Kwalifikowana nazwa bieżącego węzła. Na przykład <see langword="Name" /> jest <see langword="bk:book" /> elementu <c>&lt;bk:book&gt;</c>.  
  
Nazwa, zwracana jest zależna od <see cref="P:System.Xml.XmlReader.NodeType" /> węzła. Następujące typy węzłów zwracają wartości listy. Inne typy węzłów zwraca pusty ciąg.  
  
 <list type="table"><listheader><term> Typ węzła 
 </term><description> Nazwa 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Nazwa atrybutu.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Nazwa typu dokumentu.  
  
 </description></item><item><term><see langword="Element" /></term><description> Nazwa tagu.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Nazwa jednostki, do których odwołuje się.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Obiekt docelowy instrukcji przetwarzania.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Literał ciągu <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera identyfikator URI (zgodnie z definicją w specyfikacji Namespace W3C) węzła obszaru nazw, w którym czytnik jest umieszczony.</summary>
        <value>Identyfikator URI bieżącego węzła; przestrzeni nazw w przeciwnym razie pusty ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest przeznaczona do `Element` i `Attribute` tylko węzłów.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę lokalną każdy węzeł i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 W przykładzie użyto pliku book2.xml, jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera <see cref="T:System.Xml.XmlNameTable" /> skojarzone z tej implementacji.</summary>
        <value><see langword="XmlNameTable" /> Umożliwiając rozproszone obiekty wersję ciągu w ramach węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie nazwy węzła i atrybut zwróciło <xref:System.Xml.XmlReader> są rozproszone obiekty przy użyciu `NameTable`. Po tej samej nazwie jest zwracany wiele razy (na przykład `Customer`), następnie sam `String` obiektu zostanie zwrócony dla tej nazwy. Umożliwia pisanie efektywnego kodu, który obiekt porównania na te ciągi zamiast porównywania ciągów kosztowne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera typ bieżącego węzła.</summary>
        <value>Jedna z wartości wyliczenia, które określają typ bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera prefiks przestrzeni nazw, skojarzony z bieżącego węzła.</summary>
        <value>Prefiks przestrzeni nazw, skojarzone z bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla nazwę lokalną każdy węzeł i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 W przykładzie użyto pliku book2.xml, jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera znak cudzysłowu, używany do ująć węzłem atrybutu.</summary>
        <value>Znak cudzysłowu ("lub") używane, aby ująć wartość węzła atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy tylko węzeł atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytuje kolejnego węzła ze strumienia.</summary>
        <returns><see langword="true" /> Jeśli następny węzeł został odczytany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Xml.XmlReader> następuje utworzone i zainicjowane, nie ma żadnych informacji, które są dostępne. Należy wywołać <xref:System.Xml.XmlReader.Read%2A> odczytać pierwszy węzeł. <xref:System.Xml.XmlReader.Read%2A> Metody ustawia stan odczytującego XML, aby zainicjować <xref:System.Xml.ReadState> i przenosi za pomocą pliku XML po kolei, dopóki nie zostanie osiągnięty koniec pliku, w tym momencie metoda zwraca wartość `false`.  
  
 Ta metoda wymaga co najmniej czterech bajtów ze strumienia danych, aby rozpocząć analizy. Jeśli zwracane są mniej niż cztery bajty, i nie ma więcej danych w strumieniu, metoda zwraca `false`. Jeśli istnieje więcej danych w strumieniu, metoda zablokuje analizy do momentu otrzymania czwartego bajtu.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla każdego z węzłów:
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Dane wyjściowe:**  

 [!INCLUDE [xmlreader-read-sample-output](~/includes/xmlreader-read-sample-output.md)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania kodu XML.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje kolejnego węzła ze strumienia.</summary>
        <returns><see langword="true" /> Jeśli następny węzeł został odczytany pomyślnie; <see langword="false" /> Jeśli nie ma żadnych więcej węzłów do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.Read%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, analizuje wartość atrybutu do co najmniej jeden <see langword="Text" />, <see langword="EntityReference" />, lub <see langword="EndEntity" /> węzłów.</summary>
        <returns><see langword="true" /> w przypadku węzłów do zwrócenia.  
  
 <see langword="false" /> Czytnik nie został ustawiony na węzeł atrybutu, po nawiązaniu połączenia początkowego lub znasz wszystkie wartości atrybutów.  
  
Pusta atrybutów, takich jak <c>różne = ""</c>, zwraca <see langword="true" /> z jednym węzłem o wartości <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, po wywołaniu <xref:System.Xml.XmlReader.MoveToAttribute%2A> do przeczytania przez czytelników węzły odwołanie tekst lub jednostki, które składają się wartość atrybutu. <xref:System.Xml.XmlReader.Depth%2A> Węzłów wartość atrybutu jest jeden oraz głębokość węzła atrybutu; zwiększa i zmniejsza o jeden, gdy wchodzisz do i z odwołań do jednostek ogólne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.  
  
 **Uwaga** wraz z wydaniem programu .NET Framework 3.5, wartość <paramref name="returnType" /> parametru można teraz <see cref="T:System.DateTimeOffset" /> typu.</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> Związane konwersja typu obiektu, który jest używany do rozpoznawania wszelkie prefiksy przestrzeni nazw. Na przykład może to służyć podczas konwertowania <see cref="T:System.Xml.XmlQualifiedName" /> obiekt <c>xs:string</c>.  
  
Ta wartość może być <see langword="null" />.</param>
        <summary>Odczytuje zawartość jako obiekt o typie określonym.</summary>
        <returns>Wartości atrybutu lub zawartości tekstowej połączonych konwertowane do żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawartości tekstowej w bieżącym położeniu czytnika odczytuje i konwertuje go na żądany typ zwracany. Tekst, biały znak, istotnych białych i CDATA sekcje są łączone. Komentarze i instrukcje przetwarzania są pomijane i odwołań do jednostek są automatycznie rozwiązywane.  
  
 Ta metoda jest używana do odczytu, przekonwertować w razie potrzeby i zwraca wartość atomic elementy z bieżącego węzła zawartości. Jeśli typ danych wejściowych jest prawidłowe mapowania dla typu bieżącego węzła następnie wystąpienia typu docelowego, zawierającego wartość bieżącego węzła jest zwracany. Zobacz sekcję Uwagi w <xref:System.Xml.XmlReader> referencepage listę mapowań domyślnych.  
  
 Na przykład, jeśli masz następujący tekst XML:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Jeśli dane są wpisywane i Tablica ciągów jest dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> wywołania metody, a następnie wartości całkowitych, które są konwertowane z ciągów według listy prawidłowe mapowania typu CLR.  
  
 Jeśli dane są bez typu, a tablica ciągów jest dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> metody wywołań, a następnie zawartość jest przekształcany do oddzielnych ciągów. Tablica zawierająca dwa ciągi jest zwracany za pomocą wartości "123" i "456". Spacje nie są zachowywane od zawartości.  
  
 Ogólnie rzecz biorąc podczas odczytywania danych bez typu zawartości jest analizowany zgodnie z podanego typu. Na przykład, jeśli nie dostarczono tablicę liczb całkowitych do <xref:System.Xml.XmlReader.ReadContentAs%2A> wywołaniu metody ten ciąg jest przekształcany do tablicy liczb całkowitych {123,456}.  
  
 W poniższym przykładzie tekstu XML jest nie rozdzielone spacjami  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Jeśli zawartość jest bez typu, a tablica ciągów jest dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> metoda następnie wywoływać tablicę zawierającą jeden połączony ciąg jest zwracany za pomocą wartości "123456789".  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadContentAs%2A> metodę, aby zwrócić zawartość elementu kolory na tablicę obiektów w postaci ciągów.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 W przykładzie użyto `dataFile_2.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Zawartość nie jest w prawidłowym formacie dla typu docelowego.</exception>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="returnType" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest typem węzła obsługiwane. Zobacz tabelę poniżej, aby uzyskać szczegółowe informacje.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.OverflowException">Odczyt <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> Związane konwersja typu obiektu, który jest używany do rozpoznawania wszelkie prefiksy przestrzeni nazw.</param>
        <summary>Asynchronicznie odczytuje zawartość jako obiekt o typie określonym.</summary>
        <returns>Wartości atrybutu lub zawartości tekstowej połączonych konwertowane do żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadContentAs%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca Base64 zdekodowany binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesyła strumieniowo zawartość, dekoduje `Base64` zawartości, a następnie zwraca zdekodowany bajtów binarny (na przykład wbudowany `Base64` zakodowany obraz GIF) w buforze. Tę metodę można wywołać kolejno, można odczytać dużych strumieni osadzonego tekstu. Aby uzyskać więcej informacji, zobacz RFC 1521 bazy danych, "części MIME (Multipurpose Internet Mail Extensions) co: Mechanizmy dotyczące określania i opisujący Format treści wiadomości Internetu". Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Nie mają żadnej właściwości czytnika między wywołaniami do <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> metody do momentu, metoda zwraca wartość `0`.  
  
 Ta metoda ma następującą charakterystykę:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Zwraca wartość `0` przypadku osiągnięcia końca strumienia bajtów zostało korzysta. Czytnik jest umieszczony w pierwszym węźle-content.  
  
-   Jeśli poprosisz o mniej, lub dokładną liczbę, bajtów, niż są pozostawiane w strumieniu czytnik pozostają w jego bieżącej pozycji.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> nie jest obsługiwane na następujących typach węzła XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> nie jest obsługiwana w bieżącym węźle.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeksu + liczba jest większa niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Asynchronicznie odczytuje zawartość i zwraca Base64 zdekodowany binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca <see langword="BinHex" /> zdekodowany binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesyła strumieniowo zawartość, dekoduje `BinHex` zawartości, a następnie zwraca zdekodowany bajtów binarny (na przykład wbudowany `BinHex` zakodowany obraz GIF) w buforze. Tę metodę można wywołać kolejno, można odczytać dużych strumieni osadzonego tekstu.  
  
> [!NOTE]
>  Nie mają żadnej właściwości czytnika między wywołaniami do <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> metody do momentu, metoda zwraca wartość `0`.  
  
 Ta metoda ma następującą charakterystykę:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Zwraca wartość `0` przypadku osiągnięcia końca strumienia bajtów zostało korzysta. Czytnik jest umieszczony w pierwszym węźle-content.  
  
-   Jeśli poprosisz o mniejszej lub liczbą bajtów, niż są pozostawiane w strumieniu czytnik pozostają w jego bieżącej pozycji.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> nie jest obsługiwane na następujących typach węzła XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> nie jest obsługiwana w bieżącym węźle.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeksu + liczba jest większa niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Asynchronicznie odczytuje zawartość i zwraca <see langword="BinHex" /> zdekodowany binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako <see langword="Boolean" />.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.Boolean" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:boolean`, czytnik zwraca rozpakowany <xref:System.Boolean> obiektu. Jeśli zawartość nie jest typu `xsd:boolean`, czytnik próbuje przekonwertować go pod kątem <xref:System.Boolean> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> metodę w celu odczytania atrybutu jako B`oolean` wartość.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 W przykładzie użyto `dataFile_2.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:dateTime`, czytnik zwraca rozpakowany <xref:System.DateTime> obiektu. Jeśli zawartość nie jest typu `xsd:dateTime`, czytnik próbuje przekonwertować go pod kątem <xref:System.DateTime> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
> [!NOTE]
>  Nie można polegać na <xref:System.DateTime.Year%2A?displayProperty=nameWithType> wartości po wpisaniu zawartość jako `xsd:gMonthDay`. <xref:System.Xml.XmlReader> zawsze ustawia <xref:System.DateTime.Year%2A?displayProperty=nameWithType> w tym przypadku wartość ma zostać 1904.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.DateTimeOffset" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.Decimal" /> obiektu.</summary>
        <returns>Zawartość tekstowa w bieżącym położeniu jako <see cref="T:System.Decimal" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:decimal`, czytnik zwraca rozpakowany <xref:System.Decimal> obiektu. Jeśli zawartość nie jest typu `xsd:decimal`, czytnik próbuje przekonwertować go pod kątem <xref:System.Decimal> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Zawartość tekstowa jako liczba zmiennoprzecinkowa podwójnej precyzji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:double`, Czytelnik, zwraca wartość zmiennoprzecinkową podwójnej precyzji. Jeśli zawartość nie jest typu `xsd:double`, próbuje przekonwertować go na liczbę zmiennoprzecinkową podwójnej precyzji, zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako pojedynczej precyzji liczbę zmiennoprzecinkową.</summary>
        <returns>Zawartość tekstowa w bieżącym położeniu jako pojedynczej precyzji liczbę zmiennoprzecinkową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:float`, czytnik zwraca rozpakowany pojedynczej precyzji liczbę zmiennoprzecinkową. Jeśli zawartość nie jest typu `xsd:float`, próbuje przekonwertować pojedynczej precyzji liczba zmiennoprzecinkowa zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako liczba całkowita 32-bitowe podpisane.</summary>
        <returns>Zawartość tekstowa jako liczba całkowita 32-bitowe podpisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:integer`, czytnik zwraca liczbę całkowitą podpisem rozpakowany 32-bitowych. Jeśli zawartość nie jest typu `xsd:integer`, próbuje przekonwertować całkowita 32-bitowych zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako całkowita 64-bitowych.</summary>
        <returns>Zawartość tekstowa jako całkowita 64-bitowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest `xsd:long`, czytnik zwraca liczbę całkowitą podpisem rozpakowany 64-bitowych. Jeśli zawartość nie jest typu `xsd:long`, próbuje przekonwertować całkowita 64-bitowych zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano to metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącym położeniu|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.Object" />.</summary>
        <returns>Zawartość tekstowa jako najbardziej odpowiedni obiekt środowiska uruchomieniowego (języka wspólnego CLR) języka wspólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Jeśli zawartość jest wpisany, czytnik zwraca spakowany CLR najbardziej odpowiedniego typu, określony przez <xref:System.Xml.XmlReader.ValueType%2A> właściwości. Jeśli zawartość jest typu listy, czytnik zwraca tablicę obiektów w ramce odpowiedniego typu.  
  
> [!NOTE]
>  Jeśli występuje błąd sprawdzania poprawności, podczas analizowania zawartości i czytnik <xref:System.Xml.XmlReader> obiekt utworzony przez <xref:System.Xml.XmlReader.Create%2A> metody czytnik zwraca zawartość jako ciąg. Innymi słowy podczas sprawdzania poprawności błąd lub ostrzeżenie występuje, zawartość jest uważany za bez typu.  
  
 Jeśli zawartość nie zostanie podana, czytnik zwraca zawartość jako ciąg.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącym położeniu|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Wartość elementu, jeśli czytnik jest schematu, sprawdzanie poprawności reader (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> ustawiono <xref:System.Xml.ValidationType.Schema>); w przeciwnym razie pusty ciąg.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.Object" />.</summary>
        <returns>Zawartość tekstowa jako najbardziej odpowiedni obiekt środowiska uruchomieniowego (języka wspólnego CLR) języka wspólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak, istotnych białych i CDATA sekcje i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek są automatycznie rozwiązywane.  
  
 Ta metoda może być używana konwersji wartości typizowane na ciąg lub można odczytać zawartości tekstowej pomijanie komentarze i instrukcji przetwarzania.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały i istotnych białych węzły są konwertowane na żądanego typu.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` wartości atrybutu.|Czytnik pozostaje w bieżącej pozycji.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartości tekstowej połączonych, który następuje po PI lub komentarz.|Przechodzi do następnego elementu lub na końcu tagu początkowym elementu. Odwołania do jednostki zostaną automatycznie rozwinięte.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącej pozycji.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Zgłaszany.|Nie zdefiniowano, chociaż zazwyczaj czytnik pozostaje w bieżącej pozycji.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje zawartość tekstu w bieżącym położeniu jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadContentAsString%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako obiekt o typie określonym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.  
  
 **Uwaga** wraz z wydaniem programu .NET Framework 3.5, wartość <paramref name="returnType" /> parametru można teraz <see cref="T:System.DateTimeOffset" /> typu.</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> Związane konwersja typu obiektu, który jest używany do rozpoznawania wszelkie prefiksy przestrzeni nazw.</param>
        <summary>Odczytuje zawartość elementu jako żądanego typu.</summary>
        <returns>Zawartość elementu jest konwertowany na żądany obiekt wpisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadElementContentAs%2A> metodę w celu odczytania zawartości `date` węzła.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu do żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.OverflowException">Odczyt <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.  
  
 **Uwaga** wraz z wydaniem programu .NET Framework 3.5, wartość <paramref name="returnType" /> parametru można teraz <see cref="T:System.DateTimeOffset" /> typu.</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> Związane konwersja typu obiektu, który jest używany do rozpoznawania wszelkie prefiksy przestrzeni nazw.</param>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje zawartość elementu jako żądanego typu.</summary>
        <returns>Zawartość elementu jest konwertowany na żądany obiekt wpisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu do żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
        <exception cref="T:System.OverflowException">Odczyt <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> Związane konwersja typu obiektu, który jest używany do rozpoznawania wszelkie prefiksy przestrzeni nazw.</param>
        <summary>Asynchronicznie odczytuje zawartość elementu jako żądanego typu.</summary>
        <returns>Zawartość elementu jest konwertowany na żądany obiekt wpisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."
—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Odczytuje element i dekoduje <see langword="Base64" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje zawartość elementu, za pomocą dekoduje `Base64` kodowania i zwraca zdekodowany bajtów binarnych (na przykład wbudowany `Base64`— zakodowany obraz GIF) w buforze. Aby uzyskać więcej informacji, zobacz RFC 1521 bazy danych, "części MIME (Multipurpose Internet Mail Extensions) co: Mechanizmy dotyczące określania i opisujący Format treści wiadomości Internetu". Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](https://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> tylko mogą odczytywać elementy prostej zawartości. Element może zawierać tekst, biały znak, istotnych białych sekcji CDATA, komentarze i instrukcje przetwarzania. Może również zawierać odwołania do jednostek, które zostaną automatycznie rozwinięte. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobny do <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> metody, ale można wywołać tylko w ramach typów węzłów elementów.  
  
 Jeśli `count` wartość jest większa niż liczba bajtów w dokumencie, lub jeśli jest równa liczbie bajtów w dokumencie, <xref:System.Xml.XmlReader> odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę odczytanych bajtów. Następne <xref:System.Xml.XmlReader> wywołanie metody zwraca zero i przenosi czytnik do następującego węzła `EndElement`.  
  
 Jeśli wywołasz <xref:System.Xml.XmlReader.Read%2A> przed całą zawartość elementu jest używane, czytelnik może zachowywać się tak, jakby został wykorzystany pierwszy zawartości i następnie <xref:System.Xml.XmlReader.Read%2A> metoda została wywołana. Oznacza to, czytnik odczyta cały tekst, dopóki nie zostanie osiągnięty elementu końcowego. Następnie odczytuje węzła tagu końcowego, przeczytaj następny węzeł i umieść sam na kolejne kolejnego węzła.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wbudowany `Base64` zakodowany obrazu. `Base64` Danych zostanie osadzony w ramach `<image>` elementu. A <xref:System.IO.BinaryWriter> służy do tworzenia nowego pliku danych binarnych.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest węzłem elementu.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeksu + liczba jest większa niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera mieszane zawartość.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości do żądanego typu.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Asynchronicznie odczytuje element i dekoduje <see langword="Base64" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Odczytuje element i dekoduje <see langword="BinHex" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje zawartość elementu, za pomocą dekoduje `BinHex` kodowania i zwraca zdekodowany bajtów binarnych (na przykład wbudowany `BinHex`— zakodowany obraz GIF) w buforze.  
  
 Ta metoda może jedynie odczytywać elementy zawartości prostej. Element może zawierać tekst, biały znak, istotnych białych sekcji CDATA, komentarze i instrukcje przetwarzania. Może również zawierać odwołania do jednostek, które zostaną automatycznie rozwinięte. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobny do <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> metody, ale można wywołać tylko w ramach typów węzłów elementów.  
  
 Jeśli `count` wartość jest większa niż liczba bajtów w dokumencie, lub jeśli jest równa liczbie bajtów w dokumencie, <xref:System.Xml.XmlReader> odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę odczytanych bajtów. Następne <xref:System.Xml.XmlReader> wywołanie metody zwraca zero i przenosi czytnik do następującego węzła `EndElement`.  
  
 Jeśli wywołasz <xref:System.Xml.XmlReader.Read%2A> przed całą zawartość elementu jest używane, czytelnik może zachowywać się tak, jakby został wykorzystany pierwszy zawartości i następnie <xref:System.Xml.XmlReader.Read%2A> metoda została wywołana. Oznacza to, czytnik odczyta cały tekst, dopóki nie zostanie osiągnięty elementu końcowego. Następnie odczytuje węzła tagu końcowego, przeczytaj następny węzeł i umieść sam na kolejne kolejnego węzła.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wbudowany `BinHex` zakodowany obrazu. `BinHex` Danych zostanie osadzony w ramach `<image>` elementu. A <xref:System.IO.BinaryWriter> służy do tworzenia nowego pliku danych binarnych.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie jest węzłem elementu.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeksu + liczba jest większa niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera mieszane zawartość.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości do żądanego typu.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie zacząć, kopiując wynik.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Rzeczywista liczba bajtów skopiowanych jest zwracana z tej metody.</param>
        <summary>Asynchronicznie odczytuje element i dekoduje <see langword="BinHex" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje wartość elementu bieżącej jako <see cref="T:System.Boolean" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Boolean" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.Boolean" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość elementu jest `xsd:boolean`, czytnik zwraca rozpakowany <xref:System.Boolean> obiektu. Jeśli zawartość nie jest typu `xsd:boolean`, czytnik próbuje przekonwertować go pod kątem <xref:System.Boolean> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu <see cref="T:System.Boolean" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Boolean" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.Boolean" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:boolean`, czytnik zwraca rozpakowany <xref:System.Boolean> obiektu. Jeśli zawartość nie jest typu `xsd:boolean`, czytnik próbuje przekonwertować go pod kątem <xref:System.Boolean> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu do żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.DateTime" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:dateTime`, czytnik zwraca rozpakowany <xref:System.DateTime> obiektu. Jeśli zawartość nie jest typu `xsd:dateTime`, czytnik próbuje przekonwertować go pod kątem <xref:System.DateTime> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
> [!NOTE]
>  Nie można polegać na <xref:System.DateTime.Year%2A?displayProperty=nameWithType> wartości po wpisaniu zawartość jako `xsd:gMonthDay`. <xref:System.Xml.XmlReader> zawsze ustawia <xref:System.DateTime.Year%2A?displayProperty=nameWithType> w tym przypadku wartość ma zostać 1904.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> metodę w celu odczytania zawartości `date` elementu.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu <see cref="T:System.DateTime" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:dateTime`, czytnik zwraca rozpakowany <xref:System.DateTime> obiektu. Jeśli zawartość nie jest typu `xsd:dateTime`, czytnik próbuje przekonwertować go pod kątem <xref:System.DateTime> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
> [!NOTE]
>  Nie można polegać na <xref:System.DateTime.Year%2A?displayProperty=nameWithType> wartości po wpisaniu zawartość jako `xsd:gMonthDay`. <xref:System.Xml.XmlReader> zawsze ustawia <xref:System.DateTime.Year%2A?displayProperty=nameWithType> w tym przypadku wartość ma zostać 1904.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu do żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje wartość elementu bieżącej jako <see cref="T:System.Decimal" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Decimal" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.Decimal" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Czytnik stara się przekonwertować elementu zawartości <xref:System.Decimal> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Decimal" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.Decimal" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Czytnik stara się przekonwertować elementu zawartości <xref:System.Decimal> obiektu zgodnie z regułami określonymi w [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Zawartość elementu jako liczba zmiennoprzecinkowa podwójnej precyzji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:double`, Czytelnik, zwraca wartość zmiennoprzecinkową podwójnej precyzji. Jeśli zawartość nie jest typu `xsd:double`, próbuje przekonwertować go na liczbę zmiennoprzecinkową podwójnej precyzji, zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody, aby zwrócić zawartość elementu jako liczba zmiennoprzecinkowa podwójnej precyzji.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na liczbę zmiennoprzecinkową podwójnej precyzji.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określoną nazwę lokalnego i identyfikator URI przestrzeni nazw jest zgodny z bieżącym elementem, a następnie odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Zawartość elementu jako liczba zmiennoprzecinkowa podwójnej precyzji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:double`, Czytelnik, zwraca wartość zmiennoprzecinkową podwójnej precyzji. Jeśli zawartość nie jest typu `xsd:double`, próbuje przekonwertować go na liczbę zmiennoprzecinkową podwójnej precyzji, zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu do żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżącą wartość elementu jako liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
        <returns>Zawartość elementu jako pojedynczej precyzji liczbę zmiennoprzecinkową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Czytnik próbuje przekonwertować pojedynczej precyzji liczba zmiennoprzecinkowa zgodnie z regułami określonymi w zawartości elementu [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na liczbę zmiennoprzecinkową pojedynczej precyzji.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określoną nazwę lokalnego i identyfikator URI przestrzeni nazw jest zgodny z bieżącym elementem, a następnie odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
        <returns>Zawartość elementu jako pojedynczej precyzji liczbę zmiennoprzecinkową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Czytnik próbuje przekonwertować pojedynczej precyzji liczba zmiennoprzecinkowa zgodnie z regułami określonymi w zawartości elementu [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na liczbę zmiennoprzecinkową pojedynczej precyzji.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako wartość całkowita 32-bitowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako wartość całkowita 32-bitowych.</summary>
        <returns>Zawartość elementu jako liczba całkowita 32-bitowe podpisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:integer`, czytnik zwraca liczbę całkowitą podpisem rozpakowany 32-bitowych. Jeśli zawartość nie jest typu `xsd:integer`, próbuje przekonwertować całkowita 32-bitowych zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na całkowita 32-bitowych.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako wartość całkowita 32-bitowych.</summary>
        <returns>Zawartość elementu jako liczba całkowita 32-bitowe podpisane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:integer`, czytnik zwraca liczbę całkowitą podpisem rozpakowany 32-bitowych. Jeśli zawartość nie jest typu `xsd:integer`, próbuje przekonwertować całkowita 32-bitowych zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na całkowita 32-bitowych.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako wartość całkowita 64-bitowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako wartość całkowita 64-bitowych.</summary>
        <returns>Zawartość elementu jako całkowita 64-bitowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:long`, czytnik zwraca liczbę całkowitą podpisem rozpakowany 64-bitowych. Jeśli zawartość nie jest typu `xsd:long`, próbuje przekonwertować całkowita 64-bitowych zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> metodę w celu odczytania zawartości `longValue` elementu.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na całkowita 64-bitowych.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako wartość całkowita 64-bitowych.</summary>
        <returns>Zawartość elementu jako całkowita 64-bitowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest `xsd:long`, czytnik zwraca liczbę całkowitą podpisem rozpakowany 64-bitowych. Jeśli zawartość nie jest typu `xsd:long`, próbuje przekonwertować całkowita 64-bitowych zgodnie z regułami określonymi przez czytnik [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na całkowita 64-bitowych.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
        <returns>Spakowany wspólnego języka wspólnego (CLR) obiekt najbardziej odpowiedniego typu. <see cref="P:System.Xml.XmlReader.ValueType" /> Właściwość określa odpowiedniego typu CLR. Jeśli zawartość jest typu list, ta metoda zwraca tablicę obiektów w ramce odpowiedniego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody można odczytać zawartości `price` węzła. Czytnik używa tych informacji w schemacie mapowania zawartość na prawidłowy typ danych.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 W przykładzie użyto następujące dwa pliki jako dane wejściowe.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Zawartość elementu nie można przekonwertować na żądany typ.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
        <returns>Spakowany wspólnego języka wspólnego (CLR) obiekt najbardziej odpowiedniego typu. <see cref="P:System.Xml.XmlReader.ValueType" /> Właściwość określa odpowiedniego typu CLR. Jeśli zawartość jest typu list, ta metoda zwraca tablicę obiektów w ramce odpowiedniego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu do żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
        <returns>Spakowany wspólnego języka wspólnego (CLR) obiekt najbardziej odpowiedniego typu. <see cref="P:System.Xml.XmlReader.ValueType" /> Właściwość określa odpowiedniego typu CLR. Jeśli zawartość jest typu list, ta metoda zwraca tablicę obiektów w ramce odpowiedniego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje `stringValue` element i zwraca zawartości tekstowej (Ignorowanie komentarz i przetwarzania instrukcji).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu <see cref="T:System.String" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy określona nazwa lokalnego i identyfikator URI przestrzeni nazw są zgodne z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tagu początkowego, zawartość elementu i przenosi czytnika poza końcowym tagu elementu. On rozwijanie jednostek i ignoruje instrukcji przetwarzania i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to go nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję Uwagi <xref:System.Xml.XmlReader> odwołania do stron i [część 2 W3C XML schematu: Typy danych](https://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
   
  
## Examples  
 Poniższy przykład odczytuje `stringValue` element i zwraca zawartości tekstowej (Ignorowanie komentarz i przetwarzania instrukcji).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na element.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  
  
—lub— 
Nie można przekonwertować zawartości elementu <see cref="T:System.String" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalnego i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytywany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako element <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje proste elementy tylko tekst. Jednak firma Microsoft zaleca użycie <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> metody zamiast tego, ponieważ zapewnia bardziej bezpośredni sposób obsługi tej operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> metodę w celu odczytania elementu tekstu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje element tekstowy. Jednak firma Microsoft zaleca użycie <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> metody zamiast tego, ponieważ zapewnia bardziej bezpośredni sposób obsługi tej operacji.</summary>
        <returns>Tekst wyświetlany w elemencie, który został odczytany. Pusty ciąg, jeśli element jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString> metodę w celu odczytania elementu tekstu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Kolejnego węzła zawartości nie jest tag początkowy; lub znalezionego elementu nie zawiera wartości zwykłego tekstu.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do sprawdzenia.</param>
        <summary>Sprawdza, czy <see cref="P:System.Xml.XmlReader.Name" /> właściwości znalezionego elementu pasuje do podanego ciągu przed odczytaniem element tekstowy. Jednak firma Microsoft zaleca użycie <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> metody zamiast tego, ponieważ zapewnia bardziej bezpośredni sposób obsługi tej operacji.</summary>
        <returns>Tekst wyświetlany w elemencie, który został odczytany. Pusty ciąg, jeśli element jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString> metodę w celu odczytania elementu tekstu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Jeśli nie jest kolejnego węzła zawartości tagu początkowego; Jeśli element <see langword="Name" /> nie jest zgodny podany argument; lub jeśli znaleziono element nie zawiera wartości zwykłego tekstu.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Lokalna nazwa do sprawdzenia.</param>
        <param name="ns">Identyfikator URI przestrzeni nazw do sprawdzenia.</param>
        <summary>Sprawdza, czy <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> właściwości elementu znaleziono dopasowuje ciągi danego przed odczytaniem element tekstowy. Jednak firma Microsoft zaleca użycie <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> metody zamiast tego, ponieważ zapewnia bardziej bezpośredni sposób obsługi tej operacji.</summary>
        <returns>Tekst wyświetlany w elemencie, który został odczytany. Pusty ciąg, jeśli element jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> metodę w celu odczytania elementu tekstu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Jeśli nie jest kolejnego węzła zawartości tagu początkowego; Jeśli element <see langword="LocalName" /> lub <see langword="NamespaceURI" /> nie są zgodne z danym argumentów; lub jeśli znaleziono element nie zawiera wartości zwykłego tekstu.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest tagu końcowego i prowadzi czytnik do kolejnego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla zawartość tekstu dla każdego elementu.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 W przykładzie użyto `book3.xml` pliku.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Bieżący węzeł nie jest tagu końcowego lub jeśli niepoprawna zawartość XML jest w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytuje całą zawartość, w tym znaczników jako ciąg.</summary>
        <returns>Wszystkie zawartość XML, w tym znaczników, bieżącego węzła. Jeśli bieżący węzeł nie ma elementów podrzędnych, zwracany jest pusty ciąg.  
  
Jeśli bieżący węzeł nie jest elementem ani atrybutu, zwracany jest pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca całej zawartości bieżącego węzła, w tym znaczników. Bieżący węzeł (tagu początkowego) i odpowiedniego węzła końcowego (tag końcowy) nie są zwracane. Na przykład, jeśli było następujące:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` Zwraca `this <child id="123"/>`  
  
 Ta metoda obsługuje węzłów elementów i atrybutów w następujący sposób:  
  
|Typ węzła|Pozycja przed wywołaniem|XML fragment|Wartość zwracana|Pozycja po wywołaniu metody|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na `item1` taga otwierającego.|\<item1>text1\</item1>\<item2>text2\</item2>|TEXT1|Na `item2` taga otwierającego.|  
|`Attribute`|Na `attr1` węzeł atrybutu.|\<item attr1="val1" attr2="val2">text\</item>|val1|Pozostaje na `attr1` węzeł atrybutu.|  
  
 Jeśli czytnik jest umieszczony na węzeł liścia, wywołanie `ReadInnerXml` jest równoważne z wywoływaniem <xref:System.Xml.XmlReader.Read%2A>. Metoda ta zwraca `String.Empty` (z wyjątkiem węzłów atrybutu, w którym to przypadku jest zwracana wartość atrybutu).  
  
 Ta metoda sprawdza, czy poprawnie sformułowany dokument XML. Jeśli `ReadInnerXml` jest wywoływana z <xref:System.Xml.XmlValidatingReader>, ta metoda sprawdza poprawność zwrócona zawartość.  
  
 Zaimplementowanego w <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> i `XmlValidatingReader` klasy `ReadOuterXml` metodą jest świadomość przestrzeni nazw.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie porównano `ReadInnerXml` i <xref:System.Xml.XmlReader.ReadOuterXml%2A> metody.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 W przykładzie użyto `2books.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Plik XML nie jest poprawnie sformułowany lub wystąpił błąd podczas analizowania kodu XML.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje całą zawartość, w tym znaczników jako ciąg.</summary>
        <returns>Wszystkie zawartość XML, w tym znaczników, bieżącego węzła. Jeśli bieżący węzeł nie ma elementów podrzędnych, zwracany jest pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadInnerXml%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytuje treści, w tym znaczników, reprezentujący ten węzeł i jego elementów podrzędnych.</summary>
        <returns>Jeśli czytnik jest umieszczony na element lub węzłem atrybutu, ta metoda zwraca dane XML zawartość, łącznie z kodu znaczników elementu bieżącego węzła i wszystkich jego obiektów podrzędnych; w przeciwnym razie zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Xml.XmlReader.ReadInnerXml%2A> z wyjątkiem również zwraca tagiem początkowym i końcowym.  
  
 Ta metoda obsługuje węzłów elementów i atrybutów w następujący sposób:  
  
|Typ węzła|Pozycja przed wywołaniem|XML fragment|Wartość zwracana|Pozycja po wywołaniu metody|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na `item1` taga otwierającego.|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1>text1\</item1>|Na `item2` taga otwierającego.|  
|`Attribute`|Na `attr1` węzeł atrybutu.|\<item attr1="val1" attr2="val2">text\</item>|attr1="val1"|Pozostaje na `attr1` węzeł atrybutu.|  
  
 Jeśli czytnik jest umieszczony na węzeł liścia, wywołanie `ReadOuterXml` jest równoważne z wywoływaniem <xref:System.Xml.XmlReader.Read%2A>. Metoda ta zwraca `String.Empty` (z wyjątkiem węzłów atrybutu, w którym to przypadku jest zwracany kod znaczników atrybutu).  
  
 Ta metoda sprawdza, czy poprawnie sformułowany dokument XML. Jeśli `ReadOuterXml` jest wywoływana z <xref:System.Xml.XmlValidatingReader>, ta metoda sprawdza poprawność zawartości zwróconej  
  
 Zaimplementowanego w <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> i `XmlValidatingReader` klasy `ReadOuterXml` metodą jest świadomość przestrzeni nazw. Biorąc pod uwagę następujący tekst XML `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, jeśli czytnik był umieszczony na `S:B` tag, początkowy `ReadOuterXml` zwraca `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie porównano `ReadInnerXml` i `ReadOuterXml` metody.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 W przykładzie użyto `2books.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Plik XML nie jest poprawnie sformułowany lub wystąpił błąd podczas analizowania kodu XML.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje zawartość, w tym znaczników, reprezentujący ten węzeł i jego elementów podrzędnych.</summary>
        <returns>Jeśli czytnik jest umieszczony na element lub węzłem atrybutu, ta metoda zwraca dane XML zawartość, łącznie z kodu znaczników elementu bieżącego węzła i wszystkich jego obiektów podrzędnych; w przeciwnym razie zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadOuterXml%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Sprawdza, czy bieżący węzeł jest elementem, a następnie przesuwa czytnik do kolejnego węzła.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy bieżący węzeł jest elementem, a następnie przesuwa czytnik do kolejnego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Xml.XmlReader.IsStartElement%2A> następuje <xref:System.Xml.XmlReader.Read%2A> do pozycji możesz zawartości tego elementu w strumieniu wejściowym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu.</param>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest element z danym <see cref="P:System.Xml.XmlReader.Name" /> i prowadzi czytnik do kolejnego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody odpowiada wywołaniu <xref:System.Xml.XmlReader.IsStartElement%2A> następuje po wywołaniu <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość tekstu dla każdego elementu.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 W przykładzie użyto `book3.xml` pliku.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.  
  
—lub— 
<see cref="P:System.Xml.XmlReader.Name" /> Element nie jest zgodny danego <paramref name="name" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Lokalna nazwa elementu.</param>
        <param name="ns">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest element z danym <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> i prowadzi czytnik do kolejnego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody odpowiada wywołaniu <xref:System.Xml.XmlReader.IsStartElement%2A> następuje po wywołaniu <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.  
  
—lub— 
<see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> właściwości znalezionego elementu nie są zgodne z danym argumentów.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera stan czytnika.</summary>
        <value>Jedna z wartości wyliczenia, które określa stan czytnika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadState%2A> Właściwość posiada jedną z następujących wartości:  
  
-   <xref:System.Xml.ReadState.Initial>, gdy <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> metoda jest wywoływana.  
  
-   <xref:System.Xml.ReadState.Interactive>, gdy <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> metoda została wywołana i dodatkowe metody może być wywołana dla czytelnika.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, jeśli koniec dokumentu XML został osiągnięty pomyślnie.  
  
-   <xref:System.Xml.ReadState.Closed>, gdy <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> metoda jest wywoływana.  
  
-   <xref:System.Xml.ReadState.Error>, jeśli błąd uniemożliwia kontynuowanie operacji odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytuje zawartość węzła element lub tekst jako ciąg. Jednak firma Microsoft zaleca użycie <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> metody zamiast tego, ponieważ zapewnia bardziej bezpośredni sposób obsługi tej operacji.</summary>
        <returns>Zawartość elementu lub pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> metodę, aby odczytać zawartość element lub tekst węzła jako ciąg.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania kodu XML.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy <see langword="XmlReader" /> wystąpienia, który może służyć do odczytu z bieżącego węzła i jego elementy podrzędne.</summary>
        <returns>Ustaw nowe wystąpienie czytnika XML <see cref="F:System.Xml.ReadState.Initial" />. Wywoływanie <see cref="M:System.Xml.XmlReader.Read" /> metoda umieszcza nowym czytniku w węźle, które były aktualne przed wywołaniem do <see cref="M:System.Xml.XmlReader.ReadSubtree" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> można wywołać tylko w przypadku węzłów elementów. Przeczytaniu całe drzewo podrzędne wywołania <xref:System.Xml.XmlReader.Read%2A> metoda zwraca `false`. Kiedy nowy odczytującego XML zostało zamknięte, readeris oryginalnej, umieszczone na `EndElement` węzła drzewa podrzędnego. W związku z tym jeśli wywołano <xref:System.Xml.XmlReader.ReadSubtree%2A> metody w tagu początkowego elementu książki, po poddrzewie odczytu i nowego czytnika XML został zamknięty, oryginalnym odczytującego XML jest umieszczony przy tagu końcowym elementu książki.  
  
 Nie należy wykonywać żadnych operacji na oryginalnym czytnika, aż nowe czytnik został zamknięty. Ta akcja nie jest obsługiwana i może spowodować nieprzewidywalne zachowanie.  
  
> [!NOTE]
>  <xref:System.Xml.XmlReader.ReadSubtree%2A> Metoda nie jest przeznaczona dla creatingcopies dane XML, które można pracować niezależnie. Jego designedto utworzyć obramowanie wokół elementu XML. Jest to przydatne, jeśli chcesz przekazać dane do innego składnika do przetwarzania, i chcesz ograniczyć ilość danych mogą uzyskiwać dostęp do składnika. Podczas przekazywania odczytującego XML zwrócony przez <xref:System.Xml.XmlReader.ReadSubtree%2A> metody do innej aplikacji, aplikacji mogą uzyskiwać dostęp do tylko tego elementu XML, nie całego dokumentu XML.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Xml.XmlReader.ReadSubtree%2A> metody.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Użyj następujące dane XML, aby uruchomić przykłady w tym temacie:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Czytnik XML nie jest umieszczony w elemencie, gdy ta metoda jest wywoływana.

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Przesuwa <see cref="T:System.Xml.XmlReader" /> do następnego elementu pasującego elementu podrzędnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu, który chcesz przenieść.</param>
        <summary>Przesuwa <see cref="T:System.Xml.XmlReader" /> do następnego elementu elementu podrzędnego z określoną nazwą kwalifikowaną.</summary>
        <returns><see langword="true" /> Jeśli zostanie znaleziony pasujący element elementu podrzędnego; w przeciwnym razie <see langword="false" />. Jeśli nie zostanie znaleziony pasujący element podrzędny, <see cref="T:System.Xml.XmlReader" /> jest ustawiony na tag końcowy (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) tego elementu.  
  
Jeśli <see cref="T:System.Xml.XmlReader" /> nie jest ustawiony na element podczas <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> została wywołana metoda ta zwraca <see langword="false" /> i położenie <see cref="T:System.Xml.XmlReader" /> nie ulegną zmianie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład analizuje drugiego węzła książki.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 W przykładzie użyto pliku `2books.xml`, jako danych wejściowych.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu, który chcesz przenieść.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu, który chcesz przenieść.</param>
        <summary>Przesuwa <see cref="T:System.Xml.XmlReader" /> do następnego elementu potomnych o określonej nazwie lokalnego i identyfikator URI przestrzeni nazw.</summary>
        <returns><see langword="true" /> Jeśli zostanie znaleziony pasujący element elementu podrzędnego; w przeciwnym razie <see langword="false" />. Jeśli nie zostanie znaleziony pasujący element podrzędny, <see cref="T:System.Xml.XmlReader" /> jest ustawiony na tag końcowy (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) tego elementu.  
  
Jeśli <see cref="T:System.Xml.XmlReader" /> nie jest ustawiony na element podczas <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> została wywołana metoda ta zwraca <see langword="false" /> i położenie <see cref="T:System.Xml.XmlReader" /> nie ulegną zmianie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Obie wartości parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje aż do znalezienia nazwanego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu.</param>
        <summary>Odczytuje, dopóki nie zostanie znaleziony element z określoną nazwą kwalifikowaną.</summary>
        <returns><see langword="true" /> Jeśli zostanie znaleziony pasujący element; w przeciwnym razie <see langword="false" /> i <see cref="T:System.Xml.XmlReader" /> jest w stanie koniec pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest funkcjonalnie równoważny wykonywania `following::name` wyrażenia XPath z bieżącego węzła. Zapewnia szybki sposób znaleźć o nazwie elementu w dokumencie XML. Proces czytający przechodzi do następnego następujący element, który odpowiada określonej nazwie i zwraca `true` Jeśli zostanie znaleziony pasujący element. Korzystając z poniższego przykładu, czytnik wczytane do pierwszego wystąpienia określonego elementu podczas odczytywania do przodu.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Ta metoda może być wywołana na wszystkie typy węzłów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw elementu.</param>
        <summary>Odczytuje, dopóki nie zostanie znaleziony element o określonej nazwie lokalnego i identyfikator URI przestrzeni nazw.</summary>
        <returns><see langword="true" /> Jeśli zostanie znaleziony pasujący element; w przeciwnym razie <see langword="false" /> i <see cref="T:System.Xml.XmlReader" /> jest w stanie koniec pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest funkcjonalnie równoważny wykonywania `following::name` wyrażenia XPath z bieżącego węzła. Zapewnia szybki sposób znaleźć o nazwie elementu w dokumencie XML. Proces czytający przechodzi do następnego następujący element, który odpowiada określonej nazwie i zwraca `true` Jeśli zostanie znaleziony pasujący element.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Ta metoda może być wywołana na wszystkie typy węzłów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Obie wartości parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Przesuwa <see langword="XmlReader" /> do następnego dopasowania elementu równorzędnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa element równorzędny, którą chcesz przenieść.</param>
        <summary>Przesuwa <see langword="XmlReader" /> do następnego elementu równorzędnego z określoną nazwą kwalifikowaną.</summary>
        <returns><see langword="true" /> Jeśli zostanie znaleziony pasujący element równorzędny; w przeciwnym razie <see langword="false" />. Jeśli nie zostanie znaleziony pasujący element równorzędny, <see langword="XmlReader" /> jest ustawiony na tag końcowy (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) elementu nadrzędnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Xml.XmlReader.ReadToNextSibling%2A> podczas `XmlReader` jest początkowy stan (<xref:System.Xml.XmlReader.ReadState%2A> jest <xref:System.Xml.ReadState.Initial>). Możesz wywołać <xref:System.Xml.XmlReader.Read%2A> pomocnych `XmlReader` , a następnie wywołać <xref:System.Xml.XmlReader.ReadToNextSibling%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład odczytuje atrybut ISBN w każdym węźle książki.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa element równorzędny, którą chcesz przenieść.</param>
        <param name="namespaceURI">Identyfikator URI element równorzędny, którą chcesz przenieść do przestrzeni nazw.</param>
        <summary>Przesuwa <see langword="XmlReader" /> do następnego elementu równorzędnego o określonej nazwie lokalnego i identyfikator URI przestrzeni nazw.</summary>
        <returns><see langword="true" /> Jeśli zostanie znaleziony pasujący element równorzędny; w przeciwnym razie <see langword="false" />. Jeśli nie zostanie znaleziony pasujący element równorzędny, <see langword="XmlReader" /> jest ustawiony na tag końcowy (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) elementu nadrzędnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Xml.XmlReader.ReadToNextSibling%2A> podczas `XmlReader` jest początkowy stan (<xref:System.Xml.XmlReader.ReadState%2A> jest <xref:System.Xml.ReadState.Initial>). Możesz wywołać <xref:System.Xml.XmlReader.Read%2A> pomocnych `XmlReader` , a następnie wywołać <xref:System.Xml.XmlReader.ReadToNextSibling%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Obie wartości parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która służy jako bufor, do której są zapisywane zawartość tekstową. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie <see cref="T:System.Xml.XmlReader" /> będzie mogła rozpocząć kopiowanie wyników.</param>
        <param name="count">Maksymalna liczba znaków do skopiowania w buforze. Rzeczywista liczba znaków, kopiowane jest zwracana z tej metody.</param>
        <summary>Odczytuje dużych strumieni zawarty w dokumencie XML.</summary>
        <returns>Liczba znaków odczytanych w buforze. Brak więcej zawartości tekstu zwracana jest wartość zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywanie bardzo dużych strumieni tekstu osadzony w dokumencie XML w sposób przesyłania strumieniowego, oznacza to niewielka liczba znaków w czasie, zamiast przydzielać pojedynczego ciągu dla wartości całkowitej. Ta metoda może być wywoływana w każdym węźle, który ma wartość (<xref:System.Xml.XmlReader.HasValue%2A> jest `true`), ale tylko przesyłania strumieniowego rzeczywiste wartości węzła występuje, gdy wywoływana na tekst, biały i istotnych białych węzłów. Inne wartości typu węzła są buforowane, w tym atrybutów i węzłów CDATA.  
  
 Metoda ta zwraca tylko zawartość <xref:System.Xml.XmlReader.Value%2A> właściwości i nie powoduje przeniesienia <xref:System.Xml.XmlReader>.  
  
 Ta metoda odczytuje określoną liczbę znaków (`count`) z wartością węzeł, do buforu znaków (`buffer`) od określonego przesunięcia (`index`) i zwraca liczbę znaków zapisanych w buforze. Zwraca `0` po osiągnął koniec wartości. Nie można uruchomić ponownie do przeczytania wartość ponownie.  
  
 Between wywołania <xref:System.Xml.XmlReader.ReadValueChunk%2A> <xref:System.Xml.XmlReader> właściwości są bez zmian, z wyjątkiem <xref:System.Xml.XmlReader.Value%2A> właściwości. Gdy <xref:System.Xml.XmlReader.Value%2A> dostępu do właściwości albo może zwrócić wartość częściowa (przy użyciu znaków, które nie zostały jeszcze zwracane przez <xref:System.Xml.XmlReader.ReadValueChunk%2A>) lub pełnej wartości w zależności od implementacji. Wszystkie <xref:System.Xml.XmlReader> implementacji w <xref:System.Xml> przestrzeni nazw zwracają wartość częściowa <xref:System.Xml.XmlReader.Value%2A> implementacja właściwości.  
  
 Odczytaj wszelkie Between wywołania można wywołać metody <xref:System.Xml.XmlReader.ReadValueChunk%2A>. W takim przypadku <xref:System.Xml.XmlReader> przechodzi do następnego <xref:System.Xml.XmlNodeType> w strumieniu i wszystkie znaki, które nie zostały jeszcze zwracane są pomijane.  
  
 Może to być sytuacja, gdy <xref:System.Xml.XmlReader.ReadValueChunk%2A> zwraca mniej niż żądana liczba znaków. Na przykład, jeśli ma wartość typu long 200 znaków z Para dwuskładnikowa w pozycjach 127 i 128 i wywołana <xref:System.Xml.XmlReader.ReadValueChunk%2A> z buforem 128 znaków, wywołanie metody zwróci 127 znaków zamiast żądanego 128. Para zastępcza będzie zwracany w ciągu następnych <xref:System.Xml.XmlReader.ReadValueChunk%2A> wywołania. W tym przypadku <xref:System.Xml.XmlReader.ReadValueChunk%2A> nie zwróciło żądanej 128 znaków, ponieważ spowoduje to więc spowodowałoby para zastępcza niekompletne, na koniec buforu.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący węzeł nie ma wartość (<see cref="P:System.Xml.XmlReader.HasValue" /> jest <see langword="false" />).

—lub— 
<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> Wartość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks w buforze, lub indeksu + liczba jest większa niż rozmiar przydzielonego buforu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Dane XML nie jest poprawnie sformułowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która służy jako bufor, do której są zapisywane zawartość tekstową. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze gdzie <see cref="T:System.Xml.XmlReader" /> będzie mogła rozpocząć kopiowanie wyników.</param>
        <param name="count">Maksymalna liczba znaków do skopiowania w buforze. Rzeczywista liczba znaków, kopiowane jest zwracana z tej metody.</param>
        <summary>Asynchronicznie odczytuje dużych strumieni zawarty w dokumencie XML.</summary>
        <returns>Liczba znaków odczytanych w buforze. Brak więcej zawartości tekstu zwracana jest wartość zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.ReadValueChunk%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."
—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, jest rozpoznawana jako odwołanie do jednostki <see langword="EntityReference" /> węzłów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli czytnik jest umieszczony na `EntityReference` węzła (`XmlNodeType.EntityReference`), jeśli <xref:System.Xml.XmlReader.Read%2A> jest wywoływana po wywołaniu tej metody, tekst zamiany jednostki jest analizowany. Po zakończeniu tekst zamiany jednostki `EndEntity` węzła jest zwracana do zamknięcia zakres odwołanie do jednostki.  
  
> [!NOTE]
>  Po wywołaniu tej metody, jeśli jednostka jest częścią wartość atrybutu, należy wywołać <xref:System.Xml.XmlReader.ReadAttributeValue%2A> aby wejść do jednostki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Czytnik nie został ustawiony na <see langword="EntityReference" /> węzła; to implementacja czytnik nie może rozpoznać jednostki (<see cref="P:System.Xml.XmlReader.CanResolveEntity" /> zwraca <see langword="false" />).

—lub—

<see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o schemacie, która ma przypisane do bieżącego węzła w wyniku sprawdzania poprawności schematu.</summary>
        <value><see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> Obiekt zawierający informacje o schemacie dla bieżącego węzła. W przypadku elementów, atrybutów, lub w węzły tekstowe inną niż null można ustawić informacji o schemacie <see cref="P:System.Xml.XmlReader.ValueType" /> (wpisane wartości).  
  
Jeśli bieżący węzeł nie jest jednym z powyższych typów węzłów lub <see langword="XmlReader" /> wystąpienia nie raportuje informacje o schemacie, właściwość ta zwraca <see langword="null" />.  
  
Jeśli ta właściwość jest wywoływana z <see cref="T:System.Xml.XmlTextReader" /> lub <see cref="T:System.Xml.XmlValidatingReader" /> obiektu, właściwość ta zwraca zawsze <see langword="null" />. Te <see langword="XmlReader" /> implementacji nie ujawniaj informacji o schemacie, za pośrednictwem <see langword="SchemaInfo" /> właściwości.  
  
 <block subset="none" type="note"><para>  
 Jeśli musisz pobrać zestaw informacji po weryfikacji (PSVI) dla elementu, umieść czytnik przy tagu końcowym elementu, a nie w tagu początkowego. Uzyskujesz PSVI za pośrednictwem <see langword="SchemaInfo" /> właściwości czytnika. Czytnik sprawdzania poprawności, który jest tworzony za pomocą <see cref="Overload:System.Xml.XmlReader.Create" /> z <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> właściwością <see cref="F:System.Xml.ValidationType.Schema" /> ma pełną PSVI elementu tylko wtedy, gdy czytnik jest umieszczony przy tagu końcowym elementu.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.IXmlSchemaInfo> Interfejsu przedstawia podzbiór o wpisu schematu sprawdzania poprawności zestaw informacji (PSVI) skojarzony z węzłem XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlReaderSettings" /> użyty do utworzenia tego obiektu <see cref="T:System.Xml.XmlReader" /> wystąpienia.</summary>
        <value><see cref="T:System.Xml.XmlReaderSettings" /> Użyty do utworzenia tego wystąpienia czytnika obiektów. Jeśli ten czytnik nie został utworzony przy użyciu <see cref="Overload:System.Xml.XmlReader.Create" /> metoda, właściwość ta zwraca <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlReaderSettings> Obiektu mogą zawierać poufne informacje, takie jak poświadczenia użytkownika. Aplikacje należy zachować ostrożność, jeśli buforowanie tego obiektu lub przekazywanie jej przez inny składnik.  
  
 <xref:System.Xml.XmlReaderSettings> Klasy jest używany do określenia zestaw funkcji do obsługi wystąpienia utworzone czytnika. <xref:System.Xml.XmlReaderSettings> Nie można zmodyfikować obiektu zwróconego przez tę właściwość. Dowolne próba zmiany wyniki poszczególnych ustawień w wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pomija elementy podrzędne bieżącego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujący kod XML wejściowych, gdy czytnik jest umieszczony na `<a>` węzła lub jego atrybuty wywoływania `Skip` umieszcza czytelnika `<b>` węzła.  
  
 Jeśli czytnik jest już umieszczony na węzeł liścia (takie jak `<x>` lub węzeł tekstu `abc`), wywoływania `Skip` jest taka sama jak wywołania <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Ta metoda sprawdza, czy poprawnie sformułowany dokument XML.  
  
 Jeśli czytnik <xref:System.Xml.XmlValidatingReader>, ta metoda sprawdza poprawność pominięto zawartości.  
  
 `XmlReader` Implementacja Określa, czy `Skip` metoda rozwinie podmiotów zewnętrznych. W poniższej tabeli opisano, czy zewnętrznych jednostek zostaną rozwinięte dla różnych typów `XmlReader` obiektów.  
  
|Typ elementu XmlReader|Rozwija podmiotów zewnętrznych|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Nie.|  
|<xref:System.Xml.XmlReader> utworzone przez wystąpienie <xref:System.Xml.XmlReader.Create%2A> metodę, która odczytuje dane tekstowe.|Nie.|  
|<xref:System.Xml.XmlReader> utworzone przez wystąpienie <xref:System.Xml.XmlReader.Create%2A> metodę, która odczytuje dane binarne.|Nie dotyczy.|  
|Sprawdzanie poprawności schematu <xref:System.Xml.XmlReader> wystąpienia utworzone przez <xref:System.Xml.XmlReader.Create%2A> metody.|Tak.|  
|<xref:System.Xml.XmlValidatingReader>|Tak.|  
|<xref:System.Xml.XmlReader> wystąpienie zwrócone przez <xref:System.Xml.XPath.XPathNavigator> obiektu.|Nie dotyczy.|  
|<xref:System.Xml.XmlNodeReader>|Nie.|  
|<xref:System.Xml.XmlReader> wystąpienie otaczający innego <xref:System.Xml.XmlReader> wystąpienia.|Jest zależna od implementacji podstawowych <xref:System.Xml.XmlReader>. ( `Skip` Metody bazowego <xref:System.Xml.XmlReader> nosi nazwę).|  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład analizuje plik XML, począwszy od drugiego węzła książki.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 W przykładzie użyto pliku `2books.xml`, jako danych wejściowych.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie pomija elementy podrzędne bieżącego węzła.</summary>
        <returns>Bieżącego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna <xref:System.Xml.XmlReader.Skip%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."

—lub—

<see cref="T:System.Xml.XmlReader" /> Wywołano metodę asynchroniczną bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw dla właściwości XmlReaderSettings.Async wartość true, jeśli chcesz używać metod asynchronicznych."</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programowanie asynchroniczne z Async i Await (C# i Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.IDisposable.Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Xml.XmlReader> wystąpienia jest rzutowany na <xref:System.IDisposable> interfejsu.

Ten element członkowski może zachowywać się inaczej gdy jest używany w [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) projektu. Aby uzyskać więcej informacji, zobacz [API Differences in Portable Class Library](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100)).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość tekstowa elementu bieżącego węzła.</summary>
        <value>Wartość zwracana jest zależna od <see cref="P:System.Xml.XmlReader.NodeType" /> węzła. W poniższej tabeli wymieniono typy węzłów, które mają wartość do zwrócenia. Inny węzeł typów zwrotu <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Typ węzła 
 </term><description> Wartość 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Wartość atrybutu.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Zawartość sekcji CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Treść komentarza.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Wewnętrzny podzbiór.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Całej zawartości, z wyłączeniem element docelowy.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Odstępy między znaczników w modelu zawartości mieszanej.  
  
 </description></item><item><term><see langword="Text" /></term><description> Zawartość węzła tekstowego.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Odstępy między znaczników.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Zawartość deklaracji.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczne wersja tej właściwości dla <xref:System.Xml.XmlReader.GetValueAsync%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ środowiska uruchomieniowego języka wspólnego (CLR) dla bieżącego węzła.</summary>
        <value>Typ CLR, który odnosi się do typizowanych wartość węzła. Wartość domyślna to <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz [Obsługa typu w ramach klas zestawu System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) listę mapowań domyślnych.  
  
 Element typu `xs:int` ma `ValueType` z `System.Int32` domyślnie. Jednak `ValueType` mogą mieć jedną z prawidłowe typy, które mogą być mapowane na `xs:int`, takich jak `System.Int16` lub `System.Double`.  
  
 Jeśli węzeł jest bez, lub jeśli węzeł jest element zawierający zawartość mieszana, wartość węzła jest mapowany na `System.String` typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <block subset="none" type="overrides"><para>Należy podać implementacje <see langword="ValueType" /> dla każdego węzła, nawet jeśli jest on tylko <see langword="System.String" /> typu.</para></block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera bieżącą <see langword="xml:lang" /> zakresu.</summary>
        <value>Bieżący <see langword="xml:lang" /> zakresu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość reprezentuje `xml:lang` zakresu, w którym znajduje się bieżącego węzła. Na przykład poniżej przedstawiono fragment XML przy użyciu `xml:lang` ustawiony na US English w elemencie głównym:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Gdy czytnik jest umieszczony na `name` elementu, można używasz tej właściwości można znaleźć się w zakresie US English `xml:lang` atrybutu.  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> na przykład za pomocą tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera bieżącą <see langword="xml:space" /> zakresu.</summary>
        <value>Jedną z <see cref="T:System.Xml.XmlSpace" /> wartości. Jeśli nie <see langword="xml:space" /> występuje zakresie, tej właściwości wartość domyślna to <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.XmlSpace%2A> (w `XmlTextReader` klasy) na przykład za pomocą tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed zakończeniem poprzedniej operacji asynchronicznej. W tym przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>
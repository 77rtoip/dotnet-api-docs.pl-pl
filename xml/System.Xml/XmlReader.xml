<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a8556c50acebbf93573137f5fa5bcc18efa77878" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34256513" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje czytnik, która zapewnia szybki, niebuforowany, tylko do przodu dostępu do danych XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> Umożliwia dostęp tylko do przodu, tylko do odczytu do danych XML w dokumencie lub strumienia. Ta klasa odpowiada W3C [języka XML (Extensible Markup) 1.0 (czwarty edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) i [przestrzeniach nazw XML 1.0 (trzeci edition)](https://www.w3.org/TR/REC-xml-names/) zalecenia.  
  
 <xref:System.Xml.XmlReader> metody umożliwiają przechodzenie między dane XML i odczytywania zawartości węzła. Właściwości klasy odzwierciedlają bieżącego węzła, który jest, gdy czytnik znajduje się wartość. <xref:System.Xml.XmlReader.ReadState%2A> Wartość właściwości wskazuje bieżący stan modułu odczytującego XML. Na przykład właściwość jest ustawiona <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> przez <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> — metoda i <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> przez <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> metody. <xref:System.Xml.XmlReader> udostępnia również sprawdza zgodność danych i weryfikacji względem DTD lub schemat.  
  
 <xref:System.Xml.XmlReader> wykorzystuje model ściągania można pobrać danych. Ten model:  
  
-   Upraszcza zarządzanie stanem procedurach uściślenia fizycznych, góra dół.  
  
-   Obsługuje wiele strumieni wejściowych i tworzenie warstw.  
  
-   Umożliwia klientowi zapewniają analizator buforu, w którym ciąg są zapisywane bezpośrednio i w związku z tym pozwala uniknąć konieczności kopiowania dodatkowe parametry.  
  
-   Obsługuje przetwarzanie selektywnego. Klient może pominąć elementy i przetworzyć te, które są przydatne do aplikacji. Można również ustawić właściwości z wyprzedzeniem, aby zarządzać przetwarzaniu strumień XML (na przykład normalizacji).  
  
 W tej sekcji:  
  
 [Tworzenia modułu odczytującego XML](#xmlreader_create)   
 [Sprawdzanie poprawności danych XML](#xmlreader_validate)   
 [Zgodność danych](#xmlreader_data)   
 [Nawigować przez węzły](#xmlreader_nodes)   
 [Elementy XML odczytu](#xmlreader_elements)   
 [Atrybuty XML odczytu](#xmlreader_attributes)   
 [Zawartości XML odczytu](#xmlreader_content)   
 [Konwertowanie na typy CLR](#xmlreader_clr)   
 [Programowanie asynchroniczne](#xmlreader_async)   
 [Zagadnienia dotyczące zabezpieczeń](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Tworzenia modułu odczytującego XML  
 Użyj <xref:System.Xml.XmlReader.Create%2A> metodę w celu utworzenia <xref:System.Xml.XmlReader> wystąpienia.  
  
 Mimo że platforma .NET Framework zapewnia konkretnych implementacje <xref:System.Xml.XmlReader> klas, takich jak <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>oraz <xref:System.Xml.XmlValidatingReader> klas, firma Microsoft zaleca się używanie klas wyspecjalizowanych tylko w tych scenariuszach:  
  
-   Jeśli chcesz odczytać poddrzewo XML DOM z <xref:System.Xml.XmlNode> obiektów, użyj <xref:System.Xml.XmlNodeReader> klasy. (Jednak ta klasa nie obsługuje sprawdzania DTD lub schemat).  
  
-   Jeśli należy rozwinąć jednostek na żądanie, nie ma tekstu zawartości znormalizowany lub nie ma atrybutów zwracanych w domyślnych, użyj <xref:System.Xml.XmlTextReader> klasy.  
  
 Aby określić zestaw funkcji, które chcesz włączyć modułu odczytującego XML, Przekaż <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> do obiektu <xref:System.Xml.XmlReader.Create%2A> metody. Można użyć pojedynczego <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiekt do utworzenia wielu czytników z tą samą funkcjonalnością lub zmodyfikować <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiektu do utworzenia nowego czytnika z innym zestawem funkcji. Można również łatwo dodać funkcje do istniejącej czytnika.  
  
 Jeśli nie używasz <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> obiektu, używane są ustawienia domyślne. Zobacz <xref:System.Xml.XmlReader.Create%2A> strona referencyjna, aby uzyskać szczegółowe informacje.  
  
 <xref:System.Xml.XmlReader> zgłasza wyjątek <xref:System.Xml.XmlException> na XML analizy błędów. Po wyjątku stan czytnika danych nie jest przewidywalne. Na przykład typ węzła zgłoszone może być inny niż typ węzła rzeczywiste bieżącego węzła. Użyj <xref:System.Xml.XmlReader.ReadState%2A> właściwość do sprawdzenia, czy czytnik jest w stanie błędu.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Sprawdzanie poprawności danych XML  
 Aby zdefiniować strukturę dokumentu XML i jego element relacje, typy danych i ograniczeń zawartości, możesz użyć definicja typu dokumentu (DTD) ani schematu (XSD) języka definicji schematu XML. Dokument XML jest uznawany za być poprawnie sformułowany spełniający wszystkie wymagania syntaktycznych zdefiniowane przez [W3C XML 1.0 zalecenie](https://www.w3.org/TR/2006/REC-xml-20060816/). Uważa się nieprawidłowy, gdy jest poprawnie sformułowany i również odpowiada ograniczeń zdefiniowanych przez jego definicja DTD lub schemat. (Zobacz [W3C XML schematu część 1: struktury](https://www.w3.org/TR/xmlschema-1/) i [W3C XML schematu część 2: typy danych](https://www.w3.org/TR/xmlschema-2/)zalecenia.) W związku z tym mimo że wszystkich ważnych dokumentów XML są poprawnie sformułowane, nie wszystkie poprawnie sformułowanym dokumentów XML są prawidłowe.  
  
 Można sprawdzić poprawność danych według definicji DTD, wbudowanego schematu XSD lub schematu XSD przechowywane w <xref:System.Xml.Schema.XmlSchemaSet> obiektu (pamięci podręcznej); te scenariusze są opisane na <xref:System.Xml.XmlReader.Create%2A> strony odwołania. <xref:System.Xml.XmlReader> nie obsługuje sprawdzanie poprawności schematu XML danych (XDR).  
  
 Użyj następujących ustawień na <xref:System.Xml.XmlReaderSettings> klasę, aby określić typ sprawdzania poprawności, jeśli taki występuje, <xref:System.Xml.XmlReader> wystąpienie obsługuje.  
  
|Użyj tej <xref:System.Xml.XmlReaderSettings> elementu członkowskiego|Aby określić|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> Właściwość|Określa, czy zezwolić na przetwarzanie elementu DTD. Wartość domyślna to, aby uniemożliwić przetwarzanie elementu DTD.|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Właściwość|Określa, czy czytnik powinien sprawdzić poprawność danych i typ sprawdzania poprawności (DTD lub schemat). Poprawność nie jest domyślnie.|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler> Zdarzenia|Program obsługi zdarzeń do odbierania informacji na temat zdarzenia walidacji. Jeśli program obsługi zdarzeń nie zostanie podany, <xref:System.Xml.XmlException> jest zgłaszany na pierwszy błąd sprawdzania poprawności.|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> Właściwość|Opcje dodatkowe sprawdzenie poprawności za pośrednictwem <xref:System.Xml.Schema.XmlSchemaValidationFlags> elementy członkowskie wyliczenia:<br /><br /> -   `AllowXmlAttributes`— Zezwalaj na atrybutów XML (`xml:*`) w dokumentach wystąpienia nawet wtedy, gdy nie są one zdefiniowane w schemacie. Atrybuty są weryfikowane, na podstawie ich typu danych. Zobacz <xref:System.Xml.Schema.XmlSchemaValidationFlags> strona referencyjna ustawienia do użycia w określonych scenariuszach. (Domyślnie wyłączone.)<br />-   `ProcessIdentityConstraints` --Przetworzyć ograniczenia tożsamości (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) podczas sprawdzania poprawności. (Opcja domyślna).<br />-   `ProcessSchemaLocation` --Przetworzyć schematy określony przez `xsi:schemaLocation` lub `xsi:noNamespaceSchemaLocation` atrybutu. (Opcja domyślna).<br />-   `ProcessInlineSchema`--Przetworzyć wbudowanego schematów XML podczas sprawdzania poprawności. (Domyślnie wyłączone.)<br />-   `ReportValidationWarnings`--Zgłaszać zdarzenia, jeśli wystąpi ostrzeżenie walidacji. Ostrzeżenie zostanie wyświetlone zwykle, gdy nie istnieje DTD lub schemat XML do sprawdza, czy dany element lub atrybut przed. <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> Jest używany dla powiadomienia. (Domyślnie wyłączone.)|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<xref:System.Xml.Schema.XmlSchemaSet> Do użycia w celu weryfikacji.|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Właściwość|<xref:System.Xml.XmlResolver> Rozpoznawania i uzyskiwanie dostępu do zasobów zewnętrznych. Może to obejmować jednostek zewnętrznych, takich jak DTD i schematy i wszystkie `xs:include` lub `xs:import` elementów zawartych w schemacie XML. Jeśli nie określisz <xref:System.Xml.XmlResolver>, <xref:System.Xml.XmlReader> korzysta z domyślnego <xref:System.Xml.XmlUrlResolver> bez poświadczeń użytkownika.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Zgodność danych  
 Czytniki XML, które są tworzone przez <xref:System.Xml.XmlReader.Create%2A> metody spełniać następujące wymagania zgodności przez domyślne:  
  
-   Nowe wiersze, a wartość atrybutu są znormalizowany zgodnie z W3C [XML 1.0 zalecenie](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Automatycznie zostaną rozwinięte wszystkie jednostki.  
  
-   Domyślne atrybuty zadeklarowany w definicji typu dokumentu są dodawane zawsze, nawet wtedy, gdy czytnik nie sprawdzania poprawności.  
  
-   Deklaracja XML prefiksu mapowany na poprawną przestrzeń nazw identyfikatora XML URI jest dozwolona.  
  
-   W jednej nazwy notacji `NotationType` atrybutu deklaracji i `NmTokens` w jednej `Enumeration` deklaracji atrybutu są unikatowe.  
  
 Użyj tych <xref:System.Xml.XmlReaderSettings> chcesz włączyć właściwości, aby określić typ zgodność sprawdza możesz:  
  
|Użyj tej <xref:System.Xml.XmlReaderSettings> właściwości|Do|Domyślny|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> Właściwość|Włącz lub wyłącz sprawdza następujące czynności:<br /><br /> -Znaki są w zakresie prawidłowe znaki XML, zgodnie z definicją w [2,2 znaków](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) sekcji zalecenia W3C XML 1.0.<br />-Wszystkie nazwy XML są prawidłowe, zgodnie z definicją w [2.3 typowe konstrukcje składni](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) sekcji zalecenia W3C XML 1.0.<br /><br /> Jeśli ta właściwość jest skonfigurowana `true` (ustawienie domyślne), <xref:System.Xml.XmlException> jest zgłaszany wyjątek, jeśli plik XML zawiera niedozwolone znaki lub nieprawidłowych nazw XML (na przykład nazwę elementu rozpoczyna się od numeru).|Znak i sprawdzanie nazw jest włączone.<br /><br /> Ustawienie <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> do `false` wyłącza znak sprawdzanie odwołania do jednostki znaku. Jeśli czytnik przetwarza dane tekstowe, zawsze sprawdza to, że nazwy XML są prawidłowe, niezależnie od tego ustawienia. **Uwaga:** zalecenie XML 1.0 wymaga zgodności na poziomie dokumentu, gdy występuje DTD. W związku z tym gdy czytnik jest skonfigurowany do obsługi <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, ale w danych XML znajduje się definicja typu dokumentu (DTD), <xref:System.Xml.XmlException> jest generowany.|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> Właściwość|Wybierz poziom zgodności, aby wymusić:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Jest zgodny z regułami dotyczącymi [poprawnie sformułowany dokument XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Jest zgodny z regułami dla fragmentu poprawnie sformułowany dokument, które mogą być używane jako [zewnętrzne przeanalizowana jednostka](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Jest zgodna z poziomu przez czytnik.<br /><br /> Jeśli dane nie ma niezgodności, <xref:System.Xml.XmlException> wyjątku.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Nawigować przez węzły  
 Bieżący węzeł jest węzłem XML aktualnie znajduje modułu odczytującego XML. Wszystkie <xref:System.Xml.XmlReader> metody wykonywania operacji w odniesieniu do tego węzła oraz wszystkich <xref:System.Xml.XmlReader> właściwości odzwierciedlają wartość bieżącego węzła.  
  
 Następujących metod można ułatwić nawigować przez węzły i analizy danych.  
  
|Użyj tej <xref:System.Xml.XmlReaderSettings> — metoda|Do|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Przeczytaj pierwszy węzeł, a przechodzić przez jeden węzeł strumienia w czasie. Takie połączenia są zazwyczaj wykonywane wewnątrz `while` pętli.<br /><br /> Użyj <xref:System.Xml.XmlReader.NodeType%2A> właściwości można pobrać typu (na przykład atrybut, komentarza, element i tak dalej) bieżącego węzła.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Pomiń elementy podrzędne bieżącego węzła i przejście do następnego węzła.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> I <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Pomiń węzłów z systemem innym niż zawartości i Przenieś do następnego węzła zawartości lub na końcu pliku.<br /><br /> Węzły zawartości nie zawierają <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, i <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Węzły zawierają tekst z systemem innym niż biały znak zawartości <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , i <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Odczytywanie elementu i wszystkich jego obiektów podrzędnych i zwraca nowy <xref:System.Xml.XmlReader> ustawioną wystąpienia <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Ta metoda jest przydatna do tworzenia granic wokół elementów XML; na przykład jeśli chcesz przekazać dane do innego składnika do przetwarzania i aby ograniczyć ilość danych składnika można uzyskać dostęp.|  
  
 Zobacz <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> strona referencyjna przykład nawigować przez jeden węzeł strumienia tekstu w czasie i wyświetlanie typ każdego węzła.  
  
 W poniższych sekcjach opisano, jak można znaleźć określone typy danych, takich jak elementy, atrybuty i typu danych.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Elementy XML odczytu  
 W poniższej tabeli przedstawiono metody i właściwości który <xref:System.Xml.XmlReader> udostępnia klasy dla przetwarzania elementów. Po <xref:System.Xml.XmlReader> znajduje się w elemencie właściwości węzła, takich jak <xref:System.Xml.XmlReader.Name%2A>, wartości elementu. Oprócz członków opisane poniżej, wszystkie metody ogólne i właściwości <xref:System.Xml.XmlReader> klasy mogą służyć do przetwarzania elementów. Na przykład można użyć <xref:System.Xml.XmlReader.ReadInnerXml%2A> metody można odczytać zawartości elementu.  
  
> [!NOTE]
>  W sekcji 3.1 [W3C XML 1.0 zalecenie](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) definicje początkowe tagi, kończyć tagów i tagi pusty element.  
  
|Użyj tej <xref:System.Xml.XmlReader> elementu członkowskiego|Do|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A> — Metoda|Sprawdź, czy bieżący węzeł jest tag początkowy lub znacznik pustego elementu.|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A> — Metoda|Sprawdź, czy bieżący węzeł jest elementem i przejść do następnego węzła czytnik (wywołania <xref:System.Xml.XmlReader.IsStartElement%2A> następuje <xref:System.Xml.XmlReader.Read%2A>).|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A> — Metoda|Sprawdź, czy bieżący węzeł tagu końcowego i przejść do następnego węzła czytnika.|  
|<xref:System.Xml.XmlReader.ReadElementString%2A> — Metoda|Przeczytaj element tekstowy.|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A> — Metoda|Wcześniejsze czytnika XML do następnego elementu potomnym (podrzędny), która ma określoną nazwę.|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A> — Metoda|Wcześniejsze modułu odczytującego XML, aby następny element równorzędny, która ma określoną nazwę.|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A> Właściwość|Sprawdź, czy bieżący element został tagu końcowego elementu. Na przykład:<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> jest `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> jest `false`, mimo że zawartość elementu jest pusta.)|  
  
 Na przykład odczytywania zawartości tekstowej elementów zobacz <xref:System.Xml.XmlReader.ReadString%2A> metody. Poniższy przykład przetwarza elementy przy użyciu `while` pętli.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Atrybuty XML odczytu  
 Atrybuty XML najczęściej znajdują się w elementach, ale one również są dozwolone w deklaracji XML i węzłów typu dokumentu.  
  
 Gdy znajduje się w węźle elementu <xref:System.Xml.XmlReader.MoveToAttribute%2A> metody umożliwia przejście przez listę atrybutu element. Należy pamiętać, że po <xref:System.Xml.XmlReader.MoveToAttribute%2A> została wywołana, właściwości węzła takich jak <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, i <xref:System.Xml.XmlReader.Prefix%2A> odzwierciedlają właściwości tego atrybutu, należy nie właściwości elementu atrybutu.  
  
 <xref:System.Xml.XmlReader> Klasa udostępnia te metody i właściwości, aby odczytywać i przetwarzać atrybuty elementów.  
  
|Użyj tej <xref:System.Xml.XmlReader> elementu członkowskiego|Do|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A> Właściwość|Sprawdź, czy bieżący węzeł ma żadnych atrybutów.|  
|<xref:System.Xml.XmlReader.AttributeCount%2A> Właściwość|Pobierz liczbę atrybutów dla bieżącego elementu.|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> — Metoda|Przenieś pierwszy atrybut w elemencie.|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A> — Metoda|Przenieś do następnego atrybutu w elemencie.|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A> — Metoda|Przenieś do określonego atrybutu.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> Metoda lub <xref:System.Xml.XmlReader.Item%2A> właściwości|Pobiera wartość określonego atrybutu.|  
|<xref:System.Xml.XmlReader.IsDefault%2A> Właściwość|Sprawdź, czy bieżący węzeł jest atrybut, który został wygenerowany na podstawie wartości domyślnej zdefiniowanej w definicji DTD lub schemat.|  
|<xref:System.Xml.XmlReader.MoveToElement%2A> — Metoda|Przenieś element będący właścicielem bieżący atrybut. Użyj tej metody, aby powrócić do elementu po nawigować przez jego atrybuty.|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A> — Metoda|Przeanalizować wartość atrybutu do co najmniej jeden `Text`, `EntityReference`, lub `EndEntity` węzłów.|  
  
 Jedną z ogólnych <xref:System.Xml.XmlReader> metody i właściwości mogą służyć do przetwarzania atrybutów. Na przykład po <xref:System.Xml.XmlReader> znajduje się w atrybucie <xref:System.Xml.XmlReader.Name%2A> i <xref:System.Xml.XmlReader.Value%2A> właściwości odzwierciedlają wartości atrybutu. Można również użyć żadnej zawartości `Read` metody w celu uzyskania wartości atrybutu.  
  
 W tym przykładzie użyto <xref:System.Xml.XmlReader.AttributeCount%2A> właściwości poruszać się po wszystkie atrybuty w elemencie.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 W tym przykładzie użyto <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> metoda `while` pętli do nawigowania atrybutów.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Odczytywania atrybutów w węzłach deklaracji XML**  
  
 Gdy czytnik XML znajduje się w węźle deklaracji XML <xref:System.Xml.XmlReader.Value%2A> właściwość zwraca wersji autonomicznej i kodowania informacji jako pojedynczy ciąg. <xref:System.Xml.XmlReader> obiekty utworzone przez <xref:System.Xml.XmlReader.Create%2A> metody <xref:System.Xml.XmlTextReader> klasy i <xref:System.Xml.XmlValidatingReader> klasy ujawnia wersji autonomicznej i kodowania elementów jako atrybuty.  
  
 **Odczytywania atrybutów w węzłach typu dokumentu**  
  
 Gdy czytnik XML znajduje się w węźle typu dokumentu, <xref:System.Xml.XmlReader.GetAttribute%2A> — metoda i <xref:System.Xml.XmlReader.Item%2A> właściwości może służyć do zwrócenia wartości literałów systemu i publicznej. Na przykład wywołanie elementu `reader.GetAttribute("PUBLIC")` zwraca wartość publicznego.  
  
 **Odczytywania atrybutów na przetwarzanie instrukcji węzłów**  
  
 Gdy <xref:System.Xml.XmlReader> znajduje się w węźle instrukcji przetwarzania <xref:System.Xml.XmlReader.Value%2A> właściwość zwraca zawartość całego tekstu. Elementy w węźle instrukcji przetwarzania nie są traktowane jako atrybuty. Nie można odczytać z <xref:System.Xml.XmlReader.GetAttribute%2A> lub <xref:System.Xml.XmlReader.MoveToAttribute%2A> metody.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Zawartości XML odczytu  
 Klasy XMLReader obejmuje następujące elementy członkowskie odczytu zawartości z pliku XML i zwraca zawartość jako wartości parametrów. (Aby zwracane typy CLR, zobacz [następnej sekcji](#xmlreader_clr).)  
  
|Użyj tej <xref:System.Xml.XmlReader> elementu członkowskiego|Do|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A> Właściwość|Pobierz zawartość tekstu bieżącego węzła. Wartość zwracana zależy od typu węzła; zobacz <xref:System.Xml.XmlReader.Value%2A> strona referencyjna, aby uzyskać szczegółowe informacje.|  
|<xref:System.Xml.XmlReader.ReadString%2A> — Metoda|Uzyskaj zawartość elementu lub tekst węzła jako ciąg. Ta metoda zatrzymuje się na przetwarzanie instrukcje i komentarze.<br /><br /> Aby uzyskać więcej informacji na jak ta metoda obsługuje typy określonego węzła, zobacz <xref:System.Xml.XmlReader.ReadString%2A> strony odwołania.|  
|<xref:System.Xml.XmlReader.ReadInnerXml%2A> i <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> metody|Pobierz całą zawartość bieżącego węzła, w tym kod znaczników, z wyłączeniem tagiem początkowym i końcowym. Na przykład dla:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> Zwraca:<br /><br /> `this<child id="123"/>`|  
|<xref:System.Xml.XmlReader.ReadOuterXml%2A> i <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> metody|Pobierz całą zawartość bieżącego węzła i jego elementów podrzędnych, w tym tagi znaczników i rozpoczęcia i zakończenia. Na przykład dla:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> Zwraca:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Konwertowanie na typy CLR  
 Korzystając z członkami <xref:System.Xml.XmlReader> klasy (wymienione w poniższej tabeli) do odczytywania danych XML i zwracanie wartości jako języka wspólnego typów środowiska uruchomieniowego (języka wspólnego CLR) zamiast ciągów. Elementy te umożliwiają uzyskanie wartości w reprezentacji, która jest najbardziej odpowiednia zadania kodowania bez konieczności ręcznego przeanalizować lub konwertowanie wartości ciągu.  
  
-   **ReadElementContentAs** metody można wywołać tylko dla typów węzeł elementu. Nie można używać tych metod dla elementów, które zawierają elementy podrzędne lub zawartości mieszanej. Po wywołaniu <xref:System.Xml.XmlReader> obiektu odczytuje tagu początkowego odczytuje zawartość elementu i przenosi poza tagu końcowego. Przetwarzanie instrukcji i komentarze są ignorowane, a jednostki są rozwinięte.  
  
-   **ReadContentAs** metody odczytu zawartości tekstowej w bieżącym położeniu czytnika i jeśli w danych XML nie ma żadnego schematu lub dane typu informacje skojarzone z nią przekonwertować zawartości tekstowej na żądany typ zwracany. Tekst, biały znak, znaczący biały znak i sekcjach CDATA są połączone. Komentarze i instrukcji przetwarzania są pomijane, a odwołania do jednostek nie są automatycznie rozwiązane.  
  
 <xref:System.Xml.XmlReader> Klasa korzysta z zasadami określonymi przez [W3C XML schematu część 2: typy danych](https://www.w3.org/TR/xmlschema-2/)zalecenia.  
  
|Użyj tej <xref:System.Xml.XmlReader> — metoda|Aby powrócić do tego typu CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> I <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|Typ z `returnType` parametru|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> I <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|Najbardziej odpowiedni typ określony przez <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> właściwości. Zobacz [typu obsługi w klasach System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) uzyskać informacje dotyczące mapowania.|  
  
 Jeśli element łatwo nie można przekonwertować na typ CLR z powodu jego format, umożliwia mapowanie zapewnienia pomyślnej konwersji. W poniższym przykładzie użyto pliku XSD, aby przekonwertować `hire-date` elementu `xs:date` typu, a następnie używa <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> metodę, aby zwracać element jako <xref:System.DateTime> obiektu.  
  
 **Dane wejściowe (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Schemat (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Kod:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Dane wyjściowe:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Programowanie asynchroniczne  
 Większość <xref:System.Xml.XmlReader> metody mają asynchroniczne odpowiedników, których "Async" na końcu nazwy metody. Na przykład asynchroniczne odpowiednikiem <xref:System.Xml.XmlReader.ReadContentAsObject%2A> jest <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Następujące metody mogą być używane z wywołań metod asynchronicznych:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 W poniższych sekcjach opisano użycie asynchronicznego dla metod, które nie mają odpowiedników asynchronicznego.  
  
 **ReadStartElement — metoda**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement — metoda**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling — metoda**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing — metoda**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant — metoda**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Zagadnienia dotyczące bezpieczeństwa  
 Należy rozważyć podczas pracy z <xref:System.Xml.XmlReader> klasy:  
  
-   Wyjątków zgłaszanych przez <xref:System.Xml.XmlReader> może ujawnić informacje o ścieżce, które nie mogą zostać przepuszcza do aplikacji. Aplikacji należy przechwytywać wyjątki i odpowiednio je przetworzyć.  
  
-   Nie należy włączać DTD przetwarzania, jeśli masz obawy odmowa problemów dotyczących usługi lub w przypadku pracy z niezaufanego źródła. Przetwarzanie elementu DTD jest domyślnie wyłączona dla <xref:System.Xml.XmlReader> obiekty utworzone przez <xref:System.Xml.XmlReader.Create%2A> metody.  
  
     Jeśli przetwarzanie elementu DTD włączone, można użyć <xref:System.Xml.XmlSecureResolver> do ograniczania zasobów który <xref:System.Xml.XmlReader> może uzyskać dostęp. Można również projektować aplikacji, tak aby przetwarzania XML pamięci i ograniczonego czasu. Na przykład można skonfigurować limitów czasu w aplikacji ASP.NET.  
  
-   Dane XML mogą zawierać odwołania do zasobów zewnętrznych, takich jak plik schematu. Domyślnie zasobów zewnętrznych są rozpoznawane przy użyciu <xref:System.Xml.XmlUrlResolver> obiektu bez poświadczeń użytkownika. Można zabezpieczyć ją, wykonując jedną z następujących czynności:  
  
    -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
  
    -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości `null`.  
  
-   <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> i <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> flagi weryfikacji <xref:System.Xml.XmlReaderSettings> obiektu nie są ustawione domyślnie. Pomaga to chronić <xref:System.Xml.XmlReader> przed atakami schematu podczas przetwarzania danych XML z niezaufanego źródła. Gdy te flagi są ustawiane, <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> z <xref:System.Xml.XmlReaderSettings> obiekt jest używany do rozwiązania lokalizacji schematu w dokumencie wystąpienia w <xref:System.Xml.XmlReader>. Jeśli <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość jest ustawiona na `null`, lokalizacji schematu nie są rozwiązane nawet wtedy, gdy <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> i <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> ustawiono flagi weryfikacji.  
  
     Dodane podczas weryfikacji schematów Dodawanie nowych typów i zmienić wynik weryfikacji dokumentu sprawdzania poprawności. W związku z tym schematy zewnętrzne mają zostać rozwiązane tylko z zaufanych źródeł.  
  
     Zaleca się wyłączenie <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> Flaga podczas sprawdzania poprawności niezaufanych, duża dokumentów XML w scenariuszach wysokiej dostępności ze schematem, który ma ograniczenia tożsamości przez dużą część dokumentu. Ta flaga jest domyślnie włączona.  
  
-   Dane XML mogą zawierać dużej liczby atrybutów, deklaracje przestrzeni nazw, elementów zagnieżdżonych i tak dalej wymagające znacznej ilości czasu na przetwarzanie. Aby ograniczyć rozmiar danych wejściowych, które są wysyłane do <xref:System.Xml.XmlReader>, można wykonywać następujące czynności:  
  
    -   Limit rozmiaru dokumentu przez ustawienie <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> właściwości.  
  
    -   Ogranicz liczbę znaków, które są wynikiem rozwijanie jednostek przez ustawienie <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> właściwości.  
  
    -   Utworzenie niestandardowego `IStream` implementację <xref:System.Xml.XmlReader>.  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A> Metody można użyć do obsługi dużych strumieni danych. Ta metoda odczytuje niewielkiej liczby znaków w czasie zamiast przydzielania pojedynczy ciąg dla wartości całkowitej.  
  
-   Podczas odczytywania dokumentu XML z dużą liczbą unikatowe nazwy lokalnej, przestrzenie nazw i prefiksy, może wystąpić problem. Jeśli korzystasz z klasą pochodzącą z <xref:System.Xml.XmlReader>, i wywołania <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, lub <xref:System.Xml.XmlReader.NamespaceURI%2A> zwracany ciąg właściwości dla każdego elementu, jest dodawany do <xref:System.Xml.NameTable>. Kolekcja posiadaniu <xref:System.Xml.NameTable> nigdy nie zmniejsza rozmiar, tworzenie przeciek pamięci wirtualnej dojść ciągu. Jeden środki zaradcze dla tego ma dziedziczyć <xref:System.Xml.NameTable> klasy i wymuszać maksymalną wielkość limitu przydziału. (Nie istnieje sposób, aby uniemożliwić korzystanie z <xref:System.Xml.NameTable>, lub aby przełączyć <xref:System.Xml.NameTable> gdy jest pełny). Środki zaradcze innego jest unikać właściwości wymienionych i zamiast tego użyć <xref:System.Xml.XmlReader.MoveToAttribute%2A> metody z <xref:System.Xml.XmlReader.IsStartElement%2A> — metoda w miarę możliwości; te metody, nie zwracać ciągi i w związku z tym uniknąć problemów z przepełnienie <xref:System.Xml.NameTable> kolekcji.  
  
-   <xref:System.Xml.XmlReaderSettings> obiekty mogą zawierać poufne informacje, takie jak poświadczenia użytkownika. Można użyć niezaufany składnik <xref:System.Xml.XmlReaderSettings> obiekt i jego poświadczenia użytkownika, aby utworzyć <xref:System.Xml.XmlReader> obiektów można odczytać danych. Należy zachować ostrożność podczas buforowania <xref:System.Xml.XmlReaderSettings> obiektów, lub podczas przekazywania <xref:System.Xml.XmlReaderSettings> obiektu z jednego składnika do innego.  
  
-   Nie akceptuj pomocnicze składniki, takie jak <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, i <xref:System.Xml.XmlResolver> obiektów z niezaufanego źródła.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób analizy kodu XML za pomocą asynchronicznego interfejsu API.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="XmlReader" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez konstruktory klas pochodnych zainicjować stanu, w tym typie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera liczby atrybutów w bieżącym węźle.</summary>
        <value>Liczba atrybutów dla bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma zastosowanie w przypadku `Element`, `DocumentType` i `XmlDeclaration` tylko węzłów. (Inne typy węzłów nie ma atrybutów).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera podstawowy identyfikator URI bieżącego węzła.</summary>
        <value>Podstawowy identyfikator URI bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sieciowych dokumentu XML składa się z fragmentów dane zagregowane przy użyciu różnych mechanizmów standardowe włączenia W3C, dlatego zawiera węzły, które pochodzą z różnych miejscach. Jednostki DTD są na przykład, ale nie jest ograniczone do elementów DTD. Podstawowy identyfikator URI informuje, skąd pochodzą te węzły. Jeśli nie istnieje żadne podstawowy identyfikator URI dla węzłów zwracanych (na przykład one zostały pochodzącą z analizy ciąg w pamięci), `String.Empty` jest zwracany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Xml.XmlReader" /> implementuje metody odczytu zawartości binarnej.</summary>
        <value>
          <see langword="true" /> Jeśli binarne metody odczytu zawartości są wykonywane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zawartość binarną do odczytu metod uwzględnić <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, i <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> metody. Jeśli ta właściwość zwraca `false` <xref:System.NotSupportedException> jest zwracany, jeśli żadnego pliku binarnego do odczytu nosi nazwę metody.  
  
 Wszystkie implementacji programu Microsoft .NET Framework <xref:System.Xml.XmlReader> klasy powrotu `true` dla tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Xml.XmlReader" /> implementuje <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> metody.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xml.XmlReader" /> implementuje <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> metody; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Analizowanie tekstu <xref:System.Xml.XmlReader> obiektów, które zostały utworzone z statycznych <xref:System.Xml.XmlReader.Create%2A> zawsze zwracany metody `true`. Inne implementacje Microsoft .NET Framework z <xref:System.Xml.XmlReader> klasy, w tym <xref:System.Xml.XmlTextReader> klasy, zwraca `false`.  
  
 Jeśli ta właściwość zwraca `false` <xref:System.NotSupportedException> jest zwracany, gdy <xref:System.Xml.XmlReader.ReadValueChunk%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten czytnik można przeanalizować i rozwiązać jednostek.</summary>
        <value>
          <see langword="true" /> Jeśli czytnik można przeanalizować i rozwiązać jednostek; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `false` implementacji <xref:System.Xml.XmlReader> nie obsługują informacji DTD. W takim przypadku wywoływania <xref:System.Xml.XmlReader.ResolveEntity%2A> zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zmiany <see cref="P:System.Xml.XmlReader.ReadState" /> do <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda również zwalnia wszystkie zasoby utrzymywane podczas odczytu. Jeśli <xref:System.Xml.XmlReader.Close%2A> została już wywołana, jest wykonywana żadna akcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość <xref:System.Xml.XmlReader.Create%2A> obejmują przeciążenia `settings` parametr, który akceptuje <xref:System.Xml.XmlReaderSettings> obiektu. Można użyć tego obiektu w celu:  
  
-   Określ, które funkcje mają być obsługiwane na <xref:System.Xml.XmlReader> obiektu.  
  
-   Ponowne użycie <xref:System.Xml.XmlReaderSettings> obiektu do utworzenia wielu czytników. Tych samych ustawień umożliwia utworzenie wielu czytników z tą samą funkcjonalnością. Lub zmodyfikować ustawienia na <xref:System.Xml.XmlReaderSettings> wystąpienia i utworzenie nowego czytnika z innym zestawem funkcji.  
  
-   Dodawanie funkcji do istniejącej modułu odczytującego XML. <xref:System.Xml.XmlReader.Create%2A> Metody może akceptować innego <xref:System.Xml.XmlReader> obiektu. Podstawowa <xref:System.Xml.XmlReader> obiekt może być czytnik zdefiniowane przez użytkownika <xref:System.Xml.XmlTextReader> obiektu lub innej <xref:System.Xml.XmlReader> wystąpienie, które chcesz dodać dodatkowe funkcje.  
  
-   W pełni korzystać z funkcji, takich jak sprawdzanie lepszą zgodność oraz zgodność w celu [XML 1.0 (czwarty edition)](https://www.w3.org/TR/2006/REC-xml-20060816/)zalecenia, które są dostępne tylko na <xref:System.Xml.XmlReader> obiekty utworzone przez statycznych <xref:System.Xml.XmlReader.Create%2A> metody.  
  
> [!NOTE]
>  Mimo że programu .NET Framework obejmuje implementacje konkretnych <xref:System.Xml.XmlReader> klas, takich jak <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>i <xref:System.Xml.XmlValidatingReader> klas, zalecamy utworzenie <xref:System.Xml.XmlReader> wystąpienia przy użyciu <xref:System.Xml.XmlReader.Create%2A> Metoda.  
  
## <a name="default-settings"></a>Ustawienia domyślne  
 Jeśli używasz <xref:System.Xml.XmlReader.Create%2A> przeciążenia, które nie akceptują <xref:System.Xml.XmlReaderSettings> obiektu, stosowane są następujące domyślne ustawienia czytnika:  
  
|Ustawienie|Domyślny|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Pusta <xref:System.Xml.Schema.XmlSchemaSet> obiektu|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> włączone|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Nowy <xref:System.Xml.XmlUrlResolver> obiektu.  Począwszy od programu .NET Framework 4.5.2, to ustawienie nie ma wartości domyślnej równej `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Ustawienia dla typowych scenariuszy  
 Poniżej przedstawiono <xref:System.Xml.XmlReaderSettings> właściwości należy ustawić dla niektórych typowych scenariuszy czytnika XML.  
  
|Wymaganie|zestaw|  
|-----------------|---------|  
|Dane muszą być poprawnie sformułowany dokument XML.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> Aby <xref:System.Xml.ConformanceLevel.Document>.|  
|Dane muszą być poprawnie sformułowanym jednostki XML przeanalizować.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> Aby <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Danych musi zostać zweryfikowany względem DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> Aby <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.DTD>.|  
|Danych musi zostać zweryfikowany względem schematu XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> Aby <xref:System.Xml.Schema.XmlSchemaSet> do użycia w celu weryfikacji. Należy pamiętać, że <xref:System.Xml.XmlReader> nie obsługuje sprawdzanie poprawności schematu XML danych (XDR).|  
|Danych musi zostać zweryfikowany względem wbudowanego schematu XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> Aby <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Wpisz pomocy technicznej.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> Aby <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> Aby <xref:System.Xml.Schema.XmlSchemaSet> do użycia.|  
  
 <xref:System.Xml.XmlReader> nie obsługuje sprawdzanie poprawności schematu XML danych (XDR).  
  
## <a name="asynchronous-programming"></a>Programowanie asynchroniczne  
 W trybie synchronicznym <xref:System.Xml.XmlReader.Create%2A> metoda odczytuje pierwszego fragmentu danych z bufora czytnika plików, strumienia lub tekst. Może zgłosić wyjątek, jeśli operacja We/Wy nie powiedzie się. W trybie asynchronicznym pierwszej operacji We/Wy występuje podczas operacji odczytu, więc będą zgłaszane wyjątki, które powstają podczas operacji odczytu.  
  
## <a name="security-considerations"></a>Zagadnienia dotyczące bezpieczeństwa  
 Domyślnie <xref:System.Xml.XmlReader> używa <xref:System.Xml.XmlUrlResolver> obiektu bez poświadczeń użytkownika, aby otworzyć zasobów. Oznacza to, że domyślnie modułu odczytującego XML można uzyskać dostępu do dowolnej lokalizacji, która nie wymaga poświadczeń. Użyj <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwość, aby kontrolować dostęp do zasobów:  
  
-   Ustaw <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> do <xref:System.Xml.XmlSecureResolver> celem jest ograniczenie zasobów, które mogą uzyskiwać dostęp do modułu odczytującego XML.  
  
 —lub—  
  
-   Ustaw <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> do `null` aby uniemożliwić otwieranie dowolnych zasobów zewnętrznych modułu odczytującego XML.  
  
   
  
## Examples  
 W tym przykładzie tworzy modułu odczytującego XML taśmy nieważny biały znak, pasków, komentarze i wykonuje sprawdzanie zgodności poziomie fragmentu.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 W poniższym przykładzie użyto <xref:System.Xml.XmlUrlResolver> z domyślnych poświadczeń dostępu do pliku.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 Poniższy kod opakowuje wystąpieniem czytnika w ramach innego czytnika.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 W tym przykładzie powiązany czytników, aby dodać sprawdzanie poprawności schematu DTD i XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  <see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty wyszukiwanie znacznika kolejności bajtów lub innego znaku kodowania strumienia. Podczas kodowania jest określana, kodowanie jest używany do kontynuowania odczytu strumienia, a przetwarzanie będzie kontynuowane, analizy danych wejściowych jako strumień znaków (Unicode).</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego obiektu stream przy użyciu ustawień domyślnych.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings> Obiekt z ustawieniami domyślnymi jest używany do utworzenia czytnika. Jeśli chcesz określić, które funkcje do obsługi na utworzonej czytnika Użyj przeciążenia, które przyjmuje <xref:System.Xml.XmlReaderSettings> obiekt jako jeden z jego argumentów i podaj <xref:System.Xml.XmlReaderSettings> obiektu z prawidłowymi ustawieniami.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, która wymaga uwierzytelnienia, podaj <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiekt, który odczytuje z <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> Nie ma wystarczających uprawnień do uzyskania dostępu do lokalizacji w danych XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumień znaków Unicode, więc kodowania określony w deklaracji XML nie jest używany przez czytnik XML dekodowanie strumienia danych.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu czytnika określony tekst.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings> Obiekt z ustawieniami domyślnymi jest używany do utworzenia czytnika. Jeśli chcesz określić, które funkcje do obsługi na utworzonej czytnika Użyj przeciążenia, które przyjmuje <xref:System.Xml.XmlReaderSettings> obiekt jako jeden z jego argumentów i podaj <xref:System.Xml.XmlReaderSettings> obiektu z prawidłowymi ustawieniami.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, która wymaga uwierzytelnienia, podaj <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.StringReader> klasy można odczytać ciągu XML.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">Identyfikator URI dla pliku, który zawiera dane XML. <see cref="T:System.Xml.XmlUrlResolver" /> Klasa jest używana do konwertowania ścieżka reprezentacji canonical danych.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpieniem przy użyciu określonego identyfikatora URI.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings> Obiekt z ustawieniami domyślnymi jest używany do utworzenia czytnika. Jeśli chcesz określić, które funkcje do obsługi na utworzonej czytnika Użyj przeciążenia, które przyjmuje <xref:System.Xml.XmlReaderSettings> obiekt jako jeden z jego argumentów i podaj <xref:System.Xml.XmlReaderSettings> obiektu z prawidłowymi ustawieniami.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, która wymaga uwierzytelnienia, podaj <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiektu odczytującego określonego przez identyfikator URI pliku danych XML.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputUri" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> Nie ma wystarczających uprawnień do uzyskania dostępu do lokalizacji w danych XML.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik identyfikowanej przez URI nie istnieje.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />, zamiast tego.  </para>
          </block>  Format identyfikatora URI jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  <see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty wyszukiwanie znacznika kolejności bajtów lub innego znaku kodowania strumienia. Podczas kodowania jest określana, kodowanie jest używany do kontynuowania odczytu strumienia, a przetwarzanie będzie kontynuowane, analizy danych wejściowych jako strumień znaków (Unicode).</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienie określonego obiektu stream i ustawieniami.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumień znaków Unicode, więc kodowania określony w deklaracji XML nie jest używany przez czytnik XML dekodowanie strumienia danych.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" />. Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu czytnika określony tekst i ustawień.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">Identyfikator URI pliku zawierającego dane XML. <see cref="T:System.Xml.XmlResolver" /> Obiekt na <see cref="T:System.Xml.XmlReaderSettings" /> obiektu służy do konwertowania ścieżkę na jej reprezentację danych kanonicznej. Jeśli <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> jest <see langword="null" />, nowy <see cref="T:System.Xml.XmlUrlResolver" /> obiekt jest używany.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego identyfikatora URI i ustawień.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Oznacza to, że <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do wszystkich lokalizacjach, które nie wymaga uwierzytelniania. Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiekt, który obsługuje weryfikacji definicji (DTD) typu dokumentu.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputUri" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku określonego przez identyfikator URI.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />, zamiast tego.  </para>
          </block>  Format identyfikatora URI jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">Obiekt, który ma być używany jako podstawowy modułu odczytującego XML.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia.  Poziom zgodności <see cref="T:System.Xml.XmlReaderSettings" /> obiekt musi być albo zgodny poziom zgodności odpowiedniego czytnika lub należy wybrać opcję <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego modułu odczytującego XML i ustawień.</summary>
        <returns>Obiekt, który jest opakowany wokół określonego <see cref="T:System.Xml.XmlReader" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dodawanie dodatkowych funkcji do podstawowej <xref:System.Xml.XmlReader> obiektu. Podstawowa <xref:System.Xml.XmlReader> obiekt może mieć inny <xref:System.Xml.XmlReader> obiekt utworzony przez <xref:System.Xml.XmlReader.Create%2A> metody, lub <xref:System.Xml.XmlReader> obiektu utworzonego przy użyciu jednej z konkretnych <xref:System.Xml.XmlReader> implementacji.  
  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, takich jak schemat.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, która wymaga uwierzytelnienia, podaj <xref:System.Xml.XmlResolver> niezbędne poświadczenia, za pomocą <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy sprawdzania poprawności <xref:System.Xml.XmlReader> obiekt, który jest otaczający <xref:System.Xml.XmlNodeReader> obiektu.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeśli <see cref="T:System.Xml.XmlReaderSettings" /> obiektu określa poziom zgodności, który nie jest zgodny z poziomem zgodności odpowiedniego czytnika.  - lub - odpowiadającego <see cref="T:System.Xml.XmlReader" /> w <see cref="F:System.Xml.ReadState.Error" /> lub <see cref="F:System.Xml.ReadState.Closed" /> stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  <see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty wyszukiwanie znacznika kolejności bajtów lub innego znaku kodowania strumienia. Podczas kodowania jest określana, kodowanie jest używany do kontynuowania odczytu strumienia, a przetwarzanie będzie kontynuowane, analizy danych wejściowych jako strumień znaków (Unicode).</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="baseUri">Podstawowy identyfikator URI dla typu jednostki lub odczytu dokumentu. Ta wartość może być <see langword="null" />.  ** Zabezpieczenia Uwaga ** podstawowy identyfikator URI jest używany do rozpoznawania względny identyfikator URI dokumentu XML. Nie używaj podstawowego identyfikatora URI z niezaufanego źródła.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego obiektu stream, podstawowy identyfikator URI i ustawień.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Strumień, który zawiera dane XML.  <see cref="T:System.Xml.XmlReader" /> Skanuje pierwsze bajty wyszukiwanie znacznika kolejności bajtów lub innego znaku kodowania strumienia. Podczas kodowania jest określana, kodowanie jest używany do kontynuowania odczytu strumienia, a przetwarzanie będzie kontynuowane, analizy danych wejściowych jako strumień znaków (Unicode).</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="inputContext">Informacje o kontekście wymaganych do analizy fragmentu XML. Mogą obejmować informacje o kontekście <see cref="T:System.Xml.XmlNameTable" /> do użytku, kodowania, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c> i <c>XML: Space</c> zakres, bazowy identyfikator URI i zarządzania dokumentami definicji typu.  Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego strumienia, ustawieniami i kontekstem informacji do analizy.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumień znaków Unicode, więc kodowania określony w deklaracji XML nie jest używany przez <see cref="T:System.Xml.XmlReader" /> dekodowanie strumienia danych.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="baseUri">Podstawowy identyfikator URI dla typu jednostki lub odczytu dokumentu. Ta wartość może być <see langword="null" />.  ** Zabezpieczenia Uwaga ** podstawowy identyfikator URI jest używany do rozpoznawania względny identyfikator URI dokumentu XML. Nie używaj podstawowego identyfikatora URI z niezaufanego źródła.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu czytnika określony tekst, ustawienia i podstawowego identyfikatora URI.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Czytnik tekstu, z której mają być odczytywane dane XML. Czytnik tekstu zwraca strumień znaków Unicode, więc kodowania określony w deklaracji XML nie jest używany przez czytnik XML dekodowanie strumienia danych.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="inputContext">Informacje o kontekście wymaganych do analizy fragmentu XML. Mogą obejmować informacje o kontekście <see cref="T:System.Xml.XmlNameTable" /> do użytku, kodowania, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c> i <c>XML: Space</c> zakres, bazowy identyfikator URI i zarządzania dokumentami definicji typu.  Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia, korzystając z informacji czytnika, ustawieniami i kontekstem określony tekst do analizy.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można użyć jednej z następujących metod do kontrolowania zasobów, do których <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do:  
>   
>  -   Ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
>   
>  —lub—  
>   
>  -   Nie zezwalaj na <xref:System.Xml.XmlReader> otworzyć dowolnych zasobów zewnętrznych, ustawiając <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości `null`.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlReader> obiektu odczytującego XML fragment.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> i <see cref="P:System.Xml.XmlParserContext.NameTable" /> obie właściwości zawierają wartości. (Tylko jedna z nich <see langword="NameTable" /> właściwości można ustawić i używane).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">Identyfikator URI pliku zawierającego dane XML. <see cref="T:System.Xml.XmlResolver" /> Obiekt na <see cref="T:System.Xml.XmlReaderSettings" /> obiektu służy do konwertowania ścieżkę na jej reprezentację danych kanonicznej. Jeśli <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> jest <see langword="null" />, nowy <see cref="T:System.Xml.XmlUrlResolver" /> obiekt jest używany.</param>
        <param name="settings">Ustawienia dla nowego <see cref="T:System.Xml.XmlReader" /> wystąpienia. Ta wartość może być <see langword="null" />.</param>
        <param name="inputContext">Informacje o kontekście wymaganych do analizy fragmentu XML. Mogą obejmować informacje o kontekście <see cref="T:System.Xml.XmlNameTable" /> do użytku, kodowania, zakresie przestrzeni nazw, bieżącego <c>XML: lang</c> i <c>XML: Space</c> zakres, bazowy identyfikator URI i zarządzania dokumentami definicji typu.  Ta wartość może być <see langword="null" />.</param>
        <summary>Tworzy nową <see cref="T:System.Xml.XmlReader" /> wystąpienia przy użyciu określonego identyfikatora URI, ustawieniami i kontekstem informacje do analizy.</summary>
        <returns>Obiekt, który służy do odczytywania danych XML w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Xml.XmlUrlResolver> bez poświadczeń umożliwia dostęp do dowolnych zasobów zewnętrznych, np. Definicja typu dokumentu (DTD), jednostek, schematów i tak dalej.  
  
> [!IMPORTANT]
>  Począwszy od programu .NET Framework 4.5.2, brak wartości domyślnej <xref:System.Xml.XmlUrlResolver> jest dostępne. Jeśli rozwiązania jest przeznaczony dla platformy .NET Framework 4.5.2 lub nowszy, określ <xref:System.Xml.XmlResolver> przy użyciu <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości.  
  
 Oznacza to, że <xref:System.Xml.XmlReader> mogą uzyskiwać dostęp do wszystkich lokalizacjach, które nie wymaga uwierzytelniania. Jeśli zewnętrzny zasób znajduje się w zasobie sieciowym, który wymaga uwierzytelniania, należy użyć <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> właściwości w celu określenia <xref:System.Xml.XmlResolver> niezbędne poświadczenia.  
  
> [!IMPORTANT]
>  Można ograniczyć zasoby, do którego <xref:System.Xml.XmlReader> dostęp przez ustawienie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> właściwości <xref:System.Xml.XmlSecureResolver> obiektu.  
  
 Utworzony <xref:System.Xml.XmlReader> obiektu rozszerza odwołań do jednostek i wykonuje XML normalizacją znaki nowego wiersza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="inputUri" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> Nie ma wystarczających uprawnień do uzyskania dostępu do lokalizacji w danych XML.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> i <see cref="P:System.Xml.XmlParserContext.NameTable" /> obie właściwości zawierają wartości. (Tylko jedna z nich <see langword="NameTable" /> właściwości można ustawić i używane).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku określonego przez identyfikator URI.</exception>
        <exception cref="T:System.UriFormatException">Format identyfikatora URI jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera głębokość bieżącego węzła w dokumencie XML.</summary>
        <value>Głębokość bieżącego węzła w dokumencie XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.Depth%2A> (w `XmlTextReader` klasy) na przykład za pomocą tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Xml.XmlReader" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Xml.XmlReader" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Xml.XmlReader" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy czytnik znajduje się pod koniec strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli czytnik znajduje się na końcu strumienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu. Jest to indeks zaczynający się od zera. (Pierwszy atrybut ma indeks 0).</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonym indeksem.</summary>
        <returns>Wartość określonego atrybutu. Ta metoda nie powoduje przeniesienia czytnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu trzecich.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> jest poza zakresem. Musi być nieujemną i mniejszą niż rozmiar kolekcji atrybutów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, lub wartość jest <see langword="String.Empty" />, <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie powoduje przeniesienia czytnika.  
  
 Jeśli czytnik jest ustawiony na `DocumentType` węzła, ta metoda służy do pobrania publicznego i systemu literały, na przykład `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, lub wartość jest <see langword="String.Empty" />, <see langword="null" /> jest zwracany. Ta metoda nie powoduje przeniesienia czytnika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujący kod XML zawiera atrybut w określonej przestrzeni nazw:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Można wyszukać `dt:type` atrybutu przy użyciu jednego argumentu (prefiks i nazwa lokalna) lub dwóch argumentów (lokalna nazwa i identyfikator URI przestrzeni nazw):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Do wyszukiwania `xmlns:dt` atrybutu, użyj jednej z następujących argumentów:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Można także uzyskać te informacje przy użyciu <xref:System.Xml.XmlReader.Prefix%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie pobiera wartość bieżącego węzła.</summary>
        <returns>Wartość bieżącego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący węzeł atrybutów.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący węzeł ma atrybuty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący węzeł może mieć <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value>
          <see langword="true" /> Jeśli węzeł, na którym aktualnie znajduje się czytnik może mieć <see langword="Value" />; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, węzeł ma wartość <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono typy węzłów, które mają wartość do zwrócenia.  
  
|Typ węzła|Wartość|  
|---------------|-----------|  
|`Attribute`|Wartość atrybutu.|  
|`CDATA`|Zawartość sekcji CDATA.|  
|`Comment`|Zawartość komentarza.|  
|`DocumentType`|Podzestawie wewnętrznym.|  
|`ProcessingInstruction`|Całej zawartości, z wyłączeniem obiektu docelowego.|  
|`SignificantWhitespace`|Biały znak między znaczników w mieszanych modelu zawartości.|  
|`Text`|Zawartości węzła tekstowego.|  
|`Whitespace`|Biały znak między znaczników.|  
|`XmlDeclaration`|Zawartość deklaracji.|  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.HasValue%2A> (w `XmlTextReader` klasy) dla przykładu, za pomocą tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący węzeł jest atrybut, który został wygenerowany na podstawie wartości domyślnej zdefiniowanej w definicji DTD lub schemat.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący węzeł jest atrybutem, którego wartość został wygenerowany na podstawie wartości domyślnej zdefiniowanej w definicji DTD lub schemat; <see langword="false" /> Jeśli jawnie ustawione wartości atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` zawsze zwraca `false` implementacji `XmlReader` które nie obsługują schematu lub informacji DTD. Ta właściwość jest stosowana tylko do węzła atrybutu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w elemencie głównym.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 W przykładzie użyto następujących plików jako dane wejściowe.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący węzeł jest elementem pustym (na przykład <c> &lt;MyElement /&gt;</c>).</summary>
        <value>
          <see langword="true" /> Jeśli bieżący węzeł jest elementem (<see cref="P:System.Xml.XmlReader.NodeType" /> jest równe <see langword="XmlNodeType.Element" />) który kończy się wyrazem <c> / &gt; </c>; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie różnica między następującymi:  
  
 `<item num="123"/>` (`IsEmptyElement` jest `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` jest `false`, mimo że zawartość elementu jest pusta).  
  
 Odpowiadającego `EndElement` węzła nie jest generowane dla elementów pustych.  
  
 Jeśli domyślne zawartości został dodany do elementu z powodu sprawdzanie poprawności schematu, `IsEmptyElement` nadal zwraca `true`. Go nie ma żadnego wpływu na Określa, czy element ma wartość domyślną. Innymi słowy `IsEmptyElement` po prostu raporty, czy tag końcowy element ma element w dokumencie źródłowym.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element zawartości tekstowej.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 W przykładzie użyto pliku `elems.xml`, jak wejściowego.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Nazwa do zweryfikowania.</param>
        <summary>Zwraca wartość wskazującą, czy argument ciągu jest prawidłową nazwą XML.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwa jest prawidłowa; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [W3C XML 1.0 zalecenie](http://go.microsoft.com/fwlink/?LinkId=49863) do ustalenia, czy nazwa jest nieprawidłowa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Nazwa tokenu do zweryfikowania.</param>
        <summary>Zwraca wartość wskazującą, czy argument ciągu jest prawidłowy token nazwy XML.</summary>
        <returns>
          <see langword="true" /> Jeśli jest to prawidłowa nazwa token; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [W3C XML 1.0 zalecenie](http://go.microsoft.com/fwlink/?LinkId=49863) do ustalenia, czy nazwa tokenu jest nieprawidłowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> Wartość jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Testy, jeśli bieżący węzeł zawartości tagu początkowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołania <see cref="M:System.Xml.XmlReader.MoveToContent" /> i testy, jeśli bieżący węzeł zawartości jest tag początkowy lub tagu pustego elementu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="M:System.Xml.XmlReader.MoveToContent" /> tag początkowy lub tagu pustego elementu; <see langword="false" /> Jeśli węzeł inny niż typ <see langword="XmlNodeType.Element" /> został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pomija biały znak, komentarze i przetwarzanie instrukcji, dopóki czytnik znajduje się w węźle zawartości. Metoda następnie sprawdza, czy bieżący węzeł jest elementem.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element zawartości tekstowej.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 W przykładzie użyto pliku `elems.xml`, jak wejściowego.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg dopasowywane <see langword="Name" /> właściwości znaleziono elementu.</param>
        <summary>Wywołania <see cref="M:System.Xml.XmlReader.MoveToContent" /> i sprawdza, czy bieżący węzeł zawartości jest tag początkowy lub znacznik w pustym elemencie i czy <see cref="P:System.Xml.XmlReader.Name" /> właściwość elementu znaleziono odpowiada podany argument.</summary>
        <returns>
          <see langword="true" /> Jeśli wynikowy węzeł jest elementem i <see langword="Name" /> właściwość odpowiada określonego ciągu. <see langword="false" /> Jeśli węzeł inny niż typ <see langword="XmlNodeType.Element" /> został znaleziony lub, jeśli element <see langword="Name" /> właściwość nie pasuje do określonego ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pomija biały znak, komentarze i przetwarzanie instrukcji, dopóki czytnik znajduje się w węźle zawartości. Metoda następnie sprawdza, czy bieżący węzeł jest elementem.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element cenę.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Ciąg do dopasowywania <see langword="LocalName" /> właściwości znaleziono elementu.</param>
        <param name="ns">Ciąg do dopasowywania <see langword="NamespaceURI" /> właściwości znaleziono elementu.</param>
        <summary>Wywołania <see cref="M:System.Xml.XmlReader.MoveToContent" /> i sprawdza, czy bieżący węzeł zawartości jest tag początkowy lub znacznik w pustym elemencie i czy <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> właściwości elementu znaleziono odpowiada danym ciągów.</summary>
        <returns>
          <see langword="true" /> Jeśli wynikowy węzeł jest elementem. <see langword="false" /> Jeśli węzeł inny niż typ <see langword="XmlNodeType.Element" /> został znaleziony lub, jeśli <see langword="LocalName" /> i <see langword="NamespaceURI" /> właściwości elementu nie są zgodne z określonych ciągów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pomija biały znak, komentarze i przetwarzanie instrukcji, dopóki czytnik znajduje się w węźle zawartości. Metoda następnie sprawdza, czy bieżący węzeł jest elementem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonym indeksem.</summary>
        <value>Wartość określonego atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powoduje przeniesienia czytnika.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <value>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powoduje przeniesienia czytnika.  
  
 Jeśli czytnik jest ustawiony na `DocumentType` węzła, ta metoda służy do pobrania publicznego i systemu literały, na przykład `reader["PUBLIC"]`  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość atrybutu ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa atrybutu.</param>
        <param name="namespaceURI">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość atrybutu z określonego <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <value>Wartość określonego atrybutu. Jeśli ten atrybut nie zostanie znaleziony, <see langword="null" /> jest zwracany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie powoduje przeniesienia czytnika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę lokalnego bieżącego węzła.</summary>
        <value>Nazwa bieżącego węzła z prefiksem usunięte. Na przykład <see langword="LocalName" /> jest <see langword="book" /> dla elementu <c> &lt;bk:book&gt;</c>.  Dla typów węzłów, które nie mają nazwę (takich jak <see langword="Text" />, <see langword="Comment" />i tak dalej), ta właściwość zwraca <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono lokalna nazwa każdego węzła i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 W przykładzie użyto pliku book2.xml, jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefiks, którego identyfikator URI przestrzeni nazw ma zostać rozwiązany. Aby dopasować domyślnej przestrzeni nazw, należy przekazać pusty ciąg.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej usuwa prefiks przestrzeni nazw w zakresie bieżącego elementu.</summary>
        <returns>Identyfikator URI przestrzeni nazw, do którego mapuje prefiks lub <see langword="null" /> przypadku nieznalezienia nie zgodny prefiks.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższym ciągu XML, jeśli czytnik jest ustawiony na `href` atrybutu prefiks `a` został rozwiązany przez wywołanie metody `reader.LookupNamespace("a")`. Zwrócony ciąg jest `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>W przypadku przesłonięcia w klasie pochodnej Przenosi określony atrybut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Indeks atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej przenosi atrybut o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr ma wartość ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, są przenoszone do atrybutu z określonego <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns>
          <see langword="true" /> Jeśli ten atrybut zostanie odnaleziony; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, pozycja czytnika nie ulega zmianie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, i <xref:System.Xml.XmlReader.Prefix%2A> właściwości odzwierciedlają właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa atrybutu.</param>
        <param name="ns">Identyfikator URI przestrzeni nazw atrybutu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, są przenoszone do atrybutu z określonego <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>
          <see langword="true" /> Jeśli ten atrybut zostanie odnaleziony; w przeciwnym razie <see langword="false" />. Jeśli <see langword="false" />, pozycja czytnika nie ulega zmianie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, i <xref:System.Xml.XmlReader.Prefix%2A> właściwości odzwierciedlają właściwości tego atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Wartości obu parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy bieżący węzeł zawartości (system inny niż biały znak tekstu, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" />, lub <see langword="EndEntity" />) węzła. Jeśli węzeł nie jest węzłem zawartości, czytnik wyprzedzeniem przejdzie do następnego węzła zawartości lub koniec pliku. Nakłada się na węzłach następującego typu: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" />, lub <see langword="SignificantWhitespace" />.</summary>
        <returns>
          <see cref="P:System.Xml.XmlReader.NodeType" /> Bieżącego węzła odnaleziona przez metodę lub <see langword="XmlNodeType.None" /> Jeśli czytnik osiągnął koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący węzeł jest węzłem atrybutu, ta metoda jest przenoszony czytnik do elementu, który jest właścicielem atrybutu.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Jest to przydatne, gdy użytkownik chce pisania kodu, który można pominąć losowe znaczników XML bez podziału. Załóżmy na przykład następujący kod:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Ten kod może obsłużyć następujące dane wejściowe bez podziału:  
  
```xml  
<price>123.4</price>  
```  
  
 and  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 and  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 and  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;MoveToContentAsync&gt;c__async5))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie sprawdza, czy bieżący węzeł jest węzłem zawartości. Jeśli węzeł nie jest węzłem zawartości, czytnik wyprzedzeniem przejdzie do następnego węzła zawartości lub koniec pliku.</summary>
        <returns>
          <see cref="P:System.Xml.XmlReader.NodeType" /> Bieżącego węzła odnaleziona przez metodę lub <see langword="XmlNodeType.None" /> Jeśli czytnik osiągnął koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.MoveToContent%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, są przenoszone na element, który zawiera bieżący węzeł atrybutów.</summary>
        <returns>
          <see langword="true" /> Jeśli czytnik jest ustawiony na atrybut (czytnik jest przenoszony do elementu, który jest właścicielem atrybut); <see langword="false" /> Jeśli czytnik nie jest ustawiony na atrybut (pozycja czytnik nie ulega zmianie).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby powrócić do elementu po nawigować przez jego atrybuty. Ta metoda przenosi czytnik do jednego z następujących typów węzła: `Element`, `DocumentType`, lub `XmlDeclaration`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej przenosi do pierwszego atrybutu.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje atrybut (czytnik przenosi do pierwszego atrybutu); w przeciwnym razie <see langword="false" /> (pozycja czytnik nie ulega zmianie).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera wartość pierwszego atrybutu.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej przenosi do następnego atrybutu.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje atrybut dalej; <see langword="false" /> nie więcej atrybutach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący węzeł jest węzłem elementu, ta metoda jest odpowiednikiem <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Jeśli `MoveToNextAttribute` zwraca `true`, czytnik przechodzi do następnego atrybutu; w przeciwnym razie pozycja czytnik nie ulega zmianie.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie atrybuty w bieżącym węźle.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera kwalifikowaną nazwę bieżącego węzła.</summary>
        <value>Kwalifikowana nazwa bieżącego węzła. Na przykład <see langword="Name" /> jest <see langword="bk:book" /> dla elementu <c> &lt;bk:book&gt;</c>.  Nazwa zwrócona jest zależna od <see cref="P:System.Xml.XmlReader.NodeType" /> węzła. Następujące typy węzłów zwracać wartości listy. Wszystkie inne typy węzła zwraca pusty ciąg.  
  
 <list type="table"><listheader><term> Typ węzła </term><description> nazwa </description></listheader><item><term><see langword="Attribute" /></term><description> nazwę atrybutu.  </description></item><item><term><see langword="DocumentType" /></term><description> Nazwa typu dokumentu.  </description></item><item><term><see langword="Element" /></term><description> Nazwa tagu.  </description></item><item><term><see langword="EntityReference" /></term><description> Nazwa odwołania do jednostki.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Elementem docelowym instrukcji przetwarzania.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> Literał <see langword="xml" />.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera identyfikator URI (zgodnie z definicją w specyfikacji Namespace W3C) węzła w przestrzeni nazw na znajduje się czytnika.</summary>
        <value>Przestrzeń nazw identyfikatora URI bieżącego węzła; w przeciwnym razie ciągiem pustym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość ma zastosowanie w przypadku `Element` i `Attribute` tylko węzłów.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono lokalna nazwa każdego węzła i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 W przykładzie użyto pliku book2.xml, jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera <see cref="T:System.Xml.XmlNameTable" /> skojarzone z tą implementacją.</summary>
        <value>
          <see langword="XmlNameTable" /> Dzięki któremu można pobrać wersję atomized ciągu w węźle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie nazwy węzła i atrybut zwrócony z <xref:System.Xml.XmlReader> są atomized przy użyciu `NameTable`. Gdy takiej samej nazwie są zwracane wielokrotnie (na przykład `Customer`), następnie takie same `String` zostanie zwrócony obiekt dla tej nazwy. Dzięki temu można napisać kod wydajne, który obiekt porównania na te ciągi, zamiast porównania ciągu kosztowne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera typ bieżącego węzła.</summary>
        <value>Jedna z wartości wyliczenia, które określają typ bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera prefiks przestrzeni nazw skojarzone z bieżącego węzła.</summary>
        <value>Prefiks przestrzeni nazw skojarzone z bieżącego węzła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono lokalna nazwa każdego węzła i, jeśli istnieją, prefiksu i identyfikator URI przestrzeni nazw.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 W przykładzie użyto pliku book2.xml, jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera znak cudzysłowu ująć węzła atrybutu.</summary>
        <value>Znak cudzysłowu ("lub") używany do ująć węzła atrybutu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest stosowana tylko do węzła atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytuje następny węzeł ze strumienia.</summary>
        <returns>
          <see langword="true" /> Jeśli węzeł next został odczytany pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Xml.XmlReader> jest pierwszy utworzone i zainicjowane, nie ma żadnych informacji, które są dostępne. Należy wywołać <xref:System.Xml.XmlReader.Read%2A> odczytać pierwszy węzeł. <xref:System.Xml.XmlReader.Read%2A> Metody ustawia stan czytnika XML do zainicjowania <xref:System.Xml.ReadState> i przechodzi przez plik XML po kolei, dopóki nie zostanie osiągnięty koniec pliku, w którym metoda zwraca wartość `false`.  
  
 Ta metoda wymaga co najmniej cztery bajtów ze strumienia danych, aby rozpocząć analizy. Jeśli mniej niż cztery bajty są zwracane, a nie ma więcej danych w strumieniu, metoda zwraca `false`. Jeśli istnieje więcej danych w strumieniu, metoda będzie blokował analizowania aż do otrzymania czwarty bajt.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Dane wyjściowe:**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania pliku XML.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje następny węzeł ze strumienia.</summary>
        <returns>
          <see langword="true" /> Jeśli węzeł next został odczytany pomyślnie; <see langword="false" /> Jeśli nie ma żadnych więcej węzłów do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.Read%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, analizuje wartość atrybutu do co najmniej jeden <see langword="Text" />, <see langword="EntityReference" />, lub <see langword="EndEntity" /> węzłów.</summary>
        <returns>
          <see langword="true" /> Jeśli ma węzłów do zwrócenia.  
  
 <see langword="false" /> Czytnik nie jest ustawiony na węzła atrybutu po nawiązaniu połączenia początkowego lub wartości atrybutów zostały przeczytane.  Pusta atrybutów, takich jak <c>różne = ""</c>, zwraca <see langword="true" /> z jednego węzła przy użyciu wartości <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda po wywołaniu <xref:System.Xml.XmlReader.MoveToAttribute%2A> do przeczytania węzłów odwołania tekst lub jednostki, które składają się wartość atrybutu. <xref:System.Xml.XmlReader.Depth%2A> Węzłów wartość atrybutu jest jeden plus głębokość węzła atrybutu; powoduje zwiększenie i zmniejsza przez jeden po kroku do i z odwołań do jednostek ogólnych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.  ** Uwaga ** wraz z wydaniem programu .NET Framework 3.5, wartość <c>returnType</c> parametru może być teraz <see cref="T:System.DateTimeOffset" /> typu.</param>
        <param name="namespaceResolver">
          <see cref="T:System.Xml.IXmlNamespaceResolver" /> Powiązany konwersja typu obiektu, który jest używany do rozpoznawania wszystkie prefiksy przestrzeni nazw. Na przykład może być używany podczas konwertowania <see cref="T:System.Xml.XmlQualifiedName" /> do obiektu <c>xs:string</c>.  Ta wartość może być <see langword="null" />.</param>
        <summary>Odczytuje zawartość jako obiekt podanego typu.</summary>
        <returns>Wartość zawartości lub atrybutów tekstu połączonych przekonwertowana na żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje zawartości tekstowej w bieżącym położeniu czytnika i konwertuje ją na żądany typ zwracany. Tekst, biały znak, znaczący biały znak i sekcjach CDATA są połączone. Komentarze i instrukcji przetwarzania są pomijane i odwołań do jednostek zostały automatycznie rozwiązane.  
  
 Ta metoda służy do odczytu, przekonwertować w razie potrzeby i zwraca wartość atomic elementy z bieżącego węzła zawartości. Jeśli typ danych wejściowych jest prawidłowe mapowania dla typu bieżącego węzła następnie wystąpienia typu docelowego zawierającą wartość bieżącego węzła zostanie zwrócony. W sekcji uwag w <xref:System.Xml.XmlReader> referencepage listę mapowań domyślnych.  
  
 Na przykład, jeśli masz następujące tekstu XML:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Jeśli dane są wpisywane i tablicy ciągów został dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> wywołania metody, a następnie wartości całkowite są konwertowane z ciągów zgodnie z listą prawidłowe mapowania typu CLR.  
  
 Jeśli dane są wyrażeniami bez typu, a tablicy ciągów został dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> wywołanie metody, a następnie zawartość jest analizowana w oddzielnych ciągów. Tablica zawierająca dwa ciągi, które zostało zwrócone z wartości "123" i "456". Spacje nie są zachowywane od zawartości.  
  
 Ogólnie rzecz biorąc podczas odczytywania danych bez typu zawartości jest analizowana zgodnie z podanego typu. Na przykład, jeśli tablica całkowitą został dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> wywołanie metody, a następnie zostanie przeanalizowany ciąg na tablicę liczb całkowitych {123,456}.  
  
 W poniższym przykładzie tekstu XML jest nie rozdzielone spacjami  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Jeśli zawartość jest bez typu, a tablicy ciągów został dostarczony do <xref:System.Xml.XmlReader.ReadContentAs%2A> następnie wywołanie metody tablicę zawierającą co połączony ciąg jest zwracana wartość "123456789".  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadContentAs%2A> metody, aby zwrócić zawartość elementu kolory na tablicę obiektów string.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 W przykładzie użyto `dataFile_2.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Zawartość nie jest w poprawnym formacie dla typu docelowego.</exception>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.OverflowException">Odczyt <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsAsync&gt;c__async1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.</param>
        <param name="namespaceResolver">
          <see cref="T:System.Xml.IXmlNamespaceResolver" /> Powiązany konwersja typu obiektu, który jest używany do rozpoznawania wszystkie prefiksy przestrzeni nazw.</param>
        <summary>Asynchronicznie odczytuje zawartość jako obiekt podanego typu.</summary>
        <returns>Wartość zawartości lub atrybutów tekstu połączonych przekonwertowana na żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadContentAs%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca wartość Base64 zdekodować binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda prześle strumieniowo zawartość, dekoduje `Base64` zawartości i zwraca dekodowane bajty binarne (na przykład wbudowanego `Base64` zakodowanego obrazu GIF) w buforze. Tę metodę można wywołać kolejno odczytać dużych strumieni osadzonych tekstu. Aby uzyskać więcej informacji, zobacz dokument RFC 1521, "części MIME (Multipurpose Internet Mail Extensions) co: mechanizmy określania i opisujące formatu treści wiadomości Internet". Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Nie mają żadnej właściwości czytnika między wywołania do <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> metody do momentu metoda zwraca wartość `0`.  
  
 Ta metoda ma następującą charakterystykę:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Zwraca wartość `0` przypadku osiągnięcia końca strumienia bajtów zostało zasilany. Czytnik znajduje się na pierwszym węźle-content.  
  
-   Jeśli możesz poprosić o mniej, lub liczbą, bajtów niż pozostaną w strumieniu czytnik pozostaje w bieżącym położeniu.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> nie jest obsługiwane na następujących typach węzła XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Asynchronicznie odczytuje zawartość i zwraca wartość Base64 zdekodować binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje zawartość i zwraca <see langword="BinHex" /> zdekodować binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda prześle strumieniowo zawartość, dekoduje `BinHex` zawartości i zwraca dekodowane bajty binarne (na przykład wbudowanego `BinHex` zakodowanego obrazu GIF) w buforze. Tę metodę można wywołać kolejno odczytać dużych strumieni osadzonych tekstu.  
  
> [!NOTE]
>  Nie mają żadnej właściwości czytnika między wywołania do <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> metody do momentu metoda zwraca wartość `0`.  
  
 Ta metoda ma następującą charakterystykę:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Zwraca wartość `0` przypadku osiągnięcia końca strumienia bajtów zostało zasilany. Czytnik znajduje się na pierwszym węźle-content.  
  
-   Jeśli możesz poprosić o mniej lub liczbą bajtów niż pozostaną w strumieniu czytnik pozostaje w bieżącym położeniu.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> nie jest obsługiwane na następujących typach węzła XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Asynchronicznie odczytuje zawartość i zwraca <see langword="BinHex" /> zdekodować binarne bajtów.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako <see langword="Boolean" />.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.Boolean" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:boolean`, czytnik zwraca rozpakowany <xref:System.Boolean> obiektu. Jeśli zawartość nie jest typu `xsd:boolean`, czytnik próbuje przekonwertować go na <xref:System.Boolean> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> metody można odczytać atrybutu jako B`oolean` wartość.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 W przykładzie użyto `dataFile_2.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:dateTime`, czytnik zwraca rozpakowany <xref:System.DateTime> obiektu. Jeśli zawartość nie jest typu `xsd:dateTime`, czytnik próbuje przekonwertować go na <xref:System.DateTime> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
> [!NOTE]
>  Nie należy polegać na <xref:System.DateTime.Year%2A?displayProperty=nameWithType> wartość, gdy zawartość jest typu `xsd:gMonthDay`. <xref:System.Xml.XmlReader> zawsze ustawia <xref:System.DateTime.Year%2A?displayProperty=nameWithType> do 1904 w tym przypadku wartości.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.DateTimeOffset" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.Decimal" /> obiektu.</summary>
        <returns>Zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.Decimal" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:decimal`, czytnik zwraca rozpakowany <xref:System.Decimal> obiektu. Jeśli zawartość nie jest typu `xsd:decimal`, czytnik próbuje przekonwertować go na <xref:System.Decimal> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu w postaci liczby zmiennoprzecinkowej podwójnej precyzji.</summary>
        <returns>Zawartość tekstowa jako liczba zmiennoprzecinkowa podwójnej precyzji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:double`, czytnik zwraca liczbie zmiennoprzecinkowej podwójnej precyzji. Jeśli zawartość nie jest typu `xsd:double`, próbuje przekonwertować go do liczby zmiennoprzecinkowej podwójnej precyzji zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako pojedynczej precyzji liczba zmiennoprzecinkowa.</summary>
        <returns>Zawartość tekstu w bieżącym położeniu jako pojedynczej precyzji liczba zmiennoprzecinkowa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:float`, czytnik zwraca rozpakowany pojedynczej precyzji liczba zmiennoprzecinkowa. Jeśli zawartość nie jest typu `xsd:float`, próbuje przekonwertować go do pojedynczej precyzji liczba zmiennoprzecinkowa zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako całkowita 32-bitowych.</summary>
        <returns>Zawartość tekstowa jako całkowita 32-bitowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:integer`, czytnik zwraca rozpakowany 32-bitowej podpisanej liczby całkowitej. Jeśli zawartość nie jest typu `xsd:integer`, próbuje wykonać jego konwersję na całkowita 32-bitowych zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>Zawartość tekstowa jako 64-bitowej podpisanej liczby całkowitej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu `xsd:long`, czytnik zwraca rozpakowany 64-bitowej podpisanej liczby całkowitej. Jeśli zawartość nie jest typu `xsd:long`, próbuje wykonać jego konwersję na 64-bitowych całkowita zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 W poniższej tabeli opisano to metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącej pozycji|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.Object" />.</summary>
        <returns>Zawartość tekstowa jako obiekt najbardziej odpowiednia środowiska uruchomieniowego (języka wspólnego CLR) języka wspólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Jeśli zawartość jest typu, czytnik zwraca opakowanego CLR najbardziej odpowiedniego typu, określony przez <xref:System.Xml.XmlReader.ValueType%2A> właściwości. Jeśli zawartość jest typu listy, czytnik zwraca tablicę obiektów opakowanego odpowiedniego typu.  
  
> [!NOTE]
>  Jeśli wystąpi błąd sprawdzania poprawności podczas analizowania zawartości i czytnik <xref:System.Xml.XmlReader> obiekt utworzony przez <xref:System.Xml.XmlReader.Create%2A> , czytnik zwraca zawartość jako ciąg. Innymi słowy podczas sprawdzania poprawności błąd lub ostrzeżenie występuje, zawartość jest uważany za bez typu.  
  
 Jeśli zawartość nie jest typu, czytnik zwraca zawartość jako ciąg.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącej pozycji|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Wartość elementu, jeśli czytnik jest schemat sprawdzania poprawności czytnika (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> ma ustawioną wartość <xref:System.Xml.ValidationType.Schema>); w przeciwnym razie ciągiem pustym.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsObjectAsync&gt;c__async0))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.Object" />.</summary>
        <returns>Zawartość tekstowa jako obiekt najbardziej odpowiednia środowiska uruchomieniowego (języka wspólnego CLR) języka wspólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy tekstu, biały znak znaczący biały znak i sekcjach CDATA i pomija komentarzy ani instrukcji przetwarzania. Odwołania do jednostek nie są automatycznie rozwiązane.  
  
 Ta metoda może być używana konwersji typu wartości na ciąg lub można odczytać zawartości tekstowej podczas pomijanie komentarze i instrukcji przetwarzania.  
  
 W poniższej tabeli opisano, jak ta metoda traktuje każdy typ węzła.  
  
|XmlNodeType|Wartość zwracana|Zachowanie czytnika|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Połączonych zawartości tekstu, CDATA, biały znak i węzły znaczący biały znak przekonwertowany do żądanego typu.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`Attribute`|Taki sam jak wywołanie `XmlConvert.ToXxx` na wartość atrybutu.|Czytnik pozostaje w bieżącym położeniu.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoruje instrukcji przetwarzania (PI) lub komentarz i odczytuje zawartość tekstu połączonych następujący PI komentarza.|Przechodzi do następnego uruchomienia elementu lub na końcu tagu elementu. Automatycznie zostaną rozwinięte odwołania do jednostek.|  
|`EndElement`|Ciąg pusty.|Czytnik pozostaje w bieżącym położeniu.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> Jest generowany.|Niezdefiniowana, chociaż zazwyczaj czytnik pozostaje w bieżącym położeniu.|  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Próba rzutowanie jest nieprawidłowe.</exception>
        <exception cref="T:System.FormatException">Format ciągu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje zawartości tekstowej w bieżącym położeniu jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Zawartość jako tekst <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadContentAsString%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako obiekt podanego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.  ** Uwaga ** wraz z wydaniem programu .NET Framework 3.5, wartość <c>returnType</c> parametru może być teraz <see cref="T:System.DateTimeOffset" /> typu.</param>
        <param name="namespaceResolver">
          <see cref="T:System.Xml.IXmlNamespaceResolver" /> Powiązany konwersja typu obiektu, który jest używany do rozpoznawania wszystkie prefiksy przestrzeni nazw.</param>
        <summary>Odczytuje zawartość elementu jako żądanego typu.</summary>
        <returns>Zawartość elementu przekonwertować żądanego typu obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadElementContentAs%2A> metody można odczytać zawartości `date` węzła.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.OverflowException">Odczyt <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.  ** Uwaga ** wraz z wydaniem programu .NET Framework 3.5, wartość <c>returnType</c> parametru może być teraz <see cref="T:System.DateTimeOffset" /> typu.</param>
        <param name="namespaceResolver">
          <see cref="T:System.Xml.IXmlNamespaceResolver" /> Powiązany konwersja typu obiektu, który jest używany do rozpoznawania wszystkie prefiksy przestrzeni nazw.</param>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, a następnie odczytuje zawartość elementu jako żądanego typu.</summary>
        <returns>Zawartość elementu przekonwertować żądanego typu obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
        <exception cref="T:System.OverflowException">Odczyt <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsAsync&gt;c__async4))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Typ wartości do zwrócenia.</param>
        <param name="namespaceResolver">
          <see cref="T:System.Xml.IXmlNamespaceResolver" /> Powiązany konwersja typu obiektu, który jest używany do rozpoznawania wszystkie prefiksy przestrzeni nazw.</param>
        <summary>Asynchronicznie odczytuje zawartość elementu jako żądanego typu.</summary>
        <returns>Zawartość elementu przekonwertować żądanego typu obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje element i dekoduje <see langword="Base64" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje zawartość elementu, za pomocą dekoduje `Base64` kodowania i zwraca dekodowane bajty binarne (na przykład wbudowanego `Base64`-zakodowanego obrazu GIF) w buforze. Aby uzyskać więcej informacji, zobacz dokument RFC 1521, "części MIME (Multipurpose Internet Mail Extensions) co: mechanizmy określania i opisujące formatu treści wiadomości Internet". Specyfikacje RFC można uzyskać [żądań dla witryny sieci Web komentarze](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> można odczytywać tylko elementy zawartości prostej. Element może zawierać tekstu, biały znak, znaczący biały znak, sekcjach CDATA, komentarze i instrukcji przetwarzania. Może również zawierać odwołań do jednostek, które są automatycznie rozwinięte. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobny do <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> metody, ale można wywołać tylko dla typów węzeł elementu.  
  
 Jeśli `count` wartość jest większa niż liczba bajtów w dokumencie, lub jeśli jest taka sama liczba bajtów w dokumencie <xref:System.Xml.XmlReader> odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę bajtów do odczytu. Następne <xref:System.Xml.XmlReader> wywołanie metody zwraca zero i przenosi czytnik do następującego węzła `EndElement`.  
  
 Jeśli należy wywołać <xref:System.Xml.XmlReader.Read%2A> przed całą zawartość elementu jest używany, czytnik może zachowywać się tak, jakby został wykorzystany pierwszy zawartości, a następnie <xref:System.Xml.XmlReader.Read%2A> wywołano metodę. Oznacza to, czy czytnik odczyta cały tekst do momentu napotkano end element. Następnie odczytać węzła tagu końcowego, odczytuje następny węzeł i umieść się w węźle kolejnych dalej.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wbudowanego `Base64` zakodowanego obrazu. `Base64` Danych jest osadzony w `<image>` elementu. A <xref:System.IO.BinaryWriter> służy do tworzenia nowego pliku danych binarnych.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera zawartością mieszaną.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości na żądanego typu.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Asynchronicznie odczytuje element i dekoduje <see langword="Base64" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Odczytuje element i dekoduje <see langword="BinHex" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje zawartość elementu, za pomocą dekoduje `BinHex` kodowania i zwraca dekodowane bajty binarne (na przykład wbudowanego `BinHex`-zakodowanego obrazu GIF) w buforze.  
  
 Ta metoda może odczytywać tylko elementy zawartości prostej. Element może zawierać tekstu, biały znak, znaczący biały znak, sekcjach CDATA, komentarze i instrukcji przetwarzania. Może również zawierać odwołań do jednostek, które są automatycznie rozwinięte. Element nie może mieć elementów podrzędnych.  
  
 Ta metoda jest bardzo podobny do <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> metody, ale można wywołać tylko dla typów węzeł elementu.  
  
 Jeśli `count` wartość jest większa niż liczba bajtów w dokumencie, lub jeśli jest taka sama liczba bajtów w dokumencie <xref:System.Xml.XmlReader> odczytuje wszystkie pozostałe bajty w dokumencie i zwraca liczbę bajtów do odczytu. Następne <xref:System.Xml.XmlReader> wywołanie metody zwraca zero i przenosi czytnik do następującego węzła `EndElement`.  
  
 Jeśli należy wywołać <xref:System.Xml.XmlReader.Read%2A> przed całą zawartość elementu jest używany, czytnik może zachowywać się tak, jakby został wykorzystany pierwszy zawartości, a następnie <xref:System.Xml.XmlReader.Read%2A> wywołano metodę. Oznacza to, czy czytnik odczyta cały tekst do momentu napotkano end element. Następnie odczytać węzła tagu końcowego, odczytuje następny węzeł i umieść się w węźle kolejnych dalej.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wbudowanego `BinHex` zakodowanego obrazu. `BinHex` Danych jest osadzony w `<image>` elementu. A <xref:System.IO.BinaryWriter> służy do tworzenia nowego pliku danych binarnych.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks do buforu lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Element zawiera zawartością mieszaną.</exception>
        <exception cref="T:System.FormatException">Nie można przekonwertować zawartości na żądanego typu.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego można skopiować tekst wynikowy. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie w buforze zacząć Kopiowanie wyniku.</param>
        <param name="count">Maksymalna liczba bajtów do skopiowania w buforze. Zwracany jest rzeczywistą liczbę bajtów skopiowanych z tej metody.</param>
        <summary>Asynchronicznie odczytuje element i dekoduje <see langword="BinHex" /> zawartości.</summary>
        <returns>Liczba bajtów zapisanych w buforze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje wartość bieżącego elementu jako <see cref="T:System.Boolean" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Boolean" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.Boolean" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość elementu jest wpisany `xsd:boolean`, czytnik zwraca rozpakowany <xref:System.Boolean> obiektu. Jeśli zawartość nie jest typu `xsd:boolean`, czytnik próbuje przekonwertować go na <xref:System.Boolean> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na <see cref="T:System.Boolean" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Boolean" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.Boolean" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:boolean`, czytnik zwraca rozpakowany <xref:System.Boolean> obiektu. Jeśli zawartość nie jest typu `xsd:boolean`, czytnik próbuje przekonwertować go na <xref:System.Boolean> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.DateTime" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:dateTime`, czytnik zwraca rozpakowany <xref:System.DateTime> obiektu. Jeśli zawartość nie jest typu `xsd:dateTime`, czytnik próbuje przekonwertować go na <xref:System.DateTime> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
> [!NOTE]
>  Nie należy polegać na <xref:System.DateTime.Year%2A?displayProperty=nameWithType> wartość, gdy zawartość jest typu `xsd:gMonthDay`. <xref:System.Xml.XmlReader> zawsze ustawia <xref:System.DateTime.Year%2A?displayProperty=nameWithType> do 1904 w tym przypadku wartości.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> metody można odczytać zawartości `date` elementu.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na <see cref="T:System.DateTime" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.DateTime" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:dateTime`, czytnik zwraca rozpakowany <xref:System.DateTime> obiektu. Jeśli zawartość nie jest typu `xsd:dateTime`, czytnik próbuje przekonwertować go na <xref:System.DateTime> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
> [!NOTE]
>  Nie należy polegać na <xref:System.DateTime.Year%2A?displayProperty=nameWithType> wartość, gdy zawartość jest typu `xsd:gMonthDay`. <xref:System.Xml.XmlReader> zawsze ustawia <xref:System.DateTime.Year%2A?displayProperty=nameWithType> do 1904 w tym przypadku wartości.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje wartość bieżącego elementu jako <see cref="T:System.Decimal" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Decimal" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.Decimal" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Czytnik próbuje przekonwertować zawartości do elementu <xref:System.Decimal> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Decimal" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.Decimal" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Czytnik próbuje przekonwertować zawartości do elementu <xref:System.Decimal> obiektu zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Zawartość elementu jako liczba zmiennoprzecinkowa podwójnej precyzji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:double`, czytnik zwraca liczbie zmiennoprzecinkowej podwójnej precyzji. Jeśli zawartość nie jest typu `xsd:double`, próbuje przekonwertować go do liczby zmiennoprzecinkowej podwójnej precyzji zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody, aby zwrócić zawartość elementu w postaci liczby zmiennoprzecinkowej podwójnej precyzji.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na liczbie zmiennoprzecinkowej podwójnej precyzji.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa podwójnej precyzji.</summary>
        <returns>Zawartość elementu jako liczba zmiennoprzecinkowa podwójnej precyzji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:double`, czytnik zwraca liczbie zmiennoprzecinkowej podwójnej precyzji. Jeśli zawartość nie jest typu `xsd:double`, próbuje przekonwertować go do liczby zmiennoprzecinkowej podwójnej precyzji zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżąca wartość elementu jako liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
        <returns>Zawartość elementu jako pojedynczej precyzji liczba zmiennoprzecinkowa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Czytnik próbuje przekonwertować zawartości elementu pojedynczej precyzji liczba zmiennoprzecinkowa zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na liczbie zmiennoprzecinkowej pojedynczej precyzji.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, a następnie odczytuje bieżący element i zwraca zawartość jako liczba zmiennoprzecinkowa pojedynczej precyzji.</summary>
        <returns>Zawartość elementu jako pojedynczej precyzji liczba zmiennoprzecinkowa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Czytnik próbuje przekonwertować zawartości elementu pojedynczej precyzji liczba zmiennoprzecinkowa zgodnie z zasadami określonymi przez [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na liczbie zmiennoprzecinkowej pojedynczej precyzji.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako całkowita 32-bitowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako całkowita 32-bitowych.</summary>
        <returns>Zawartość elementu jako całkowita 32-bitowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:integer`, czytnik zwraca rozpakowany 32-bitowej podpisanej liczby całkowitej. Jeśli zawartość nie jest typu `xsd:integer`, próbuje wykonać jego konwersję na całkowita 32-bitowych zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na 32-bitowej podpisanej liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako całkowita 32-bitowych.</summary>
        <returns>Zawartość elementu jako całkowita 32-bitowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:integer`, czytnik zwraca rozpakowany 32-bitowej podpisanej liczby całkowitej. Jeśli zawartość nie jest typu `xsd:integer`, próbuje wykonać jego konwersję na całkowita 32-bitowych zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na 32-bitowej podpisanej liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako 64-bitowej podpisanej liczby całkowitej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>Zawartość elementu jako 64-bitowej podpisanej liczby całkowitej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:long`, czytnik zwraca rozpakowany 64-bitowej podpisanej liczby całkowitej. Jeśli zawartość nie jest typu `xsd:long`, próbuje wykonać jego konwersję na 64-bitowych całkowita zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> metody można odczytać zawartości `longValue` elementu.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na 64-bitowej podpisanej liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>Zawartość elementu jako 64-bitowej podpisanej liczby całkowitej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Jeśli zawartość jest typu `xsd:long`, czytnik zwraca rozpakowany 64-bitowej podpisanej liczby całkowitej. Jeśli zawartość nie jest typu `xsd:long`, próbuje wykonać jego konwersję na 64-bitowych całkowita zgodnie z zasadami określonymi przez czytnik [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strony odwołania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na 64-bitowej podpisanej liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
        <returns>Opakowany wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) obiektu najbardziej odpowiedniego typu. <see cref="P:System.Xml.XmlReader.ValueType" /> Właściwość określa odpowiedni typ CLR. Jeśli zawartość jest typu jako typu listy, ta metoda zwraca tablicę obiektów opakowanego odpowiedniego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody można odczytać zawartości `price` węzła. Czytnik informacje są używane w schemacie mapowania zawartości na prawidłowy typ danych.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 W przykładzie użyto następujące dwa pliki jako dane wejściowe.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądany typ</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
        <returns>Opakowany wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) obiektu najbardziej odpowiedniego typu. <see cref="P:System.Xml.XmlReader.ValueType" /> Właściwość określa odpowiedni typ CLR. Jeśli zawartość jest typu jako typu listy, ta metoda zwraca tablicę obiektów opakowanego odpowiedniego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na żądanego typu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsObjectAsync&gt;c__async2))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.Object" />.</summary>
        <returns>Opakowany wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) obiektu najbardziej odpowiedniego typu. <see cref="P:System.Xml.XmlReader.ValueType" /> Właściwość określa odpowiedni typ CLR. Jeśli zawartość jest typu jako typu listy, ta metoda zwraca tablicę obiektów opakowanego odpowiedniego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład odczytuje `stringValue` element i zwraca zawartości tekstowej (Ignorowanie komentarz i przetwarzania instrukcji).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na <see cref="T:System.String" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy określona nazwa lokalna i identyfikator URI przestrzeni nazw jest zgodna z bieżącego elementu, następnie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje z tagiem początkowym zawartość elementu i przenosi czytnika poza tagu końcowego. Umożliwia rozwijanie jednostek, a pomija przetwarzanie instrukcji i komentarze. Element może zawierać tylko prostej zawartości. Oznacza to, że jej nie może mieć elementów podrzędnych.  
  
 Aby uzyskać więcej informacji, zobacz sekcję uwag <xref:System.Xml.XmlReader> strona referencyjna i [W3C XML schematu część 2: typy danych](http://go.microsoft.com/fwlink/?LinkId=4871) zalecenia.  
  
   
  
## Examples  
 Poniższy przykład odczytuje `stringValue` element i zwraca zawartości tekstowej (Ignorowanie komentarz i przetwarzania instrukcji).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 W przykładzie użyto `dataFile.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.Xml.XmlException">Bieżący element zawiera elementy podrzędne.  - lub - zawartości elementu nie można przekonwertować na <see cref="T:System.String" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">Metoda jest wywoływana z <see langword="null" /> argumentów.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa lokalna i identyfikator URI przestrzeni nazw nie są zgodne z bieżącego elementu odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsStringAsync&gt;c__async3))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje bieżący element i zwraca zawartość jako <see cref="T:System.String" /> obiektu.</summary>
        <returns>Element zawartości jako <see cref="T:System.String" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje proste elementy tylko tekst. Jednak zaleca się używanie <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> — metoda, ponieważ zapewnia bardziej łatwe do obsługi tej operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> metody do odczytu elementu tekstowego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje element tekstowy. Jednak zaleca się używanie <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> — metoda, ponieważ zapewnia bardziej łatwe do obsługi tej operacji.</summary>
        <returns>Tekst wyświetlany w elemencie, który został odczytany. Pusty ciąg, jeśli element jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString> metody do odczytu elementu tekstowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Następny węzeł zawartości nie jest tagu początkowego; lub znaleziono elementu nie zawiera wartości zwykłego tekstu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa do sprawdzenia.</param>
        <summary>Sprawdza, czy <see cref="P:System.Xml.XmlReader.Name" /> właściwość elementu znaleziono pasującej do ciągu danego przed odczytaniem elementu tylko tekst. Jednak zaleca się używanie <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> — metoda, ponieważ zapewnia bardziej łatwe do obsługi tej operacji.</summary>
        <returns>Tekst wyświetlany w elemencie, który został odczytany. Pusty ciąg, jeśli element jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString> metody do odczytu elementu tekstowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Jeśli nie jest następnego węzła zawartości tagu początkowego; Jeśli element <see langword="Name" /> nie jest zgodny z podany argument; lub jeśli znaleziono element nie zawiera wartości zwykłego tekstu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Lokalna nazwa do sprawdzenia.</param>
        <param name="ns">Identyfikator URI przestrzeni nazw do sprawdzenia.</param>
        <summary>Sprawdza, czy <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> właściwości elementu znaleziono dopasowuje ciągi danego przed odczytaniem elementu tylko tekst. Jednak zaleca się używanie <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> — metoda, ponieważ zapewnia bardziej łatwe do obsługi tej operacji.</summary>
        <returns>Tekst wyświetlany w elemencie, który został odczytany. Pusty ciąg, jeśli element jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> metody do odczytu elementu tekstowego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Jeśli nie jest następnego węzła zawartości tagu początkowego; Jeśli element <see langword="LocalName" /> lub <see langword="NamespaceURI" /> nie są zgodne z danym argumentów; lub jeśli znaleziono element nie zawiera wartości zwykłego tekstu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest tagu końcowego i przechodzi do następnego węzła czytnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element zawartości tekstowej.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 W przykładzie użyto `book3.xml` pliku.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Bieżący węzeł nie jest tagu końcowego lub jeśli niepoprawna zawartość XML jest w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytuje całą zawartość, w tym znaczników jako ciąg.</summary>
        <returns>Wszystkie zawartość XML, znaczników, łącznie z bieżącego węzła. Jeśli bieżący węzeł nie ma elementów podrzędnych, zwracany jest pustym ciągiem.  Jeśli bieżący węzeł nie jest ani elementu, jak ani atrybutów, zwracany jest pustym ciągiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca całej zawartości bieżącego węzła, w tym kod znaczników. Bieżący węzeł (tagu początkowego) i odpowiedniego węzła końcowego (tagu końcowego) nie są zwracane. Na przykład, jeśli były następujące:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` Zwraca `this <child id="123"/>`  
  
 Ta metoda obsługuje węzłów elementów i atrybutów w następujący sposób:  
  
|Typ węzła|Pozycja przed wywołaniem|XML fragment|Wartość zwracana|Pozycja po wywołaniu metody|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na `item1` tag początkowy.|\<item1>text1\</item1>\<item2>text2\</item2>|Tekst1|Na `item2` tag początkowy.|  
|`Attribute`|Na `attr1` węzła atrybutu.|\<item attr1="val1" attr2="val2">text\</item>|val1|Pozostaje na `attr1` węzła atrybutu.|  
  
 Jeśli czytnik jest ustawiony na węzeł liścia, wywoływania `ReadInnerXml` jest odpowiednikiem wywołania <xref:System.Xml.XmlReader.Read%2A>. Metoda zwraca `String.Empty` (z wyjątkiem węzłów atrybutu w takim przypadku jest zwracana wartość atrybutu).  
  
 Ta metoda sprawdza, czy poprawnie sformułowany plik XML. Jeśli `ReadInnerXml` jest wywoływana z <xref:System.Xml.XmlValidatingReader>, ta metoda sprawdza również zwracana zawartość.  
  
 Zgodnie z implementacją w <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> i `XmlValidatingReader` klasy `ReadOuterXml` metoda jest świadome przestrzeni nazw.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład porównuje `ReadInnerXml` i <xref:System.Xml.XmlReader.ReadOuterXml%2A> metody.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 W przykładzie użyto `2books.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Kod XML nie jest poprawnie sformułowany lub wystąpił błąd podczas analizowania pliku XML.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadInnerXmlAsync&gt;c__async6))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje całą zawartość, w tym znaczników jako ciąg.</summary>
        <returns>Wszystkie zawartość XML, znaczników, łącznie z bieżącego węzła. Jeśli bieżący węzeł nie ma elementów podrzędnych, zwracany jest pustym ciągiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadInnerXml%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej odczytuje zawartość, w tym znaczników, reprezentujący ten węzeł i wszystkie jego elementy podrzędne.</summary>
        <returns>Jeśli czytnik jest ustawiony na element lub węzła atrybutu, ta metoda zwraca plik XML zawartości, w tym znaczników bieżącego węzła i wszystkich jego obiektów podrzędnych; w przeciwnym wypadku zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Xml.XmlReader.ReadInnerXml%2A> z wyjątkiem również zwraca tagiem początkowym i końcowym.  
  
 Ta metoda obsługuje węzłów elementów i atrybutów w następujący sposób:  
  
|Typ węzła|Pozycja przed wywołaniem|XML fragment|Wartość zwracana|Pozycja po wywołaniu metody|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na `item1` tag początkowy.|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1 > Tekst1\</item1 >|Na `item2` tag początkowy.|  
|`Attribute`|Na `attr1` węzła atrybutu.|\<item attr1="val1" attr2="val2">text\</item>|attr1="val1"|Pozostaje na `attr1` węzła atrybutu.|  
  
 Jeśli czytnik jest ustawiony na węzeł liścia, wywoływania `ReadOuterXml` jest odpowiednikiem wywołania <xref:System.Xml.XmlReader.Read%2A>. Metoda zwraca `String.Empty` (z wyjątkiem węzłów atrybutu w takim przypadku jest zwracany kod znaczników atrybutu).  
  
 Ta metoda sprawdza, czy poprawnie sformułowany plik XML. Jeśli `ReadOuterXml` jest wywoływana z <xref:System.Xml.XmlValidatingReader>, ta metoda sprawdza również zwracana zawartość  
  
 Zgodnie z implementacją w <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> i `XmlValidatingReader` klasy `ReadOuterXml` metoda jest świadome przestrzeni nazw. Podane następujący tekst XML `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, jeśli czytnik był ustawiony na `S:B` tag, początkowy `ReadOuterXml` zwraca `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład porównuje `ReadInnerXml` i `ReadOuterXml` metody.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 W przykładzie użyto `2books.xml` pliku jako dane wejściowe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Kod XML nie jest poprawnie sformułowany lub wystąpił błąd podczas analizowania pliku XML.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadOuterXmlAsync&gt;c__async8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje zawartość, w tym znaczników, reprezentujący ten węzeł i wszystkie jego elementy podrzędne.</summary>
        <returns>Jeśli czytnik jest ustawiony na element lub węzła atrybutu, ta metoda zwraca plik XML zawartości, w tym znaczników bieżącego węzła i wszystkich jego obiektów podrzędnych; w przeciwnym wypadku zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadOuterXml%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Sprawdza, czy bieżący węzeł jest elementem i przechodzi do następnego węzła czytnik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy bieżący węzeł jest elementem i przechodzi do następnego węzła czytnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Xml.XmlReader.IsStartElement%2A> następuje <xref:System.Xml.XmlReader.Read%2A> należy umieścić na zawartość tego elementu w strumieniu wejściowym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu.</param>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest element z danym <see cref="P:System.Xml.XmlReader.Name" /> i przechodzi do następnego węzła czytnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody odpowiada wywołaniu <xref:System.Xml.XmlReader.IsStartElement%2A> następuje wywołanie <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono każdy element zawartości tekstowej.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 W przykładzie użyto `book3.xml` pliku.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.  - lub - <see cref="P:System.Xml.XmlReader.Name" /> elementu nie odpowiada danym <paramref name="name" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Lokalna nazwa elementu.</param>
        <param name="ns">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Sprawdza, czy bieżący węzeł zawartości jest element z danym <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> i przechodzi do następnego węzła czytnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody odpowiada wywołaniu <xref:System.Xml.XmlReader.IsStartElement%2A> następuje wywołanie <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Niepoprawna zawartość XML napotkano w strumieniu wejściowym.  - lub - <see cref="P:System.Xml.XmlReader.LocalName" /> i <see cref="P:System.Xml.XmlReader.NamespaceURI" /> właściwości znaleziono elementu nie są zgodne z danym argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera stan czytnika danych.</summary>
        <value>Jedna z wartości wyliczenia, które określa stan czytnika danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadState%2A> Właściwość ma jeden z następujących wartości:  
  
-   <xref:System.Xml.ReadState.Initial>, gdy <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> metoda jest wywoływana.  
  
-   <xref:System.Xml.ReadState.Interactive>, gdy <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> została wywołana metoda i dodatkowe metody może zostać wywołana w czytniku.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, gdy koniec dokumentu XML został osiągnięty pomyślnie.  
  
-   <xref:System.Xml.ReadState.Closed>, gdy <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> metoda jest wywoływana.  
  
-   <xref:System.Xml.ReadState.Error>, jeśli błąd uniemożliwia kontynuowanie operacji odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej odczytuje zawartość elementu lub tekst węzła jako ciąg. Jednak zaleca się używanie <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> — metoda, ponieważ zapewnia bardziej łatwe do obsługi tej operacji.</summary>
        <returns>Zawartość elementu lub ciąg pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma Microsoft zaleca użycie <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> metody do odczytu treści elementu lub tekst węzła jako ciąg.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wystąpił błąd podczas analizowania pliku XML.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nowy <see langword="XmlReader" /> wystąpienia, który może służyć do odczytu dla bieżącego węzła i wszystkich jego elementów podrzędnych.</summary>
        <returns>Ustaw nowe wystąpienie czytnika XML <see cref="F:System.Xml.ReadState.Initial" />. Wywoływanie <see cref="M:System.Xml.XmlReader.Read" /> metody umieszcza nowym czytniku na węźle, który został przed wywołaniem do bieżącego <see cref="M:System.Xml.XmlReader.ReadSubtree" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> można wywołać tylko dla węzłów elementów. Przeczytaniu całego poddrzewa wywołań <xref:System.Xml.XmlReader.Read%2A> metoda zwraca `false`. Gdy nowego modułu odczytującego XML został zamknięty readeris oryginalnej, znajduje się na `EndElement` węzeł drzewa podrzędnego. W związku z tym jeśli wywołujesz <xref:System.Xml.XmlReader.ReadSubtree%2A> metody w tagu początkowym elementu książki, po poddrzewa odczytu i nowego modułu odczytującego XML został zamknięty, oryginalny czytnik XML jest ustawiony na tagu końcowego elementu księgi.  
  
 Nie należy wykonać jakichkolwiek działań na oryginalnym czytnika dopóki nowym czytniku został zamknięty. Ta akcja nie jest obsługiwana i może spowodować nieprzewidywalne zachowanie.  
  
> [!NOTE]
>  <xref:System.Xml.XmlReader.ReadSubtree%2A> Metoda nie jest przeznaczona dla creatingcopies danych XML, którego można używać z niezależnie. Jego designedto Utwórz granicę wokół elementu XML. Jest to przydatne, jeśli chcesz przekazać dane do innego składnika do przetwarzania i aby ograniczyć ilość danych mogą uzyskiwać dostęp do składnika. Podczas przekazywania modułu odczytującego XML zwrócony przez <xref:System.Xml.XmlReader.ReadSubtree%2A> metody do innej aplikacji, aplikacja może uzyskać dostęp tylko tego elementu XML, nie całego dokumentu XML.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Xml.XmlReader.ReadSubtree%2A> metody.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Użyj następujących danych XML do uruchomienia w przykładach w tym temacie:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Przesuwa <see cref="T:System.Xml.XmlReader" /> do następnego dopasowania elementu elementów podrzędnych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu, który chcesz przenieść.</param>
        <summary>Przesuwa <see cref="T:System.Xml.XmlReader" /> do następnego elementu elementów podrzędnych o określonej nazwie kwalifikowanej.</summary>
        <returns>
          <see langword="true" /> Jeśli można znaleźć zgodnego elementu podrzędne; w przeciwnym razie <see langword="false" />. Jeśli nie ma pasującego elementu podrzędnego, <see cref="T:System.Xml.XmlReader" /> znajduje się w tagu końcowego (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) elementu.  Jeśli <see cref="T:System.Xml.XmlReader" /> nie znajduje się w elemencie podczas <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> została wywołana, ta metoda zwraca <see langword="false" /> i położenie <see cref="T:System.Xml.XmlReader" /> nie ulega zmianie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład analizuje drugiego węzła książki.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 W przykładzie użyto pliku `2books.xml`, jak wejściowego.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu, który chcesz przenieść.</param>
        <param name="namespaceURI">Identyfikator URI elementu, który chcesz przenieść do przestrzeni nazw.</param>
        <summary>Przesuwa <see cref="T:System.Xml.XmlReader" /> do następnego elementu podrzędnego elementu z określoną nazwę lokalnego i identyfikator URI przestrzeni nazw.</summary>
        <returns>
          <see langword="true" /> Jeśli można znaleźć zgodnego elementu podrzędne; w przeciwnym razie <see langword="false" />. Jeśli nie ma pasującego elementu podrzędnego, <see cref="T:System.Xml.XmlReader" /> znajduje się w tagu końcowego (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) elementu.  Jeśli <see cref="T:System.Xml.XmlReader" /> nie znajduje się w elemencie podczas <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> została wywołana, ta metoda zwraca <see langword="false" /> i położenie <see cref="T:System.Xml.XmlReader" /> nie ulega zmianie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Wartości obu parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Odczytuje aż do znalezienia nazwanego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa elementu.</param>
        <summary>Odczytuje, dopóki nie zostanie znaleziony element z określoną nazwą kwalifikowaną.</summary>
        <returns>
          <see langword="true" /> Jeśli pasujący element zostanie odnaleziony; w przeciwnym razie <see langword="false" /> i <see cref="T:System.Xml.XmlReader" /> jest w stanie koniec pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taką samą funkcję wykonywania `following::name` wyrażenia XPath z bieżącego węzła. Zapewnia szybkie można znaleźć w dokumencie XML nazwanego elementu. Czytnik ją przechodzi do następnego elementu następujące, która odpowiada podanej nazwie i zwraca `true` Jeśli można znaleźć zgodnego elementu. Korzystając z poniższego przykładu, czytnik może odczytać pierwsze wystąpienie określonego elementu podczas odczytywania do przodu.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Tę metodę można wywołać dla wszystkich typów węzłów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa elementu.</param>
        <param name="namespaceURI">Identyfikator URI elementu przestrzeni nazw.</param>
        <summary>Odczytuje, dopóki nie zostanie znaleziony element z określoną nazwę lokalnego i identyfikator URI przestrzeni nazw.</summary>
        <returns>
          <see langword="true" /> Jeśli pasujący element zostanie odnaleziony; w przeciwnym razie <see langword="false" /> i <see cref="T:System.Xml.XmlReader" /> jest w stanie koniec pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taką samą funkcję wykonywania `following::name` wyrażenia XPath z bieżącego węzła. Zapewnia szybkie można znaleźć w dokumencie XML nazwanego elementu. Czytnik ją przechodzi do następnego elementu następujące, która odpowiada podanej nazwie i zwraca `true` Jeśli można znaleźć zgodnego elementu.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Tę metodę można wywołać dla wszystkich typów węzłów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Wartości obu parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <summary>Przesuwa <see langword="XmlReader" /> do następnego dopasowania element równorzędny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Kwalifikowana nazwa element równorzędny, który chcesz przenieść.</param>
        <summary>Przesuwa <see langword="XmlReader" /> na następny element równorzędny o określonej nazwie kwalifikowanej.</summary>
        <returns>
          <see langword="true" /> Jeśli zostanie znaleziony pasujący element równorzędny; w przeciwnym razie <see langword="false" />. Jeśli nie ma pasujący element równorzędny, <see langword="XmlReader" /> znajduje się w tagu końcowego (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) elementu nadrzędnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Xml.XmlReader.ReadToNextSibling%2A> podczas `XmlReader` jest stan początkowy (<xref:System.Xml.XmlReader.ReadState%2A> jest <xref:System.Xml.ReadState.Initial>). Możesz wywołać <xref:System.Xml.XmlReader.Read%2A> można poprawić `XmlReader` , a następnie wywołać <xref:System.Xml.XmlReader.ReadToNextSibling%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład odczytuje atrybutu ISBN w każdym węźle książki.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentException">Parametr jest pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa element równorzędny, który chcesz przenieść.</param>
        <param name="namespaceURI">Identyfikator URI element równorzędny, który chcesz przenieść do przestrzeni nazw.</param>
        <summary>Przesuwa <see langword="XmlReader" /> na następny element równorzędny z określoną nazwę lokalnego i identyfikator URI przestrzeni nazw.</summary>
        <returns>
          <see langword="true" /> Jeśli zostanie znaleziony pasujący element równorzędny; w przeciwnym razie <see langword="false" />. Jeśli nie ma pasujący element równorzędny, <see langword="XmlReader" /> znajduje się w tagu końcowego (<see cref="P:System.Xml.XmlReader.NodeType" /> jest <see langword="XmlNodeType.EndElement" />) elementu nadrzędnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Xml.XmlReader.ReadToNextSibling%2A> podczas `XmlReader` jest stan początkowy (<xref:System.Xml.XmlReader.ReadState%2A> jest <xref:System.Xml.ReadState.Initial>). Możesz wywołać <xref:System.Xml.XmlReader.Read%2A> można poprawić `XmlReader` , a następnie wywołać <xref:System.Xml.XmlReader.ReadToNextSibling%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">Wartości obu parametrów są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która pełni rolę bufora, do którego zawartość tekstową są zapisywane. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie buforu gdzie <see cref="T:System.Xml.XmlReader" /> można uruchomić skopiować wyniki.</param>
        <param name="count">Maksymalna liczba znaków, które ma zostać skopiowany do buforu. Rzeczywista liczba znaków kopiowany jest zwracana z tej metody.</param>
        <summary>Odczytuje dużych strumieni tekstu osadzony w dokumencie XML.</summary>
        <returns>Liczba znaków do odczytu w buforze. Brak więcej zawartości tekstu jest zwracana wartość zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odczytywanie bardzo dużych strumieni tekstu osadzony w dokumencie XML w sposób przesyłania strumieniowego, oznacza to niewielka liczba znaków w czasie zamiast przydzielania pojedynczy ciąg dla wartości całkowitej. Tę metodę można wywołać w każdym węźle, który ma wartość (<xref:System.Xml.XmlReader.HasValue%2A> jest `true`), ale tylko przesyłania strumieniowego rzeczywistej wartości węzła występuje, gdy wywołano tekstu, biały znak i węzły znaczący biały znak. Inne wartości typu węzła są buforowane, łącznie z atrybutów i węzły CDATA.  
  
 Ta metoda zwraca tylko zawartość <xref:System.Xml.XmlReader.Value%2A> właściwości i nie powoduje przeniesienia <xref:System.Xml.XmlReader>.  
  
 Ta metoda odczytuje określoną liczbę znaków (`count`) wartości węzła w buforze znaków (`buffer`) od określonego przesunięcia (`index`) i zwraca liczbę znaków, zapisać w buforze. Zwraca `0` po osiągnął koniec wartości. Nie można uruchomić ponownie do przeczytania wartość ponownie.  
  
 Between wywołań <xref:System.Xml.XmlReader.ReadValueChunk%2A> <xref:System.Xml.XmlReader> właściwości czy żadnych zmian, z wyjątkiem <xref:System.Xml.XmlReader.Value%2A> właściwości. Gdy <xref:System.Xml.XmlReader.Value%2A> dostępu do właściwości albo może zwrócić wartości częściowej (ze znakami nie została jeszcze zwrócona przez <xref:System.Xml.XmlReader.ReadValueChunk%2A>) lub wartość pełną w zależności od wdrożenia. Wszystkie <xref:System.Xml.XmlReader> implementacje w <xref:System.Xml> przestrzeni nazw zwracają wartość częściowej dla <xref:System.Xml.XmlReader.Value%2A> implementacja właściwości.  
  
 Wszelkie odczytu Between wywołania można wywołać metody <xref:System.Xml.XmlReader.ReadValueChunk%2A>. W takim przypadku <xref:System.Xml.XmlReader> przechodzi do następnego <xref:System.Xml.XmlNodeType> strumienia i znaków nie została jeszcze zwracane są pomijane.  
  
 Może być sytuacja, gdy <xref:System.Xml.XmlReader.ReadValueChunk%2A> zwraca mniej niż żądana liczba znaków. Na przykład, jeśli ma wartość typu long 200 znaków z para zastępcza w miejscach 127 i 128 i wywołana <xref:System.Xml.XmlReader.ReadValueChunk%2A> buforem 128 znaków, wywołanie metody zwróci 127 znaków zamiast żądanego 128. Para zastępcza może być zwracany w następnej <xref:System.Xml.XmlReader.ReadValueChunk%2A> wywołania. W takim przypadku <xref:System.Xml.XmlReader.ReadValueChunk%2A> nie zwrócił żądanego 128 znaków, ponieważ to tak spowodowałaby para zastępcza niekompletne na końcu buforu.  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Wartość jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks w buforze, lub indeks i liczba jest większa niż rozmiar buforu przydzielone.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> Implementacja nie obsługuje tej metody.</exception>
        <exception cref="T:System.Xml.XmlException">Dane XML nie jest poprawnie sformułowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która pełni rolę bufora, do którego zawartość tekstową są zapisywane. Ta wartość nie może być <see langword="null" />.</param>
        <param name="index">Przesunięcie buforu gdzie <see cref="T:System.Xml.XmlReader" /> można uruchomić skopiować wyniki.</param>
        <param name="count">Maksymalna liczba znaków, które ma zostać skopiowany do buforu. Rzeczywista liczba znaków kopiowany jest zwracana z tej metody.</param>
        <summary>Asynchronicznie odczytuje dużych strumieni tekstu osadzony w dokumencie XML.</summary>
        <returns>Liczba znaków do odczytu w buforze. Brak więcej zawartości tekstu jest zwracana wartość zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.ReadValueChunk%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej Usuwa odwołanie do jednostki dla <see langword="EntityReference" /> węzłów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli czytnik jest ustawiony na `EntityReference` węzła (`XmlNodeType.EntityReference`), jeśli <xref:System.Xml.XmlReader.Read%2A> jest wywoływana po wywołaniu tej metody, tekst zastępczy jednostki zostanie przeanalizowany. Po zakończeniu operacji tekst zastępczy jednostki `EndEntity` węzła jest zwracana do zamknięcia zakresu odwołanie do jednostki.  
  
> [!NOTE]
>  Po wywołaniu tej metody, jeśli jednostka jest częścią wartości atrybutu należy wywołać <xref:System.Xml.XmlReader.ReadAttributeValue%2A> do kroku do jednostki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o schemacie, który został przypisany do bieżącego węzła w wyniku sprawdzania poprawności schematu.</summary>
        <value>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> Obiekt zawierający informacje o schemacie dla bieżącego węzła. Informacje o schemacie można ustawić na elementy, atrybuty, lub na węzły tekstowe z inną niż null <see cref="P:System.Xml.XmlReader.ValueType" /> (wpisane wartości).  Jeśli bieżący węzeł nie jest jednym z powyższych typów węzeł lub jeśli <see langword="XmlReader" /> wystąpienia nie raportuje informacje o schemacie, ta właściwość zwraca <see langword="null" />.  Jeśli ta właściwość jest wywoływana z <see cref="T:System.Xml.XmlTextReader" /> lub <see cref="T:System.Xml.XmlValidatingReader" /> obiektu, ta właściwość zawsze zwraca <see langword="null" />. Te <see langword="XmlReader" /> implementacji nie ujawniaj informacji o schemacie za pośrednictwem <see langword="SchemaInfo" /> właściwości.  
  
 <block subset="none" type="note"><para> Jeśli trzeba uzyskać zestaw informacji po schema weryfikacji (PSVI) dla elementu, umieść czytnik przy tagu końcowym elementu, a nie w tagu początkowego. Pobierz PSVI za pośrednictwem <see langword="SchemaInfo" /> właściwości czytnika. Sprawdzanie poprawności reader, który został utworzony przez <see cref="Overload:System.Xml.XmlReader.Create" /> z <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> ustawioną właściwość <see cref="F:System.Xml.ValidationType.Schema" /> ma pełną PSVI dla elementu tylko wtedy, gdy czytnik znajduje się w tagu końcowego elementu.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.IXmlSchemaInfo> Interfejsu przedstawia podzbiór z Post schemat sprawdzania poprawności typu Infoset (PSVI) skojarzony z węzłem XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.XmlReaderSettings" /> użytej do utworzenia tego obiektu <see cref="T:System.Xml.XmlReader" /> wystąpienia.</summary>
        <value>
          <see cref="T:System.Xml.XmlReaderSettings" /> Obiekt używany do utworzenia tego wystąpienia czytnika. Jeśli ten czytnik nie został utworzony przy użyciu <see cref="Overload:System.Xml.XmlReader.Create" /> , ta właściwość zwraca <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlReaderSettings> Obiektu mogą zawierać poufne informacje, takie jak poświadczenia użytkownika. Aplikacje należy zachować ostrożność, gdy buforowanie tego obiektu lub przekazanie jej do innego składnika.  
  
 <xref:System.Xml.XmlReaderSettings> Klasa jest używana do określania zestaw funkcji do obsługi wystąpienia utworzone czytnika. <xref:System.Xml.XmlReaderSettings> Obiektu zwróconego przez tę właściwość nie może być modyfikowany. Próby zmiany wyniki poszczególnych ustawień w wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pomija elementy podrzędne bieżącego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższych XML wejściowych, jeśli czytnik jest ustawiony na `<a>` węzła lub dowolny z jego atrybuty wywoływania `Skip` umieszcza czytelnika `<b>` węzła.  
  
 Jeśli czytnik jest już ustawiony na węzeł liścia (takich jak `<x>` węzła lub węzeł tekstowy `abc`), wywoływania `Skip` jest taka sama jak wywołanie <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Ta metoda sprawdza, czy poprawnie sformułowany plik XML.  
  
 Jeśli czytnik <xref:System.Xml.XmlValidatingReader>, ta metoda sprawdza poprawność zawartości zostało pominięte.  
  
 `XmlReader` Implementacji określa, czy `Skip` metody rozwinie podmiotów zewnętrznych. W poniższej tabeli opisano, czy w jednostkach zewnętrznych zostaną rozwinięte dla różnych typów `XmlReader` obiektów.  
  
|Typ elementu XmlReader|Umożliwia rozwijanie jednostek zewnętrznych|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Nie.|  
|<xref:System.Xml.XmlReader> wystąpienia utworzone przez <xref:System.Xml.XmlReader.Create%2A> metoda odczytuje dane tekstowe.|Nie.|  
|<xref:System.Xml.XmlReader> wystąpienia utworzone przez <xref:System.Xml.XmlReader.Create%2A> metoda odczytuje dane binarne.|Nie dotyczy.|  
|Sprawdzanie poprawności schematu <xref:System.Xml.XmlReader> wystąpienia utworzone przez <xref:System.Xml.XmlReader.Create%2A> metody.|Tak.|  
|<xref:System.Xml.XmlValidatingReader>|Tak.|  
|<xref:System.Xml.XmlReader> zwrócone przez wystąpienie <xref:System.Xml.XPath.XPathNavigator> obiektu.|Nie dotyczy.|  
|<xref:System.Xml.XmlNodeReader>|Nie.|  
|<xref:System.Xml.XmlReader> wystąpienie otaczający innego <xref:System.Xml.XmlReader> wystąpienia.|Zależy od implementacji podstawowych <xref:System.Xml.XmlReader>. ( `Skip` Metoda podstawowa <xref:System.Xml.XmlReader> nosi nazwę).|  
  
 Asynchroniczne wersja tej metody dla <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład analizuje uruchamianie na drugi węzeł książki pliku XML.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 W przykładzie użyto pliku `2books.xml`, jak wejściowego.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie pomija elementy podrzędne bieżącego węzła.</summary>
        <returns>Bieżącego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wersja asynchroniczna elementu <xref:System.Xml.XmlReader.Skip%2A>, z tą samą funkcjonalnością. Aby użyć tej metody, należy ustawić <xref:System.Xml.XmlReaderSettings.Async%2A> flaga `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Wywołano asynchroniczną metodę bez ustawienia <see cref="P:System.Xml.XmlReaderSettings.Async" /> flaga <see langword="true" />. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest zgłaszany z komunikatem "Ustaw właściwość XmlReaderSettings.Async na wartość true, jeśli chcesz używać metod asynchronicznych".</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartości tekstowej bieżącego węzła.</summary>
        <value>Wartość zwracana jest zależna od <see cref="P:System.Xml.XmlReader.NodeType" /> węzła. W poniższej tabeli wymieniono typy węzłów, które mają wartość do zwrócenia. Zwracane typy inny węzeł <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Typ węzła </term><description> wartość </description></listheader><item><term><see langword="Attribute" /></term><description> wartość atrybutu.  </description></item><item><term><see langword="CDATA" /></term><description> Zawartość sekcji CDATA.  </description></item><item><term><see langword="Comment" /></term><description> Zawartość komentarza.  </description></item><item><term><see langword="DocumentType" /></term><description> Podzestawie wewnętrznym.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Całej zawartości, z wyłączeniem obiektu docelowego.  </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Biały znak między znaczników w mieszanych modelu zawartości.  </description></item><item><term><see langword="Text" /></term><description> Zawartości węzła tekstowego.  </description></item><item><term><see langword="Whitespace" /></term><description> Biały znak między znaczników.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> Zawartość deklaracji.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczne wersja tej właściwości dla <xref:System.Xml.XmlReader.GetValueAsync%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład umożliwia odczytanie pliku XML i wyświetla każdego z węzłów.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 W przykładzie użyto `items.xml` pliku.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ środowiska uruchomieniowego języka wspólnego (CLR) dla bieżącego węzła.</summary>
        <value>Typ CLR, która odnosi się do typu wartość węzła. Wartość domyślna to <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz [typu obsługi w klasach System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) listę mapowań domyślnych.  
  
 Element typu `xs:int` ma `ValueType` z `System.Int32` domyślnie. Jednak `ValueType` może być jedną z prawidłowe typy, które mogą być mapowane na `xs:int`, takich jak `System.Int16` lub `System.Double`.  
  
 Jeśli węzeł ma wyrażeniami bez typu, lub jeśli węzeł ma element, który zawiera zawartość mieszaną, wartość węzła jest mapowany na `System.String` typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <block subset="none" type="overrides">
          <para>Podaj implementacje <see langword="ValueType" /> dla każdego węzła, nawet jeśli jest on tylko <see langword="System.String" /> typu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera bieżącą <see langword="xml:lang" /> zakresu.</summary>
        <value>Bieżący <see langword="xml:lang" /> zakresu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość reprezentuje `xml:lang` zakres, w którym znajduje się bieżącego węzła. Na przykład poniżej przedstawiono fragment XML z `xml:lang` ustawiony na US English w elemencie głównym:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Gdy czytnik jest ustawiony na `name` elementu, można użyć tej właściwości można znaleźć się w zakresie US English `xml:lang` atrybutu.  
  
   
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> przykład za pomocą tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera bieżącą <see langword="xml:space" /> zakresu.</summary>
        <value>Jeden z <see cref="T:System.Xml.XmlSpace" /> wartości. Jeśli nie <see langword="xml:space" /> zakresu istnieje, ta właściwość jest równa <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Zobacz <xref:System.Xml.XmlTextReader.XmlSpace%2A> (w `XmlTextReader` klasy) na przykład za pomocą tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Metoda została wywołana przed ukończeniem poprzedniej operacji asynchronicznej. W takim przypadku <see cref="T:System.InvalidOperationException" /> jest generowany komunikat "Operacja asynchroniczna jest już w toku."</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>
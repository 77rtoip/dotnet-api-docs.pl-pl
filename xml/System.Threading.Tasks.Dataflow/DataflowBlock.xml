<Type Name="DataflowBlock" FullName="System.Threading.Tasks.Dataflow.DataflowBlock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9511afa8d5aeec0589b889a0879e1941f38526e2" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56361415" /></Metadata><TypeSignature Language="C#" Value="public static class DataflowBlock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DataflowBlock extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.DataflowBlock" />
  <TypeSignature Language="VB.NET" Value="Public Module DataflowBlock" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataflowBlock abstract sealed" />
  <TypeSignature Language="F#" Value="type DataflowBlock = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.5.25.0</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
    <AssemblyVersion>4.6.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera zestaw metody statyczne (Shared w języku Visual Basic) do pracy z bloków przepływu danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsObservable&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IObservable&lt;TOutput&gt; AsObservable&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObservable`1&lt;!!TOutput&gt; AsObservable&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObservable(Of TOutput) (source As ISourceBlock(Of TOutput)) As IObservable(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObservable&lt;TOutput&gt; ^ AsObservable(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsObservable : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; IObservable&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObservable&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło do opakowania.</param>
        <summary>Tworzy nową <see cref="T:System.IObservable`1" /> abstrakcji <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns><see cref="T:System.IObservable`1" /> Umożliwiającej obserwatorów do subskrypcji źródłowej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsObserver&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static IObserver&lt;TInput&gt; AsObserver&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObserver`1&lt;!!TInput&gt; AsObserver&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObserver(Of TInput) (target As ITargetBlock(Of TInput)) As IObserver(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObserver&lt;TInput&gt; ^ AsObserver(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member AsObserver : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; -&gt; IObserver&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObserver&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ danych wejściowych zaakceptowane przez blok docelowy.</typeparam>
        <param name="target">Miejsce docelowe do opakowania.</param>
        <summary>Tworzy nową <see cref="T:System.IObserver`1" /> abstrakcji <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns>Obserwatora, który otacza blok docelowy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwsze źródło.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi do wykonania na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi do wykonania na danych z drugiego źródła.</param>
        <summary>Monitoruje dwóch źródeł przepływu danych w celu wywoływania podana Obsługa niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli oba źródła zostaną ukończone przed ukończenie wybór, wynikowe zadanie zostanie anulowane. Jeśli jedno ze źródeł ma dostępnych danych, a pomyślnie propaguje do wyboru, wynikowe zadanie zostanie ukończone, po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie zakończy się w <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się za pomocą jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> równa 0 lub 1 do reprezentowania źródła pierwszej lub drugiej, odpowiednio.  
  
Ta metoda zajmie tylko element z jednego z dwóch źródeł danych, nigdy nie oba.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="source2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action2" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwsze źródło.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi do wykonania na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi do wykonania na danych z drugiego źródła.</param>
        <param name="dataflowBlockOptions">Opcje, z którego chcesz skonfigurować ten wybór.</param>
        <summary>Monitoruje dwóch źródeł przepływu danych w celu wywoływania podana Obsługa niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli oba źródła są wykonywane przed ukończenie wybór lub <see cref="T:System.Threading.CancellationToken" /> w ramach <paramref name="dataflowBlockOptions" /> zostanie anulowane przed ukończenie wybór, wynikowe zadanie zostanie anulowane. Jeśli jedno ze źródeł ma dostępnych danych, a pomyślnie propaguje do wyboru, wynikowe zadanie zostanie ukończone, po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie zakończy się w <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się za pomocą jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> równa 0 lub 1 do reprezentowania źródła pierwszej lub drugiej, odpowiednio.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="source2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="dataflowBlockOptions" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2, T3) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2), source3 As ISourceBlock(Of T3), action3 As Action(Of T3)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwsze źródło.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <typeparam name="T3">Określa typ danych zawartych w trzecim źródła.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi do wykonania na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi do wykonania na danych z drugiego źródła.</param>
        <param name="source3">Trzeci źródło.</param>
        <param name="action3">Program obsługi do wykonania na danych z trzeciej źródła.</param>
        <summary>Monitoruje trzech źródeł przepływu danych w celu wywoływania podana Obsługa niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli wszystkie źródła są wykonywane przed ukończenie wybór, wynikowe zadanie zostanie anulowane. Jeśli jedno ze źródeł ma dostępnych danych, a pomyślnie propaguje do wyboru, wynikowe zadanie zostanie ukończone, po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie zakończy się w <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się za pomocą jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> ustawiona na indeks oparty na 0 źródła.  
  
Ta metoda tylko zużyje nigdy nie więcej niż jeden element z jednego ze źródeł danych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="source2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="source3" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action3" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwsze źródło.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <typeparam name="T3">Określa typ danych zawartych w trzecim źródła.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi do wykonania na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi do wykonania na danych z drugiego źródła.</param>
        <param name="source3">Trzeci źródło.</param>
        <param name="action3">Program obsługi do wykonania na danych z trzeciej źródła.</param>
        <param name="dataflowBlockOptions">Opcje, z którego chcesz skonfigurować ten wybór.</param>
        <summary>Monitoruje trzech źródeł przepływu danych w celu wywoływania podana Obsługa niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli wszystkie źródła są wykonywane przed ukończenie wybór lub <see cref="T:System.Threading.CancellationToken" /> w ramach <paramref name="dataflowBlockOptions" /> zostanie anulowane przed ukończenie wybór, wynikowe zadanie zostanie anulowane. Jeśli jedno ze źródeł ma dostępnych danych, a pomyślnie propaguje do wyboru, wynikowe zadanie zostanie ukończone, po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie zakończy się w <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się za pomocą jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> ustawiona na indeks oparty na 0 źródła.  
  
Ta metoda tylko zużyje nigdy nie więcej niż jeden element z jednego ze źródeł danych. Czy zażądano anulowania po otrzymaniu elementu żądanie anulowania zostanie zignorowany, a odpowiedni program obsługi będzie mogła wykonać.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action1" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="source2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action2" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="source3" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="action3" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="dataflowBlockOptions" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encapsulate&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt; Encapsulate&lt;TInput,TOutput&gt; (System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!!TInput, !!TOutput&gt; Encapsulate&lt;TInput, TOutput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate``2(System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Encapsulate(Of TInput, TOutput) (target As ITargetBlock(Of TInput), source As ISourceBlock(Of TOutput)) As IPropagatorBlock(Of TInput, TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;TInput, TOutput&gt; ^ Encapsulate(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Encapsulate : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;'Input, 'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate (target, source)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ danych wejściowych, oczekiwane przez element docelowy.</typeparam>
        <typeparam name="TOutput">Określa typ dane wyjściowe wytwarzane przez źródło.</typeparam>
        <param name="target">Miejsce docelowe do hermetyzacji.</param>
        <param name="source">Źródło do hermetyzacji.</param>
        <summary>Hermetyzuje źródłowe i docelowe do pojedynczego propagator.</summary>
        <returns>Hermetyzowany źródłowe i docelowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Wymaga, aby dwa istniejące bloki: blok docelowy (wystąpienia klasy, która implementuje <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>) i blok źródłowy (wystąpienia klasy, która implementuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>). <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Tworzy nowe wystąpienie klasy wewnętrznej, który nawiązuje połączenie <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsu członkom `target` parametru i <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> interfejsu członkom `source` parametru.  Zarówno <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> i <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> dziedziczyć <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>. Uzupełnianie bloku jawnie jest przekazywany z źródeł do celów. W związku z tym <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> i <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> metody są podłączone do obiektu docelowego podczas <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwość jest podłączony do źródła.  Należy upewnić się, że w przypadku docelowego połowie zakończeniu źródła połowę ukończenia w sposób najbardziej odpowiednie. na przykład:  
  
 `target.Completion.ContinueWith(completion => source.Complete());`  
  
 Lub do propagowania Typ ukończenia, możesz użyć ten kod bardziej zaawansowanych:  
  
```  
target.Completion.ContinueWith(completion => { if (completion.IsFaulted)    
  
((IDataflowBlock)batchBlock).Fault(completion.Exception);   
else   
batchBlock.Complete();   
});  
  
```  
  
 Musi również jawnie określić Propagacja komunikatów z docelowym źródłem. Zaletą tego jawnego połączenia jest, czy zapewnia swobodę wykonywać żadnego przetwarzania nieograniczonego między dwa bloki hermetyzowany. Możesz to zrobić, kodując wymagane przetwarzanie na te bloki delegatów (jeśli bloki delegatów) lub przez osadzanie podrzędnych sieci bloków między nimi. Łatwiejsze sposobem jest użycie bloku, który przyjmuje delegatów; na przykład użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> (jeśli dotyczy), lub niestandardowych bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którym chcesz się łączyć.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> Do połączenia ze źródłem.</param>
        <summary>Linki <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> określonej <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns><see cref="T:System.IDisposable" /> , Podczas wywoływania <see langword="Dispose" />, spowoduje to odłączenie źródła z obiektu docelowego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="target" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którym chcesz się łączyć.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> Do połączenia ze źródłem.</param>
        <param name="predicate">Filtr wiadomości musi przekazać w kolejności na jego propagację ze źródła do docelowego.</param>
        <summary>Linki <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> określonej <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> przy użyciu określonego filtru.</summary>
        <returns><see cref="T:System.IDisposable" /> , Podczas wywoływania <see langword="Dispose" />, spowoduje to odłączenie źródła z obiektu docelowego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="target" /> Jest <see langword="null" />.  
  
—lub— 
<paramref name="predicate" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.DataflowLinkOptions,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), linkOptions As DataflowLinkOptions, predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, linkOptions, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którym chcesz się łączyć.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> Do połączenia ze źródłem.</param>
        <param name="linkOptions">Jedna z wartości wyliczenia, które określa, jak skonfigurować połączenie między bloków przepływu danych.</param>
        <param name="predicate">Filtr wiadomości musi przekazać w kolejności na jego propagację ze źródła do docelowego.</param>
        <summary>Linki <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> określonej <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> przy użyciu określonego filtru.</summary>
        <returns><see cref="T:System.IDisposable" /> , Podczas wywoływania <see langword="Dispose" />, spowoduje to odłączenie źródła z obiektu docelowego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> Ma wartość null (Nothing w języku Visual Basic).  
  
—lub— 
<paramref name="target" /> Ma wartość null (Nothing w języku Visual Basic).  
  
—lub— 
<paramref name="linkOptions" /> Ma wartość null (Nothing w języku Visual Basic).  
  
—lub— 
<paramref name="predicate" /> Ma wartość null (Nothing w języku Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="NullTarget&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; NullTarget&lt;TInput&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; NullTarget&lt;TInput&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget``1" />
      <MemberSignature Language="VB.NET" Value="Public Function NullTarget(Of TInput) () As ITargetBlock(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA; static System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ NullTarget();" />
      <MemberSignature Language="F#" Value="static member NullTarget : unit -&gt; System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TInput">Typ wiadomości, ten blok można zaakceptować.</typeparam>
        <summary>Pobiera blok docelowy, który synchronicznie akceptuje wszystkie komunikaty oferowana do niego i umieszcza je.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> , akceptuje i następnie porzuca wszystkie komunikaty oferowane.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OutputAvailableAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło do monitorowania.</param>
        <summary>Udostępnia <see cref="T:System.Threading.Tasks.Task`1" /> który asynchronicznie monitoruje źródło pod kątem dostępnych danych wyjściowych.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> informuje, czy i kiedy więcej danych wyjściowych jest dostępna. Jeśli po zakończeniu zadania, jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> jest <see langword="true" />, więcej danych wyjściowych jest dostępna w źródle (chociaż innego konsumenta źródła może pobrać danych).  
  
Jeśli zostanie zwrócona <see langword="false" />, więcej danych wyjściowych jest i nigdy nie będą dostępne, ze względu na kończenie źródła przed danych wyjściowych jest dostępna.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło do monitorowania.</param>
        <param name="cancellationToken">Token anulowania, z którą chcesz anulować operację asynchroniczną.</param>
        <summary>Udostępnia <see cref="T:System.Threading.Tasks.Task`1" /> który asynchronicznie monitoruje źródło pod kątem dostępnych danych wyjściowych.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> informuje, czy i kiedy więcej danych wyjściowych jest dostępna. Jeśli po zakończeniu zadania, jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> jest <see langword="true" />, więcej danych wyjściowych jest dostępna w źródle (chociaż innego konsumenta źródła może pobrać danych). Jeśli zostanie zwrócona <see langword="false" />, więcej danych wyjściowych jest i nigdy nie będą dostępne, ze względu na kończenie źródła przed danych wyjściowych jest dostępna.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Post&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static bool Post&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Post&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Post``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Post(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Post(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member Post : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Post (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ danych zaakceptowane przez blok docelowy.</typeparam>
        <param name="target">Blok docelowy.</param>
        <param name="item">Element oferowana do obiektu docelowego.</param>
        <summary>Element do wpisów <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns><see langword="true" /> Jeśli element został zaakceptowany przez blok docelowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwróci po bloku docelowego podjęto decyzję o zaakceptowanie lub odrzucenie elementu, ale chyba że definiowane w przeciwnym razie specjalnych semantykę blok docelowy, go nie czeka na element, aby rzeczywiście być przetwarzane. Adapterem <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zwróci z <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> zaraz po przechował opublikowany element do jego danych wejściowych w kolejce). Z punktu widzenia przetwarzania tego bloku `Post` jest asynchroniczna. Za miejsce docelowe blokuje tej obsługi odracza dostępne komunikaty lub bloków, które może wykonać przetwarzanie większej ilości danych w ich `Post` wdrożenia, należy rozważyć użycie <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A>, która zwróci natychmiast i umożliwi docelowych można odroczyć ogłoszony komunikat i później stosować go po `SendAsync` zwraca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput)) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <summary>Synchronicznie otrzymuje wartość z określonego źródła.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementów można otrzymać ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="cancellationToken">Token, który służy do anulowania operacji odbierania.</param>
        <summary>Synchronicznie otrzymuje wartość z określonego źródła i zawiera token, aby anulować operację.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło oferowane pomyślnie elementu, który został odebrany przez tę operację, zwracany jest ten element, nawet w przypadku wystąpienia na żądanie anulowania współbieżnych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementów można otrzymać ze źródła.</exception>
        <exception cref="T:System.OperationCanceledException">Operacja została anulowana, zanim element został odebrany ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Interwał maksymalny czas (w milisekundach) oczekiwania na zakończenie, synchronicznych operacji lub interwału, który reprezentuje wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Synchronicznie odbiera wartość z określonym źródłem obserwacji opcjonalny limit czasu.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło oferowane pomyślnie elementu, który został odebrany przez tę operację, zwracany jest ten element, nawet w przypadku wystąpienia równoczesne limitu czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.  
  
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementów można otrzymać ze źródła.</exception>
        <exception cref="T:System.TimeoutException">Określony limit czasu upłynął, zanim element został odebrany ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Interwał maksymalny czas (w milisekundach) oczekiwania na zakończenie, synchronicznych operacji lub interwału, który reprezentuje wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <param name="cancellationToken">Token, który służy do anulowania operacji odbierania.</param>
        <summary>Synchronicznie otrzymuje wartość z określonego źródła, zapewniając tokenu, anulować operację i obserwowania opcjonalny limit czasu.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło oferowane pomyślnie wartość elementu, który został odebrany przez tę operację, ta wartość jest zwracana, nawet jeśli wystąpi równoczesnych żądań przekroczenia limitu czasu i anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.  
  
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementów można otrzymać ze źródła.</exception>
        <exception cref="T:System.TimeoutException">Określony limit czasu upłynął, zanim element został odebrany ze źródła.</exception>
        <exception cref="T:System.OperationCanceledException">Operacja została anulowana, zanim element został odebrany ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <summary>Asynchronicznie otrzymuje wartość z określonego źródła.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość elementu została odebrana pomyślnie ze źródła, zwrócone zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca odebranej wartości. Jeśli nie można pobrać wartość elementu, ponieważ źródłem jest pusta i ukończone, <see cref="T:System.InvalidOperationException" /> wyjątek w zwróconym zadaniu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="cancellationToken">Token, który służy do anulowania operacji odbierania.</param>
        <summary>Asynchronicznie otrzymuje wartość z określonego źródła i zawiera token, aby anulować operację.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość została odebrana pomyślnie ze źródła, zwrócone zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca wartość. Jeśli nie można pobrać wartości, ponieważ zażądano anulowania, zwrócone zadanie zostanie anulowane. Jeśli nie można pobrać wartości, ponieważ źródłem jest pusta i ukończone, <see cref="T:System.InvalidOperationException" /> wyjątek w zwróconym zadaniu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Interwał maksymalny czas (w milisekundach) oczekiwania na zakończenie, synchronicznych operacji lub interwału, który reprezentuje wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Asynchronicznie odbiera wartość z określonym źródłem obserwacji opcjonalny limit czasu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość została odebrana pomyślnie ze źródła, zwrócone zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca wartość. Jeśli nie można pobrać wartości, ponieważ upływie limitu czasu, zwrócone zadanie zostanie anulowane. Jeśli nie można pobrać wartości, ponieważ źródłem jest pusta i ukończone, <see cref="T:System.InvalidOperationException" /> wyjątek w zwróconym zadaniu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.  
  
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Interwał maksymalny czas (w milisekundach) oczekiwania na zakończenie, synchronicznych operacji lub interwału, który reprezentuje wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <param name="cancellationToken">Token, który może służyć do anulowania operacji odbierania.</param>
        <summary>Asynchronicznie otrzymuje wartość z określonego źródła, zapewniając tokenu, anulować operację i obserwowania opcjonalny limit czasu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość została odebrana pomyślnie ze źródła, zwrócone zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca wartość. Jeśli nie można pobrać wartości, ponieważ upływie limitu czasu lub zażądano anulowania, zwrócone zadanie zostanie anulowane. Jeśli nie można pobrać wartości, ponieważ źródłem jest pusta i ukończone, <see cref="T:System.InvalidOperationException" /> wyjątek w zwróconym zadaniu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu.  
  
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SendAsync(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ dane do przesłania do obiektu docelowego.</typeparam>
        <param name="target">Obiekt docelowy, do którego ma zostać wysyłania danych.</param>
        <param name="item">Element oferowana do obiektu docelowego.</param>
        <summary>Asynchronicznie oferuje komunikat miejsce docelowe bloku komunikatów, dzięki czemu dla opóźnienia.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący asynchronicznego wysyłania. Jeśli element docelowy akceptuje i zużywa oferowane elementu podczas wywołania <see cref="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />, od zwrotu z wywołania wynikowy <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończona i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwróci właściwości <see langword="true" />. Jeśli element docelowy odmówi oferowane elementu podczas wywołania, od zwrotu z wywołania wynikowy <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończona i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwróci właściwość <see langword="false" />. Jeśli element docelowy odłoży oferowane elementu, element będą buforowane do czasu zużywa lub zwalnia go w tym momencie zadanie zostanie ukończone, docelowe z jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> wskazującą, czy komunikat został wykorzystany. Jeśli element docelowy nigdy nie próbuje używają lub wersji wiadomości, zwrócone zadanie nigdy nie zostanie ukończone.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ dane do przesłania do obiektu docelowego.</typeparam>
        <param name="target">Obiekt docelowy, do którego ma zostać wysyłania danych.</param>
        <param name="item">Element oferowana do obiektu docelowego.</param>
        <param name="cancellationToken">Token anulowania, z którą ma zostać żądanie anulowania operacji wysyłania.</param>
        <summary>Asynchronicznie oferuje komunikat miejsce docelowe bloku komunikatów, dzięki czemu dla opóźnienia.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący asynchronicznego wysyłania.  Jeśli element docelowy akceptuje i wykorzystuje oferowane elementu podczas wywołania SendAsync, po zwrócić z wywołania wynikowy <see cref="T:System.Threading.Tasks.Task`1" /> zakończy się i jego <c>wynik</c> właściwość zostanie zwrócona wartość PRAWDA.  Jeśli element docelowy odmówi oferowane elementu podczas wywołania, od zwrotu z wywołania wynikowy <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończona i jego <c>wynik</c> właściwość zwraca wartość false. Jeśli element docelowy odłoży oferowane elementu, element będą buforowane do czasu zużywa lub zwalnia go w tym momencie zadanie zostanie ukończone, docelowe z jego <c>wynik</c> wskazującą, czy komunikat został wykorzystany. Jeśli element docelowy nigdy nie próbuje używają lub wersji wiadomości, zwrócone zadanie nigdy nie zostanie ukończone.  
  
Czy zażądano anulowania, zanim obiekt docelowy zużyła pomyślnie wysłane dane, zwrócone zadanie zostanie ukończone ze stanem anulowane, a danych nie będzie już dostępna do obiektu docelowego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> Ma wartość null (Nothing w języku Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static bool TryReceive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt; source, out TOutput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReceive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!!TOutput&gt; source, [out] !!TOutput&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive``1(System.Threading.Tasks.Dataflow.IReceivableSourceBlock{``0},``0@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryReceive(Of TOutput) (source As IReceivableSourceBlock(Of TOutput), ByRef item As TOutput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryReceive(System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;TOutput&gt; ^ source, [Runtime::InteropServices::Out] TOutput % item);" />
      <MemberSignature Language="F#" Value="static member TryReceive : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;'Output&gt; *  -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="item" Type="TOutput" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych znajdujących się w źródle.</typeparam>
        <param name="source">Źródło, z którego ma zostać wyświetlony.</param>
        <param name="item">Element, który otrzymał ze źródła.</param>
        <summary>Próby uzyskania synchronicznego elementu z <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns><see langword="true" /> Jeśli element może być; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie poczekaj, aż źródło nie zawiera element, aby zapewnić.  
  
 Zwróci informację określającą, czy element była dostępna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DataflowBlock" FullName="System.Threading.Tasks.Dataflow.DataflowBlock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f558bf9a029763285a5fd334c30a979714b81d23" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36606939" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class DataflowBlock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DataflowBlock extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.DataflowBlock" />
  <TypeSignature Language="VB.NET" Value="Public Module DataflowBlock" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataflowBlock abstract sealed" />
  <TypeSignature Language="F#" Value="type DataflowBlock = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera zestaw metody statyczne (Shared w języku Visual Basic) do pracy z bloków przepływu danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsObservable&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IObservable&lt;TOutput&gt; AsObservable&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObservable`1&lt;!!TOutput&gt; AsObservable&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObservable(Of TOutput) (source As ISourceBlock(Of TOutput)) As IObservable(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObservable&lt;TOutput&gt; ^ AsObservable(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsObservable : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; IObservable&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObservable&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło do zakodowania.</param>
        <summary>Tworzy nowy <see cref="T:System.IObservable`1" /> abstrakcji za pośrednictwem <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns>
          <see cref="T:System.IObservable`1" /> , Który umożliwia obserwatorów do subskrypcji źródłowej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsObserver&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static IObserver&lt;TInput&gt; AsObserver&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObserver`1&lt;!!TInput&gt; AsObserver&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObserver(Of TInput) (target As ITargetBlock(Of TInput)) As IObserver(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObserver&lt;TInput&gt; ^ AsObserver(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member AsObserver : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; -&gt; IObserver&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObserver&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ danych wejściowych zaakceptowane przez blok docelowy.</typeparam>
        <param name="target">Element docelowy do zakodowania.</param>
        <summary>Tworzy nowy <see cref="T:System.IObserver`1" /> abstrakcji za pośrednictwem <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns>Obserwator opakowuje blok docelowy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwszym źródła.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi, można wykonać na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi ma zostać wykonane na danych z drugiego źródła.</param>
        <summary>Monitoruje dwóch źródeł przepływu danych, wywoływania podanego programu obsługi dla niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli wykonaniu obu źródeł przed Kończenie wybór zadaniu wynikowym zostanie anulowane. Gdy jedno ze źródeł danych i pomyślnie propaguje do wyboru, zadaniu wynikowym ukończy po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie będzie kończyć się <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się z jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> ustawione na 0 lub 1, aby reprezentować odpowiednio źródło pierwszej lub drugiej.  Ta metoda zajmie tylko element na podstawie jednej z dwóch źródeł danych, nigdy nie oba.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> Jest <see langword="null" />.  - lub - <paramref name="action1" /> jest <see langword="null" />.  - lub - <paramref name="source2" /> jest <see langword="null" />.  - lub - <paramref name="action2" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwszym źródła.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi, można wykonać na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi ma zostać wykonane na danych z drugiego źródła.</param>
        <param name="dataflowBlockOptions">Opcje, z której chcesz skonfigurować ten wybór.</param>
        <summary>Monitoruje dwóch źródeł przepływu danych, wywoływania podanego programu obsługi dla niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli obu źródeł zostały zakończone przed Kończenie wybór lub <see cref="T:System.Threading.CancellationToken" /> w ramach <paramref name="dataflowBlockOptions" /> zostało anulowane przed zakończeniu wyboru zostanie anulowane zadaniu wynikowym. Gdy jedno ze źródeł danych i pomyślnie propaguje do wyboru, zadaniu wynikowym ukończy po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie będzie kończyć się <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się z jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> ustawione na 0 lub 1, aby reprezentować odpowiednio źródło pierwszej lub drugiej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> Jest <see langword="null" />.  - lub - <paramref name="action1" /> jest <see langword="null" />.  - lub - <paramref name="source2" /> jest <see langword="null" />.  - lub - <paramref name="action2" /> jest <see langword="null" />.  - lub - <paramref name="dataflowBlockOptions" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2, T3) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2), source3 As ISourceBlock(Of T3), action3 As Action(Of T3)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwszym źródła.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <typeparam name="T3">Określa typ danych zawartych w źródle trzecich.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi, można wykonać na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi ma zostać wykonane na danych z drugiego źródła.</param>
        <param name="source3">Trzeci źródło.</param>
        <param name="action3">Program obsługi do wykonania na danych z źródła trzecich.</param>
        <summary>Monitoruje trzech źródeł przepływu danych, wywoływania podanego programu obsługi dla niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli wszystkie źródła są wykonywane przed Kończenie wybór, wynikowy zadania zostanie anulowane. Gdy jedno ze źródeł danych i pomyślnie propaguje do wyboru, zadaniu wynikowym ukończy po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie będzie kończyć się <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się z jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> ustawiona na podstawie 0 indeks źródła.  Ta metoda tylko zużyje nigdy nie więcej niż jeden element z jednego ze źródeł danych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> Jest <see langword="null" />.  - lub - <paramref name="action1" /> jest <see langword="null" />.  - lub - <paramref name="source2" /> jest <see langword="null" />.  - lub - <paramref name="action2" /> jest <see langword="null" />.  - lub - <paramref name="source3" /> jest <see langword="null" />.  - lub - <paramref name="action3" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Określa typ danych zawartych w pierwszym źródła.</typeparam>
        <typeparam name="T2">Określa typ danych zawartych w drugie źródło.</typeparam>
        <typeparam name="T3">Określa typ danych zawartych w źródle trzecich.</typeparam>
        <param name="source1">Pierwsze źródło.</param>
        <param name="action1">Program obsługi, można wykonać na danych z pierwszego źródła.</param>
        <param name="source2">Drugie źródło.</param>
        <param name="action2">Program obsługi ma zostać wykonane na danych z drugiego źródła.</param>
        <param name="source3">Trzeci źródło.</param>
        <param name="action3">Program obsługi do wykonania na danych z źródła trzecich.</param>
        <param name="dataflowBlockOptions">Opcje, z której chcesz skonfigurować ten wybór.</param>
        <summary>Monitoruje trzech źródeł przepływu danych, wywoływania podanego programu obsługi dla niezależnie od źródła udostępnia dane najpierw.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący wybór asynchronicznego. Jeśli wszystkie źródła są wykonywane przed Kończenie wybór lub <see cref="T:System.Threading.CancellationToken" /> w ramach <paramref name="dataflowBlockOptions" /> zostało anulowane przed zakończeniu wyboru zostanie anulowane zadaniu wynikowym. Gdy jedno ze źródeł danych i pomyślnie propaguje do wyboru, zadaniu wynikowym ukończy po zakończeniu obsługi; Jeśli program obsługi zgłasza wyjątek, zadanie będzie kończyć się <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i będzie zawierać nieobsługiwany wyjątek. W przeciwnym razie zadanie zakończy się z jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> ustawiona na podstawie 0 indeks źródła.  Ta metoda tylko zużyje nigdy nie więcej niż jeden element z jednego ze źródeł danych. Jeśli żądanie anulowania po otrzymaniu elementu, żądanie anulowania zostanie zignorowany, a odpowiedni program obsługi będzie można wykonać operacji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> Jest <see langword="null" />.  - lub - <paramref name="action1" /> jest <see langword="null" />.  - lub - <paramref name="source2" /> jest <see langword="null" />.  - lub - <paramref name="action2" /> jest <see langword="null" />.  - lub - <paramref name="source3" /> jest <see langword="null" />.  - lub - <paramref name="action3" /> jest <see langword="null" />.  - lub - <paramref name="dataflowBlockOptions" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encapsulate&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt; Encapsulate&lt;TInput,TOutput&gt; (System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!!TInput, !!TOutput&gt; Encapsulate&lt;TInput, TOutput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate``2(System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Encapsulate(Of TInput, TOutput) (target As ITargetBlock(Of TInput), source As ISourceBlock(Of TOutput)) As IPropagatorBlock(Of TInput, TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;TInput, TOutput&gt; ^ Encapsulate(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Encapsulate : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;'Input, 'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate (target, source)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ wprowadzania danych przez element docelowy.</typeparam>
        <typeparam name="TOutput">Określa typ dane wyjściowe generowane przez źródło.</typeparam>
        <param name="target">Element docelowy w celu hermetyzacji.</param>
        <param name="source">Źródło w celu hermetyzacji.</param>
        <summary>Hermetyzuje źródłowe i docelowe do pojedynczego propagator.</summary>
        <returns>Hermetyzowany źródłowe i docelowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Metoda wymaga dwóch bloków istniejących: bloku docelowego (wystąpienia klasy, która implementuje <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>) i bloku źródłowego (wystąpienia klasy, która implementuje <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>). <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Tworzy nowe wystąpienie klasy wewnętrzna, która łączy <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfejsu członków do `target` parametru i <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> interfejsu członkom `source` parametru.  Zarówno <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> i <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> pochodzi od <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>. Bloku ukończenia jawnie jest przekazywany z źródeł do obiektów docelowych. W związku z tym <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> i <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> metody są połączone z docelowymi podczas <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> właściwości jest podłączony do źródła.  Należy upewnić się, że w przypadku docelowej połowy zakończeniu źródło połowy pobiera ukończone w najbardziej odpowiedni sposób; na przykład:  
  
 `target.Completion.ContinueWith(completion => source.Complete());`  
  
 Lub propagację Typ ukończenia należy użyć tego dokładniejsze kodu:  
  
```  
target.Completion.ContinueWith(completion => { if (completion.IsFaulted) 3   
  
((IDataflowBlock)batchBlock).Fault(completion.Exception);   
else   
batchBlock.Complete();   
});  
  
```  
  
 Należy podać również jawnie propagacji wiadomości z docelowym źródłem. Korzyści wynikające z tego połączenia jawne jest, że daje swobody żadnych nieograniczonego przetwarzania między dwa bloki hermetyzowany. Użytkownik może zrobić kodowanie konieczne przetwarzanie na bloki delegatów (jeśli bloki potrwać delegatów) lub osadzania podrzędne sieci bloków między nimi. Łatwiejsze sposobem jest użycie bloku pobierającej obiektów delegowanych; na przykład użyć <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> (jeśli dotyczy), lub niestandardowy bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którym chcesz się łączyć.</param>
        <param name="target">
          <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> Do połączenia ze źródłem.</param>
        <summary>Łącza <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> do określonego <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns>
          <see cref="T:System.IDisposable" /> , Która po wywołaniu <see langword="Dispose" />, będą rozłączyć źródła z elementem docelowym.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Jest <see langword="null" />.  - lub - <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którym chcesz się łączyć.</param>
        <param name="target">
          <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> Do połączenia ze źródłem.</param>
        <param name="predicate">Filtr komunikatu należy przekazać w kolejności na jego propagację ze źródła do obiektu docelowego.</param>
        <summary>Łącza <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> do określonego <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> przy użyciu określonego filtru.</summary>
        <returns>
          <see cref="T:System.IDisposable" /> , Która po wywołaniu <see langword="Dispose" />, będą rozłączyć źródła z elementem docelowym.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Jest <see langword="null" />.  - lub - <paramref name="target" /> jest <see langword="null" />.  - lub - <paramref name="predicate" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.DataflowLinkOptions,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), linkOptions As DataflowLinkOptions, predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, linkOptions, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którym chcesz się łączyć.</param>
        <param name="target">
          <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> Do połączenia ze źródłem.</param>
        <param name="linkOptions">Jedna z wartości wyliczenia, które określa, jak skonfigurować połączenie między bloków przepływu danych.</param>
        <param name="predicate">Filtr komunikatu należy przekazać w kolejności na jego propagację ze źródła do obiektu docelowego.</param>
        <summary>Łącza <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> do określonego <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> przy użyciu określonego filtru.</summary>
        <returns>
          <see cref="T:System.IDisposable" /> , Która po wywołaniu <see langword="Dispose" />, będą rozłączyć źródła z elementem docelowym.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Ma wartość null (Nothing w języku Visual Basic).  - lub - <paramref name="target" /> ma wartość null (Nothing w języku Visual Basic).  - lub - <paramref name="linkOptions" /> ma wartość null (Nothing w języku Visual Basic).  - lub - <paramref name="predicate" /> ma wartość null (Nothing w języku Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="NullTarget&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; NullTarget&lt;TInput&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; NullTarget&lt;TInput&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget``1" />
      <MemberSignature Language="VB.NET" Value="Public Function NullTarget(Of TInput) () As ITargetBlock(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA; static System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ NullTarget();" />
      <MemberSignature Language="F#" Value="static member NullTarget : unit -&gt; System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TInput">Typ wiadomości, który może zaakceptować tego bloku.</typeparam>
        <summary>Pobiera blok docelowy, który synchronicznie akceptuje wszystkie komunikaty oferowane do niego i porzuca je.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> akceptuje i następnie porzuca wszystkie komunikaty oferowany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OutputAvailableAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło do monitorowania.</param>
        <summary>Udostępnia <see cref="T:System.Threading.Tasks.Task`1" /> który monitoruje asynchronicznie źródła dla dostępnych danych wyjściowych.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> który informuje o tym, czy i kiedy dostępnych jest więcej danych wyjściowych. Jeśli po zakończeniu wykonywania zadania, jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> jest <see langword="true" />, moc jest dostępne w źródle (chociaż innego konsumenta źródła może pobrać danych).  Jeśli zmienna zwraca <see langword="false" />, moc jest i nigdy nie będą dostępne z powodu Kończenie źródła przed wyjściowy jest dostępny.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło do monitorowania.</param>
        <param name="cancellationToken">Token anulowania, z którą chcesz anulować operację asynchroniczną.</param>
        <summary>Udostępnia <see cref="T:System.Threading.Tasks.Task`1" /> który monitoruje asynchronicznie źródła dla dostępnych danych wyjściowych.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> który informuje o tym, czy i kiedy dostępnych jest więcej danych wyjściowych. Jeśli po zakończeniu wykonywania zadania, jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> jest <see langword="true" />, moc jest dostępne w źródle (chociaż innego konsumenta źródła może pobrać danych). Jeśli zmienna zwraca <see langword="false" />, moc jest i nigdy nie będą dostępne z powodu Kończenie źródła przed wyjściowy jest dostępny.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Post&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static bool Post&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Post&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Post``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Post(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Post(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member Post : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Post (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ danych zaakceptowane przez blok docelowy.</typeparam>
        <param name="target">Blok docelowy.</param>
        <param name="item">Element oferowany do obiektu docelowego.</param>
        <summary>Zapisuje element, aby <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli element został zaakceptowany przez blok docelowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwróci po blok docelowy podjęto decyzję o zaakceptowanie lub odrzucenie elementu, ale chyba, że inaczej ustawieniem specjalne semantykę docelowy blok, nie oczekiwania dla elementu faktycznie przetwarzania. For example <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zwróci z <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> jak przechowywanych przesłanego elementu do jego danych wejściowych w kolejce). Z punktu widzenia przetwarzania bloku `Post` jest asynchroniczne. Blokuje docelowego tej obsługi opóźnienia oferowane wiadomości, lub dla bloków, które może wykonać większe obciążenie ich `Post` implementacji, należy rozważyć użycie <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A>, który zwróci natychmiast i włączy docelowej odłożyć komunikatów oczekujących na opublikowanie i później pobrać go po `SendAsync` zwraca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput)) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <summary>Synchronicznie odbiera wartość z określonego źródła.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementu można otrzymać ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="cancellationToken">Token do użycia, aby anulować operację odbierania.</param>
        <summary>Synchronicznie odbiera wartość z określonego źródła i zapewnia token, aby anulować operację.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło oferowane pomyślnie elementu, które zostały odebrane przez tę operację, zwracany jest tego elementu, nawet jeśli wystąpi żądanie anulowania równoczesnych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementu można otrzymać ze źródła.</exception>
        <exception cref="T:System.OperationCanceledException">Operacja została anulowana, zanim Odebrano element ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Maksymalny czas, w milisekundach, poczekaj na zakończenie, synchronicznych operacji lub przedziale czasu, który reprezentuje-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Synchronicznie odbiera wartość z określonego źródła obserwowania opcjonalne limitu czasu.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło oferowane pomyślnie elementu, które zostały odebrane przez tę operację, ten element jest zwracane, nawet jeśli równoczesnych przekroczenia limitu czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończonego limitu czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementu można otrzymać ze źródła.</exception>
        <exception cref="T:System.TimeoutException">Określony limit czasu upłynął, zanim Odebrano element ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Maksymalny czas, w milisekundach, poczekaj na zakończenie, synchronicznych operacji lub przedziale czasu, który reprezentuje-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <param name="cancellationToken">Token do użycia, aby anulować operację odbierania.</param>
        <summary>Synchronicznie odbiera wartość z określonego źródła, zapewniając token, aby anulować operację i obserwowania opcjonalne limitu czasu.</summary>
        <returns>Odebrano wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło oferowane pomyślnie wartość elementu, które zostały odebrane przez tę operację, ta wartość jest zwracana, nawet jeśli wystąpi żądanie równoczesnych przekroczenia limitu czasu i anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończonego limitu czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak elementu można otrzymać ze źródła.</exception>
        <exception cref="T:System.TimeoutException">Określony limit czasu upłynął, zanim Odebrano element ze źródła.</exception>
        <exception cref="T:System.OperationCanceledException">Operacja została anulowana, zanim Odebrano element ze źródła.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <summary>Asynchronicznie odbiera wartość z określonego źródła.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość elementu została odebrana pomyślnie ze źródła, zwracane zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca odebranej wartości. Jeśli nie można pobrać wartości elementu, ponieważ źródło jest puste i zakończonych, <see cref="T:System.InvalidOperationException" /> wyjątek zwrócony zadań.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="cancellationToken">Token do użycia, aby anulować operację odbierania.</param>
        <summary>Asynchronicznie odbiera wartość z określonego źródła i zapewnia token, aby anulować operację.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość została odebrana pomyślnie ze źródła, zwracane zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca wartość. Jeśli nie można pobrać wartości, ponieważ zażądano anulowania, zwracane zadanie zostało anulowane. Jeśli nie można pobrać wartości, ponieważ źródło jest puste i zakończonych, <see cref="T:System.InvalidOperationException" /> wyjątek zwrócony zadań.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Maksymalny czas, w milisekundach, poczekaj na zakończenie, synchronicznych operacji lub przedziale czasu, który reprezentuje-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Asynchronicznie odbiera wartość z określonego źródła obserwowania opcjonalne limitu czasu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość została odebrana pomyślnie ze źródła, zwracane zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca wartość. Jeśli nie można pobrać wartości, ponieważ limit czasu, zwracane zadanie zostało anulowane. Jeśli nie można pobrać wartości, ponieważ źródło jest puste i zakończonych, <see cref="T:System.InvalidOperationException" /> wyjątek zwrócony zadań.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończonego limitu czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego można uzyskać wartości.</param>
        <param name="timeout">Maksymalny czas, w milisekundach, poczekaj na zakończenie, synchronicznych operacji lub przedziale czasu, który reprezentuje-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <param name="cancellationToken">Token, który może służyć do anulowania operacji odbierania.</param>
        <summary>Asynchronicznie odbiera wartość z określonego źródła, zapewniając token, aby anulować operację i obserwowania opcjonalne limitu czasu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odbioru. Jeśli wartość została odebrana pomyślnie ze źródła, zwracane zadanie zostało ukończone i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> zwraca wartość. Jeśli nie można pobrać wartości, ponieważ limit czasu wygasł lub zażądano anulowania, zwracane zadanie zostało anulowane. Jeśli nie można pobrać wartości, ponieważ źródło jest puste i zakończonych, <see cref="T:System.InvalidOperationException" /> wyjątek zwrócony zadań.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończonego limitu czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SendAsync(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ dane do przesłania do obiektu docelowego.</typeparam>
        <param name="target">Obiekt docelowy, do którego można wysłać danych.</param>
        <param name="item">Element oferowany do obiektu docelowego.</param>
        <summary>Asynchronicznie oferuje komunikat dla bloku komunikatów docelowych, co pozwala na opóźnienia.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący asynchronicznego wysyłania. Jeśli element docelowy akceptuje i wykorzystuje podczas wywołania elementu oferowany <see cref="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />, po zwracany z wywołania powstałe w ten sposób <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończona i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> właściwość, którą będzie zwracać <see langword="true" />. Jeśli element docelowy odmawia oferowany elementu podczas wywołania, po zwracany z wywołania powstałe w ten sposób <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończona i jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> właściwość, którą będzie zwracać <see langword="false" />. Jeśli element docelowy odłoży oferowany elementu, element będą buforowane do czasu zużywa lub zwalnia go w takim przypadku ukończy zadanie, docelowe z jego <see cref="P:System.Threading.Tasks.Task`1.Result" /> wskazującą, czy wiadomość została wykorzystana. Jeśli element docelowy nigdy nie próbuje używają lub wersji wiadomości, zadanie zwrócone nigdy nie zostanie ukończona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Określa typ dane do przesłania do obiektu docelowego.</typeparam>
        <param name="target">Obiekt docelowy, do którego można wysłać danych.</param>
        <param name="item">Element oferowany do obiektu docelowego.</param>
        <param name="cancellationToken">Token anulowania, z którą ma zostać żądanie anulowania operacji wysyłania.</param>
        <summary>Asynchronicznie oferuje komunikat dla bloku komunikatów docelowych, co pozwala na opóźnienia.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> reprezentujący asynchronicznego wysyłania.  Jeśli element docelowy akceptuje i wykorzystuje oferowany elementu podczas wywołania SendAsync, po zwracany z wywołania powstałe w ten sposób <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończone i jego <c>wynik</c> właściwości zwróci wartość true.  Jeśli element docelowy odmawia oferowany elementu podczas wywołania, po zwracany z wywołania powstałe w ten sposób <see cref="T:System.Threading.Tasks.Task`1" /> zostanie ukończona i jego <c>wynik</c> właściwości zwróci wartość false. Jeśli element docelowy odłoży oferowany elementu, element będą buforowane do czasu zużywa lub zwalnia go w takim przypadku ukończy zadanie, docelowe z jego <c>wynik</c> wskazującą, czy wiadomość została wykorzystana. Jeśli element docelowy nigdy nie próbuje używają lub wersji wiadomości, zadanie zwrócone nigdy nie zostanie ukończona.  Jeśli żądanie anulowania przed elementem docelowym zużyła pomyślnie wysłane dane, zwracane zadań zakończy się w stanie anulowane i dane nie będą dostępne do obiektu docelowego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> Ma wartość null (Nothing w języku Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static bool TryReceive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt; source, out TOutput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReceive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!!TOutput&gt; source, [out] !!TOutput&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive``1(System.Threading.Tasks.Dataflow.IReceivableSourceBlock{``0},``0@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryReceive(Of TOutput) (source As IReceivableSourceBlock(Of TOutput), ByRef item As TOutput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryReceive(System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;TOutput&gt; ^ source, [Runtime::InteropServices::Out] TOutput % item);" />
      <MemberSignature Language="F#" Value="static member TryReceive : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;'Output&gt; *  -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="item" Type="TOutput&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Określa typ danych zawartych w źródle.</typeparam>
        <param name="source">Źródło, z którego ma zostać wyświetlony.</param>
        <param name="item">Element odebranych ze źródła.</param>
        <summary>Próbuje synchronicznie odbierania element <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli element może być odebrany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie poczekaj, aż źródło ma element, aby zapewnić.  
  
 Element był dostępny lub nie zostanie zwrócone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
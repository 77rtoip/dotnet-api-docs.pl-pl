<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a828f52f868e838b613c6f4b5659fdd536130220" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36605880" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia operacji niepodzielnych w przypadku zmiennych, które są współużytkowane przez wiele wątków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody tej klasy pomóc zapewnić ochronę przed błędami występującymi podczas planista zmienia kontekstów, gdy wątek jest aktualizowana zmiennej dostępnej przez inne wątki lub dwoma wątkami są wykonywane jednocześnie na oddzielnych procesorów. Elementy członkowskie tej klasy nie zgłaszają wyjątki.  
  
 <xref:System.Threading.Interlocked.Increment%2A> i <xref:System.Threading.Interlocked.Decrement%2A> metody zwiększyć lub zmniejszyć zmienną i przechowywać wartość wynikową w ramach jednej operacji. W przypadku większości komputerów o wartości zmiennej nie jest operacją niepodzielną wymagające następujące czynności:  
  
1.  Ładowanie wartości z zmienna wystąpienia do rejestru.  
  
2.  Zwiększyć lub zmniejszyć wartość.  
  
3.  Przechowywanie wartości w zmiennej wystąpienia.  
  
 Jeśli nie używasz <xref:System.Threading.Interlocked.Increment%2A> i <xref:System.Threading.Interlocked.Decrement%2A>, może być wywłaszczony wątku po wykonaniu pierwsze dwa kroki. Inny wątek można następnie wykonać wszystkie trzy kroki. Po pierwszym wątkiem wznawia wykonywanie, zastępuje on wartość w zmiennej wystąpienia i inkrementacji lub dekrementacji wykonywane przez wątek drugi powoduje utratę.  
  
 <xref:System.Threading.Interlocked.Exchange%2A> Metody atomowo zamienia wartości określonych zmiennych. <xref:System.Threading.Interlocked.CompareExchange%2A> Metoda obejmuje dwie operacje: porównanie dwóch wartości i przechowywania innej wartości w jednej ze zmiennych, w oparciu o wyniki porównania. Jako operacją niepodzielną wykonywane są operacje porównania i exchange.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje mechanizm blokowania zasobu wątkowo.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje dwie liczb całkowitych i zastępuje sum, jako operacją niepodzielną pierwszej liczby całkowitej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienną zawierającą pierwszą wartość do dodania. Suma dwóch wartości są przechowywane w <c>location1</c>.</param>
        <param name="value">Wartość do dodania do liczby całkowitej na <c>location1</c>.</param>
        <summary>Dodaje dwa 32-bitowych liczb całkowitych i zastępuje sum, jako operacją niepodzielną pierwszej liczby całkowitej.</summary>
        <returns>Nowa wartość przechowywana w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje nastąpiło przepełnienie zawijania: Jeśli wartość `location1` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType> i `value` 1, wynikiem jest <xref:System.Int32.MinValue?displayProperty=nameWithType>; Jeśli `value` 2, wynikiem jest (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); i tak dalej. Nie wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienną zawierającą pierwszą wartość do dodania. Suma dwóch wartości są przechowywane w <c>location1</c>.</param>
        <param name="value">Wartość do dodania do liczby całkowitej na <c>location1</c>.</param>
        <summary>Dodaje dwa 64-bitowych liczb całkowitych i zastępuje sum, jako operacją niepodzielną pierwszej liczby całkowitej.</summary>
        <returns>Nowa wartość przechowywana w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje nastąpiło przepełnienie zawijania: Jeśli wartość `location1` jest <xref:System.Int64.MaxValue?displayProperty=nameWithType> i `value` 1, wynikiem jest <xref:System.Int64.MinValue?displayProperty=nameWithType>; Jeśli `value` 2, wynikiem jest (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); i tak dalej. Nie wyjątek.  
  
 <xref:System.Threading.Interlocked.Read%2A> — Metoda i 64-bitowych przeciążeń <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, i <xref:System.Threading.Interlocked.Add%2A> metody są naprawdę atomic tylko w systemach gdzie <xref:System.IntPtr?displayProperty=nameWithType> jest 64 bitów. W innych systemach te metody są atomic w odniesieniu do siebie, ale nie w odniesieniu do innych środków dostęp do danych. W związku z tym, aby zapewniać bezpieczeństwo wątkowe w systemach 32-bitowych, dostęp do 64-bitową wartość musi być wprowadzane za pośrednictwem członków <xref:System.Threading.Interlocked> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje dwie wartości pod kątem równości i, jeśli są one takie same, zastępuje pierwszej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">Miejsce docelowe, którego wartość jest porównywana z <c>wzorzec</c> i ewentualnie zamieniany.</param>
        <param name="value">Wartość, która zastąpi wartość docelowego, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">Wartość, która jest porównywana z wartością w <c>location1</c>.</param>
        <summary>Porównuje dwa podwójnej precyzji liczby zmiennoprzecinkowe równości i, jeśli są one takie same, zastępuje pierwszej wartości.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i wartość w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Jako operacją niepodzielną wykonywane są operacje porównania i exchange. Wartość zwracana <xref:System.Threading.Interlocked.CompareExchange%2A> jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano metodę wątkowo, która gromadzi sumę <xref:System.Double> wartości. Dwoma wątkami dodać serii <xref:System.Double> wartości przy użyciu metody wątkowo i zwykłe Dodawanie i po ukończeniu wątki sumy są porównywane. Na komputerze, dwuprocesorowy Brak znaczące różnice dotyczące sum.  
  
 W metodzie wątkowo jest zapisywany początkowej wartości całkowitej uruchomiona, a następnie <xref:System.Threading.Interlocked.CompareExchange%2A> metoda jest używana do programu exchange do nowo obliczona ogólnej starego łączną liczbę. Jeśli wartości zwracanej nie jest równa wartości zapisane sumy, następnie inny wątek został zaktualizowany łączną liczbę w tym samym czasie. W takim przypadku należy powtórzyć próby zaktualizowania sumy bieżącej.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Miejsce docelowe, którego wartość jest porównywana z <c>wzorzec</c> i ewentualnie zamieniany.</param>
        <param name="value">Wartość, która zastąpi wartość docelowego, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">Wartość, która jest porównywana z wartością w <c>location1</c>.</param>
        <summary>Porównuje dwa 32-bitowych liczb całkowitych ze znakiem równości i, jeśli są one takie same, zastępuje pierwszej wartości.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i wartość w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Jako operacją niepodzielną wykonywane są operacje porównania i exchange. Wartość zwracana <xref:System.Threading.Interlocked.CompareExchange%2A> jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano metodę wątkowo, która gromadzi sumy bieżącej. Początkowa wartość całkowita uruchomiona jest zapisywany, a następnie <xref:System.Threading.Interlocked.CompareExchange%2A> metoda jest używana do programu exchange do nowo obliczona ogólnej starego łączną liczbę. Jeśli wartości zwracanej nie jest równa wartości zapisane sumy, następnie inny wątek został zaktualizowany łączną liczbę w tym samym czasie. W takim przypadku należy powtórzyć próby zaktualizowania sumy bieżącej.  
  
> [!NOTE]
>  <xref:System.Threading.Interlocked.Add%2A> Metoda, wprowadzonych w wersji 2.0 programu .NET Framework zapewnia więcej wygodny sposób gromadzone wątkowo uruchomionych sumy liczb całkowitych.  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Miejsce docelowe, którego wartość jest porównywana z <c>wzorzec</c> i ewentualnie zamieniany.</param>
        <param name="value">Wartość, która zastąpi wartość docelowego, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">Wartość, która jest porównywana z wartością w <c>location1</c>.</param>
        <summary>Porównuje dwa 64-bitowych liczb całkowitych ze znakiem równości i, jeśli są one takie same, zastępuje pierwszej wartości.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i wartość w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Jako operacją niepodzielną wykonywane są operacje porównania i exchange. Wartość zwracana <xref:System.Threading.Interlocked.CompareExchange%2A> jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">Miejsce docelowe <see cref="T:System.IntPtr" />, którego wartość jest porównywana z wartością <c>wzorzec</c> i ewentualnie zamieniany przez <c>wartość</c>.</param>
        <param name="value">
          <see cref="T:System.IntPtr" /> Zastępuje wartość docelowego, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">
          <see cref="T:System.IntPtr" /> Który jest porównywana z wartością w <c>location1</c>.</param>
        <summary>Porównuje dwa uchwyty specyficzne dla platformy lub wskaźniki równości i czy są równe, zastępuje pierwsza z nich.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i wartość w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Jako operacją niepodzielną wykonywane są operacje porównania i exchange. Wartość zwracana ta metoda jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
> [!NOTE]
>  <xref:System.IntPtr> jest to typ specyficzne dla platformy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Obiekt docelowy, który jest porównywany ze <c>wzorzec</c> i ewentualnie zamieniany.</param>
        <param name="value">Obiekt, który zastępuje obiekt docelowy, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">Obiekt, który jest porównywany z obiektem <c>location1</c>.</param>
        <summary>Porównuje dwa obiekty pod kątem równości odwołań oraz czy są równe, zastępuje pierwszy obiekt.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i obiektu w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Jako operacją niepodzielną wykonywane są operacje porównania i exchange. Wartość zwracana <xref:System.Threading.Interlocked.CompareExchange%2A> jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
 Od programu .NET Framework w wersji 2.0, <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> przeciążenie metody stanowi alternatywę bezpieczne dla typów odwołań.  
  
> [!NOTE]
>  Obiekty są porównywane równości odwołań, a nie <xref:System.Object.Equals%2A?displayProperty=nameWithType>. W związku z tym dwa wystąpienia opakowanego tego samego typu wartości (na przykład całkowitą 3) zawsze jest nierówne, a nie przeprowadzono żadnej operacji. Nie należy używać tego przeciążenia z typów wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Miejsce docelowe, którego wartość jest porównywana z <c>wzorzec</c> i ewentualnie zamieniany.</param>
        <param name="value">Wartość, która zastąpi wartość docelowego, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">Wartość, która jest porównywana z wartością w <c>location1</c>.</param>
        <summary>Porównuje dwa pojedynczej precyzji liczby zmiennoprzecinkowe równości i, jeśli są one takie same, zastępuje pierwszej wartości.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i wartość w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Jako operacją niepodzielną wykonywane są operacje porównania i exchange. Wartość zwracana <xref:System.Threading.Interlocked.CompareExchange%2A> jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano metodę wątkowo, która gromadzi sumę <xref:System.Single> wartości. Dwoma wątkami dodać serii <xref:System.Single> wartości przy użyciu metody wątkowo i zwykłe Dodawanie i po ukończeniu wątki sumy są porównywane. Na komputerze, dwuprocesorowy Brak znaczące różnice dotyczące sum.  
  
 W metodzie wątkowo jest zapisywany początkowej wartości całkowitej uruchomiona, a następnie <xref:System.Threading.Interlocked.CompareExchange%2A> metoda jest używana do programu exchange do nowo obliczona ogólnej starego łączną liczbę. Jeśli wartości zwracanej nie jest równa wartości zapisane sumy, następnie inny wątek został zaktualizowany łączną liczbę w tym samym czasie. W takim przypadku należy powtórzyć próby zaktualizowania sumy bieżącej.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ do zastosowania w przypadku <c>location1</c>, <c>wartość</c>, i <c>wzorzec</c>. Ten typ musi być typem referencyjnym.</typeparam>
        <param name="location1">Miejsce docelowe, którego wartość jest porównywana z <c>wzorzec</c> i ewentualnie zamieniany. Jest to parametr odwołania (<see langword="ref" /> w języku C# <see langword="ByRef" /> w języku Visual Basic).</param>
        <param name="value">Wartość, która zastąpi wartość docelowego, jeśli wynikiem porównania jest równość.</param>
        <param name="comparand">Wartość, która jest porównywana z wartością w <c>location1</c>.</param>
        <summary>Porównuje dwa wystąpienia typu referencyjnego określonego <paramref name="T" /> równości i czy są równe, zastępuje pierwsza z nich.</summary>
        <returns>Pierwotna wartość w <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparand` i wartość w `location1` są takie same, wówczas `value` są przechowywane w `location1`. W przeciwnym razie operacja nie jest wykonywana. Porównanie i programu exchange są wykonywane jako operacją niepodzielną. Wartość zwracana ta metoda jest oryginalnej wartości w `location1`, czy odbywa się programu exchange.  
  
 Ta metoda obsługuje tylko typy referencyjne. Istnieją przeciążenia metody <xref:System.Threading.Interlocked.CompareExchange%2A> metody dla typów wartości <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, i <xref:System.Double>, ale nie jest obsługiwane dla innych typów wartości.  
  
> [!NOTE]
>  Preferowane jest przeciążenie tej metody <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> przeciążenia metody, ponieważ to drugie wymaga obiektu docelowego można uzyskać dostęp z późnym wiązaniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmniejsza określonej zmiennej i zapisuje wynik w postaci niepodzielną operację.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Zmienna, którego wartość ma zostać zmniejszona.</param>
        <summary>Zmniejsza określonej zmiennej i zapisuje wynik w postaci niepodzielną operację.</summary>
        <returns>Zmniejszona wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje nastąpiło przepełnienie zawijania: Jeśli `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Nie wyjątek.  
  
   
  
## Examples  
 Poniższy przykład określa, ile liczb losowych, które należeć do zakresu od 0 do 1000 są wymagane do wygenerowania 1000 liczby losowe z wartością środkową. Aby śledzić liczbę środkowego wartości zmiennej, `midpointCount`, jest równa 1000 i zmniejszany zawsze generatora liczb losowych zwraca punkt środkowy wartość. Ponieważ trzech wątków generatora liczb losowych, <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> metoda jest wywoływana, aby upewnić się, że wiele wątków nie Aktualizuj `midpointCount` jednocześnie. Należy pamiętać, że blokady jest również używany do ochrony generatora liczb losowych oraz że <xref:System.Threading.CountdownEvent> obiekt służy do zapewnienia, że `Main` — metoda nie zakończyć wykonywania przed trzech wątków.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 Poniższy przykład jest podobny do poprzedniego, z wyjątkiem tego, aby były używane zamiast procedury wątku do generowania 50 000 środkowego losowych liczb całkowitych. W tym przykładzie zastępuje wyrażenia lambda `GenerateNumbers` procedury wątku i wywołania w celu <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody eliminuje potrzebę stosowania <xref:System.Threading.CountdownEvent> obiektu.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Adres <paramref name="location" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Zmienna, którego wartość ma zostać zmniejszona.</param>
        <summary>Zmniejsza określonej zmiennej i zapisuje wynik w postaci niepodzielną operację.</summary>
        <returns>Zmniejszona wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje nastąpiło przepełnienie zawijania: Jeśli `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Nie wyjątek.  
  
 <xref:System.Threading.Interlocked.Read%2A> — Metoda i 64-bitowych przeciążeń <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, i <xref:System.Threading.Interlocked.Add%2A> metody są naprawdę atomic tylko w systemach gdzie <xref:System.IntPtr?displayProperty=nameWithType> jest 64 bitów. W innych systemach te metody są atomic w odniesieniu do siebie, ale nie w odniesieniu do innych środków dostęp do danych. W związku z tym, aby zapewniać bezpieczeństwo wątkowe w systemach 32-bitowych, dostęp do 64-bitową wartość musi być wprowadzane za pośrednictwem członków <xref:System.Threading.Interlocked> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Adres <paramref name="location" /> jest wskaźnika o wartości null.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia zmienną wartości określonej jako operacją niepodzielną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienna, aby ustawić określoną wartość.</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia określoną wartość podwójnej precyzji liczb zmiennoprzecinkowych i zwraca oryginalną wartość jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienna, aby ustawić określoną wartość.</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia określoną wartość całkowita 32-bitowe i zwraca oryginalną wartość jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje mechanizm blokowania zasobu wątkowo.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienna, aby ustawić określoną wartość.</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia określoną wartość całkowita 64-bitowe i zwraca oryginalną wartość jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienna, aby ustawić określoną wartość.</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia specyficzne dla platformy dojściem lub wskaźnikiem do określonej wartości i zwraca oryginalną wartość jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienna, aby ustawić określoną wartość.</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia określoną wartość obiektu i zwraca odwołanie do oryginalnego obiektu jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!NOTE]
> Od programu .NET Framework w wersji 2.0, <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> przeciążenie metody stanowi alternatywę bezpieczne dla typów odwołań.  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Zmienna, aby ustawić określoną wartość.</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia określoną wartość o pojedynczej dokładności liczb zmiennoprzecinkowych i zwraca oryginalną wartość jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ do zastosowania w przypadku <c>location1</c> i <c>wartość</c>. Ten typ musi być typem referencyjnym.</typeparam>
        <param name="location1">Zmienna, aby ustawić określoną wartość. Jest to parametr odwołania (<see langword="ref" /> w języku C# <see langword="ByRef" /> w języku Visual Basic).</param>
        <param name="value">Wartość, do której <c>location1</c> ustawiono parametr.</param>
        <summary>Ustawia zmienną określonego typu <paramref name="T" /> do określonej wartości i zwraca oryginalną wartość jako operacją niepodzielną.</summary>
        <returns>Oryginalna wartość <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje tylko typy referencyjne. Istnieją przeciążenia metody <xref:System.Threading.Interlocked.Exchange%2A> metodę <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, i <xref:System.Double> typy wartości, ale nie jest obsługiwane dla innych typów wartości.  
  
> [!NOTE]
>  Preferowane jest przeciążenie tej metody <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> przeciążenia metody, ponieważ to drugie wymaga dostępu z późnym wiązaniem do obiektu docelowego.  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location1" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwiększa określonej zmiennej i zapisuje wynik, jako operacją niepodzielną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Zmienna, którego wartość ma być zwiększany.</param>
        <summary>Zwiększa określonej zmiennej i zapisuje wynik, jako operacją niepodzielną.</summary>
        <returns>Wartość zwiększany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje nastąpiło przepełnienie zawijania: Jeśli `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>. Nie wyjątek.  
  
   
  
## Examples  
 Poniższy przykład określa, ile liczb losowych, które należeć do zakresu od 0 do 1000 są wymagane do wygenerowania 1000 liczby losowe z wartością środkową. Aby śledzić liczbę środkowego wartości zmiennej, `midpointCount`, jest równa 0 i zwiększany po każdej generatora liczb losowych zwraca wartość punkt środkowy, dopóki nie osiągnie 10 000. Ponieważ trzech wątków generatora liczb losowych, <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> metoda jest wywoływana, aby upewnić się, że wiele wątków nie Aktualizuj `midpointCount` jednocześnie. Należy pamiętać, że blokady jest również używany do ochrony generatora liczb losowych oraz że <xref:System.Threading.CountdownEvent> obiekt służy do zapewnienia, że `Main` — metoda nie zakończyć wykonywania przed trzech wątków.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 Poniższy przykład jest podobny do poprzedniego, z wyjątkiem tego, aby były używane zamiast procedury wątku do generowania 50 000 środkowego losowych liczb całkowitych. W tym przykładzie zastępuje wyrażenia lambda `GenerateNumbers` procedury wątku i wywołania w celu <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody eliminuje potrzebę stosowania <xref:System.Threading.CountdownEvent> obiektu.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Zmienna, którego wartość ma być zwiększany.</param>
        <summary>Zwiększa określonej zmiennej i zapisuje wynik, jako operacją niepodzielną.</summary>
        <returns>Wartość zwiększany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje nastąpiło przepełnienie zawijania: Jeśli `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>. Nie wyjątek.  
  
 <xref:System.Threading.Interlocked.Read%2A> — Metoda i 64-bitowych przeciążeń <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, i <xref:System.Threading.Interlocked.Add%2A> metody są naprawdę atomic tylko w systemach gdzie <xref:System.IntPtr?displayProperty=nameWithType> jest 64 bitów. W innych systemach te metody są atomic w odniesieniu do siebie, ale nie w odniesieniu do innych środków dostęp do danych. W związku z tym, aby zapewniać bezpieczeństwo wątkowe w systemach 32-bitowych, dostęp do 64-bitową wartość musi być wprowadzane za pośrednictwem członków <xref:System.Threading.Interlocked> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="location" /> jest wskaźnika o wartości null.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronizuje dostęp do pamięci w następujący sposób: procesor, wykonująca bieżący wątek nie można zmienić kolejności instrukcje w taki sposób, że pamięć uzyskuje dostęp do przed wywołaniem do <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> wykonanie uzyskuje dostęp do pamięci, które należy wykonać wywołanie <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda została dodana do <xref:System.Threading.Interlocked> klasy w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] jako udogodnienie; jest otoki dla <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> metody.  
  
 <xref:System.Threading.Interlocked.MemoryBarrier%2A> jest wymagany tylko w systemach wieloprocesorowych, które mają słaby pamięci porządkowanie (na przykład system, używającego wielu procesorów Intel Itanium).  
  
 W większości przypadków, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji lub <xref:System.Threading.Monitor> klasy umożliwiają łatwiejsze do synchronizacji danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Wartość 64-bitowej do załadowania.</param>
        <summary>Zwraca wartość 64-bitowych załadowany jako niepodzielną operację.</summary>
        <returns>Wartość załadowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Interlocked.Read%2A> Metody jest wykorzystywana w systemach 64-bitowych, ponieważ 64-bitowe operacje odczytu są już atomic. W 32-bitowych systemach 64-bitowe operacje odczytu nie są atomic, chyba że wykonywane przy użyciu <xref:System.Threading.Interlocked.Read%2A>.  
  
 <xref:System.Threading.Interlocked.Read%2A> — Metoda i 64-bitowych przeciążeń <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, i <xref:System.Threading.Interlocked.Add%2A> metody są naprawdę atomic tylko w systemach gdzie <xref:System.IntPtr?displayProperty=nameWithType> jest 64 bitów. W innych systemach te metody są atomic w odniesieniu do siebie, ale nie w odniesieniu do innych środków dostęp do danych. W związku z tym, aby zapewniać bezpieczeństwo wątkowe w systemach 32-bitowych, dostęp do 64-bitową wartość musi być wprowadzane za pośrednictwem członków <xref:System.Threading.Interlocked> klasy.  
  
> [!NOTE]
>  <xref:System.IntPtr> jest to typ specyficzne dla platformy.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
      </Docs>
    </Member>
  </Members>
</Type>
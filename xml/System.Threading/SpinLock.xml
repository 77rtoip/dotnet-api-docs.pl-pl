<Type Name="SpinLock" FullName="System.Threading.SpinLock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eea5b7defd586cc476971ef2f607aac3eafb3dee" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69143899" /></Metadata><TypeSignature Language="C#" Value="public struct SpinLock" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SpinLock extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SpinLock" />
  <TypeSignature Language="VB.NET" Value="Public Structure SpinLock" />
  <TypeSignature Language="C++ CLI" Value="public value class SpinLock" />
  <TypeSignature Language="F#" Value="type SpinLock = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsHeld = {IsHeld}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia wzajemne wykluczenie blokady pierwotnej, gdzie wątek próbujący uzyskać blokadę czeka w pętli wielokrotnie, dopóki blokada nie zostanie udostępniona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykład korzystania z blokady pokrętła można znaleźć w temacie [How to: Użyj struktury spinlock do synchronizacji](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)niskiego poziomu.  
  
 Blokady pokrętła mogą być używane dla blokad na poziomie liścia, w których alokacja obiektu jest <xref:System.Threading.Monitor>implikowana przy użyciu, w rozmiarze lub z powodu siły wyrzucania elementów bezużytecznych, jest zbyt kosztowna. Blokada pokrętła może być przydatna, aby uniknąć zablokowania; Jeśli jednak spodziewasz się znacznej ilości blokowania, prawdopodobnie nie należy używać blokad pokrętła ze względu na nadmierną wirowanie. Wirowanie może być korzystne, gdy blokady są szczegółowe i duże w liczbie (na przykład blokada na węzeł na liście połączonej), a także gdy czasy wstrzymania blokady są zawsze bardzo krótkie. Ogólnie rzecz biorąc, podczas utrzymywania blokady pokrętła, należy unikać jednej z następujących akcji:  
  
-   blokad  
  
-   Wywołanie wszystkiego, co może być blokowane,  
  
-   Jednoczesne trzymanie więcej niż jednej blokady pokrętła  
  
-   wykonywanie wywołań dynamicznie wywoływanych (interfejs i wirtualne),  
  
-   wykonywanie statycznie wysyłanych wywołań do dowolnego kodu, który nie jest własny, lub  
  
-   Przydzielanie pamięci.  
  
 <xref:System.Threading.SpinLock>powinno być używane tylko po ustaleniu, że w ten sposób poprawi wydajność aplikacji. Należy również pamiętać, że <xref:System.Threading.SpinLock> jest to typ wartości, ze względu na wydajność. Z tego powodu należy zachować ostrożność bez przypadkowego kopiowania <xref:System.Threading.SpinLock> wystąpienia, ponieważ dwa wystąpienia (oryginał i kopia) byłyby całkowicie niezależne od siebie, co prawdopodobnie doprowadziłoby do błędnego zachowania aplikacji. <xref:System.Threading.SpinLock> Jeśli wystąpienie musi być przesłane, powinno być przesyłane przez odwołanie, a nie przez wartość.  
  
 Nie należy przechowywać <xref:System.Threading.SpinLock> wystąpień w polach tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.SpinLock>jak używać:  
  
 [!code-csharp[System.Threading.SpinLock#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.spinlock/cs/spinlock.cs#01)]
 [!code-vb[System.Threading.SpinLock#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.spinlock/vb/spinlock.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.SpinLock" /> są bezpieczne dla wątków i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
    <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Korzystanie z Metody SpinWait i struktury spinlock</related>
    <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpinLock (bool enableThreadOwnerTracking);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool enableThreadOwnerTracking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (enableThreadOwnerTracking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpinLock(bool enableThreadOwnerTracking);" />
      <MemberSignature Language="F#" Value="new System.Threading.SpinLock : bool -&gt; System.Threading.SpinLock" Usage="new System.Threading.SpinLock enableThreadOwnerTracking" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="enableThreadOwnerTracking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enableThreadOwnerTracking">Czy przechwytywać i używać identyfikatorów wątków do celów debugowania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.SpinLock" /> struktury z opcją śledzenia identyfikatorów wątków w celu usprawnienia debugowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor bez parametrów do <xref:System.Threading.SpinLock> śledzenia własności wątku.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można używać struktury spinlock.  
  
```csharp  
// C#  
public class MyType  
{  
    private SpinLock _spinLock = new SpinLock();  
  
    public void DoWork()  
    {  
        bool lockTaken = false;   
        try  
        {  
           _spinLock.Enter(ref lockTaken);  
           // do work here protected by the lock  
        }  
        finally  
        {  
            if (lockTaken) _spinLock.Exit();  
        }  
    }  
}  
```  
  
```vb  
' Visual Basic  
  
Class MyType  
   Private _spinLock As New SpinLock()  
  
   Public Sub DoWork()  
      Dim lockTaken As Boolean = False  
      Try  
         _spinLock.Enter(lockTaken)  
         ' do work here protected by the lock  
      Finally  
         If lockTaken Then _spinLock.Exit()  
      End Try  
   End Sub  
End Class  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public void Enter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.Enter :  -&gt; unit" Usage="spinLock.Enter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">Ma wartość true, jeśli blokada jest pozyskana; w przeciwnym razie false. <paramref name="lockTaken" />musi być zainicjowany do wartości false przed wywołaniem tej metody.</param>
        <summary>Uzyskuje blokadę w niezawodny sposób, tak że nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby określić, czy blokada została pobrana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.SpinLock>jest blokadą niewspółpracującą, co oznacza, że jeśli wątek utrzymuje blokadę, nie można ponownie wprowadzić blokady. Jeśli funkcja śledzenia własności wątku jest włączona (czy jest dostępna za pomocą <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>programu), zostanie zgłoszony wyjątek, gdy wątek spróbuje ponownie wprowadzić blokadę, która już mieści się. Jeśli jednak śledzenie własności wątku jest wyłączone, próba wprowadzenia blokady jest już zablokowana.  
  
 W <xref:System.Threading.SpinLock.Enter%2A> <xref:System.Threading.SpinLock.Exit%2A> przypadku<xref:System.Threading.SpinLock> wywołania bez wcześniejszego wywołania stanu wewnętrznego może ulec uszkodzeniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> Argument musi być zainicjowany do wartości false przed wywołaniem metody ENTER.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Śledzenie własności wątku jest włączone, a bieżący wątek już uzyskał tę blokadę.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia blokadę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit();" />
      <MemberSignature Language="F#" Value="member this.Exit : unit -&gt; unit" Usage="spinLock.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia blokadę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne Przeciążenie <xref:System.Threading.SpinLock.Exit%2A> zapewnia takie samo zachowanie, jak w przypadku wywołania <xref:System.Threading.SpinLock.Exit%2A> przy użyciu wartości true jako argumentu.  
  
 W <xref:System.Threading.SpinLock.Enter%2A> <xref:System.Threading.SpinLock.Exit%2A> przypadku<xref:System.Threading.SpinLock> wywołania bez wcześniejszego wywołania stanu wewnętrznego może ulec uszkodzeniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Śledzenie własności wątku jest włączone, a bieżący wątek nie jest właścicielem tej blokady.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit (bool useMemoryBarrier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit(bool useMemoryBarrier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit (useMemoryBarrier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit(bool useMemoryBarrier);" />
      <MemberSignature Language="F#" Value="member this.Exit : bool -&gt; unit" Usage="spinLock.Exit useMemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useMemoryBarrier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useMemoryBarrier">Wartość logiczna wskazująca, czy należy wydać ogranicznik pamięci, aby natychmiast opublikować operację wyjścia w innych wątkach.</param>
        <summary>Zwalnia blokadę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.SpinLock.Exit%2A> Wywołanie`useMemoryBarrier` z argumentem ustawionym na wartość true poprawi atrakcyjność blokady kosztem pewnej wydajności. Domyślne <xref:System.Threading.SpinLock.Exit%2A> Przeciążenie zachowuje się tak, jakby określono wartość true `useMemoryBarrier`dla.  
  
 W <xref:System.Threading.SpinLock.Enter%2A> <xref:System.Threading.SpinLock.Exit%2A> przypadku<xref:System.Threading.SpinLock> wywołania bez wcześniejszego wywołania stanu wewnętrznego może ulec uszkodzeniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Śledzenie własności wątku jest włączone, a bieżący wątek nie jest właścicielem tej blokady.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeld">
      <MemberSignature Language="C#" Value="public bool IsHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeld : bool" Usage="System.Threading.SpinLock.IsHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy blokada jest obecnie utrzymywana przez dowolny wątek.</summary>
        <value>ma wartość true, jeśli blokada jest aktualnie utrzymywana przez dowolny wątek; w przeciwnym razie false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeldByCurrentThread">
      <MemberSignature Language="C#" Value="public bool IsHeldByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeldByCurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeldByCurrentThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeldByCurrentThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeldByCurrentThread : bool" Usage="System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy blokada jest utrzymywana przez bieżący wątek.</summary>
        <value>ma wartość true, jeśli blokada jest utrzymywana przez bieżący wątek; w przeciwnym razie false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli blokada została zainicjowana do śledzenia wątków właściciela, spowoduje to zwrócenie tego, czy blokada jest pobierana przez bieżący wątek. Nie można użyć tej właściwości, gdy blokada została zainicjowana, aby nie śledzić własności wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Śledzenie własności wątku jest wyłączone.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadOwnerTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool IsThreadOwnerTrackingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadOwnerTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadOwnerTrackingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadOwnerTrackingEnabled : bool" Usage="System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, czy dla tego wystąpienia jest włączone śledzenie własności wątków.</summary>
        <value>prawda, jeśli śledzenie własności wątku jest włączone dla tego wystąpienia; w przeciwnym razie false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje uzyskać blokadę w niezawodny sposób, tak że nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby określić, czy blokada została pobrana.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter :  -&gt; unit" Usage="spinLock.TryEnter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">Ma wartość true, jeśli blokada jest pozyskana; w przeciwnym razie false. <paramref name="lockTaken" />musi być zainicjowany do wartości false przed wywołaniem tej metody.</param>
        <summary>Próbuje uzyskać blokadę w niezawodny sposób, tak że nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby określić, czy blokada została pobrana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.SpinLock.Enter%2A>do TryEnter — nie będzie blokować oczekiwania na udostępnienie blokady. Jeśli blokada jest niedostępna, gdy TryEnter — jest wywoływana, nastąpi natychmiastowe zwrócenie natychmiast bez dalszej wirowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> Argument musi być zainicjowany do wartości false przed wywołaniem TryEnter —.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Śledzenie własności wątku jest włączone, a bieżący wątek już uzyskał tę blokadę.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : int *  -&gt; unit" Usage="spinLock.TryEnter (millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="lockTaken">Ma wartość true, jeśli blokada jest pozyskana; w przeciwnym razie false. <paramref name="lockTaken" />musi być zainicjowany do wartości false przed wywołaniem tej metody.</param>
        <summary>Próbuje uzyskać blokadę w niezawodny sposób, tak że nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby określić, czy blokada została pobrana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.SpinLock.Enter%2A>do TryEnter — nie będzie blokować czas oczekiwania na udostępnienie blokady. Zostanie ona Zablokowani do momentu udostępnienia blokady lub do `millisecondsTimeout` momentu wygaśnięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> Argument musi być zainicjowany do wartości false przed wywołaniem TryEnter —.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Śledzenie własności wątku jest włączone, a bieżący wątek już uzyskał tę blokadę.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : TimeSpan *  -&gt; unit" Usage="spinLock.TryEnter (timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <param name="lockTaken">Ma wartość true, jeśli blokada jest pozyskana; w przeciwnym razie false. <paramref name="lockTaken" />musi być zainicjowany do wartości false przed wywołaniem tej metody.</param>
        <summary>Próbuje uzyskać blokadę w niezawodny sposób, tak że nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby określić, czy blokada została pobrana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie <xref:System.Threading.SpinLock.Enter%2A>do TryEnter — nie będzie blokować czas oczekiwania na udostępnienie blokady. Zostanie ona Zablokowani do momentu udostępnienia blokady lub do `timeout` momentu wygaśnięcia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu lub limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" /> milisekunda.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> Argument musi być zainicjowany do wartości false przed wywołaniem TryEnter —.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Śledzenie własności wątku jest włączone, a bieżący wątek już uzyskał tę blokadę.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Instrukcje: Użyj struktury spinlock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Instrukcje: Włącz tryb śledzenia wątków w struktury spinlock</related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="SpinLock" FullName="System.Threading.SpinLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="10f26e6ab91a3ed621e096451edb0d7cae5bcc16" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48595451" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct SpinLock" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SpinLock extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SpinLock" />
  <TypeSignature Language="VB.NET" Value="Public Structure SpinLock" />
  <TypeSignature Language="C++ CLI" Value="public value class SpinLock" />
  <TypeSignature Language="F#" Value="type SpinLock = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsHeld = {IsHeld}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia podstawowego blokady wzajemne wykluczenie, gdzie wątek, próbując uzyskać blokadę czeka w pętli, sprawdzanie wielokrotnie, dopóki blokada staje się dostępna.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jak używać blokadę pokrętła zobacz [porady: Użyj struktury SpinLock do synchronizacji niższego poziomu](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md).  
  
 Pokrętła blokady może służyć do blokady na poziomie liścia gdzie Alokacja obiektu jest implikowane przy użyciu <xref:System.Threading.Monitor>, rozmiarze lub z powodu dużego wykorzystania kolekcji wyrzucania elementów, jest zbyt kosztowne. Zablokuj pokrętła może być przydatne w celu unikania blokowania; Jednak jeśli oczekujesz, że znaczną ilość blokowania, prawdopodobnie nie należy używać blokad pokrętła z powodu nadmiernego obrotowych. Rotowania może być korzystne, gdy blokady są szczegółowe, jak i dużych wiele (na przykład blokadę na węzeł połączonej liście), a także podczas blokady wstrzymania i godziny są zawsze bardzo krótko. Ogólnie rzecz biorąc podczas utrzymywania blokady pokrętła, jeden należy unikać dowolnej z tych akcji:  
  
-   blokuje,  
  
-   Cokolwiek wywołanie tej samej mogą blokować,  
  
-   jednocześnie, zawierający więcej niż jedną blokadę pokrętła  
  
-   dynamiczne tworzenie wysyłane wywołania (interfejs i elementy wirtualne)  
  
-   Tworzenie statycznie wysyłane wywołania do jakiegokolwiek kodu, jeden nie posiada, lub  
  
-   Przydzielanie pamięci.  
  
 <xref:System.Threading.SpinLock> należy używać tylko po użytkownik zostały uznane za, spowoduje to więc poprawi wydajność aplikacji. Jest również pamiętać, że <xref:System.Threading.SpinLock> jest typem wartości w celu zapewnienia optymalnej wydajności. Z tego powodu należy zwrócić szczególną uwagę na nie skopiować przypadkowo <xref:System.Threading.SpinLock> wystąpienia, tak, jak dwa wystąpienia (oryginału i kopii) będzie wówczas całkowicie niezależne od siebie nawzajem, które prawdopodobnie mogłyby prowadzić do błędne zachowanie aplikacji. Jeśli <xref:System.Threading.SpinLock> wystąpienia muszą być przekazywane w całym, powinien być przekazywany przez odwołanie, a nie przez wartość.  
  
 Nie należy przechowywać <xref:System.Threading.SpinLock> wystąpień w pola tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.SpinLock>:  
  
 [!code-csharp[System.Threading.SpinLock#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.spinlock/cs/spinlock.cs#01)]
 [!code-vb[System.Threading.SpinLock#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.spinlock/vb/spinlock.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.SpinLock" /> są odporne na wątki i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
    <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: Użyj metody SpinWait i strukturze SpinLock</related>
    <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SpinLock (bool enableThreadOwnerTracking);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool enableThreadOwnerTracking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (enableThreadOwnerTracking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SpinLock(bool enableThreadOwnerTracking);" />
      <MemberSignature Language="F#" Value="new System.Threading.SpinLock : bool -&gt; System.Threading.SpinLock" Usage="new System.Threading.SpinLock enableThreadOwnerTracking" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="enableThreadOwnerTracking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enableThreadOwnerTracking">Identyfikatory czy przechwytywania i wykorzystania wątków na potrzeby debugowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SpinLock" /> struktury z opcją do śledzenia wątków identyfikatorów w celu debugowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny konstruktor dla <xref:System.Threading.SpinLock> śledzi wątku własności.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak może służyć w strukturze SpinLock.  
  
```csharp  
// C#  
public class MyType  
{  
    private SpinLock _spinLock = new SpinLock();  
  
    public void DoWork()  
    {  
        bool lockTaken = false;   
        try  
        {  
           _spinLock.Enter(ref lockTaken);  
           // do work here protected by the lock  
        }  
        finally  
        {  
            if (lockTaken) _spinLock.Exit();  
        }  
    }  
}  
```  
  
```vb  
' Visual Basic  
  
Class MyType  
   Private _spinLock As New SpinLock()  
  
   Public Sub DoWork()  
      Dim lockTaken As Boolean = False  
      Try  
         _spinLock.Enter(lockTaken)  
         ' do work here protected by the lock  
      Finally  
         If lockTaken Then _spinLock.Exit()  
      End Try  
   End Sub  
End Class  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public void Enter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.Enter :  -&gt; unit" Usage="spinLock.Enter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">Wartość true, jeśli jest blokada; w przeciwnym razie wartość false. <c>lockTaken</c> musi zostać zainicjowana na wartość false przed wywołaniem tej metody.</param>
        <summary>Uzyskuje blokadę w sposób niezawodny, nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby ustalić, czy blokada została uzyskana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.SpinLock> blokady nie obsługującą to, co oznacza, że jeśli wątek nałoży blokadę, nie może ponownie wprowadź blokadę. Jeśli wątek własność śledzenia jest włączona (czy jest włączony jest dostępna za pośrednictwem <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), wyjątek zostanie zgłoszony, gdy wątek spróbuje ponownie wprowadzić już posiada blokadę. Jednak jeśli własność wątku śledzenie jest wyłączone, próby wprowadź blokadę z już posiadanych spowoduje zakleszczenia.  
  
 Jeśli wywołasz <xref:System.Threading.SpinLock.Exit%2A> bez konieczności najpierw wywołuje <xref:System.Threading.SpinLock.Enter%2A> wewnętrzny stan <xref:System.Threading.SpinLock> mogą ulec uszkodzeniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> Argument musi być zainicjowany na wartość false przed wywołaniem Enter.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Własność wątku śledzenia jest włączona, a bieżący wątek ustawił już tę blokadę.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia blokadę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit();" />
      <MemberSignature Language="F#" Value="member this.Exit : unit -&gt; unit" Usage="spinLock.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia blokadę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia domyślnego <xref:System.Threading.SpinLock.Exit%2A> zapewnia takie samo zachowanie, tak, jakby wywoływania <xref:System.Threading.SpinLock.Exit%2A> przy użyciu wartości true jako argument.  
  
 Jeśli wywołasz <xref:System.Threading.SpinLock.Exit%2A> bez konieczności najpierw wywołuje <xref:System.Threading.SpinLock.Enter%2A> wewnętrzny stan <xref:System.Threading.SpinLock> mogą ulec uszkodzeniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Własność wątku śledzenia jest włączona, a bieżący wątek nie jest właścicielem tego blokady.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public void Exit (bool useMemoryBarrier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Exit(bool useMemoryBarrier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.Exit(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Exit (useMemoryBarrier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Exit(bool useMemoryBarrier);" />
      <MemberSignature Language="F#" Value="member this.Exit : bool -&gt; unit" Usage="spinLock.Exit useMemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useMemoryBarrier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useMemoryBarrier">Wartość logiczna wskazująca, czy powinno być wydane horyzont pamięci, aby natychmiast opublikować operacji wyjścia dla innych wątków.</param>
        <summary>Zwalnia blokadę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Threading.SpinLock.Exit%2A> z `useMemoryBarrier` argument ma wartość true poprawia sprawiedliwe blokady kosztem wydajności. Wartość domyślna <xref:System.Threading.SpinLock.Exit%2A> przeciążenia zachowuje się tak, określając wartość true dla `useMemoryBarrier`.  
  
 Jeśli wywołasz <xref:System.Threading.SpinLock.Exit%2A> bez konieczności najpierw wywołuje <xref:System.Threading.SpinLock.Enter%2A> wewnętrzny stan <xref:System.Threading.SpinLock> mogą ulec uszkodzeniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Własność wątku śledzenia jest włączona, a bieżący wątek nie jest właścicielem tego blokady.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeld">
      <MemberSignature Language="C#" Value="public bool IsHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeld : bool" Usage="System.Threading.SpinLock.IsHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy blokada jest aktualnie trzymana w żadnym z wątków.</summary>
        <value>wartość true, jeśli blokada jest aktualnie trzymana przez wątek; w przeciwnym razie wartość false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsHeldByCurrentThread">
      <MemberSignature Language="C#" Value="public bool IsHeldByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeldByCurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHeldByCurrentThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHeldByCurrentThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHeldByCurrentThread : bool" Usage="System.Threading.SpinLock.IsHeldByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy blokada jest używana przez bieżącego wątku.</summary>
        <value>wartość true, jeśli blokada jest używana przez bieżący wątek; w przeciwnym razie wartość false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli blokada została zainicjowana do śledzenia wątków właściciela, spowoduje to zwrócenie czy jest blokada przez bieżącego wątku. Jest on nieprawidłowy, aby używać tej właściwości, gdy blokady zostało zainicjowane do "nie Śledź" własność wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Własność wątku śledzenie jest wyłączone.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadOwnerTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool IsThreadOwnerTrackingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadOwnerTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadOwnerTrackingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadOwnerTrackingEnabled : bool" Usage="System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy wątek własność śledzenia jest włączona dla tego wystąpienia.</summary>
        <value>wartość true, jeśli wątek własność śledzenia jest włączona dla tego wystąpienia; w przeciwnym razie wartość false.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje uzyskać blokadę w sposób niezawodny, nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby ustalić, czy blokada została uzyskana.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter :  -&gt; unit" Usage="spinLock.TryEnter lockTaken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockTaken">Wartość true, jeśli jest blokada; w przeciwnym razie wartość false. <c>lockTaken</c> musi zostać zainicjowana na wartość false przed wywołaniem tej metody.</param>
        <summary>Próbuje uzyskać blokadę w sposób niezawodny, nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby ustalić, czy blokada została uzyskana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.SpinLock.Enter%2A>, tryenter — nie będzie blokować oczekiwanie na blokadę, które mają być dostępne. Jeśli blokada nie jest dostępna, gdy wywoływana jest tryenter —, zwróci natychmiast bez dalszego obrotowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> Argument musi być zainicjowany na wartość false przed wywołaniem tryenter —.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Własność wątku śledzenia jest włączona, a bieżący wątek ustawił już tę blokadę.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : int *  -&gt; unit" Usage="spinLock.TryEnter (millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="lockTaken">Wartość true, jeśli jest blokada; w przeciwnym razie wartość false. <c>lockTaken</c> musi zostać zainicjowana na wartość false przed wywołaniem tej metody.</param>
        <summary>Próbuje uzyskać blokadę w sposób niezawodny, nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby ustalić, czy blokada została uzyskana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.SpinLock.Enter%2A>, tryenter — nie będzie blokować przez czas nieokreślony oczekujący na blokadę, które mają być dostępne. Spowoduje to zablokowanie, dopóki blokada jest dostępny, lub do momentu `millisecondsTimeout` utracił ważność.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> Argument musi być zainicjowany na wartość false przed wywołaniem tryenter —.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Własność wątku śledzenia jest włączona, a bieżący wątek ustawił już tę blokadę.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public void TryEnter (TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TryEnter(valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TryEnter (timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TryEnter(TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="member this.TryEnter : TimeSpan *  -&gt; unit" Usage="spinLock.TryEnter (timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <param name="lockTaken">Wartość true, jeśli jest blokada; w przeciwnym razie wartość false. <c>lockTaken</c> musi zostać zainicjowana na wartość false przed wywołaniem tej metody.</param>
        <summary>Próbuje uzyskać blokadę w sposób niezawodny, nawet jeśli wystąpi wyjątek w wywołaniu metody, <paramref name="lockTaken" /> może być niezawodnie zbadane, aby ustalić, czy blokada została uzyskana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Threading.SpinLock.Enter%2A>, tryenter — nie będzie blokować przez czas nieokreślony oczekujący na blokadę, które mają być dostępne. Spowoduje to zablokowanie, dopóki blokada jest dostępny, lub do momentu `timeout` utracił ważność.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna, innych niż-1 MS, który reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> Argument musi być zainicjowany na wartość false przed wywołaniem tryenter —.</exception>
        <exception cref="T:System.Threading.LockRecursionException">Własność wątku śledzenia jest włączona, a bieżący wątek ustawił już tę blokadę.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/f9af93bb-7a0d-4ba5-afe8-74f48b6b6958">SpinLock</related>
        <related type="Article" href="http://msdn.microsoft.com/library/a9ed3e4e-4f29-4207-b730-ed0a51ecbc19">Porady: używanie struktury SpinLock do synchronizacji niskiego poziomu</related>
        <related type="Article" href="http://msdn.microsoft.com/library/62ee2e68-0bdd-4869-afc9-f0a57a11ae01">Porady: włączanie śledzenia wątków w strukturze SpinLock</related>
      </Docs>
    </Member>
  </Members>
</Type>
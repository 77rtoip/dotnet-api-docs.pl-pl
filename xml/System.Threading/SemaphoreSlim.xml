<Type Name="SemaphoreSlim" FullName="System.Threading.SemaphoreSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1e6737b8822da41a3896bdc42c2ea1cf634528d3" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57913114" /></Metadata><TypeSignature Language="C#" Value="public class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SemaphoreSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SemaphoreSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class SemaphoreSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type SemaphoreSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Current Count = {m_currentCount}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje uproszczone zamiast <see cref="T:System.Threading.Semaphore" /> , która ogranicza liczbę wątków, które mogą uzyskać dostęp do zasobu lub puli zasobów jednocześnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją dwa typy semaforów: lokalne semaforów i semaforów systemu o nazwie. Jest lokalne dla aplikacji. Te ostatnie są widoczne w całym systemie operacyjnym i nadaje się do synchronizacji między procesami. <xref:System.Threading.SemaphoreSlim> Jest uproszczone alternatywa dla <xref:System.Threading.Semaphore> klasę, która nie korzysta z semaforów jądra Windows. W odróżnieniu od <xref:System.Threading.Semaphore> klasy <xref:System.Threading.SemaphoreSlim> klasa nie obsługuje systemu o nazwie semaforów. Służy on jako tylko lokalne semafora. <xref:System.Threading.SemaphoreSlim> Klasa jest zalecane semafora synchronizacji w obrębie pojedynczej aplikacji.  
  
 Uproszczone semafora kontroluje dostęp do puli zasobów, lokalne dla aplikacji. Podczas tworzenia wystąpienia semafor, można określić maksymalną liczbę wątków, które można wprowadzić semafora jednocześnie. Możesz również określić początkowa liczba wątków, które można wprowadzić semafora jednocześnie. Definiuje liczbę semafora.  
  
 Liczba zostanie zmniejszony każdorazowo wątek wchodzi semafora i zwiększana za każdym razem wątku zwalnia semafora. Aby wprowadzić semafora, wątek wywołuje jedną z <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> przeciążenia. Aby zwolnić semafora, wywołuje jedną z <xref:System.Threading.SemaphoreSlim.Release%2A> przeciążenia. Gdy licznik osiągnie zero, kolejne wywołania do jednego z `Wait` metody zapewnić blokowanie do zakończenia inne wątki wersji semafora. Po zablokowaniu wiele wątków nie jest zagwarantowana kolejność, takich jak FIFO lub LIFO sterującą, kiedy wątków wprowadź semafora.  
  
 Podstawowa struktura kodu, który używa semafor do ochrony zasobów jest:  
  
```vb  
  
' Enter semaphore by calling one of the Wait or WaitAsync methods.  
SemaphoreSlim.Wait()  
'   
' Execute code protected by the semaphore.   
'  
SemaphoreSlim.Release()  
  
```  
  
 Gdy wszystkie wątki zostały wydane semafora, liczba przy maksymalnej wartości określono podczas tworzenia semafora. Semafor licznik jest dostępny z <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości.  
  
> [!IMPORTANT]
>  <xref:System.Threading.SemaphoreSlim> Klasy nie wymuszają tożsamość wątku lub zadania na wywołania <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, i <xref:System.Threading.SemaphoreSlim.Release%2A> metody. Ponadto jeśli <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> Konstruktor jest używany do utworzenia wystąpienia <xref:System.Threading.SemaphoreSlim> obiektu <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości można zwiększyć przekracza wartość ustawioną przy użyciu konstruktora. Odpowiada za programisty upewnij się, który wywołuje w celu <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody odpowiednio są skojarzone z wywołaniami <xref:System.Threading.SemaphoreSlim.Release%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy semafor maksymalna liczba wątków trzy i początkowa liczba wątków, zerowego. W przykładzie uruchomiono pięć zadań, które blokować oczekiwanie na semafora. Wywołania wątku głównego <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> przeciążenia, aby zwiększyć tę liczbę semafora jego wartość maksymalną, co pozwala trzy zadania wprowadzić semafora. Każdorazowo, gdy wydaniu semafora wyświetlane liczba semafora w poprzednim. Użycie konsoli komunikaty śledzenia semafora. Interwał symulowane pracy zwiększa się nieco dla każdego wątku ułatwić dane wyjściowe.  
  
 [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]
 [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.SemaphoreSlim" /> są odporne na wątki i mogą być używane jednocześnie z wielu wątków, z wyjątkiem produktów <see cref="M:System.Threading.SemaphoreSlim.Dispose" />, które muszą być zastosowane tylko wtedy, gdy wszystkie operacje na <see cref="T:System.Threading.SemaphoreSlim" /> została ukończona.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim initialCount" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semaforów, które mogą być przyznane jednocześnie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy, określając początkowa liczba żądań, które mogą być udzielane jednocześnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `initialCount` Parametr określa liczbę równoczesnych żądań, aby wprowadzić semafor, które mogą być przyznane. Jednak nedefinuje maksymalną liczbę żądań, które mogą być udzielane jednocześnie. A <xref:System.Threading.SemaphoreSlim> tworzone przez wywołanie konstruktora tego obiektu nie wyrzuca <xref:System.Threading.SemaphoreFullException> wyjątek, jeśli wywołanie <xref:System.Threading.SemaphoreSlim.Release%2A> metody zwiększa ich wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość poza `initialCount`. Dzieje się tak w przypadku więcej wywołań <xref:System.Threading.SemaphoreSlim.Release%2A> metody niż tam są <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody. Aby ustawić maksymalną liczbę równoczesnych żądań, aby wprowadzić semafor, które mogą być przyznane, należy wywołać <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount" /> jest mniejsza niż 0.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount, int maxCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maxCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maxCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount, int maxCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int * int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim (initialCount, maxCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maxCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semaforów, które mogą być przyznane jednocześnie.</param>
        <param name="maxCount">Maksymalna liczba żądań dotyczących semafor, które mogą być przyznane jednocześnie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy, określający początkowej i maksymalna liczba żądań, które mogą być udzielane jednocześnie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount" /> jest mniejsza niż 0, lub <paramref name="initialCount" /> jest większa niż <paramref name="maxCount" />, lub <paramref name="maxCount" /> jest równa lub mniejsza niż 0.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AvailableWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AvailableWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AvailableWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableWaitHandle : System.Threading.WaitHandle" Usage="System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca <see cref="T:System.Threading.WaitHandle" /> można czekać na semafora.</summary>
        <value>Element <see cref="T:System.Threading.WaitHandle" /> można czekać na semafora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko wtedy, gdy musi czekać na SemaphoreSlim z innymi obiektami synchronizacja na podstawie jądra z tej samej dojście oczekiwania, należy użyć tej właściwości. Pomyślne oczekiwania na <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> nie oznacza pomyślne oczekiwania na <xref:System.Threading.SemaphoreSlim> , ani nie jest zmniejsza liczbę semafora. Po dojście oczekiwania dostępne jest sygnalizowane, należy poczekać <xref:System.Threading.SemaphoreSlim> specjalnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCount : int" Usage="System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozostałych wątków, które można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" /> obiektu.</summary>
        <value>Liczba pozostałych wątków, które można wprowadzić semafora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość jest ustawiana przez wywołanie metody <xref:System.Threading.SemaphoreSlim.%23ctor%2A> konstruktora klasy. Jest zmniejszany przez każde wywołanie <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody i zwiększając każde wywołanie <xref:System.Threading.SemaphoreSlim.Release%2A> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="semaphoreSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `Dispose` po zakończeniu przy użyciu <xref:System.Threading.SemaphoreSlim>. `Dispose` Pozostawia metoda <xref:System.Threading.SemaphoreSlim> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, trzeba zwolnić wszystkie odwołania do <xref:System.Threading.SemaphoreSlim> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Threading.SemaphoreSlim> zajmowaną przez wystąpienie.  
  
 Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj `Dispose` przed publikacją swoje ostatnie odwołanie do <xref:System.Threading.SemaphoreSlim>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Threading.SemaphoreSlim> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="semaphoreSlim.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.SemaphoreSlim" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości elementów członkowskich <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> nie jest metodą o bezpiecznych wątkach i nie mogą być używane równocześnie z innymi członkami tego wystąpienia.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wersje <see cref="T:System.Threading.SemaphoreSlim" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphoreSlim.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wersje <see cref="T:System.Threading.SemaphoreSlim" /> obiekt na raz.</summary>
        <returns>Liczba poprzednich <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.SemaphoreSlim.Release> metody zwiększa <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną. Jeśli wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości wynosi zero, zanim ta metoda jest wywoływana, metoda umożliwia również jednego wątku lub zadania zablokowane przez wywołanie <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metodę, aby wprowadzić semafora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><see cref="T:System.Threading.SemaphoreSlim" /> Osiągnęło już maksymalny rozmiar.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphoreSlim.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Liczba razy, aby zamknąć semafora.</param>
        <summary>Wersje <see cref="T:System.Threading.SemaphoreSlim" /> obiekt o określoną liczbę razy.</summary>
        <returns>Liczba poprzednich <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> metody zwiększa <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według `releaseCount`. Jeśli wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości wynosi zero, zanim ta metoda jest wywoływana, metoda umożliwia również `releaseCount` wątków lub zadania, zablokowane przez wywołanie <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metodę, aby wprowadzić semafora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" /> jest mniejsza niż 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><see cref="T:System.Threading.SemaphoreSlim" /> Osiągnęło już maksymalny rozmiar.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="semaphoreSlim.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątku lub zadania jest możliwość wprowadzania semafor, jego zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="semaphoreSlim.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, <see cref="F:System.Threading.Timeout.Infinite" />(-1), aby czekać w nieskończoność, lub od zera do testowania stanu dojście oczekiwania i natychmiast zwróci.</param>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu 32-bitowa liczba całkowita ze znakiem określa limit czasu.</summary>
        <returns><see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 
Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast.

Jeśli wątku lub zadania jest możliwość wprowadzania semafor, jego zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną.  
  
Jeśli wątku lub zadania, jest zablokowany podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> i interwał limitu czasu określonego przez `millisecondsTimeout` wygasa:

- Wątku lub zadania, nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwości nie są odejmowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="semaphoreSlim.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Token do obserwowania.</param>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />, obserwując <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątku lub zadania jest możliwość wprowadzania semafor, jego zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną.  
  
 Jeśli `cancellationToken` jest anulowane, wątku lub zadania, nie można przejść do semafor i <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości nie są odejmowane. Metoda zgłasza <xref:System.OperationCanceledException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.  
  
—lub— 
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzonego <paramref name="cancellationToken" /> został już usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="semaphoreSlim.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1 lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund 0 i przetestować dojście oczekiwania i natychmiast zwróci.</param>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />przy użyciu <see cref="T:System.TimeSpan" /> określić limit czasu.</summary>
        <returns><see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast. 
 
Jeśli wątku lub zadania jest możliwość wprowadzania semafor, jego zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną.  
  
Jeśli wątku lub zadania, jest zablokowany podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> i interwał limitu czasu określonego przez `millisecondsTimeout` wygasa:

- Wątku lub zadania, nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwości nie są odejmowane.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Wystąpienie semaphoreSlim został usunięty. <paramref name="." /></exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, <see cref="F:System.Threading.Timeout.Infinite" />(-1), aby czekać w nieskończoność, lub od zera do testowania stanu dojście oczekiwania i natychmiast zwróci.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Do obserwowania.</param>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu 32-bitowa liczba całkowita ze znakiem określa limit czasu podczas obserwowania <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns><see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast.

Jeśli wątku lub zadania jest możliwość wprowadzania semafor, jego zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną.  
  
Jeśli `cancellationToken` zostało anulowane, lub jeśli wątku lub zadania, jest zablokowany podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> i interwał limitu czasu określonego przez `millisecondsTimeout` wygasa:

- Wątku lub zadania, nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwości nie są odejmowane.  
 
Jeśli `cancellationToken` jest anulowane, metoda zgłasza <xref:System.OperationCanceledException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Wystąpienie zostało usunięte, lub <see cref="T:System.Threading.CancellationTokenSource" /> utworzonego <paramref name="cancellationToken" /> został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1 lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund 0 i przetestować dojście oczekiwania i natychmiast zwróci.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Do obserwowania.</param>
        <summary>Blokuje bieżący wątek, dopóki nie można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />przy użyciu <see cref="T:System.TimeSpan" /> określa limit czasu podczas obserwowania <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns><see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast. 

Jeśli wątku lub zadania jest możliwość wprowadzania semafor, jego zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość, według jedną.  
  
Jeśli `cancellationToken` zostało anulowane, lub jeśli wątku lub zadania, jest zablokowany podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> i interwał limitu czasu określonego przez `millisecondsTimeout` wygasa:

- Wątku lub zadania, nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwości nie są odejmowane.  

Jeśli `cancellationToken` jest anulowane, metoda zgłasza <xref:System.OperationCanceledException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Wystąpienie semaphoreSlim został usunięty. <paramref name="." /><paramref name="-or-" />  
  
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzonego <paramref name="cancellationToken" /> został już usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : unit -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <returns>Zadanie, które zostanie ukończone, gdy wprowadzono semafora.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (millisecondsTimeout As Integer) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność, lub od zera do testowania stanu dojście oczekiwania i natychmiast zwróci.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, za pomocą całkowita 32-bitowego do mierzenia przedział czasu.</summary>
        <returns>Zadanie, które zostanie ukończone z wynikiem <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie z wynikiem <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
 Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Token do obserwowania.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, obserwując <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie ukończone, gdy wprowadzono semafora.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (timeout As TimeSpan) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1 lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund 0 i przetestować dojście oczekiwania i natychmiast zwróci.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />przy użyciu <see cref="T:System.TimeSpan" /> do mierzenia przedział czasu.</summary>
        <returns>Zadanie, które zostanie ukończone z wynikiem <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie z wynikiem <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
 Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność, lub od zera do testowania stanu dojście oczekiwania i natychmiast zwróci.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Do obserwowania.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, za pomocą całkowita 32-bitowego do mierzenia przedział czasu, obserwując <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie ukończone z wynikiem <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie z wynikiem <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.
 
 Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> jest to liczba innych niż -1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1 lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund 0 i przetestować dojście oczekiwania i natychmiast zwróci.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Token do obserwowania.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />przy użyciu <see cref="T:System.TimeSpan" /> do mierzenia przedział czasu, obserwując <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie ukończone z wynikiem <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie z wynikiem <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na wartość-1 MS, metoda czeka na czas nieokreślony.

 Jeśli limit czasu jest równa zero milisekund, metoda nie blokuje. Testuje, stan dojście oczekiwania i zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, która reprezentuje nieskończony limit czasu — lub — limit czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
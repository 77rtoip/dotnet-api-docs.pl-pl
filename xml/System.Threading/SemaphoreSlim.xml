<Type Name="SemaphoreSlim" FullName="System.Threading.SemaphoreSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="573a8e5298201cd79283db5935a893129d2ba7a0" />
    <Meta Name="ms.sourcegitcommit" Value="d3cf721118797166546daadbf87d91d5c256d489" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/28/2018" />
    <Meta Name="ms.locfileid" Value="37077390" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SemaphoreSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SemaphoreSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class SemaphoreSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type SemaphoreSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Current Count = {m_currentCount}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje lekkie zamiast <see cref="T:System.Threading.Semaphore" /> , która ogranicza liczbę wątków, które mogą uzyskać dostęp do zasobu lub pulę zasobów jednocześnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją dwa typy semaforów: semaforów lokalnych i semaforów systemu o nazwie. Jest lokalny dla aplikacji. Drugie jest widoczny w całym systemie operacyjnym i nadaje się do synchronizacji między procesami. <xref:System.Threading.SemaphoreSlim> Jest lekki alternatywą do <xref:System.Threading.Semaphore> klasy, który nie używa semaforów jądra systemu Windows. W odróżnieniu od <xref:System.Threading.Semaphore> klasy <xref:System.Threading.SemaphoreSlim> klasa nie obsługuje systemu o nazwie semaforów. Można użyć jej jako tylko lokalne semafora. <xref:System.Threading.SemaphoreSlim> Klasa jest zalecane semafora synchronizacji w jednej aplikacji.  
  
 Semafor lekkie kontroluje dostęp do puli zasobów jest lokalny dla aplikacji. W przypadku wystąpienia semafora, można określić maksymalną liczbę wątków, które można wprowadzić jednocześnie semafora. Możesz również określić początkowa liczba wątków, które można wprowadzić jednocześnie semafora. Definiuje Licznik semafora.  
  
 Wartość licznika jest zmniejszany za każdym razem, wątek wprowadza semafora, i zwiększany po każdej wątku zwalnia semafora. Aby wprowadzić semafora, wątek wywołuje jeden z <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> przeciążenia. Aby zwolnić semafora, wywołuje jeden z <xref:System.Threading.SemaphoreSlim.Release%2A> przeciążenia. Gdy licznik osiągnie wartość 0, wezwań do jednego z `Wait` metody zablokować aż do semafora zwolnienia inne wątki. Po zablokowaniu wiele wątków jest nie gwarantuje kolejność, takich jak FIFO lub LIFO sterującą, gdy wątków wprowadź semafora.  
  
 Podstawowa struktura kodu, który używa semafora do ochrony zasobów jest:  
  
```vb  
  
' Enter semaphore by calling one of the Wait or WaitAsync methods.  
SemaphoreSlim.Wait()  
'   
' Execute code protected by the semaphore.   
'  
SemaphoreSlim.Release()  
  
```  
  
 Gdy wszystkie wątki zostały wydane semafora, wartość licznika jest wartość maksymalna określone podczas tworzenia semafora. Licznik semafora jest dostępna z <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości.  
  
> [!IMPORTANT]
>  <xref:System.Threading.SemaphoreSlim> Klasy nie wymusić tożsamości wątku lub zadań na wywołania <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, i <xref:System.Threading.SemaphoreSlim.Release%2A> metody. Ponadto jeśli <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> Konstruktor jest używany do utworzenia wystąpienia <xref:System.Threading.SemaphoreSlim> obiektu <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości można zwiększyć przekracza wartość ustawioną przez konstruktora. Odpowiada programisty upewnij się, który odwołuje się do <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody odpowiednio są skojarzone z wywołaniami <xref:System.Threading.SemaphoreSlim.Release%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy semafora z maksymalną liczbę wątków trzy i początkowa liczba wątków zero. W przykładzie uruchomiono pięć zadań, które zablokować oczekiwania semaforów. Wywołania wątku głównego <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> przeciążenia, aby zwiększyć licznik semafora do jego maksymalnej, co pozwala na wejście do semafora trzech zadań. Zawsze, gdy wydaniu semafora poprzedniej Licznik semafora jest wyświetlany. Użycie semafora śledzenie wiadomości konsoli. Interwał symulowane pracy zwiększają się nieznacznie dla każdego wątku ułatwić dane wyjściowe.  
  
 [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]
 [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.SemaphoreSlim" /> są wątkowo i mogą być stosowane jednocześnie wiele wątków, z wyjątkiem produktów <see cref="M:System.Threading.SemaphoreSlim.Dispose" />, którego można użyć tylko wtedy, gdy wszystkie operacje na <see cref="T:System.Threading.SemaphoreSlim" /> została ukończona.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim initialCount" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy, określając początkowa liczba żądań, które mogą mieć jednocześnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `initialCount` Parametr określa liczbę jednoczesnych żądań, aby wprowadzić semafora, które mogą być przyznane. Jednak go nie definiuje maksymalną liczbę żądań, które mogą mieć jednocześnie. A <xref:System.Threading.SemaphoreSlim> obiektu utworzone przez wywołanie tego konstruktora nie throw <xref:System.Threading.SemaphoreFullException> wyjątek, jeśli wywołanie <xref:System.Threading.SemaphoreSlim.Release%2A> metody zwiększa wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości poza `initialCount`. Dzieje się tak, jeśli jest więcej wywołań <xref:System.Threading.SemaphoreSlim.Release%2A> metody niż tam <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody. Aby ustawić maksymalną liczbę jednoczesnych żądań skierowanych do wprowadź semafora, które mogą być przyznane, należy wywołać <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount, int maxCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maxCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maxCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount, int maxCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int * int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim (initialCount, maxCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maxCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <param name="maxCount">Maksymalna liczba żądań semafora, które mogą być przyznane jednocześnie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy, określając początkowej i maksymalną liczbę żądań, które mogą mieć jednocześnie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> jest mniejsza niż 0, lub <paramref name="initialCount" /> jest większa niż <paramref name="maxCount" />, lub <paramref name="maxCount" /> jest równa lub mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="AvailableWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AvailableWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AvailableWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AvailableWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableWaitHandle : System.Threading.WaitHandle" Usage="System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca <see cref="T:System.Threading.WaitHandle" /> można czekać na semafora.</summary>
        <value>A <see cref="T:System.Threading.WaitHandle" /> można czekać na semafora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć tylko wtedy, gdy należy poczekać na SemaphoreSlim z innymi obiektami na podstawie jądra synchronizacji z tym samym dojście oczekiwania. Pomyślne oczekiwanie na <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> nie oznacza pomyślne oczekiwania na <xref:System.Threading.SemaphoreSlim> , ani nie jest dekrementacji Licznik semafora. Po dojście oczekiwania dostępne jest sygnalizowane, należy poczekać <xref:System.Threading.SemaphoreSlim> specjalnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCount : int" Usage="System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozostałych wątków, które można wprowadzić <see cref="T:System.Threading.SemaphoreSlim" /> obiektu.</summary>
        <value>Liczba pozostałych wątków, które można wprowadzić semafora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość jest ustawiana przez wywołanie <xref:System.Threading.SemaphoreSlim.%23ctor%2A> konstruktora klasy. Jest zmniejszany przez każde wywołanie <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody i zwiększając każde wywołanie <xref:System.Threading.SemaphoreSlim.Release%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="semaphoreSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie `Dispose` po zakończeniu przy użyciu <xref:System.Threading.SemaphoreSlim>. `Dispose` Pozostawia metody <xref:System.Threading.SemaphoreSlim> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Threading.SemaphoreSlim> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Threading.SemaphoreSlim> klasy.  
  
 Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze `Dispose` przed zwolnieniem ostatniego odwołania do <xref:System.Threading.SemaphoreSlim>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Threading.SemaphoreSlim> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="semaphoreSlim.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.SemaphoreSlim" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości członków <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> nie jest bezpieczne wątkowo i nie mogą być używane równocześnie z innymi członkami tego wystąpienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wersje <see cref="T:System.Threading.SemaphoreSlim" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphoreSlim.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wersje <see cref="T:System.Threading.SemaphoreSlim" /> obiekt na raz.</summary>
        <returns>Liczba poprzednich <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.SemaphoreSlim.Release> zwiększa metody <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden. Jeśli wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości wynosi zero, aby wywołać tę metodę, metoda pozwala jeden wątek lub zablokowane przez wywołanie do zadań <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metodę, aby wprowadzić semafora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Osiągnęła już maksymalny rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphoreSlim.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Liczba razy, aby zamknąć semafora.</param>
        <summary>Wersje <see cref="T:System.Threading.SemaphoreSlim" /> obiekt o określoną liczbę razy.</summary>
        <returns>Liczba poprzednich <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> zwiększa metody <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości przez `releaseCount`. Jeśli wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości wynosi zero, aby wywołać tę metodę, metoda umożliwia również `releaseCount` wątków lub zablokowane przez wywołanie zadania <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metodę, aby wprowadzić semafora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> jest mniejsza niż 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Osiągnęła już maksymalny rozmiar.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="semaphoreSlim.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątku lub zadanie jest w stanie semafora, wprowadź go zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości o jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="semaphoreSlim.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" />(-1), aby czekać w nieskończoność, lub zero, aby przetestować stan dojście oczekiwania i zwracać natychmiast.</param>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu 32-bitowe liczby całkowite ze znakiem określa limit czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 
Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast.

Jeśli wątku lub zadanie jest w stanie semafora, wprowadź go zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości o jeden.  
  
Wątek lub zadanie zostało zablokowane podczas wywoływania metody <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> i limit czasu określony przez `millisecondsTimeout` wygaśnie:

- Wątek lub zadania nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="semaphoreSlim.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Token, aby przyjrzeć się.</param>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />, obserwując <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątku lub zadanie jest w stanie semafora, wprowadź go zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości o jeden.  
  
 Jeśli `cancellationToken` jest anulowane, wątek lub zadania nie można przejść do semafora i <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość nie jest zmniejszany. Metoda zgłasza <xref:System.OperationCanceledException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.  - lub - <see cref="T:System.Threading.CancellationTokenSource" /> utworzony <paramref name="cancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="semaphoreSlim.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony, lub <see cref="T:System.TimeSpan" /> reprezentujący 0 milisekund, aby przetestować dojście oczekiwania i zwracać natychmiast.</param>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />za pomocą <see cref="T:System.TimeSpan" /> określić limit czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast. 
 
Jeśli wątku lub zadanie jest w stanie semafora, wprowadź go zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości o jeden.  
  
Wątek lub zadanie zostało zablokowane podczas wywoływania metody <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> i limit czasu określony przez `millisecondsTimeout` wygaśnie:

- Wątek lub zadania nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszany.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Wystąpienie semaphoreSlim został usunięty. <paramref name="." /></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" />(-1), aby czekać w nieskończoność, lub zero, aby przetestować stan dojście oczekiwania i zwracać natychmiast.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Aby przyjrzeć się.</param>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu 32-bitowe liczby całkowite ze znakiem określa limit czasu podczas obserwowania <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast.

Jeśli wątku lub zadanie jest w stanie semafora, wprowadź go zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości o jeden.  
  
Jeśli `cancellationToken` zostało anulowane lub wątku lub zadanie zostało zablokowane podczas wywoływania metody <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> i limit czasu określony przez `millisecondsTimeout` wygaśnie:

- Wątek lub zadania nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszany.  
 
Jeśli `cancellationToken` jest anulowany, metoda wygeneruje <xref:System.OperationCanceledException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Wystąpienia został usunięty, lub <see cref="T:System.Threading.CancellationTokenSource" /> utworzony <paramref name="cancellationToken" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony, lub <see cref="T:System.TimeSpan" /> reprezentujący 0 milisekund, aby przetestować dojście oczekiwania i zwracać natychmiast.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Aby przyjrzeć się.</param>
        <summary>Blokuje bieżącego wątku, dopóki nie można go wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />za pomocą <see cref="T:System.TimeSpan" /> określający limit czasu podczas obserwowania <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast. 

Jeśli wątku lub zadanie jest w stanie semafora, wprowadź go zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości o jeden.  
  
Jeśli `cancellationToken` zostało anulowane lub wątku lub zadanie zostało zablokowane podczas wywoływania metody <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> i limit czasu określony przez `millisecondsTimeout` wygaśnie:

- Wątek lub zadania nie można przejść do semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszany.  

Jeśli `cancellationToken` jest anulowany, metoda wygeneruje <xref:System.OperationCanceledException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Został usunięty z wystąpieniem semaphoreSlim <paramref name="." /><paramref name="-or-" /><see cref="T:System.Threading.CancellationTokenSource" /> utworzony <paramref name="cancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : unit -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <returns>Zadanie, które zostanie zakończony, gdy semafor został wprowadzony.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (millisecondsTimeout As Integer) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność, lub zero, aby przetestować stan dojście oczekiwania i zwracać natychmiast.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu całkowita 32-bitowej do mierzenia przedział czasu.</summary>
        <returns>Zadanie, które zostanie zakończony w wyniku <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie wynik z <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
 Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Token, aby przyjrzeć się.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, obserwując <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie zakończony, gdy semafor został wprowadzony.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (timeout As TimeSpan) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony, lub <see cref="T:System.TimeSpan" /> reprezentujący 0 milisekund, aby przetestować dojście oczekiwania i zwracać natychmiast.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />za pomocą <see cref="T:System.TimeSpan" /> do mierzenia przedział czasu.</summary>
        <returns>Zadanie, które zostanie zakończony w wyniku <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie wynik z <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
 Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność, lub zero, aby przetestować stan dojście oczekiwania i zwracać natychmiast.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Aby przyjrzeć się.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu całkowita 32-bitowej do mierzenia przedział czasu podczas obserwowania <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie zakończony w wyniku <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie wynik z <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.
 
 Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony, lub <see cref="T:System.TimeSpan" /> reprezentujący 0 milisekund, aby przetestować dojście oczekiwania i zwracać natychmiast.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Token, aby przyjrzeć się.</param>
        <summary>Asynchronicznie oczekuje na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />za pomocą <see cref="T:System.TimeSpan" /> do mierzenia przedział czasu podczas obserwowania <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie zakończony w wyniku <see langword="true" /> Jeśli bieżący wątek pomyślnie wprowadzone <see cref="T:System.Threading.SemaphoreSlim" />, w przeciwnym razie wynik z <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu ma ustawioną wartość-1 milisekund, metody oczekuje w nieskończoność.

 Jeśli limit czasu wynosi zero w milisekundach, nie blokuje metody. Sprawdza stan dojście oczekiwania, a zwraca natychmiast. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna od-1, która reprezentuje nieskończonego limitu czasu - lub - limitu czasu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
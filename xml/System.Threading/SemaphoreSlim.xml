<Type Name="SemaphoreSlim" FullName="System.Threading.SemaphoreSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90123bc6c711f4739700b8e51f6e2da7873234f5" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69098742" /></Metadata><TypeSignature Language="C#" Value="public class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SemaphoreSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SemaphoreSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class SemaphoreSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type SemaphoreSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Current Count = {m_currentCount}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje uproszczoną alternatywę <see cref="T:System.Threading.Semaphore" /> , która ogranicza liczbę wątków, które mogą uzyskać dostęp do zasobów lub puli zasobów współbieżnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Semafory są dwa typy: semafory lokalne i nazwane semafory systemowe. Była to lokalna dla aplikacji. Ten drugi jest widoczny w całym systemie operacyjnym i jest odpowiedni do synchronizacji między procesami. Jest to lekki alternatywa <xref:System.Threading.Semaphore> dla klasy, która nie używa semaforów jądra systemu Windows. <xref:System.Threading.SemaphoreSlim> W przeciwieństwie <xref:System.Threading.Semaphore> do klasy <xref:System.Threading.SemaphoreSlim> Klasa nie obsługuje nazwanych semaforów systemu. Można go używać tylko jako semafora lokalnego. <xref:System.Threading.SemaphoreSlim> Klasa jest zalecanym semaforem dla synchronizacji w ramach jednej aplikacji.  
  
 Lekki semafor kontroluje dostęp do puli zasobów, która jest lokalna dla Twojej aplikacji. Podczas tworzenia wystąpienia semafora można określić maksymalną liczbę wątków, które mogą wprowadzać semafor współbieżnie. Należy również określić początkową liczbę wątków, które mogą wprowadzać semafor współbieżnie. Definiuje liczbę semaforów.  
  
 Licznik jest zmniejszany za każdym razem, gdy wątek przechodzi do semafora i zwiększa się za każdym razem, gdy wątek zwalnia semafor. Aby wprowadzić semafor, wątek wywołuje jedno z <xref:System.Threading.SemaphoreSlim.Wait%2A> <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> przeciążeń. Do zwolnienia semafora wywołuje jedno z <xref:System.Threading.SemaphoreSlim.Release%2A> przeciążeń. Gdy licznik osiągnie wartość zero, kolejne wywołania do jednej z tych `Wait` metod są blokowane do momentu zwolnienia semafora przez inne wątki. W przypadku zablokowania wielu wątków nie istnieje gwarantowana kolejność, taka jak FIFO lub LIFO, która kontroluje, kiedy wątki wprowadzają semafor.  
  
 Podstawowa struktura kodu korzystającego z semafora do ochrony zasobów to:  
  
```vb  
  
' Enter semaphore by calling one of the Wait or WaitAsync methods.  
SemaphoreSlim.Wait()  
'   
' Execute code protected by the semaphore.   
'  
SemaphoreSlim.Release()  
  
```  
  
 Gdy wszystkie wątki wywydały semafor, licznik jest przy maksymalnej wartości określonej podczas tworzenia semafora. Liczba semaforów jest dostępna z <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości.  
  
> [!IMPORTANT]
>  Klasa nie wymusza tożsamości wątku ani zadania dla wywołań <xref:System.Threading.SemaphoreSlim.Wait%2A>metod, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, i <xref:System.Threading.SemaphoreSlim.Release%2A>. <xref:System.Threading.SemaphoreSlim> Ponadto, jeśli <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> Konstruktor jest używany do tworzenia <xref:System.Threading.SemaphoreSlim> wystąpienia obiektu, <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość może wzrosnąć poza wartość ustawioną przez konstruktora. Programista jest odpowiedzialny za zapewnienie, że wywołania <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody są odpowiednio <xref:System.Threading.SemaphoreSlim.Release%2A> sparowane z wywołaniami metod.  
  
   
  
## Examples  
 Poniższy przykład tworzy semafor z maksymalną liczbą trzech wątków i początkową liczbą zero wątków. Przykład uruchamia pięć zadań, dla których blok oczekuje na semafor. Główny wątek wywołuje <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> Przeciążenie, aby zwiększyć maksymalną liczbę semaforów, co umożliwia wykonywanie trzech zadań w celu wejścia do semafora. Za każdym razem, gdy semafor zostanie wystawiony, zostanie wyświetlona Poprzednia liczba semaforów. Komunikaty konsoli śledzą użycie semafora. Symulowany interwał pracy został nieco zwiększony dla każdego wątku, aby ułatwić odczytywanie danych wyjściowych.  
  
 [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]
 [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.SemaphoreSlim" /> są bezpieczne dla wątków i mogą być używane współbieżnie z wielu wątków, z <see cref="M:System.Threading.SemaphoreSlim.Dispose" />wyjątkiem, które muszą być używane tylko wtedy, gdy <see cref="T:System.Threading.SemaphoreSlim" /> wszystkie inne operacje na zakończono.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim initialCount" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.SemaphoreSlim" /> klasy, określając początkową liczbę żądań, które mogą być przyznawane współbieżnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `initialCount` Parametr określa liczbę współbieżnych żądań do wprowadzenia semafora, który może być przyznany. Nie definiuje jednak maksymalnej liczby żądań, które mogą być przyznawane współbieżnie. <xref:System.Threading.SemaphoreSlim.Release%2A> <xref:System.Threading.SemaphoreFullException> `initialCount` <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Obiekt skonkretyzowany przez wywołanie tego konstruktora nie zgłasza wyjątku, jeśli wywołanie metody zwiększa wartość właściwości poza. <xref:System.Threading.SemaphoreSlim> Dzieje się tak, jeśli istnieją więcej wywołań <xref:System.Threading.SemaphoreSlim.Release%2A> metod niż istnieje <xref:System.Threading.SemaphoreSlim.Wait%2A> lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> metody. Aby ustawić maksymalną liczbę równoczesnych żądań w celu wprowadzenia semafora, który może być przyznany, <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> Wywołaj konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount" />jest mniejsza niż 0.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount, int maxCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maxCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maxCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount, int maxCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int * int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim (initialCount, maxCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maxCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Początkowa liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <param name="maxCount">Maksymalna liczba żądań dla semafora, które mogą być przyznawane współbieżnie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.SemaphoreSlim" /> klasy, określając początkową i maksymalną liczbę żądań, które mogą być przyznawane współbieżnie.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount" />jest mniejsza niż 0 lub <paramref name="initialCount" /> jest większa niż <paramref name="maxCount" /> <paramref name="maxCount" /> lub równa lub mniejsza od 0.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AvailableWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AvailableWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AvailableWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableWaitHandle : System.Threading.WaitHandle" Usage="System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Threading.WaitHandle" /> , która może być używana do oczekiwania na semafor.</summary>
        <value><see cref="T:System.Threading.WaitHandle" /> , Który może być używany do oczekiwania na semafor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy używać tylko wtedy, gdy trzeba czekać na SemaphoreSlim wraz z innymi obiektami synchronizacji opartymi na jądrze z tym samym dojściem oczekiwania. Pomyślne oczekiwanie na to <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> nie oznacza pomyślne oczekiwanie <xref:System.Threading.SemaphoreSlim> na siebie lub zmniejszenie liczby semaforów. Po zasygnalizowaniu dostępnego uchwytu oczekiwania należy zaczekać na <xref:System.Threading.SemaphoreSlim> założenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCount : int" Usage="System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę pozostałych wątków, które mogą wprowadzić <see cref="T:System.Threading.SemaphoreSlim" /> obiekt.</summary>
        <value>Liczba pozostałych wątków, które mogą wprowadzić semafor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowa wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości jest ustawiana przez wywołanie <xref:System.Threading.SemaphoreSlim.%23ctor%2A> konstruktora klasy. Jest zmniejszany przez każde wywołanie <xref:System.Threading.SemaphoreSlim.Wait%2A> metody lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> i zwiększane <xref:System.Threading.SemaphoreSlim.Release%2A> przez każde wywołanie metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="semaphoreSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.SemaphoreSlim" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `Dispose` po zakończeniu korzystania z <xref:System.Threading.SemaphoreSlim>. `Dispose` Metoda<xref:System.Threading.SemaphoreSlim> pozostawia w stanie niezdatnym do użytku. Po wywołaniu `Dispose`należy wydać wszystkie odwołania <xref:System.Threading.SemaphoreSlim> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Threading.SemaphoreSlim> , którą zajmował.  
  
 Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj `Dispose` przed wydaniem ostatniego odwołania <xref:System.Threading.SemaphoreSlim>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Threading.SemaphoreSlim> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="semaphoreSlim.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.SemaphoreSlim" />program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości elementów członkowskich <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> nie jest bezpieczne dla wątków i nie może być używane jednocześnie z innymi elementami członkowskimi tego wystąpienia.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.SemaphoreSlim" /> Zwalnia obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphoreSlim.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.SemaphoreSlim" /> Zwalnia obiekt jeden raz.</summary>
        <returns>Poprzednia liczba <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.SemaphoreSlim.Release> metody zwiększa <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden. Jeśli wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości jest równa zero przed wywołaniem tej metody, Metoda również zezwala jednemu wątkowi lub zadaniu blokowanym przez wywołanie <xref:System.Threading.SemaphoreSlim.Wait%2A> metody lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> , aby wprowadzić semafor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><see cref="T:System.Threading.SemaphoreSlim" /> Osiągnięto już maksymalny rozmiar.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphoreSlim.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Liczba godzin zamykania semafora.</param>
        <summary><see cref="T:System.Threading.SemaphoreSlim" /> Zwalnia obiekt określoną liczbę razy.</summary>
        <returns>Poprzednia liczba <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> metody powoduje zwiększenie <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości przez `releaseCount`. Jeśli wartość <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwości jest równa zero przed wywołaniem tej metody, Metoda również zezwala `releaseCount` na wątki lub zadania zablokowane <xref:System.Threading.SemaphoreSlim.Wait%2A> przez wywołanie metody lub <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> , aby wprowadzić semafor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" />jest mniejsza niż 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><see cref="T:System.Threading.SemaphoreSlim" /> Osiągnięto już maksymalny rozmiar.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje bieżący wątek, dopóki nie będzie mógł wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="semaphoreSlim.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje bieżący wątek, dopóki nie będzie mógł wprowadzić <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek lub zadanie jest w stanie wprowadzić semafor, zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="semaphoreSlim.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" />(-1) oczekiwania na czas nieokreślony lub zero w celu przetestowania stanu uchwytu oczekiwania i natychmiastowego zwrócenia.</param>
        <summary>Blokuje bieżący wątek <see cref="T:System.Threading.SemaphoreSlim" />, dopóki nie będzie mógł wprowadzić, przy użyciu 32-bitowej podpisanej liczby całkowitej, która określa limit czasu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek został pomyślnie wprowadzony <see cref="T:System.Threading.SemaphoreSlim" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 
Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca.

Jeśli wątek lub zadanie jest w stanie wprowadzić semafor, zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden.  
  
Jeśli wątek lub zadanie są blokowane podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> i interwał limitu czasu określony przez `millisecondsTimeout` wygasną:

- Wątek lub zadanie nie wprowadza semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="semaphoreSlim.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Token do obserwowania.</param>
        <summary>Blokuje bieżący wątek, dopóki nie będzie mógł wejść <see cref="T:System.Threading.SemaphoreSlim" />do programu, podczas gdy <see cref="T:System.Threading.CancellationToken" />zaobserwować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek lub zadanie jest w stanie wprowadzić semafor, zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden.  
  
 Jeśli `cancellationToken` zostanie anulowana, wątek lub zadanie nie wprowadza semafora <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> i właściwość nie zostanie zmniejszona. Zamiast tego Metoda zgłasza <xref:System.OperationCanceledException> wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" />zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.  
  
—lub— 
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzony<paramref name="cancellationToken" /> został już usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="semaphoreSlim.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentujący liczbę milisekund oczekiwania <see cref="T:System.TimeSpan" /> , która reprezentuje-1 milisekund, czeka na czas nieokreślony, lub wartość <see cref="T:System.TimeSpan" /> reprezentującą 0 milisekund do przetestowania uchwytu oczekiwania i natychmiastowego zwrócenia. <see cref="T:System.TimeSpan" /></param>
        <summary>Blokuje bieżący wątek do momentu <see cref="T:System.Threading.SemaphoreSlim" />, w którym będzie można wprowadzić <see cref="T:System.TimeSpan" /> przy użyciu polecenia, aby określić limit czasu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek został pomyślnie wprowadzony <see cref="T:System.Threading.SemaphoreSlim" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca. 
 
Jeśli wątek lub zadanie jest w stanie wprowadzić semafor, zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden.  
  
Jeśli wątek lub zadanie są blokowane podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> i interwał limitu czasu określony przez `millisecondsTimeout` wygasną:

- Wątek lub zadanie nie wprowadza semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszana.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
        <exception cref="T:System.ObjectDisposedException">Wystąpienie semaphoreSlim zostało usunięte<paramref name="." /></exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" />(-1) oczekiwania na czas nieokreślony lub zero w celu przetestowania stanu uchwytu oczekiwania i natychmiastowego zwrócenia.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Do obserwowania.</param>
        <summary>Blokuje bieżący wątek <see cref="T:System.Threading.SemaphoreSlim" />, dopóki nie będzie mógł wprowadzić, przy użyciu 32-bitowej podpisanej liczby całkowitej, która określa limit czasu, przy <see cref="T:System.Threading.CancellationToken" />zachowaniu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek został pomyślnie wprowadzony <see cref="T:System.Threading.SemaphoreSlim" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca.

Jeśli wątek lub zadanie jest w stanie wprowadzić semafor, zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden.  
  
Jeśli `cancellationToken` zostanie anulowana, lub jeśli wątek lub zadanie są blokowane podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> i interwał limitu czasu określony przez `millisecondsTimeout` wygasną:

- Wątek lub zadanie nie wprowadza semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszana.  
 
Jeśli `cancellationToken` zostanie anulowana, Metoda <xref:System.OperationCanceledException> zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" />zostało anulowane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
        <exception cref="T:System.ObjectDisposedException">Wystąpienie zostało zlikwidowane <see cref="T:System.Threading.CancellationTokenSource" /> lub utworzone <paramref name="cancellationToken" /> zostało usunięte. <see cref="T:System.Threading.SemaphoreSlim" /></exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentujący liczbę milisekund oczekiwania <see cref="T:System.TimeSpan" /> , która reprezentuje-1 milisekund, czeka na czas nieokreślony, lub wartość <see cref="T:System.TimeSpan" /> reprezentującą 0 milisekund do przetestowania uchwytu oczekiwania i natychmiastowego zwrócenia. <see cref="T:System.TimeSpan" /></param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Do obserwowania.</param>
        <summary>Blokuje bieżący wątek do momentu <see cref="T:System.Threading.SemaphoreSlim" />, w <see cref="T:System.TimeSpan" /> którym będzie można wprowadzić, przy użyciu, który określa limit czasu <see cref="T:System.Threading.CancellationToken" />, przy zachowaniu.</summary>
        <returns><see langword="true" />Jeśli bieżący wątek został pomyślnie wprowadzony <see cref="T:System.Threading.SemaphoreSlim" />; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca. 

Jeśli wątek lub zadanie jest w stanie wprowadzić semafor, zmniejsza <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> właściwość o jeden.  
  
Jeśli `cancellationToken` zostanie anulowana, lub jeśli wątek lub zadanie są blokowane podczas wywoływania <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> i interwał limitu czasu określony przez `millisecondsTimeout` wygasną:

- Wątek lub zadanie nie wprowadza semafora.
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> Właściwość nie jest zmniejszana.  

Jeśli `cancellationToken` zostanie anulowana, Metoda <xref:System.OperationCanceledException> zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" />zostało anulowane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
        <exception cref="T:System.ObjectDisposedException">Wystąpienie semaphoreSlim zostało usunięte<paramref name="." /><paramref name="-or-" />  
  
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzony<paramref name="cancellationToken" /> został już usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafor i klasa SemaphoreSlim</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : unit -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <returns>Zadanie, które zostanie ukończone po wprowadzeniu semafora.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (millisecondsTimeout As Integer) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony lub zero w celu przetestowania stanu uchwytu oczekiwania i natychmiastowego zwrócenia.</param>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu 32-bitowej podpisanej liczby całkowitej w celu zmierzenia interwału czasu.</summary>
        <returns>Zadanie, które zostanie wykonane z wynikiem <see langword="true" /> <see cref="T:System.Threading.SemaphoreSlim" />, jeśli bieżący wątek został pomyślnie wprowadzony, w <see langword="false" />przeciwnym razie z wynikiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
 Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Token do obserwowania.</param>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, podczas gdy zaobserwować <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Zadanie, które zostanie ukończone po wprowadzeniu semafora.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" />zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (timeout As TimeSpan) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentujący liczbę milisekund oczekiwania <see cref="T:System.TimeSpan" /> , która reprezentuje-1 milisekund, czeka na czas nieokreślony, lub wartość <see cref="T:System.TimeSpan" /> reprezentującą 0 milisekund do przetestowania uchwytu oczekiwania i natychmiastowego zwrócenia. <see cref="T:System.TimeSpan" /></param>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu <see cref="T:System.TimeSpan" /> a do mierzenia interwału czasu.</summary>
        <returns>Zadanie, które zostanie wykonane z wynikiem <see langword="true" /> <see cref="T:System.Threading.SemaphoreSlim" />, jeśli bieżący wątek został pomyślnie wprowadzony, w <see langword="false" />przeciwnym razie z wynikiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
 Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania, <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony lub zero w celu przetestowania stanu uchwytu oczekiwania i natychmiastowego zwrócenia.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Do obserwowania.</param>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu 32-bitowej podpisanej liczby całkowitej w celu zmierzenia interwału czasu, zachowując. <see cref="T:System.Threading.CancellationToken" /></summary>
        <returns>Zadanie, które zostanie wykonane z wynikiem <see langword="true" /> <see cref="T:System.Threading.SemaphoreSlim" />, jeśli bieżący wątek został pomyślnie wprowadzony, w <see langword="false" />przeciwnym razie z wynikiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.
 
 Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą inną niż-1, która reprezentuje nieskończony limit czasu lub wartość-Timeout jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie zostało już usunięte.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" />zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentujący liczbę milisekund oczekiwania <see cref="T:System.TimeSpan" /> , która reprezentuje-1 milisekund, czeka na czas nieokreślony, lub wartość <see cref="T:System.TimeSpan" /> reprezentującą 0 milisekund do przetestowania uchwytu oczekiwania i natychmiastowego zwrócenia. <see cref="T:System.TimeSpan" /></param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Token do obserwowania.</param>
        <summary>Asynchronicznie czeka na wprowadzenie <see cref="T:System.Threading.SemaphoreSlim" />, przy użyciu <see cref="T:System.TimeSpan" /> a w celu zmierzenia interwału czasu <see cref="T:System.Threading.CancellationToken" />, przy zachowaniu.</summary>
        <returns>Zadanie, które zostanie wykonane z wynikiem <see langword="true" /> <see cref="T:System.Threading.SemaphoreSlim" />, jeśli bieżący wątek został pomyślnie wprowadzony, w <see langword="false" />przeciwnym razie z wynikiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli limit czasu jest ustawiony na-1 milisekund, metoda czeka na czas nieokreślony.

 Jeśli limit czasu jest ustawiony na zero milisekund, metoda nie blokuje. Testuje stan uchwytu oczekiwania i natychmiast wraca. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, która reprezentuje nieskończony limit czasu-lub-limit czasu jest większy <see cref="F:System.Int32.MaxValue" />niż.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" />zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.SemaphoreSlim" /> Został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

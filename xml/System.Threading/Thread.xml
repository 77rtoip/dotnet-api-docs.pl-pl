<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7aae04c039e4c598f2f78c1131b5525f9c9e9654" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407698" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Tworzy i formanty wątku, ustawia jego priorytetu i pobiera jego stan.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu procesu środowisko uruchomieniowe języka wspólnego automatycznie tworzy wątku pojedynczego pierwszego planu na wykonanie kodu aplikacji. Wraz z tego wątku głównego pierwszego planu procesu można utworzyć jeden lub więcej wątków do wykonania fragment kodu programu skojarzonych z procesem. Wątki te mogą wykonywać na pierwszym planie lub w tle. Ponadto można użyć <xref:System.Threading.ThreadPool> klasy na wykonanie kodu na wątków roboczych, które są zarządzane przez środowisko uruchomieniowe języka wspólnego.  
  
 W tej sekcji  
  
 [Uruchamianie wątku](#Starting)   
 [Pobieranie obiektów wątków](#Retrieving)   
 [Wątki pierwszego planu i tła](#Foreground)   
 [Kultura i wątków](#Culture)   
 [Otrzymanie informacji o i sterowanie wątkami](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Uruchamianie wątku  
 Podając delegata, który reprezentuje metodę, którą wątek znajduje się w jego konstruktora klasy można rozpocząć wątku. Następnie wywołaj <xref:System.Threading.Thread.Start%2A> metody, aby rozpocząć wykonywania.  
  
 <xref:System.Threading.Thread> Konstruktorów może przybrać jedną z delegata dwa typy, w zależności od tego, czy przekazując argument do metody do wykonania:  
  
-   Jeśli metoda nie ma argumentów, Przekaż <xref:System.Threading.ThreadStart> delegować do konstruktora. Ma podpis:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Poniższy przykład utworzenie i uruchomienie wątku, który wykonuje `ExecuteInForeground` metody. Metoda Wyświetla informacje o niektórych właściwości wątku, a następnie wykonuje pętlę, w którym wstrzymuje pół sekundy i wyświetla liczbę sekund, który upłynął. Gdy wątek zostało wykonane co najmniej pięć sekund, kończy się pętli i wątku kończy wykonywanie.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Jeśli metoda ma argument, Przekaż <xref:System.Threading.ParameterizedThreadStart> delegować do konstruktora. Ma podpis:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Metoda wykonywane przez delegata można rzutowanie (C#) lub przekonwertować (w języku Visual Basic) parametr do odpowiedniego typu.  
  
     Poniższy przykład jest taki sam jak poprzedni, z wyjątkiem tego, aby wywoływał <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora. Ta wersja `ExecuteInForeground` metoda ma jeden parametr reprezentujący przybliżoną liczbę milisekund pętli ma zostać wykonany.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Nie jest konieczne zachować odwołanie do <xref:System.Threading.Thread> obiektu po uruchomieniu wątku. Wątek w dalszym ciągu wykonaj aż do zakończenia procedury wątku.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Pobieranie obiektów wątków  
 Można użyć statycznych (`Shared` w języku Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> właściwość, aby pobrać odwołanie do aktualnie realizowanej wątku z kodu, który jest wykonywany wątku. W poniższym przykładzie użyto <xref:System.Threading.Thread.CurrentThread%2A> właściwości, aby wyświetlić informacje o wątku głównego aplikacji, inny wątek pierwszego planu wątku w tle i wątku puli wątków.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Wątki pierwszego planu i tła  
 Wystąpienia <xref:System.Threading.Thread> klasy reprezentują wątki pierwszoplanowe lub wątki w tle. Wątki w tle są takie same jak wątki pierwszoplanowe z jednym wyjątkiem: wątku w tle nie przechowuje proces uruchomiony, jeśli wszystkie wątki pierwszoplanowe zostały zakończone. Po zostały zatrzymane wszystkie wątki pierwszego planu, środowisko uruchomieniowe zatrzymuje wszystkie wątki w tle i zamyka.  
  
 Domyślnie następujące wątków wykonania na pierwszym planie:  
  
-   Wątku głównego aplikacji.  
  
-   Wszystkie wątki utworzona przez wywołanie metody <xref:System.Threading.Thread> konstruktora klasy.  
  
 Domyślnie następujące wątków wykonywane w tle:  
  
-   Wątków z puli wątków, które są puli wątków roboczych obsługiwane przez środowisko uruchomieniowe.  Wątek puli i harmonogram pracy można skonfigurować na wątków z puli wątków, przy użyciu <xref:System.Threading.ThreadPool> klasy.  
  
    > [!NOTE]
    >  Oparty na zadaniach asynchronicznej operacji automatycznie wykonywane na wątków z puli wątków. Użyj opartego na zadaniach asynchronicznej operacji <xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> klasy do zaimplementowania [wzorca asynchronicznego opartego na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Wszystkie wątki, które wprowadź zarządzanego środowiska wykonawczego z kodem niezarządzanym.  
  
 Możesz zmienić wątku do wykonania w tle przez ustawienie <xref:System.Threading.Thread.IsBackground%2A> właściwości w dowolnym momencie.  Wątki w tle są przydatne do żadnej operacji, które powinno być kontynuowane tak długo, jak aplikacja jest uruchomiona, ale nie powinien uniemożliwiają aplikacji przerywanie, takich jak monitorowanie zmian systemu plików lub przychodzące połączenia gniazda.  
  
 Poniższy przykład przedstawia różnice między wątkami pierwszego planu i tła. Podobnie jak w pierwszym przykładzie [uruchamianie wątku](#Starting) sekcji z tą różnicą, że ustawia wątku do wykonania w tle przed jego rozpoczęciem. Jak pokazano na dane wyjściowe, pętli zostało przerwane przed rozpoczęciem wykonywania przez pięć sekund.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Kultura i wątków  
 Każdy wątek jest kulturą reprezentowany przez <xref:System.Threading.Thread.CurrentCulture%2A> właściwości i kultury interfejsu użytkownika, reprezentowane przez <xref:System.Threading.Thread.CurrentUICulture%2A> właściwości.  Bieżąca kultura obsługuje takie zależne od kultury operacje jako analizowania i formatowanie, porównywanie i sortowanie ciągów i również określać system pisma i używany przez wątek kalendarz. Udostępnia bieżącej kultury interfejsu użytkownika dla pobierania zależne od kultury zasobów plików zasobów.  
  
 Podczas tworzenia wystąpienia klasy nowego wątku jego kultury i kultury interfejsu użytkownika są definiowane przez bieżącego ustawienia kulturowego systemu i kultury interfejsu użytkownika, a nie przez kultury i kultury interfejsu użytkownika w wątku, z którego jest tworzony nowego wątku. Oznacza to, na przykład, że jeśli bieżące ustawienia kulturowe systemu jest angielski (Stany Zjednoczone) i bieżącej kultury wątku aplikacji głównej jest francuski (Francja), kultura nowego wątku utworzona przez wywołanie metody <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora z podstawowym wątku jest angielski (Stany Zjednoczone), francuski (Francja). Aby uzyskać więcej informacji, zobacz sekcję "Kultury i wątków" <xref:System.Globalization.CultureInfo> klasy tematu.  
  
> [!IMPORTANT]
>  Nie dotyczy wątków, które wykonują operacje asynchroniczne dla aplikacji przeznaczonych [!INCLUDE[net_v46](~/includes/net-v46-md.md)] i nowszych wersjach, w tym przypadku, kultury i kultury interfejsu użytkownika jest częścią asynchronicznego operacjach kontekście; wątku, w którym operacji asynchronicznej wykonuje przez domyślny dziedziczy kultury i kultury interfejsu użytkownika w wątku, w którym została uruchomiona operacja asynchroniczna. Aby uzyskać więcej informacji, zobacz sekcję "Kultury i oparty na zadaniach asynchronicznej operacji" <xref:System.Globalization.CultureInfo> klasy tematu.  
  
 Wykonaj jedną z następujących czynności, aby upewnić się, że wszystkie wątki wykonywania w aplikacji korzysta z tej samej kultury i kultura interfejsu użytkownika:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tego kultura <xref:System.Threading.ParameterizedThreadStart> delegować lub <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> metody.  
  
-   Dla aplikacji działających na [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i nowszych wersjach można zdefiniować kultury i kultury interfejsu użytkownika, który ma być przypisana do wszystkich wątków utworzonych w domenie aplikacji przez ustawienie wartości <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> właściwości. Należy pamiętać, że jest to ustawienie domeny dla poszczególnych aplikacji.  
  
 Aby uzyskać dodatkowe informacje i przykłady, zobacz sekcję "Kultury i wątków" <xref:System.Globalization.CultureInfo> klasy tematu.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Otrzymanie informacji o i sterowanie wątkami  
 Możesz pobrać wiele wartości właściwości, które zawierają informacje o wątku. W niektórych przypadkach można również ustawić wartości tych właściwości, do kontrolowania operacji wątek. Te właściwości wątku obejmują:  
  
-   Nazwa. <xref:System.Threading.Thread.Name%2A> jest zapis — raz właściwość, która służy do identyfikowania wątku.  Jego wartość domyślna to `null`.  
  
-   Wartość skrótu, który można pobrać przez wywołanie metody <xref:System.Threading.Thread.GetHashCode%2A> metody. Wartość skrótu służy do jednoznacznej identyfikacji wątku; przez czas ich istnienia z wątku jego wartość skrótu nie będzie kolidują z wartości z innego wątku, niezależnie od domeny aplikacji, z którego można uzyskać wartości.  
  
-   Identyfikator wątku. Wartość tylko do odczytu <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości jest przypisywany przez środowisko uruchomieniowe i unikatowo identyfikuje wątku w procesie.  
  
    > [!NOTE]
    >  System operacyjny [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) nie ma stałej relacji do zarządzanego wątku, ponieważ niezarządzane hosta można kontrolować relacji między wątkami zarządzane i niezarządzane. W szczególności mogą używać hosta zaawansowane [API hostingu środowiska CLR](https://msdn.microsoft.com/library/ms404385.aspx) można zaplanować wiele wątków zarządzanych względem tego samego wątku systemu operacyjnego, lub zarządzanego wątku między wątki innego systemu operacyjnego.  
  
-   Bieżący stan wątku. Czas trwania jego istnienia wątek jest zawsze w co najmniej jednej stanów zdefiniowane przez <xref:System.Threading.ThreadState> właściwości.  
  
-   Poziom priorytetu planowania, który jest zdefiniowany przez <xref:System.Threading.ThreadPriority> właściwości. Mimo że można ustawić tej wartości, priorytetu wątku żądania, nie jest gwarantowana aby były używane przez system operacyjny.  
  
-   Tylko do odczytu <xref:System.Threading.Thread.IsThreadPoolThread%2A> właściwość, która wskazuje, czy wątek jest wątku puli wątków.  
  
-   <xref:System.Threading.Thread.IsBackground%2A> Właściwości. Aby uzyskać więcej informacji, zobacz [wątki pierwszego planu i tła](#Foreground) sekcji.  
  
## Examples  
 W poniższym przykładzie pokazano proste funkcje wątków.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Ten kod generuje dane wyjściowe podobne do następujących:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Delegat, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając delegata, który umożliwia obiektu do przekazania do wątku, gdy wątek jest uruchomiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie zaczyna się wykonywania podczas jego tworzenia. Aby zaplanować wątku do wykonania, należy wywołać <xref:System.Threading.Thread.Start%2A> metody. Aby przekazać obiekt danych do wątku, należy użyć <xref:System.Threading.Thread.Start%28System.Object%29> przeciążenie metody.  
  
> [!NOTE]
>  Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.ThreadStart> Konstruktor podczas tworzenia wątku. Użyj `AddressOf` operator podczas przekazywania metodę, na przykład `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnię tworzenie i używanie <xref:System.Threading.ParameterizedThreadStart> delegata z metody statycznej i metody wystąpienia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ThreadStart" /> delegata, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie zaczyna się wykonywania podczas jego tworzenia. Aby zaplanować wątku do wykonania, należy wywołać <xref:System.Threading.Thread.Start%2A> metody.  
  
> [!NOTE]
>  Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.ThreadStart> Konstruktor podczas tworzenia wątku. Użyj `AddressOf` operator podczas przekazywania metodę, na przykład `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można utworzyć wątku, który wykonuje metodą statyczną.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak utworzyć wątku, który wykonuje metodę wystąpienia.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegata, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</param>
        <param name="maxStackSize">Rozmiar stosu maksymalny w bajtach do użycia przez wątek lub 0 Aby użyć domyślny rozmiar maksymalny stosu określony w nagłówku pliku wykonywalnego.  Ważne dla częściowo zaufanego kodu, <c>maxStackSize</c> jest ignorowana, jeśli jest większy niż domyślny rozmiar stosu. Nie wyjątek.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając delegata, który umożliwia obiektu do przekazania do wątku, gdy wątek jest uruchomiony i określania rozmiaru maksymalnego stosu wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unikaj stosowania tego przeciążenia konstruktora. Domyślny rozmiar stosu używana przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> przeładowania konstruktora jest rozmiar stosu zalecane dla wątków. Jeśli wątek występują problemy z pamięcią, najbardziej prawdopodobną przyczyną jest programowania, błąd, taki jak nieskończoną rekursję.  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tylko w pełni zaufane, można ustawić kodu `maxStackSize` na wartość, która jest większa niż domyślny rozmiar stosu (1 megabajt). Jeśli określono wartość większą dla `maxStackSize` gdy kod działa z częściowej relacji zaufania, `maxStackSize` jest ignorowany i jest używany domyślny rozmiar stosu. Nie wyjątek. Można ustawić kodu na dowolnym poziomie zaufania `maxStackSize` na wartość, która jest mniejsza niż domyślny rozmiar stosu.  
  
> [!NOTE]
>  Jeśli tworzysz biblioteki pełni zaufany, który będzie używany przez kod częściowo zaufany, należy rozpocząć wątku wymagający stosu dużych, musi assert pełne zaufanie przed utworzeniem wątku lub domyślny rozmiar stosu będą używane. Nie należy tego robić, chyba że w pełni kontrolować kod uruchamiany w wątku.  
  
 Jeśli `maxStackSize` jest mniejszy niż rozmiar minimalny stos rozmiar minimalny stosu jest używany. Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony jest zaokrąglana do większych dalej wielokrotnością rozmiaru strony. Na przykład jeśli używasz programu .NET Framework w wersji 2.0 w systemie Windows Vista, rozmiar minimalny stos jest 256KB (262 144 bajty), a rozmiar strony jest 64KB (65 536 bajtów).  
  
> [!NOTE]
>  W wersjach systemu Microsoft Windows starszych niż Windows XP i Windows Server 2003 `maxStackSize` jest ignorowany i jest używany rozmiar stosu określony w nagłówku pliku wykonywalnego.  
  
 Określ rozmiar stosu niewielkie, może być konieczne wyłączenie sondowanie przepełnienie stosu. Jeśli stosu jest znacznie ograniczone, sondowanie może spowodować przepełnienie stosu. Aby wyłączyć sondowanie przepełnienie stosu, dodaj następującą wartość do pliku konfiguracji aplikacji.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ThreadStart" /> delegata, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</param>
        <param name="maxStackSize">Rozmiar stosu maksymalny w bajtach do użycia przez wątek lub 0 Aby użyć domyślny rozmiar maksymalny stosu określony w nagłówku pliku wykonywalnego.  Ważne dla częściowo zaufanego kodu, <c>maxStackSize</c> jest ignorowana, jeśli jest większy niż domyślny rozmiar stosu. Nie wyjątek.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy określania rozmiaru maksymalnego stosu wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unikaj stosowania tego przeciążenia konstruktora. Domyślny rozmiar stosu używana przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> przeładowania konstruktora jest rozmiar stosu zalecane dla wątków. Jeśli wątek występują problemy z pamięcią, najbardziej prawdopodobną przyczyną jest programowania, błąd, taki jak nieskończoną rekursję.  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tylko w pełni zaufane, można ustawić kodu `maxStackSize` na wartość, która jest większa niż domyślny rozmiar stosu (1 megabajt). Jeśli określono wartość większą dla `maxStackSize` gdy kod działa z częściowej relacji zaufania, `maxStackSize` jest ignorowany i jest używany domyślny rozmiar stosu. Nie wyjątek. Można ustawić kodu na dowolnym poziomie zaufania `maxStackSize` na wartość, która jest mniejsza niż domyślny rozmiar stosu.  
  
> [!NOTE]
>  Jeśli tworzysz biblioteki pełni zaufany, który będzie używany przez kod częściowo zaufany, należy rozpocząć wątku wymagający stosu dużych, musi assert pełne zaufanie przed utworzeniem wątku lub domyślny rozmiar stosu będą używane. Nie należy tego robić, chyba że w pełni kontrolować kod uruchamiany w wątku.  
  
 Jeśli `maxStackSize` jest mniejszy niż rozmiar minimalny stos rozmiar minimalny stosu jest używany. Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony jest zaokrąglana do większych dalej wielokrotnością rozmiaru strony. Na przykład jeśli używasz programu .NET Framework w wersji 2.0 w systemie Windows Vista, rozmiar minimalny stos jest 256KB (262 144 bajty), a rozmiar strony jest 64KB (65 536 bajtów).  
  
> [!NOTE]
>  W wersjach systemu Microsoft Windows starszych niż Windows XP i Windows Server 2003 `maxStackSize` jest ignorowany i jest używany rozmiar stosu określony w nagłówku pliku wykonywalnego.  
  
 Określ rozmiar stosu niewielkie, może być konieczne wyłączenie sondowanie przepełnienie stosu. Jeśli stosu jest znacznie ograniczone, sondowanie może spowodować przepełnienie stosu. Aby wyłączyć sondowanie przepełnienie stosu, dodaj następującą wartość do pliku konfiguracji aplikacji.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zgłasza <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces przerywanie wątku. Wywołanie tej metody zwykle kończy wątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces przerywanie wątku. Wywołanie tej metody zwykle kończy wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana w wątku, system generuje <xref:System.Threading.ThreadAbortException> w wątku, aby przerwać go. `ThreadAbortException` specjalne wyjątek, który może być przechwycony przez kod aplikacji, ale jest zgłoszony ponownie na końcu `catch` zablokować, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana. `ResetAbort` anuluje żądanie do przerwania, a także zapobiega `ThreadAbortException` z przerywanie wątku. Cofnąć `finally` bloki są wykonywane przed wątek został przerwany.  
  
> [!NOTE]
>  Gdy wywołuje wątku `Abort` na siebie, efekt jest podobny do generowania wyjątku; <xref:System.Threading.ThreadAbortException> się stanie, a wynik jest atrybutem wartości prognozowanych. Jednak jeśli wywołuje jeden wątek `Abort` w innym wątku, przerwanie przerwań działa niezależnie od kodu. Istnieje prawdopodobieństwo, że może spowodować przerwanie Konstruktor statyczny. W rzadkich przypadkach to może uniemożliwić wystąpienia tej klasy w tej domenie aplikacji. W wersji systemu .NET Framework 1.0 i 1.1, istnieje ryzyko, można przerwać wątek podczas `finally` bloku jest uruchomiona, w którym to przypadku `finally` bloku zostało przerwane.  
  
 Wątek nie jest gwarantowana przerwania natychmiast lub w ogóle. Taka sytuacja może wystąpić, jeśli wątek nie niezwiązana ilość obliczeń w `finally` bloków, które są wywoływane w ramach procedury przerwania, w tym samym nieograniczony czas opóźnienia przerwanie. Poczekać, aż wątek został przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> metody w wątku po wywołaniu <xref:System.Threading.Thread.Abort%2A> metody, ale nie ma żadnej gwarancji zakończy się czas oczekiwania.  
  
> [!NOTE]
>  Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> może zablokować, jeśli wątek, który jest przerywana znajduje się w regionie chronionym kodu, takie jak `catch` bloku `finally` bloku lub region ograniczonego wykonania. Jeśli wątku wywołującym <xref:System.Threading.Thread.Abort%2A> utrzymuje blokadę przez wątek zostało przerwane, może wystąpić zakleszczenie.  
  
 Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek przerwie, kiedy <xref:System.Threading.Thread.Start%2A> jest wywoływana. Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest w stanie uśpienia, wątek przerwane i następnie przerwane.  
  
 Jeśli `Abort` jest wywoływana w wątku, który zostało zawieszone, <xref:System.Threading.ThreadStateException> jest zgłaszany w wątku, który wywołuje <xref:System.Threading.Thread.Abort%2A>, i <xref:System.Threading.ThreadState.AbortRequested> jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości przerywany wątek. A <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w wątku zawieszonym do <xref:System.Threading.Thread.Resume%2A> jest wywoływana.  
  
 Jeśli `Abort` jest wywoływana w wątku zarządzanego podczas wykonywania kodu niezarządzanego `ThreadAbortException` nie jest generowany, dopóki wątek powróci do kodu zarządzanego.  
  
 Jeśli dwa wywołań `Abort` występować w tym samym czasie, istnieje możliwość jedno wywołanie ustawić informacje o stanie i inne wywołania w celu wykonania `Abort`. Jednak aplikacja nie wykrywa on tę sytuację.  
  
 Po `Abort` jest wywoływane w wątku, zawiera stan wątku <xref:System.Threading.ThreadState.AbortRequested>. Po zakończeniu wątku wyniku pomyślnym nawiązaniu połączenia z `Abort`, stan wątku jest zmieniany na <xref:System.Threading.ThreadState.Stopped>. Z wystarczającymi uprawnieniami, wątek to obiekt docelowy `Abort` można anulować przy użyciu przerwania `ResetAbort` metody. Na przykład, który demonstruje wywołania `ResetAbort` metody, zobacz `ThreadAbortException` klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek, który jest przerywana jest aktualnie wstrzymana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje w wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Obiekt, który zawiera informacje specyficzne dla aplikacji, takie jak stan, które mogą być używane przez przerywany wątek.</param>
        <summary>Zgłasza <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces zakończenia wątku, jednocześnie zapewniając wyjątek informacji o zakończenie wątku. Wywołanie tej metody zwykle kończy wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana w wątku, system generuje <xref:System.Threading.ThreadAbortException> w wątku, aby przerwać go. `ThreadAbortException` specjalne wyjątek, który może być przechwycony przez kod aplikacji, ale jest zgłoszony ponownie na końcu `catch` zablokować, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana. `ResetAbort` anuluje żądanie do przerwania, a także zapobiega `ThreadAbortException` z przerywanie wątku. Cofnąć `finally` bloki są wykonywane przed wątek został przerwany.  
  
> [!NOTE]
>  Gdy wywołuje wątku `Abort` na siebie, efekt jest podobny do generowania wyjątku; <xref:System.Threading.ThreadAbortException> się stanie, a wynik jest atrybutem wartości prognozowanych. Jednak jeśli wywołuje jeden wątek `Abort` w innym wątku, przerwanie przerwań działa niezależnie od kodu. Istnieje ryzyko, że może spowodować przerwanie Konstruktor statyczny. W rzadkich przypadkach to może uniemożliwić wystąpienia tej klasy w tej domenie aplikacji. W wersji systemu .NET Framework 1.0 i 1.1, istnieje ryzyko, można przerwać wątek podczas `finally` bloku jest uruchomiona, w którym to przypadku `finally` bloku zostało przerwane.  
  
 Wątek nie jest gwarantowana przerwania natychmiast lub w ogóle. Taka sytuacja może wystąpić, jeśli wątek nie niezwiązana ilość obliczeń w `finally` bloków, które są wywoływane w ramach procedury przerwania, w tym samym nieograniczony czas opóźnienia przerwanie. Poczekać, aż wątek został przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> metody w wątku po wywołaniu <xref:System.Threading.Thread.Abort%2A> metody, ale nie ma żadnej gwarancji, który zakończy się czas oczekiwania.  
  
> [!NOTE]
>  Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> może zablokować, jeśli wątek, który jest przerywana znajduje się w regionie chronionym kodu, takie jak `catch` bloku `finally` bloku lub region ograniczonego wykonania. Jeśli wątku wywołującym <xref:System.Threading.Thread.Abort%2A> utrzymuje blokadę przez wątek zostało przerwane, może wystąpić zakleszczenie.  
  
 Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek przerwie, kiedy <xref:System.Threading.Thread.Start%2A> jest wywoływana. Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest w stanie uśpienia, wątek przerwane i następnie przerwane.  
  
 Jeśli `Abort` jest wywoływana w wątku, który zostało zawieszone, <xref:System.Threading.ThreadStateException> jest zgłaszany w wątku, który wywołuje <xref:System.Threading.Thread.Abort%2A>, i <xref:System.Threading.ThreadState.AbortRequested> jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości przerywany wątek. A <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w wątku zawieszonym do <xref:System.Threading.Thread.Resume%2A> jest wywoływana.  
  
 Jeśli `Abort` jest wywoływana w wątku zarządzanego podczas wykonywania kodu niezarządzanego `ThreadAbortException` nie jest generowany, dopóki wątek powróci do kodu zarządzanego.  
  
 Jeśli dwa wywołań `Abort` występować w tym samym czasie, istnieje możliwość jedno wywołanie ustawić informacje o stanie i inne wywołania w celu wykonania `Abort`. Jednak aplikacja nie wykrywa on tę sytuację.  
  
 Po `Abort` jest wywoływane w wątku, zawiera stan wątku <xref:System.Threading.ThreadState.AbortRequested>. Po zakończeniu wątku wyniku pomyślnym nawiązaniu połączenia z `Abort`, stan wątku jest zmieniany na <xref:System.Threading.ThreadState.Stopped>. Z wystarczającymi uprawnieniami, wątek to obiekt docelowy `Abort` można anulować przy użyciu przerwania `ResetAbort` metody. Na przykład, który demonstruje wywołania `ResetAbort` metody, zobacz `ThreadAbortException` klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób przekazywania informacji do wątku, który jest przerywana.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek, który jest przerywana jest aktualnie wstrzymana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje w wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przydziela gniazda danych bez nazwy na wszystkie wątki. W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>Przydzielony o nazwie gniazda danych na wszystkie wątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych. Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Miejsce jest przydzielane w wszystkie wątki.  
  
 Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia. Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku. Gniazda danych różnią się na wątek. Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku. Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.  
  
 **Pierwszym przykładzie**  
  
 Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku. Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład kodu pokazuje, jak używać gniazda danych do przechowywania informacji na temat określonego wątku.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych do przydzielenia.</param>
        <summary>Przydziela gniazda danych o podanej nazwie w wszystkie wątki. W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>Przydzielony o nazwie gniazda danych na wszystkie wątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych. Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia. Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku. Gniazda danych różnią się na wątek. Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.  
  
 Nie jest konieczne użycie <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metodę, aby przydzielić miejsce danych o podanej nazwie, ponieważ <xref:System.Threading.Thread.GetNamedDataSlot%2A> — metoda przydziela miejsce, jeśli nie został jeszcze przydzielony.  
  
> [!NOTE]
>  Jeśli <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metoda jest używana, należy nadać mu w głównym wątku w momencie uruchamiania programu, ponieważ zgłasza wyjątek, jeśli w miejscu o określonej nazwie została już przydzielona. Nie istnieje sposób sprawdzić, czy gnieździe została już przydzielona.  
  
 Gniazda przydzielonych za pomocą tej metody należy oddzielić z <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku. Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.  
  
 **Pierwszym przykładzie**  
  
 Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku. Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.  
  
> [!NOTE]
>  Przykład kodu nie używa <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metody, ponieważ <xref:System.Threading.Thread.GetNamedDataSlot%2A> — metoda przydziela miejsce, jeśli nie został jeszcze przydzielony. Jeśli <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metoda jest używana, powinna być wywoływana w głównym wątku w momencie uruchamiania programu.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Gniazdo danych o podanej nazwie, o określonej nazwie już istnieje.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia stan apartamentu tego wątku.</summary>
        <value>Jeden z <see cref="T:System.Threading.ApartmentState" /> wartości. Jest to wartość początkowa <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A> Właściwość jest przestarzała.**  Nieprzestarzała alternatyw <xref:System.Threading.Thread.GetApartmentState%2A> metoda pobierania stanu apartamentu i <xref:System.Threading.Thread.SetApartmentState%2A> metody do ustawiania stanu apartamentu.  
  
 W wersji systemu .NET Framework 1.0 i 1.1 `ApartmentState` właściwości oznacza wątek, aby wskazać, że będą wykonywane w pojedynczym wątku lub wielowątkowe typu apartment. Tej właściwości można ustawić, gdy wątek znajduje się w `Unstarted` lub `Running` wątku stanu; jednak można ją ustawić tylko raz dla wątku. Jeśli nie ustawiono właściwości, zwraca `Unknown`.  
  
 Próba użycia <xref:System.Threading.Thread.ApartmentState%2A> właściwość do ustawiania stanu apartamentu wątku, w których stanu apartamentu została już ustawiona jest ignorowana. Jednak <xref:System.Threading.Thread.SetApartmentState%2A> metoda zgłasza <xref:System.InvalidOperationException> w takim przypadku.  
  
> [!IMPORTANT]
>  W programie .NET Framework w wersji 2.0, nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stanu apartamentu nie została ustawiona, zanim zostaną uruchomione. Zainicjowano wątku głównego aplikacji do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie. Nie można ustawić wątku głównego aplikacji <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> przez ustawienie <xref:System.Threading.ApartmentState?displayProperty=nameWithType> właściwości w pierwszym wierszu kodu. Użyj <xref:System.STAThreadAttribute> zamiast tego.  
  
 W programie .NET Framework w wersji 2.0, można określić wątków aplikacji C++ za pomocą modelu COM. [/CLRTHREADATTRIBUTE (Ustaw CLR wątku atrybut)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) — opcja konsolidatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można ustawić stanu apartamentu wątku.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aby ustawić tę właściwość na stanie, który nie jest stanu apartamentu prawidłowy podejmowana jest próba (stanie innym niż jednowątkowego apartamentu (<see langword="STA" />) lub wielowątkowe apartamentu (<see langword="MTA" />)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta wykonywania o zbliżającym się podanie kodu, w którym wątek przerwania lub nieobsługiwany wyjątek może zagrozić inne zadania w domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosty środowisko uruchomieniowe języka wspólnego (CLR), takich jak Microsoft SQL Server 2005, można ustanowić różne zasady dla niepowodzenia w regionach krytyczne i niekrytyczne kodu. Krytyczne region jest jednym w którym przerwania wątku lub nieobsługiwany wyjątek nie mogą być ograniczone do bieżącego zadania. Z kolei przerwania lub niepowodzenia w regionie niekrytyczne kodu dotyczy tylko zadania, w którym występuje błąd.  
  
 Rozważmy na przykład zadanie, które próbuje przydzielić pamięci podczas utrzymywania blokady. W przypadku niepowodzenia alokacji pamięci przerywanie bieżącego zadania nie jest wystarczająca do zapewnienia stabilności <xref:System.AppDomain>, ponieważ może być inne zadania w domenie oczekiwanie na tym samym blokady. Jeśli bieżące zadanie jest zakończone, można zakleszczone innych zadań.  
  
 Gdy wystąpi awaria w regionie krytycznych, host zdecydować się na zwolnienie całą <xref:System.AppDomain> zamiast zaryzykować i kontynuowanie wykonywania w potencjalnie niestabilnym stanie. Aby poinformować hosta, że kod jest wprowadzane krytyczne regionu, należy wywołać <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Wywołanie <xref:System.Threading.Thread.EndCriticalRegion%2A> podczas wykonywania zwraca niekrytyczne regionu kodu.  
  
 W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> metody do dzielenia bloku kodu na krytyczne i niekrytyczne regionów.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia ma wykonać instrukcje, które są zależne od tożsamości bieżącego wątku fizycznego systemu operacyjnego hosta, który kodu zarządzanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre hosty środowiska CLR, takich jak Microsoft SQL Server 2005, podać własne zarządzania wątku. Hosta, który dostarcza kierownictwo wątku można przenieść wykonywanie zadania z jednego wątku fizycznego systemu operacyjnego w dowolnym momencie. Większość zadań nie dotyczy to przełączanie. Jednak niektóre zadania mają koligacji wątku - oznacza to, że są one zależne od tożsamości wątku fizycznego systemu operacyjnego. Te zadania, należy poinformować hosta podczas ich wykonywania kodu, który nie powinien być przełączane.  
  
 Na przykład, jeśli zablokować wywołania aplikacji interfejsu API systemu uzyskać systemu operacyjnego, który ma koligacji wątków, takich jak Win32 CRITICAL_SECTION, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskiwanie blokady, i <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnienie blokady.  
  
 W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> i <xref:System.Threading.Thread.EndThreadAffinity%2A> metody powiadomiono hosta, który blok kodu jest zależna od tożsamości wątku fizycznego systemu operacyjnego.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący kontekst, w którym jest wykonywany wątku.</summary>
        <value>A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> reprezentujący bieżący kontekst wątku.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kulturę bieżącego wątku.</summary>
        <value>Obiekt, który reprezentuje kultura bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Obiekt, który jest zwracany przez tę właściwość, wraz z powiązane obiekty, określić domyślnego formatu daty, godziny, liczb, wartości waluty, sortowanie kolejność tekstu, wielkość liter konwencje i porównywania ciągów. Zobacz <xref:System.Globalization.CultureInfo> klasy informacje na temat nazwy kultury i identyfikatory, różnice między niezmiennej neutralne i określonej kultury, a informacje o ustawieniach kulturowych sposób wpływa na wątków i domen aplikacji. Zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości, aby dowiedzieć się, jak jest określany przez wątek domyślną kulturę i konfiguracji informacji o kulturze na komputerach użytkowników.  
  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], można ustawić <xref:System.Threading.Thread.CurrentCulture%2A> kultury neutralnej dla właściwości. Jest to spowodowane zachowanie <xref:System.Globalization.CultureInfo> klasa uległa zmianie: gdy reprezentuje kultury neutralnej jej wartości właściwości (w szczególności <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, i <xref:System.Globalization.CultureInfo.TextInfo%2A> właściwości) teraz odzwierciedlają określoną kulturę, która jest skojarzona z kultury neutralnej. We wcześniejszych wersjach programu .NET Framework <xref:System.Threading.Thread.CurrentCulture%2A> zwrócił właściwość <xref:System.NotSupportedException> wyjątku, gdy kultury neutralnej została przypisana.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wątkowości instrukcji, która umożliwia interfejsu użytkownika formularzy systemu Windows, aby wyświetlić kultura, która jest ustawiona w Panelu sterowania. Wymagany jest dodatkowy kod.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla ustawienia właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący podmiot zabezpieczeń wątku (dla opartej na rolach zabezpieczeń).</summary>
        <value>
          <see cref="T:System.Security.Principal.IPrincipal" /> Wartość reprezentującą kontekst zabezpieczeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie kodu przedstawiono sposób ustawiania i pobierania podmiot zabezpieczeń wątku.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień wymaganych, aby ustawić podmiot zabezpieczeń.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do manipulowania obiekt główny. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obecnie uruchomiony wątek.</summary>
        <value>A <see cref="T:System.Threading.Thread" /> czyli reprezentację aktualnie uruchomiony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy zadanie, które z kolei tworzy 20 zadania podrzędne. Aplikacja, jak również każdego zadania wywołuje `ShowThreadInformation` metodę, która używa <xref:System.Threading.Thread.CurrentThread%2A> właściwości, aby wyświetlić informacje o wątku, w którym jest uruchomiona.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Każde zadanie podrzędne generuje 1 milion liczb losowych od 1 do 1 milion i zwraca ich średniej. Wywołania zadanie nadrzędne <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody, aby upewnić się, że zadania podrzędne zostały ukończone przed wyświetleniem średniej zwrócony przez każdego zadania i obliczenia średniej środków.  
  
 Należy pamiętać, że aplikacja działa na pierwszym planie wątku, każde zadanie uruchamia się w wątku puli wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą kulturę używaną przez Menedżera zasobów do wyszukiwania zasobów określonej kultury w czasie wykonywania.</summary>
        <value>Obiekt, który reprezentuje bieżącej kultury.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kultura interfejsu użytkownika określa zasoby, aplikacja musi obsługiwać użytkowników w danych wejściowych i wyjściowych i domyślnie jest taka sama jak kultury systemu operacyjnego. Zobacz <xref:System.Globalization.CultureInfo> klasy informacje na temat nazwy kultury i identyfikatory, różnice między niezmiennej neutralne i określonej kultury, a informacje o ustawieniach kulturowych sposób wpływa na wątków i domen aplikacji. Zobacz <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości, aby dowiedzieć się, jak jest określany przez wątek domyślną kulturę interfejsu użytkownika.  
  
 <xref:System.Globalization.CultureInfo> Zwracane przez tę właściwość można kultury neutralnej. Neutralne kultury nie powinien być używany z metod formatowania, takich jak <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, i <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Użyj <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> metodę, aby uzyskać określoną kulturę, lub użyj <xref:System.Threading.Thread.CurrentCulture%2A> właściwości.  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Metoda zgłasza <xref:System.ArgumentException> neutralne kultury "zh-Hant" ("zh-CHT") i "zh-Hans" ("zh-CHS").  
  
   
  
## Examples  
 Poniższy przykład określa, czy język kultury interfejsu użytkownika bieżącego wątku jest francuski. Jeśli nie jest, ustawia kulturę interfejsu użytkownika bieżącego wątku język angielski (Stany Zjednoczone).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Poniższy przykład kodu pokazuje wątkowości instrukcji, która umożliwia interfejsu użytkownika formularzy systemu Windows, aby wyświetlić kultura, która jest ustawiona w Panelu sterowania. Wymagany jest dodatkowy kod.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na nazwę kultury, której nie można użyć do zlokalizowania pliku zasobu. W nazwach plików zasobów musi zawierać tylko litery, cyfry, łączniki i znaki podkreślenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje wyłączenie automatycznego oczyszczania wywoływane otoki środowiska uruchomieniowego (otoki RCW) dla bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie środowisko uruchomieniowe języka wspólnego (CLR) Czyści wywoływane otoki środowiska uruchomieniowego automatycznie. Komunikaty pomp CLR podczas oczyszczania, co może spowodować problemy wielobieżność kilka aplikacji, które spełniają następujące kryteria nietypowe:  
  
-   Aplikacja ma własny przekazywania wiadomości.  
  
-   Aplikacja musi kontrolować dokładnie podczas przekazywania wiadomości.  
  
 Takie aplikacje mogą używać <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> metodę, aby zapobiec czynności wywoływane otoki automatyczne odzyskiwanie danych środowiska uruchomieniowego CLR.  
  
 Gdy ta metoda została wywołana dla wątku, automatycznego oczyszczania nie może być ponownie włączone dla tego wątku. Gdy aplikacja jest gotowa wyczyścić wywoływane otoki środowiska uruchomieniowego, użyj <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> metody w celu poinstruowania środowiska wykonawczego, aby wyczyścić wszystkie wywoływane otoki środowiska uruchomieniowego w bieżącym kontekście. Przekazywanie komunikatów wystąpi podczas wykonywania metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta wykonywania o zbliżającym się podanie kodu, w którym są ograniczone do bieżącego zadania przerwania wątku lub nieobsługiwany wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosty środowisko uruchomieniowe języka wspólnego (CLR), takich jak Microsoft SQL Server 2005, można ustanowić różne zasady dla niepowodzenia w regionach krytyczne i niekrytyczne kodu. Krytyczne region jest jednym w którym przerwania wątku lub nieobsługiwany wyjątek nie mogą być ograniczone do bieżącego zadania. Z kolei przerwania lub niepowodzenia w regionie niekrytyczne kodu dotyczy tylko zadania, w którym występuje błąd.  
  
 Rozważmy na przykład zadanie, które próbuje przydzielić pamięci podczas utrzymywania blokady. W przypadku niepowodzenia alokacji pamięci przerywanie bieżącego zadania nie jest wystarczająca do zapewnienia stabilności <xref:System.AppDomain>, ponieważ może być inne zadania w domenie oczekiwanie na tym samym blokady. Jeśli bieżące zadanie jest zakończone, można zakleszczone innych zadań.  
  
 Gdy wystąpi awaria w regionie krytycznych, host zdecydować się na zwolnienie całą <xref:System.AppDomain> zamiast zaryzykować i kontynuowanie wykonywania w potencjalnie niestabilnym stanie. Aby poinformować hosta, że kod jest wprowadzane krytyczne regionu, należy wywołać <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Wywołanie <xref:System.Threading.Thread.EndCriticalRegion%2A> podczas wykonywania zwraca niekrytyczne regionu kodu.  
  
 W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> metody do dzielenia bloku kodu na krytyczne i niekrytyczne regionów.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia host, na którym kodu zarządzanego zakończył wykonywania instrukcji, które są zależne od tożsamości bieżącego wątku fizycznego systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre hosty środowiska CLR, takich jak Microsoft SQL Server 2005, podać własne zarządzania wątku. Hosta, który dostarcza kierownictwo wątku można przenieść wykonywanie zadania z jednego wątku fizycznego systemu operacyjnego w dowolnym momencie. Większość zadań nie dotyczy to przełączanie. Jednak niektóre zadania mają koligacji wątku - oznacza to, że są one zależne od tożsamości wątku fizycznego systemu operacyjnego. Te zadania, należy poinformować hosta podczas ich wykonywania kodu, który nie powinien być przełączane.  
  
 Na przykład, jeśli zablokować wywołania aplikacji interfejsu API systemu uzyskać systemu operacyjnego, który ma koligacji wątków, takich jak Win32 CRITICAL_SECTION, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskiwanie blokady, i <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnienie blokady.  
  
 W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> i <xref:System.Threading.Thread.EndThreadAffinity%2A> metody powiadomiono hosta, który blok kodu jest zależna od tożsamości wątku fizycznego systemu operacyjnego.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.ExecutionContext" /> obiektu, który zawiera informacje o różnych kontekstach bieżącego wątku.</summary>
        <value>
          <see cref="T:System.Threading.ExecutionContext" /> Obiektu, który konsoliduje informacje o kontekście bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext> Klasa udostępnia jeden kontener dla wszystkich informacji dotyczących logicznego wątku wykonywania. W tym kontekstu zabezpieczeń, kontekst wywołania kontekst synchronizacji, lokalizacja kontekstu i kontekst transakcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <see cref="T:System.Threading.Thread" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania modułu zbierającego elementy bezużyteczne <xref:System.Threading.Thread.Finalize%2A> Jeśli bieżący obiekt jest gotowy do przetwarzania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych ma zostać zwolniony.</param>
        <summary>Eliminuje skojarzenia między nazwą gniazdo, wszystkie wątki tego procesu. W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych. Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Po żadnego wątku wywołania `FreeNamedDataSlot`, innego wątku, który wywołuje <xref:System.Threading.Thread.GetNamedDataSlot%2A> o takiej samej nazwie przyzna nowe miejsce skojarzone z nazwą. Kolejne wywołania `GetNamedDataSlot` przez wszystkie wątki zwróci nowego miejsca. Jednak którymkolwiek wątku nadal mający <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> zwrócony przez wywołanie wcześniejszych `GetNamedDataSlot` można nadal używać starego miejsca.  
  
 Zwolnienia miejsca, który został skojarzony z nazwą tylko wtedy, gdy co `LocalDataStoreSlot` uzyskany przed wywołaniem do `FreeNamedDataSlot` został zwolniony i zbierane pamięci.  
  
 Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia. Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku. Gniazda danych różnią się na wątek. Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku. Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.  
  
 **Pierwszym przykładzie**  
  
 Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku. Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Threading.ApartmentState" /> wartość wskazującą stanu apartamentu.</summary>
        <returns>Jeden z <see cref="T:System.Threading.ApartmentState" /> wartości, wskazując stanu apartamentu wątku zarządzanego. Wartość domyślna to <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wraz z <xref:System.Threading.Thread.SetApartmentState%2A> — metoda i <xref:System.Threading.Thread.TrySetApartmentState%2A> zastępuje metodę, <xref:System.Threading.Thread.ApartmentState%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody. Przykład kodu tworzy wątku. Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stanu apartamentu jest już ustawiony. Jeśli tę samą operację miał usiłowano <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> czy zgłoszony.  
  
 Po uruchomieniu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> ponownie używana jest metoda. Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek został już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Threading.CompressedStack" /> obiektu, który może służyć do przechwytywania stosu dla bieżącego wątku.</summary>
        <returns>Brak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest już obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">
          <see cref="T:System.LocalDataStoreSlot" /> z którego ma zostać pobrana wartość.</param>
        <summary>Pobiera wartość z określonym miejscu w bieżącym wątku w bieżącej domenie bieżącego wątku. W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>Pobrana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych. Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia. Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku. Gniazda danych różnią się na wątek. Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> jest `Shared` metodę, która zawsze ma zastosowanie do aktualnie realizowanej wątku, nawet wtedy, gdy wywołanie za pomocą zmiennej, która odwołuje się do innego wątku. Aby uniknąć pomyłek, należy użyć nazwy klasy podczas wywoływania metody `Shared` metody: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku. Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.  
  
 **Pierwszym przykładzie**  
  
 Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku. Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 W poniższym przykładzie pokazano sposób użycia gniazda danych do przechowywania informacji na temat określonego wątku.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca bieżącej domenie, w której bieżący wątek jest uruchomiony.</summary>
        <returns>
          <see cref="T:System.AppDomain" /> Reprezentujący bieżącej domeny aplikacji uruchomionej wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak można pobrać nazwy i Identyfikatora `AppDomain` , w którym wątek jest uruchomiony.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca identyfikator domeny aplikacji.</summary>
        <returns>32-bitowe całkowita unikatowo identyfikujący domeny aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak można pobrać nazwy i Identyfikatora `AppDomain` , w którym wątek jest uruchomiony.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wątku.</summary>
        <returns>Wartość całkowita skrótu kodu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość skrótu jest nie musi być unikatowy. Użyj <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości, jeśli potrzebujesz Unikatowy identyfikator zarządzanego wątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych lokalnych.</param>
        <summary>Wyszukuje miejsca danych o podanej nazwie. W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>A <see cref="T:System.LocalDataStoreSlot" /> przydzielone dla tego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych. Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia. Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku. Gniazda danych różnią się na wątek. Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.  
  
 Jeśli miejsca o nazwie nie istnieje, nowe miejsce jest przydzielane. Gniazda danych o nazwie są publiczne i może manipulować dla wszystkich użytkowników.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku. Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.  
  
 **Pierwszym przykładzie**  
  
 Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku. Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przerywa wątku, który znajduje się w <see langword="WaitSleepJoin" /> stan wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten wątek nie jest obecnie zablokowany oczekiwania, stan sprzężenia lub uśpienia, zostanie przerwana, gdy dalej rozpocznie się do blokowania.  
  
 <xref:System.Threading.ThreadInterruptedException> jest generowany w przerwanego wątku, ale nie do bloków wątku. Wątek nigdy nie blokuje, nigdy nie wyjątku i w związku z tym wątek może zostać ukończone bez kiedykolwiek przerwane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie uruchomiony wątek, gdy zostało przerwane, a następnie zostanie zablokowane.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniej <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje w wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, stan wykonania bieżącego wątku.</summary>
        <value>
          <see langword="true" /> Jeśli ten wątek został uruchomiony i nie ma zwykle zakończone lub przerwane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wątek jest wątku w tle.</summary>
        <value>
          <see langword="true" /> Jeśli ten wątek jest lub będzie wątku w tle; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek jest wątku w tle lub wątku pierwszego planu. Wątki w tle są identyczne wątki pierwszego planu, z wyjątkiem tego, że wątki w tle uniemożliwia zakończenie procesu. Po zakończeniu wszystkie wątki pierwszoplanowe należących do procesu, środowisko uruchomieniowe języka wspólnego kończy proces. Wszystkie pozostałe wątki w tle są zatrzymane i nie zostanie wypełnione.  
  
 Domyślnie następujące wątków wykonania na pierwszym planie (to znaczy ich <xref:System.Threading.Thread.IsBackground%2A> zwraca `false`):  
  
-   Podstawowy wątku (lub wątku głównego aplikacji).  
  
-   Wszystkie wątki utworzona przez wywołanie metody <xref:System.Threading.Thread> konstruktora klasy.  
  
 Domyślnie następujące wątków wykonywania w tle (to znaczy ich <xref:System.Threading.Thread.IsBackground%2A> zwraca `true`):  
  
-   Wątków z puli wątków, które są puli wątków roboczych obsługiwane przez środowisko uruchomieniowe. Wątek puli i harmonogram pracy można skonfigurować na wątków z puli wątków, przy użyciu <xref:System.Threading.ThreadPool> klasy.  
  
    > [!NOTE]
    >  Oparty na zadaniach asynchronicznej operacji automatycznie wykonywane na wątków z puli wątków.  
  
-   Wszystkie wątki, które wprowadź zarządzanego środowiska wykonawczego z kodem niezarządzanym.  
  
   
  
## Examples  
 Poniższy przykład różni się znacząco zachowanie wątki pierwszego planu i tła. Tworzy wątku pierwszego planu i wątku w tle. Wątek pierwszego planu śledzi proces uruchomiony, dopóki nie ukończy jego `for` pętli i kończy. Jednakże jak dane wyjściowe w przykładzie pokazano, ponieważ wątek pierwszego planu zakończył wykonanie, proces jest zakończony przed wątku w tle zakończy działanie.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek jest martwy.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wątek należy do puli wątków zarządzanych.</summary>
        <value>
          <see langword="true" /> Jeśli ten wątek należy do puli wątków zarządzanych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [wątku Pula zarządzana](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób określania, czy wątek jest z puli wątków.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wątek wywołujący blokuje, aż do zakończenia wątku reprezentowanym przez to wystąpienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wątek wywołujący blokuje, aż do zakończenia wątku reprezentowanym przez to wystąpienie, pozostawiając do wykonywania standardowych COM i <see langword="SendMessage" /> przekazywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> jest to metoda synchronizacji, która blokuje wątku wywołującym (to znaczy wątku, który wywołuje metodę), aż do wątku którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została ukończona. Użyj tej metody, aby upewnić się, że wątek został zakończony. Wątek nie zakończy wywołującego zablokują przez nieograniczony czas. W poniższym przykładzie `Thread1` wątku wywołania <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` blok do `Thread2` zostało ukończone.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.  
  
> [!WARNING]
>  Nigdy nie powinien wywoływać <xref:System.Threading.Thread.Join%2A> metody <xref:System.Threading.Thread> obiekt, który reprezentuje bieżący wątek z bieżącego wątku. Powoduje to, że aplikacja zawieszenie, ponieważ bieżący wątek oczekuje od samego siebie  
  
 Ta metoda zmieni stan wątku uwzględnienie <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Obiekt wywołujący próbował przyłączyć wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek jest przerwane podczas oczekiwania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania na zakończenie wątku.</param>
        <summary>Wątek wywołujący aż do zakończenia wątku reprezentowanym przez to wystąpienie lub określonego czasu upłynie, pozostawiając do wykonywania standardowych COM i SendMessage przekazywanie bloków.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek został zakończony; <see langword="false" /> Jeśli wątek nie został zakończony po upływie czasu określonego przez <paramref name="millisecondsTimeout" /> parametru upłynął.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> to metoda synchronizacji, która blokuje wątku wywołującym (to znaczy wątku, który wywołuje metodę) do wątku albo którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została ukończona lub upłynął limit czasu. W poniższym przykładzie `Thread1` wątku wywołania <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` blokowanie bądź do `Thread2` została ukończona lub upłynęły 2 sekundy.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> określono `millisecondsTimeout` parametru, ta metoda działa identycznie do <xref:System.Threading.Thread.Join> przeciążenie metody, z wyjątkiem wartości zwracanej.  
  
 Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.  
  
 Ta metoda zmieni stan wątku uwzględnienie <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> w milisekundach.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> ustawioną ilość czasu oczekiwania na zakończenie wątku.</param>
        <summary>Wątek wywołujący aż do zakończenia wątku reprezentowanym przez to wystąpienie lub określonego czasu upłynie, pozostawiając do wykonywania standardowych COM i SendMessage przekazywanie bloków.</summary>
        <returns>
          <see langword="true" /> Jeśli wątek zakończony; <see langword="false" /> Jeśli wątek nie został zakończony po upływie czasu określonego przez <paramref name="timeout" /> parametru upłynął.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> to metoda synchronizacji, która blokuje wątku wywołującym (to znaczy wątku, który wywołuje metodę) do wątku albo którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została ukończona lub upłynął limit czasu. W poniższym przykładzie `Thread1` wątku wywołania <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` blokowanie bądź do `Thread2` została ukończona lub upłynęły 2 sekundy.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> określono `timeout`, ta metoda zachowuje się tak samo <xref:System.Threading.Thread.Join> przeciążenie metody, z wyjątkiem wartości zwracanej.  
  
 Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.  
  
 Ta metoda zmieni stan bieżący wątek, aby uwzględnić <xref:System.Threading.ThreadState.WaitSleepJoin>. Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia `TimeSpan` wartości z `Join` metody.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (w milisekundach), albo jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Obiekt wywołujący próbował przyłączyć wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator bieżącego wątku zarządzanego.</summary>
        <value>Liczba całkowita, która reprezentuje unikatowy identyfikator dla tego wątku zarządzanego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek <xref:System.Threading.Thread.ManagedThreadId%2A> wartość właściwości służy do jednoznacznej identyfikacji tego wątku w procesie.  
  
 Wartość <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości nie zmienia się wraz z upływem czasu, nawet jeśli kodu niezarządzanego, który obsługuje środowisko uruchomieniowe języka wspólnego implementuje wątku, co włókien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronizuje dostęp do pamięci w następujący sposób: procesor wykonywania bieżącego wątku nie można zmienić kolejności instrukcje w taki sposób, że pamięć uzyskuje dostęp do przed wywołaniem do <see cref="M:System.Threading.Thread.MemoryBarrier" /> wykonanie uzyskuje dostęp do pamięci, które należy wykonać wywołanie <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> jest wymagany tylko w systemach wieloprocesorowych słabe pamięci porządkowanie (na przykład system, w których zastosowano wiele procesorów Intel Itanium).  
  
 W większości przypadków, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji lub <xref:System.Threading.Monitor> klasy umożliwiają łatwiejsze do synchronizacji danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wątku.</summary>
        <value>Ciąg zawierający nazwę wątku, lub <see langword="null" /> , jeśli nie została podana nazwa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zapisu — po. Ponieważ wartość domyślną dla wątku <xref:System.Threading.Thread.Name%2A> właściwość jest `null`, można określić, czy nazwa już jawnie przypisany do wątku porównując go z `null`.  
  
 Ciąg znaków przypisany do <xref:System.Threading.Thread.Name%2A> właściwości może zawierać znaków Unicode.  
  
   
  
## Examples  
 Poniższy przykład przedstawia nazwę wątku.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zażądano operacji set, ale <see langword="Name" /> właściwość została już ustawiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą priorytet wątku w harmonogramie.</summary>
        <value>Jeden z <see cref="T:System.Threading.ThreadPriority" /> wartości. Wartość domyślna to <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek można przypisać jeden z następujących priorytet <xref:System.Threading.ThreadPriority> wartości:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Systemy operacyjne nie muszą przestrzegać priorytetu wątku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wynik zmiana priorytetu wątku. Trzy wątki są tworzone, ma ustawioną wartość priorytetu jeden wątek <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, i ma ustawioną wartość priorytetu sekundy <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Każdy wątek zwiększa zmiennej w `while` pętli i działa na określony czas.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek osiągnął stanu końcowego, takie jak <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla operacji set nie jest prawidłową <see cref="T:System.Threading.ThreadPriority" /> wartość.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje <see cref="M:System.Threading.Thread.Abort(System.Object)" /> żądanie dla bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać tylko przez kod z odpowiednimi uprawnieniami.  
  
 Gdy połączenie jest nawiązywane w przypadku `Abort` zakończenie wątku, system generuje <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` specjalne wyjątek, który może być przechwycony przez kod aplikacji, ale zgłoszony na końcu bloku catch, chyba że jest `ResetAbort` jest wywoływana. `ResetAbort` anuluje żądanie do przerwania, a także zapobiega `ThreadAbortException` z przerywanie wątku.  
  
 Zobacz <xref:System.Threading.ThreadAbortException> przykład przedstawiający wywołania `ResetAbort` metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> nie została wywołana w bieżącym wątku.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień zabezpieczeń dla bieżącego wątku.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje w wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia wątku, który został wstrzymany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Nie używaj <xref:System.Threading.Thread.Suspend%2A> i <xref:System.Threading.Thread.Resume%2A> metodami synchronizacji działania wątków. Nie ma możliwości wiedzy, jaki kod w wątku jest wykonywany po jego wstrzymaniu. Jeśli zawieszenia wątku, gdy posiada blokady podczas sprawdzania uprawnień zabezpieczeń, inne wątki we <xref:System.AppDomain> może zostać zablokowany. Jeśli podczas wykonywania konstruktora klasy zawieszenia się wątku, inne wątki we <xref:System.AppDomain> który próba użycia, że klasa są blokowane. Zakleszczenie może występować bardzo łatwe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony, jest martwy lub nie jest w stanie wstrzymania.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniej <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje w wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nowy stan apartamentu.</param>
        <summary>Ustawia stan apartamentu wątku przed jej uruchomieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stanu apartamentu nie została ustawiona, zanim zostaną uruchomione. Stanem apartamentu musi być ustawiona przed uruchomieniem wątku.  
  
> [!NOTE]
>  Zainicjowano wątku głównego aplikacji do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie. Jedynym sposobem stanu apartamentu wątku głównego aplikacji, aby <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> stosuje się <xref:System.STAThreadAttribute> atrybutu metoda punktu wejścia.  
  
 <xref:System.Threading.Thread.SetApartmentState%2A> Metody, wraz z <xref:System.Threading.Thread.GetApartmentState%2A> — metoda i <xref:System.Threading.Thread.TrySetApartmentState%2A> zastępuje metodę, <xref:System.Threading.Thread.ApartmentState%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody. Przykład kodu tworzy wątku. Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stanu apartamentu jest już ustawiony. Jeśli tę samą operację miał usiłowano <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> czy zgłoszony.  
  
 Po uruchomieniu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> ponownie używana jest metoda. Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek został już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwana w macOS i platformy Linux.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> nie jest stanu apartamentu prawidłowe.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek została już uruchomiona.</exception>
        <exception cref="T:System.InvalidOperationException">Stanem apartamentu został już zainicjowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">
          <see cref="T:System.Threading.CompressedStack" /> Obiekt ma zostać zastosowany do bieżącego wątku.</param>
        <summary>Stosuje przechwyconych <see cref="T:System.Threading.CompressedStack" /> do bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest już obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">
          <see cref="T:System.LocalDataStoreSlot" /> w którym można ustawić wartości.</param>
        <param name="data">Wartość do ustawienia.</param>
        <summary>Ustawia dane w określonym miejscu na aktualnie uruchomionych wątków, dla tego wątku bieżącej domeny. W celu poprawy wydajności użyj pola oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych. Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia. Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia od zakończenia procedury wątku i <xref:System.Threading.Thread> obiekt ma zostać odzyskana przez wyrzucanie elementów bezużytecznych. Gniazda danych różnią się na wątek. Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> jest `Shared` metodę, która zawsze ma zastosowanie do aktualnie realizowanej wątku, nawet wtedy, gdy wywołanie za pomocą zmiennej, która odwołuje się do innego wątku. Aby uniknąć pomyłek, należy użyć nazwy klasy podczas wywoływania metody `Shared` metody: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku. Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.  
  
 **Pierwszym przykładzie**  
  
 Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku. Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstrzymuje bieżącego wątku dla określonego przedziału czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, dla których wątek jest zawieszony. Jeśli wartość <c>millisecondsTimeout</c> argumentów wynosi zero, wątek zwalnia pozostałej części jej przedział czasu do dowolnego wątku taki sam priorytet, który jest gotowy do uruchomienia. Jeśli nie ma nie ma innych wątków o priorytecie, które są gotowe do uruchomienia, wykonanie bieżący wątek nie został wstrzymany.</param>
        <summary>Wstrzymuje bieżącego wątku dla określoną liczbę milisekund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie będzie można zaplanowane do uruchomienia przez system operacyjny przez czas określony. Ta metoda zmieni stan wątku w celu uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Można określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> dla `millisecondsTimeout` parametru nieograniczony czas wstrzymania wątku. Jednak zalecane jest użycie innych <xref:System.Threading?displayProperty=nameWithType> klas takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, lub <xref:System.Threading.Semaphore> zamiast wątków sychronize lub zarządzania zasobami.  
  
 Takty zegara systemu z określoną szybkością nazywany rozpoznawaniem zegara. Limit czasu rzeczywistego może nie być dokładnie określony limit czasu, ponieważ określony limit czasu zostanie dostosowana do pokrywa się z Takty zegara. Aby uzyskać więcej informacji na rozdzielczość zegara i czas oczekiwania, zobacz [uśpienia funkcja](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tematu. Ta metoda wywołuje [uśpienia funkcja](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) z interfejsów API systemu Windows.  
  
 Ta metoda nie przeprowadza standardowe COM i SendMessage przekazywania.  
  
> [!NOTE]
>  Jeśli musisz uśpienia w wątku, który ma <xref:System.STAThreadAttribute>, ale chcesz wykonać standard COM i SendMessage przekazywania, należy wziąć pod uwagę przy użyciu jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metodę, która określa wartość limitu czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Thread.Sleep%2A> metodę, aby zablokować wątku głównego aplikacji.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość limitu czasu ma ujemną wartość i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ilość czasu, dla którego wątek jest zawieszony. Jeśli wartość <c>millisecondsTimeout</c> argument jest <see cref="F:System.TimeSpan.Zero" />, wątek zwalnia pozostałej części jej przedział czasu do dowolnego wątku taki sam priorytet, który jest gotowy do uruchomienia. Jeśli nie ma nie ma innych wątków o priorytecie, które są gotowe do uruchomienia, wykonanie bieżący wątek nie został wstrzymany.</param>
        <summary>Wstrzymuje bieżącego wątku dla określonego przedziału czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie będzie można zaplanowane do uruchomienia przez system operacyjny przez czas określony. Ta metoda zmieni stan wątku w celu uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Można określić <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> dla `timeout` parametru nieograniczony czas wstrzymania wątku. Jednak zalecane jest użycie innych <xref:System.Threading?displayProperty=nameWithType> klas takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, lub <xref:System.Threading.Semaphore> zamiast wątków sychronize lub zarządzania zasobami.  
  
 To przeciążenie metody <xref:System.Threading.Thread.Sleep%2A> użyje całkowitej liczby pełnych milisekund w `timeout`. Ułamkowych milisekund zostaną odrzucone.  
  
 Ta metoda nie przeprowadza standardowe COM i SendMessage przekazywania.  
  
> [!NOTE]
>  Jeśli musisz uśpienia w wątku, który ma <xref:System.STAThreadAttribute>, ale chcesz wykonać standard COM i SendMessage przekazywania, należy wziąć pod uwagę przy użyciu jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metodę, która określa wartość limitu czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> przeciążenie metody, aby zablokować wątku głównego aplikacji pięć razy dla dwóch sekund.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (w milisekundach), albo jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">32-bitowe całkowita definiująca, ile wątek jest oczekiwania.</param>
        <summary>Powoduje, że wątek oczekuje liczba zdefiniowanych przez <paramref name="iterations" /> parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A> Metoda jest przydatna do implementacji blokad. Klas w programie .NET Framework, takich jak <xref:System.Threading.Monitor> i <xref:System.Threading.ReaderWriterLock>, korzystanie z tej metody. <xref:System.Threading.Thread.SpinWait%2A> zasadniczo umieszcza procesor z licznikiem pętli określony przez pętlę bardzo ścisłej `iterations` parametru. Czas trwania czas oczekiwania w związku z tym zależy od szybkości procesora.  
  
 Natomiast to z <xref:System.Threading.Thread.Sleep%2A> metody. Wątek, który wywołuje <xref:System.Threading.Thread.Sleep%2A> daje z resztą jego bieżący fragment czasu procesora, nawet jeśli w określonym przedziale czasu wynosi zero. Określanie niezerowy interwał <xref:System.Threading.Thread.Sleep%2A> usuwa wątek brany pod uwagę przez wątek harmonogram przedział czasu przed upływem.  
  
 <xref:System.Threading.Thread.SpinWait%2A> nie jest zazwyczaj przydatne w przypadku zwykłej aplikacji. W większości przypadków należy używać klas synchronizacji podał .NET Framework; na przykład wywołać <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> lub instrukcję, która opakowuje <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` w języku C# lub `SyncLock` w języku Visual Basic).  
  
> [!CAUTION]
>  W rzadkich przypadkach, w których jest korzystne w celu uniknięcia przełączenie kontekstu, np. gdy wiesz, czy zmiany stanu jest bliska, wywoływania <xref:System.Threading.Thread.SpinWait%2A> metody w Twojej pętli. Kod <xref:System.Threading.Thread.SpinWait%2A> wykonuje pozwala uniknąć problemów, które mogą wystąpić na komputerach z wieloma procesorami. Na przykład na komputerach z wielu procesorów Intel wykorzystujące technologię Hyper-Threading <xref:System.Threading.Thread.SpinWait%2A> uniemożliwia zablokowania procesora w pewnych sytuacjach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że zaplanowane wykonanie wątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że system operacyjny zmiany stanu do bieżącego wystąpienia <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek jest w <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stan systemu operacyjnego można zaplanować na wykonanie. Wątek rozpoczyna wykonywanie na pierwszy wiersz metodę reprezentowaną przez <xref:System.Threading.ThreadStart> lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku. Należy pamiętać, że wywołanie <xref:System.Threading.Thread.Start%2A> wątek wywołujący nie są blokowane.  
  
> [!NOTE]
>  Jeśli to przeciążenie jest używany z wątkiem utworzone za pomocą <xref:System.Threading.ParameterizedThreadStart> delegować, `null` jest przekazywany do metody wykonywane przez wątek.  
  
 Gdy zakończenie wątku, go nie można uruchomić ponownie z innym wywołaniu `Start`.  
  
   
  
## Examples  
 Poniższy przykład utworzenie i uruchomienie wątku.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek została już uruchomiona.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do uruchomienia tego wątku.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Obiekt zawierający dane, które mają być używane przez metodę wykonuje wątku.</param>
        <summary>Powoduje, że system operacyjny zmiany stanu do bieżącego wystąpienia <see cref="F:System.Threading.ThreadState.Running" />i opcjonalnie dostarcza obiekt zawierający dane mają być używane przez metodę wykonuje wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek jest w <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stan systemu operacyjnego można zaplanować na wykonanie. Wątek rozpoczyna wykonywanie na pierwszy wiersz metodę reprezentowaną przez <xref:System.Threading.ThreadStart> lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku. Należy pamiętać, że wywołanie <xref:System.Threading.Thread.Start%2A> wątek wywołujący nie są blokowane.  
  
 Gdy zakończenie wątku, go nie można uruchomić ponownie z innym wywołaniu `Start`.  
  
 To przeciążenie i <xref:System.Threading.ParameterizedThreadStart> delegata ułatwiają przekazywanie danych do procedury wątku, ale technika nie jest typem bezpieczne, ponieważ każdy obiekt mogą zostać przekazane do tego przeciążenia. Bardziej niezawodna sposobem przekazywania danych do procedury wątku jest poddane zarówno procedury wątku i pola danych z obiektu procesu roboczego. Aby uzyskać więcej informacji, zobacz [Tworzenie wątków i przekazywanie danych w chwili uruchomienia](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Threading.ParameterizedThreadStart> delegata z metody statycznej i metody wystąpienia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek została już uruchomiona.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie ma wystarczającej ilości pamięci do uruchomienia tego wątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten wątek został utworzony przy użyciu <see cref="T:System.Threading.ThreadStart" /> delegować zamiast <see cref="T:System.Threading.ParameterizedThreadStart" /> delegowanie.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje wątek albo jeśli wątek jest już wstrzymana, nie ma znaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek jest już wstrzymana, ta metoda nie ma znaczenia.  
  
> [!CAUTION]
>  Nie używaj <xref:System.Threading.Thread.Suspend%2A> i <xref:System.Threading.Thread.Resume%2A> metodami synchronizacji działania wątków. Nie ma możliwości wiedzy, jaki kod w wątku jest wykonywany po jego wstrzymaniu. Jeśli zawieszenia wątku, gdy posiada blokady podczas sprawdzania uprawnień zabezpieczeń, inne wątki we <xref:System.AppDomain> może zostać zablokowany. Jeśli podczas wykonywania konstruktora klasy zawieszenia się wątku, inne wątki we <xref:System.AppDomain> który próba użycia, że klasa są blokowane. Zakleszczenie może występować bardzo łatwe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony lub jest martwy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniej <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje w wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość zawierającą stanów bieżącego wątku.</summary>
        <value>Jeden z <see cref="T:System.Threading.ThreadState" /> wartości wskazujący stan bieżącego wątku. Jest to wartość początkowa <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A> Właściwość zapewnia bardziej szczegółowych informacji niż <xref:System.Threading.Thread.IsAlive%2A> właściwości.  
  
> [!IMPORTANT]
>  Stan wątku jest tylko w scenariuszach debugowania. Kod nigdy nie należy używać stan wątku do synchronizowania działania wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, uzyskiwanie dostępu do `ThreadState` wątku.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nowy stan apartamentu.</param>
        <summary>Ustawia stan apartamentu wątku przed jej uruchomieniem.</summary>
        <returns>
          <see langword="true" /> Jeśli ustawiono stan apartamentu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stanu apartamentu nie została ustawiona, zanim zostaną uruchomione. Stanem apartamentu musi być ustawiona przed uruchomieniem wątku.  
  
> [!NOTE]
>  Zainicjowano wątku głównego aplikacji do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie. Jedynym sposobem stanu apartamentu wątku głównego aplikacji, aby <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> stosuje się <xref:System.STAThreadAttribute> atrybutu metoda punktu wejścia.  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A> Metody, wraz z <xref:System.Threading.Thread.GetApartmentState%2A> — metoda i <xref:System.Threading.Thread.SetApartmentState%2A> zastępuje metodę, <xref:System.Threading.Thread.ApartmentState%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody. Przykład kodu tworzy wątku. Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stanu apartamentu jest już ustawiony. Jeśli tę samą operację miał usiłowano <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> czy zgłoszony.  
  
 Po uruchomieniu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> ponownie używana jest metoda. Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek został już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> nie jest stanu apartamentu prawidłowe.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek została już uruchomiona.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisana w polu przez dowolnego procesora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisany wartość.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji. W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesorów.  
  
 Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wątek wywołujący umożliwiające uzyskanie wykonywania do innego wątku, który jest gotowy do uruchomienia na bieżącym procesora. System operacyjny wybierze na uzyskanie do wątku.</summary>
        <returns>
          <see langword="true" /> Jeśli system operacyjny przełączono wykonywania na inny wątek; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zakończy się powodzeniem, jest uzyskane z resztą przedział czasu bieżącego wątku. System operacyjny planuje wątek wywołujący dla innego przedział czasu, zależnie od jego priorytetu i stanu innych wątków, które są dostępne do uruchomienia.  
  
 Reaguje jest ograniczona do procesora, który jest wykonywany wątek wywołujący. System operacyjny nie przechodzi wykonywania do innego procesora, nawet wtedy, gdy ten procesor jest bezczynny lub jest uruchomiony wątek o niższym priorytecie. Jeśli nie ma nie ma innych wątków gotowych do wykonania na bieżącym procesora, system operacyjny nie przekazuje wykonywania i ta metoda zwraca `false`.  
  
 Ta metoda jest odpowiednikiem przy użyciu platformy wywołania do wywołań natywnych Win32 `SwitchToThread` funkcji. Należy wywołać <xref:System.Threading.Thread.Yield%2A> wywołania metody zamiast platformy, ponieważ pomija wszelkie niestandardowe zachowanie wątkowości hosta zażądał wywołanie platformy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
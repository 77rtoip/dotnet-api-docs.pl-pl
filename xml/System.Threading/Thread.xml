<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="70043b3fb7b7bab63012cb47f77848879069524a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4517f-101">Tworzy i formanty wątku, ustawia jego priorytetu i pobiera jego stan.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4517f-101">Creates and controls a thread, sets its priority, and gets its status.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-102">Po uruchomieniu procesu środowisko uruchomieniowe języka wspólnego automatycznie tworzy wątku pojedynczego pierwszego planu na wykonanie kodu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="4517f-103">Wraz z tego wątku głównego pierwszego planu procesu można utworzyć jeden lub więcej wątków do wykonania fragment kodu programu skojarzonych z procesem.</span><span class="sxs-lookup"><span data-stu-id="4517f-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="4517f-104">Wątki te mogą wykonywać na pierwszym planie lub w tle.</span><span class="sxs-lookup"><span data-stu-id="4517f-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="4517f-105">Ponadto można użyć <xref:System.Threading.ThreadPool> klasy na wykonanie kodu na wątków roboczych, które są zarządzane przez środowisko uruchomieniowe języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="4517f-106">W tej sekcji</span><span class="sxs-lookup"><span data-stu-id="4517f-106">In this section</span></span>  
  
 <span data-ttu-id="4517f-107">[Uruchamianie wątku](#Starting) </span><span class="sxs-lookup"><span data-stu-id="4517f-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="4517f-108">[Pobieranie obiektów wątków](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="4517f-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="4517f-109">[Wątki pierwszego planu i tła](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="4517f-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="4517f-110">[Kultura i wątków](#Culture) </span><span class="sxs-lookup"><span data-stu-id="4517f-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="4517f-111">Otrzymanie informacji o i sterowanie wątkami</span><span class="sxs-lookup"><span data-stu-id="4517f-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="4517f-112">Uruchamianie wątku</span><span class="sxs-lookup"><span data-stu-id="4517f-112">Starting a thread</span></span>  
 <span data-ttu-id="4517f-113">Podając delegata, który reprezentuje metodę, którą wątek znajduje się w jego konstruktora klasy można rozpocząć wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="4517f-114">Następnie wywołaj <xref:System.Threading.Thread.Start%2A> metody, aby rozpocząć wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4517f-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="4517f-115"><xref:System.Threading.Thread> Konstruktorów może przybrać jedną z delegata dwa typy, w zależności od tego, czy przekazując argument do metody do wykonania:</span><span class="sxs-lookup"><span data-stu-id="4517f-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="4517f-116">Jeśli metoda nie ma argumentów, Przekaż <xref:System.Threading.ThreadStart> delegować do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="4517f-117">Ma podpis:</span><span class="sxs-lookup"><span data-stu-id="4517f-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="4517f-118">Poniższy przykład utworzenie i uruchomienie wątku, który wykonuje `ExecuteInForeground` metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="4517f-119">Metoda Wyświetla informacje o niektórych właściwości wątku, a następnie wykonuje pętlę, w którym wstrzymuje pół sekundy i wyświetla liczbę sekund, który upłynął.</span><span class="sxs-lookup"><span data-stu-id="4517f-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="4517f-120">Gdy wątek zostało wykonane co najmniej pięć sekund, kończy się pętli i wątku kończy wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="4517f-121">Jeśli metoda ma argument, Przekaż <xref:System.Threading.ParameterizedThreadStart> delegować do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="4517f-122">Ma podpis:</span><span class="sxs-lookup"><span data-stu-id="4517f-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="4517f-123">Metoda wykonywane przez delegata można rzutowanie (C#) lub przekonwertować (w języku Visual Basic) parametr do odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="4517f-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="4517f-124">Poniższy przykład jest taki sam jak poprzedni, z wyjątkiem tego, aby wywoływał <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="4517f-125">Ta wersja `ExecuteInForeground` metoda ma jeden parametr reprezentujący przybliżoną liczbę milisekund pętli ma zostać wykonany.</span><span class="sxs-lookup"><span data-stu-id="4517f-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="4517f-126">Nie jest konieczne zachować odwołanie do <xref:System.Threading.Thread> obiektu po uruchomieniu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="4517f-127">Wątek w dalszym ciągu wykonaj aż do zakończenia procedury wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="4517f-128">Pobieranie obiektów wątków</span><span class="sxs-lookup"><span data-stu-id="4517f-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="4517f-129">Można użyć statycznych (`Shared` w języku Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> właściwość, aby pobrać odwołanie do aktualnie realizowanej wątku z kodu, który jest wykonywany wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="4517f-130">W poniższym przykładzie użyto <xref:System.Threading.Thread.CurrentThread%2A> właściwości, aby wyświetlić informacje o wątku głównego aplikacji, inny wątek pierwszego planu wątku w tle i wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="4517f-131">Wątki pierwszego planu i tła</span><span class="sxs-lookup"><span data-stu-id="4517f-131">Foreground and background threads</span></span>  
 <span data-ttu-id="4517f-132">Wystąpienia <xref:System.Threading.Thread> klasy reprezentują wątki pierwszoplanowe lub wątki w tle.</span><span class="sxs-lookup"><span data-stu-id="4517f-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="4517f-133">Wątki w tle są takie same jak wątki pierwszoplanowe z jednym wyjątkiem: wątku w tle nie przechowuje proces uruchomiony, jeśli wszystkie wątki pierwszoplanowe zostały zakończone.</span><span class="sxs-lookup"><span data-stu-id="4517f-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="4517f-134">Po zostały zatrzymane wszystkie wątki pierwszego planu, środowisko uruchomieniowe zatrzymuje wszystkie wątki w tle i zamyka.</span><span class="sxs-lookup"><span data-stu-id="4517f-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="4517f-135">Domyślnie następujące wątków wykonania na pierwszym planie:</span><span class="sxs-lookup"><span data-stu-id="4517f-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="4517f-136">Wątku głównego aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="4517f-137">Wszystkie wątki utworzona przez wywołanie metody <xref:System.Threading.Thread> konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="4517f-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="4517f-138">Domyślnie następujące wątków wykonywane w tle:</span><span class="sxs-lookup"><span data-stu-id="4517f-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="4517f-139">Wątków z puli wątków, które są puli wątków roboczych obsługiwane przez środowisko uruchomieniowe.</span><span class="sxs-lookup"><span data-stu-id="4517f-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="4517f-140">Wątek puli i harmonogram pracy można skonfigurować na wątków z puli wątków, przy użyciu <xref:System.Threading.ThreadPool> klasy.</span><span class="sxs-lookup"><span data-stu-id="4517f-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4517f-141">Oparty na zadaniach asynchronicznej operacji automatycznie wykonywane na wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="4517f-142">Użyj opartego na zadaniach asynchronicznej operacji <xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> klasy do zaimplementowania [wzorca asynchronicznego opartego na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="4517f-143">Wszystkie wątki, które wprowadź zarządzanego środowiska wykonawczego z kodem niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="4517f-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="4517f-144">Możesz zmienić wątku do wykonania w tle przez ustawienie <xref:System.Threading.Thread.IsBackground%2A> właściwości w dowolnym momencie.</span><span class="sxs-lookup"><span data-stu-id="4517f-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="4517f-145">Wątki w tle są przydatne do żadnej operacji, które powinno być kontynuowane tak długo, jak aplikacja jest uruchomiona, ale nie powinien uniemożliwiają aplikacji przerywanie, takich jak monitorowanie zmian systemu plików lub przychodzące połączenia gniazda.</span><span class="sxs-lookup"><span data-stu-id="4517f-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="4517f-146">Poniższy przykład przedstawia różnice między wątkami pierwszego planu i tła.</span><span class="sxs-lookup"><span data-stu-id="4517f-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="4517f-147">Podobnie jak w pierwszym przykładzie [uruchamianie wątku](#Starting) sekcji z tą różnicą, że ustawia wątku do wykonania w tle przed jego rozpoczęciem.</span><span class="sxs-lookup"><span data-stu-id="4517f-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="4517f-148">Jak pokazano na dane wyjściowe, pętli zostało przerwane przed rozpoczęciem wykonywania przez pięć sekund.</span><span class="sxs-lookup"><span data-stu-id="4517f-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="4517f-149">Kultura i wątków</span><span class="sxs-lookup"><span data-stu-id="4517f-149">Culture and threads</span></span>  
 <span data-ttu-id="4517f-150">Każdy wątek jest kulturą reprezentowany przez <xref:System.Threading.Thread.CurrentCulture%2A> właściwości i kultury interfejsu użytkownika, reprezentowane przez <xref:System.Threading.Thread.CurrentUICulture%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="4517f-151">Bieżąca kultura obsługuje takie zależne od kultury operacje jako analizowania i formatowanie, porównywanie i sortowanie ciągów i również określać system pisma i używany przez wątek kalendarz.</span><span class="sxs-lookup"><span data-stu-id="4517f-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="4517f-152">Udostępnia bieżącej kultury interfejsu użytkownika dla pobierania zależne od kultury zasobów plików zasobów.</span><span class="sxs-lookup"><span data-stu-id="4517f-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  
  
 <span data-ttu-id="4517f-153">Podczas tworzenia wystąpienia klasy nowego wątku jego kultury i kultury interfejsu użytkownika są definiowane przez bieżącego ustawienia kulturowego systemu i kultury interfejsu użytkownika, a nie przez kultury i kultury interfejsu użytkownika w wątku, z którego jest tworzony nowego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-153">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="4517f-154">Oznacza to, na przykład, że jeśli bieżące ustawienia kulturowe systemu jest angielski (Stany Zjednoczone) i bieżącej kultury wątku aplikacji głównej jest francuski (Francja), kultura nowego wątku utworzona przez wywołanie metody <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora z podstawowym wątku jest angielski (Stany Zjednoczone), francuski (Francja).</span><span class="sxs-lookup"><span data-stu-id="4517f-154">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="4517f-155">Aby uzyskać więcej informacji, zobacz sekcję "Kultury i wątków" <xref:System.Globalization.CultureInfo> klasy tematu.</span><span class="sxs-lookup"><span data-stu-id="4517f-155">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-156">Nie dotyczy wątków, które wykonują operacje asynchroniczne dla aplikacji przeznaczonych [!INCLUDE[net_v46](~/includes/net-v46-md.md)] i nowszych wersjach, w tym przypadku, kultury i kultury interfejsu użytkownika jest częścią asynchronicznego operacjach kontekście; wątku, w którym operacji asynchronicznej wykonuje przez domyślny dziedziczy kultury i kultury interfejsu użytkownika w wątku, w którym została uruchomiona operacja asynchroniczna.</span><span class="sxs-lookup"><span data-stu-id="4517f-156">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="4517f-157">Aby uzyskać więcej informacji, zobacz sekcję "Kultury i oparty na zadaniach asynchronicznej operacji" <xref:System.Globalization.CultureInfo> klasy tematu.</span><span class="sxs-lookup"><span data-stu-id="4517f-157">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="4517f-158">Wykonaj jedną z następujących czynności, aby upewnić się, że wszystkie wątki wykonywania w aplikacji korzysta z tej samej kultury i kultura interfejsu użytkownika:</span><span class="sxs-lookup"><span data-stu-id="4517f-158">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="4517f-159">Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tego kultura <xref:System.Threading.ParameterizedThreadStart> delegować lub <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-159">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="4517f-160">Dla aplikacji działających na [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i nowszych wersjach można zdefiniować kultury i kultury interfejsu użytkownika, który ma być przypisana do wszystkich wątków utworzonych w domenie aplikacji przez ustawienie wartości <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-160">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="4517f-161">Należy pamiętać, że jest to ustawienie domeny dla poszczególnych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-161">Note that this is a per-application domain setting.</span></span>  
  
 <span data-ttu-id="4517f-162">Aby uzyskać dodatkowe informacje i przykłady, zobacz sekcję "Kultury i wątków" <xref:System.Globalization.CultureInfo> klasy tematu.</span><span class="sxs-lookup"><span data-stu-id="4517f-162">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="4517f-163">Otrzymanie informacji o i sterowanie wątkami</span><span class="sxs-lookup"><span data-stu-id="4517f-163">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="4517f-164">Możesz pobrać wiele wartości właściwości, które zawierają informacje o wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-164">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="4517f-165">W niektórych przypadkach można również ustawić wartości tych właściwości, do kontrolowania operacji wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-165">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="4517f-166">Te właściwości wątku obejmują:</span><span class="sxs-lookup"><span data-stu-id="4517f-166">These thread properties include:</span></span>  
  
-   <span data-ttu-id="4517f-167">Nazwa.</span><span class="sxs-lookup"><span data-stu-id="4517f-167">A name.</span></span> <span data-ttu-id="4517f-168"><xref:System.Threading.Thread.Name%2A> jest zapis — raz właściwość, która służy do identyfikowania wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-168"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="4517f-169">Jego wartość domyślna to `null`.</span><span class="sxs-lookup"><span data-stu-id="4517f-169">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="4517f-170">Wartość skrótu, który można pobrać przez wywołanie metody <xref:System.Threading.Thread.GetHashCode%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-170">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="4517f-171">Wartość skrótu służy do jednoznacznej identyfikacji wątku; przez czas ich istnienia z wątku jego wartość skrótu nie będzie kolidują z wartości z innego wątku, niezależnie od domeny aplikacji, z którego można uzyskać wartości.</span><span class="sxs-lookup"><span data-stu-id="4517f-171">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="4517f-172">Identyfikator wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-172">A thread ID.</span></span> <span data-ttu-id="4517f-173">Wartość tylko do odczytu <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości jest przypisywany przez środowisko uruchomieniowe i unikatowo identyfikuje wątku w procesie.</span><span class="sxs-lookup"><span data-stu-id="4517f-173">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4517f-174">System operacyjny [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) nie ma stałej relacji do zarządzanego wątku, ponieważ niezarządzane hosta można kontrolować relacji między wątkami zarządzane i niezarządzane.</span><span class="sxs-lookup"><span data-stu-id="4517f-174">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="4517f-175">W szczególności mogą używać hosta zaawansowane [API hostingu środowiska CLR](https://msdn.microsoft.com/library/ms404385.aspx) można zaplanować wiele wątków zarządzanych względem tego samego wątku systemu operacyjnego, lub zarządzanego wątku między wątki innego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-175">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="4517f-176">Bieżący stan wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-176">The thread's current state.</span></span> <span data-ttu-id="4517f-177">Czas trwania jego istnienia wątek jest zawsze w co najmniej jednej stanów zdefiniowane przez <xref:System.Threading.ThreadState> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-177">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="4517f-178">Poziom priorytetu planowania, który jest zdefiniowany przez <xref:System.Threading.ThreadPriority> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-178">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="4517f-179">Mimo że można ustawić tej wartości, priorytetu wątku żądania, nie jest gwarantowana aby były używane przez system operacyjny.</span><span class="sxs-lookup"><span data-stu-id="4517f-179">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="4517f-180">Tylko do odczytu <xref:System.Threading.Thread.IsThreadPoolThread%2A> właściwość, która wskazuje, czy wątek jest wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-180">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="4517f-181"><xref:System.Threading.Thread.IsBackground%2A> Właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-181">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="4517f-182">Aby uzyskać więcej informacji, zobacz [wątki pierwszego planu i tła](#Foreground) sekcji.</span><span class="sxs-lookup"><span data-stu-id="4517f-182">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="4517f-183">W poniższym przykładzie pokazano proste funkcje wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-183">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="4517f-184">Ten kod generuje dane wyjściowe podobne do następujących:</span><span class="sxs-lookup"><span data-stu-id="4517f-184">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="4517f-185">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4517f-185">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-186">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-186">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="4517f-187">Delegat, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-187">A delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-188">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając delegata, który umożliwia obiektu do przekazania do wątku, gdy wątek jest uruchomiony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-188">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-189">Wątek nie zaczyna się wykonywania podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-189">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="4517f-190">Aby zaplanować wątku do wykonania, należy wywołać <xref:System.Threading.Thread.Start%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-190">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="4517f-191">Aby przekazać obiekt danych do wątku, należy użyć <xref:System.Threading.Thread.Start%28System.Object%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-191">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-192">Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.ThreadStart> Konstruktor podczas tworzenia wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-192">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="4517f-193">Użyj `AddressOf` operator podczas przekazywania metodę, na przykład `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="4517f-193">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="4517f-194">Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-194">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-195">W poniższym przykładzie przedstawiono składnię tworzenie i używanie <xref:System.Threading.ParameterizedThreadStart> delegata z metody statycznej i metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4517f-195">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4517f-196">
            <paramref name="start" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-196">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="4517f-197">A <see cref="T:System.Threading.ThreadStart" /> delegata, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-197">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-198">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-198">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-199">Wątek nie zaczyna się wykonywania podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-199">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="4517f-200">Aby zaplanować wątku do wykonania, należy wywołać <xref:System.Threading.Thread.Start%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-200">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-201">Użytkownicy programu Visual Basic można pominąć <xref:System.Threading.ThreadStart> Konstruktor podczas tworzenia wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-201">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="4517f-202">Użyj `AddressOf` operator podczas przekazywania metodę, na przykład `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="4517f-202">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="4517f-203">Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-203">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-204">Poniższy przykład kodu pokazuje, jak można utworzyć wątku, który wykonuje metodą statyczną.</span><span class="sxs-lookup"><span data-stu-id="4517f-204">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="4517f-205">Poniższy przykład kodu pokazuje, jak utworzyć wątku, który wykonuje metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4517f-205">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4517f-206">
            <paramref name="start" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-206">The <paramref name="start" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="4517f-207">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegata, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-207">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <param name="maxStackSize">
          <span data-ttu-id="4517f-208">Rozmiar stosu maksymalny w bajtach do użycia przez wątek lub 0 Aby użyć domyślny rozmiar maksymalny stosu określony w nagłówku pliku wykonywalnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-208">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span>
          </span>
          <span data-ttu-id="4517f-209">Ważne dla częściowo zaufanego kodu, <c>maxStackSize</c> jest ignorowana, jeśli jest większy niż domyślny rozmiar stosu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-209">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span>
          </span>
          <span data-ttu-id="4517f-210">Nie wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-210">No exception is thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-211">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając delegata, który umożliwia obiektu do przekazania do wątku, gdy wątek jest uruchomiony i określania rozmiaru maksymalnego stosu wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-211">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-212">Unikaj stosowania tego przeciążenia konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-212">Avoid using this constructor overload.</span></span> <span data-ttu-id="4517f-213">Domyślny rozmiar stosu używana przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> przeładowania konstruktora jest rozmiar stosu zalecane dla wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-213">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="4517f-214">Jeśli wątek występują problemy z pamięcią, najbardziej prawdopodobną przyczyną jest programowania, błąd, taki jak nieskończoną rekursję.</span><span class="sxs-lookup"><span data-stu-id="4517f-214">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-215">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tylko w pełni zaufane, można ustawić kodu `maxStackSize` na wartość, która jest większa niż domyślny rozmiar stosu (1 megabajt).</span><span class="sxs-lookup"><span data-stu-id="4517f-215">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="4517f-216">Jeśli określono wartość większą dla `maxStackSize` gdy kod działa z częściowej relacji zaufania, `maxStackSize` jest ignorowany i jest używany domyślny rozmiar stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-216">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="4517f-217">Nie wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-217">No exception is thrown.</span></span> <span data-ttu-id="4517f-218">Można ustawić kodu na dowolnym poziomie zaufania `maxStackSize` na wartość, która jest mniejsza niż domyślny rozmiar stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-218">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-219">Jeśli tworzysz biblioteki pełni zaufany, który będzie używany przez kod częściowo zaufany, należy rozpocząć wątku wymagający stosu dużych, musi assert pełne zaufanie przed utworzeniem wątku lub domyślny rozmiar stosu będą używane.</span><span class="sxs-lookup"><span data-stu-id="4517f-219">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="4517f-220">Nie należy tego robić, chyba że w pełni kontrolować kod uruchamiany w wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-220">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="4517f-221">Jeśli `maxStackSize` jest mniejszy niż rozmiar minimalny stos rozmiar minimalny stosu jest używany.</span><span class="sxs-lookup"><span data-stu-id="4517f-221">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="4517f-222">Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony jest zaokrąglana do większych dalej wielokrotnością rozmiaru strony.</span><span class="sxs-lookup"><span data-stu-id="4517f-222">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="4517f-223">Na przykład jeśli używasz programu .NET Framework w wersji 2.0 w systemie Windows Vista, rozmiar minimalny stos jest 256KB (262 144 bajty), a rozmiar strony jest 64KB (65 536 bajtów).</span><span class="sxs-lookup"><span data-stu-id="4517f-223">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-224">W wersjach systemu Microsoft Windows starszych niż Windows XP i Windows Server 2003 `maxStackSize` jest ignorowany i jest używany rozmiar stosu określony w nagłówku pliku wykonywalnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-224">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="4517f-225">Określ rozmiar stosu niewielkie, może być konieczne wyłączenie sondowanie przepełnienie stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-225">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="4517f-226">Jeśli stosu jest znacznie ograniczone, sondowanie może spowodować przepełnienie stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-226">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="4517f-227">Aby wyłączyć sondowanie przepełnienie stosu, dodaj następującą wartość do pliku konfiguracji aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-227">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4517f-228">
            <paramref name="start" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-228">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4517f-229">
            <paramref name="maxStackSize" /> jest mniejsza od zera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-229">
              <paramref name="maxStackSize" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="4517f-230">A <see cref="T:System.Threading.ThreadStart" /> delegata, który reprezentuje metody do wywołania po rozpoczęciu tego wątku wykonywania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-230">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <param name="maxStackSize">
          <span data-ttu-id="4517f-231">Rozmiar stosu maksymalny w bajtach do użycia przez wątek lub 0 Aby użyć domyślny rozmiar maksymalny stosu określony w nagłówku pliku wykonywalnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-231">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span>
          </span>
          <span data-ttu-id="4517f-232">Ważne dla częściowo zaufanego kodu, <c>maxStackSize</c> jest ignorowana, jeśli jest większy niż domyślny rozmiar stosu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-232">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span>
          </span>
          <span data-ttu-id="4517f-233">Nie wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-233">No exception is thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-234">Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy określania rozmiaru maksymalnego stosu wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-234">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-235">Unikaj stosowania tego przeciążenia konstruktora.</span><span class="sxs-lookup"><span data-stu-id="4517f-235">Avoid using this constructor overload.</span></span> <span data-ttu-id="4517f-236">Domyślny rozmiar stosu używana przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> przeładowania konstruktora jest rozmiar stosu zalecane dla wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-236">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="4517f-237">Jeśli wątek występują problemy z pamięcią, najbardziej prawdopodobną przyczyną jest programowania, błąd, taki jak nieskończoną rekursję.</span><span class="sxs-lookup"><span data-stu-id="4517f-237">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-238">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tylko w pełni zaufane, można ustawić kodu `maxStackSize` na wartość, która jest większa niż domyślny rozmiar stosu (1 megabajt).</span><span class="sxs-lookup"><span data-stu-id="4517f-238">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="4517f-239">Jeśli określono wartość większą dla `maxStackSize` gdy kod działa z częściowej relacji zaufania, `maxStackSize` jest ignorowany i jest używany domyślny rozmiar stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-239">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="4517f-240">Nie wyjątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-240">No exception is thrown.</span></span> <span data-ttu-id="4517f-241">Można ustawić kodu na dowolnym poziomie zaufania `maxStackSize` na wartość, która jest mniejsza niż domyślny rozmiar stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-241">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-242">Jeśli tworzysz biblioteki pełni zaufany, który będzie używany przez kod częściowo zaufany, należy rozpocząć wątku wymagający stosu dużych, musi assert pełne zaufanie przed utworzeniem wątku lub domyślny rozmiar stosu będą używane.</span><span class="sxs-lookup"><span data-stu-id="4517f-242">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="4517f-243">Nie należy tego robić, chyba że w pełni kontrolować kod uruchamiany w wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-243">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="4517f-244">Jeśli `maxStackSize` jest mniejszy niż rozmiar minimalny stos rozmiar minimalny stosu jest używany.</span><span class="sxs-lookup"><span data-stu-id="4517f-244">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="4517f-245">Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony jest zaokrąglana do większych dalej wielokrotnością rozmiaru strony.</span><span class="sxs-lookup"><span data-stu-id="4517f-245">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="4517f-246">Na przykład jeśli używasz programu .NET Framework w wersji 2.0 w systemie Windows Vista, rozmiar minimalny stos jest 256KB (262 144 bajty), a rozmiar strony jest 64KB (65 536 bajtów).</span><span class="sxs-lookup"><span data-stu-id="4517f-246">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-247">W wersjach systemu Microsoft Windows starszych niż Windows XP i Windows Server 2003 `maxStackSize` jest ignorowany i jest używany rozmiar stosu określony w nagłówku pliku wykonywalnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-247">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="4517f-248">Określ rozmiar stosu niewielkie, może być konieczne wyłączenie sondowanie przepełnienie stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-248">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="4517f-249">Jeśli stosu jest znacznie ograniczone, sondowanie może spowodować przepełnienie stosu.</span><span class="sxs-lookup"><span data-stu-id="4517f-249">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="4517f-250">Aby wyłączyć sondowanie przepełnienie stosu, dodaj następującą wartość do pliku konfiguracji aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-250">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4517f-251">
            <paramref name="start" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-251">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4517f-252">
            <paramref name="maxStackSize" /> jest mniejsza od zera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-252">
              <paramref name="maxStackSize" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-253">Zgłasza <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces przerywanie wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-253">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span>
          </span>
          <span data-ttu-id="4517f-254">Wywołanie tej metody zwykle kończy wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-254">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-255">Zgłasza <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces przerywanie wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-255">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span>
          </span>
          <span data-ttu-id="4517f-256">Wywołanie tej metody zwykle kończy wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-256">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-257">Gdy ta metoda jest wywoływana w wątku, system generuje <xref:System.Threading.ThreadAbortException> w wątku, aby przerwać go.</span><span class="sxs-lookup"><span data-stu-id="4517f-257">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="4517f-258">`ThreadAbortException` specjalne wyjątek, który może być przechwycony przez kod aplikacji, ale jest zgłoszony ponownie na końcu `catch` zablokować, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-258">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="4517f-259">`ResetAbort` anuluje żądanie do przerwania, a także zapobiega `ThreadAbortException` z przerywanie wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-259">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="4517f-260">Cofnąć `finally` bloki są wykonywane przed wątek został przerwany.</span><span class="sxs-lookup"><span data-stu-id="4517f-260">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-261">Gdy wywołuje wątku `Abort` na siebie, efekt jest podobny do generowania wyjątku; <xref:System.Threading.ThreadAbortException> się stanie, a wynik jest atrybutem wartości prognozowanych.</span><span class="sxs-lookup"><span data-stu-id="4517f-261">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="4517f-262">Jednak jeśli wywołuje jeden wątek `Abort` w innym wątku, przerwanie przerwań działa niezależnie od kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-262">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="4517f-263">Istnieje prawdopodobieństwo, że może spowodować przerwanie Konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="4517f-263">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="4517f-264">W rzadkich przypadkach to może uniemożliwić wystąpienia tej klasy w tej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-264">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="4517f-265">W wersji systemu .NET Framework 1.0 i 1.1, istnieje ryzyko, można przerwać wątek podczas `finally` bloku jest uruchomiona, w którym to przypadku `finally` bloku zostało przerwane.</span><span class="sxs-lookup"><span data-stu-id="4517f-265">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="4517f-266">Wątek nie jest gwarantowana przerwania natychmiast lub w ogóle.</span><span class="sxs-lookup"><span data-stu-id="4517f-266">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="4517f-267">Taka sytuacja może wystąpić, jeśli wątek nie niezwiązana ilość obliczeń w `finally` bloków, które są wywoływane w ramach procedury przerwania, w tym samym nieograniczony czas opóźnienia przerwanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-267">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="4517f-268">Poczekać, aż wątek został przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> metody w wątku po wywołaniu <xref:System.Threading.Thread.Abort%2A> metody, ale nie ma żadnej gwarancji zakończy się czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="4517f-268">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-269">Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> może zablokować, jeśli wątek, który jest przerywana znajduje się w regionie chronionym kodu, takie jak `catch` bloku `finally` bloku lub region ograniczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="4517f-269">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="4517f-270">Jeśli wątku wywołującym <xref:System.Threading.Thread.Abort%2A> utrzymuje blokadę przez wątek zostało przerwane, może wystąpić zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="4517f-270">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="4517f-271">Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek przerwie, kiedy <xref:System.Threading.Thread.Start%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-271">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="4517f-272">Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest w stanie uśpienia, wątek przerwane i następnie przerwane.</span><span class="sxs-lookup"><span data-stu-id="4517f-272">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="4517f-273">Jeśli `Abort` jest wywoływana w wątku, który zostało zawieszone, <xref:System.Threading.ThreadStateException> jest zgłaszany w wątku, który wywołuje <xref:System.Threading.Thread.Abort%2A>, i <xref:System.Threading.ThreadState.AbortRequested> jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości przerywany wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-273">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="4517f-274">A <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w wątku zawieszonym do <xref:System.Threading.Thread.Resume%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-274">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="4517f-275">Jeśli `Abort` jest wywoływana w wątku zarządzanego podczas wykonywania kodu niezarządzanego `ThreadAbortException` nie jest generowany, dopóki wątek powróci do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="4517f-275">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="4517f-276">Jeśli dwa wywołań `Abort` występować w tym samym czasie, istnieje możliwość jedno wywołanie ustawić informacje o stanie i inne wywołania w celu wykonania `Abort`.</span><span class="sxs-lookup"><span data-stu-id="4517f-276">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="4517f-277">Jednak aplikacja nie wykrywa on tę sytuację.</span><span class="sxs-lookup"><span data-stu-id="4517f-277">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="4517f-278">Po `Abort` jest wywoływane w wątku, zawiera stan wątku <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="4517f-278">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="4517f-279">Po zakończeniu wątku wyniku pomyślnym nawiązaniu połączenia z `Abort`, stan wątku jest zmieniany na <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="4517f-279">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="4517f-280">Z wystarczającymi uprawnieniami, wątek to obiekt docelowy `Abort` można anulować przy użyciu przerwania `ResetAbort` metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-280">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="4517f-281">Na przykład, który demonstruje wywołania `ResetAbort` metody, zobacz `ThreadAbortException` klasy.</span><span class="sxs-lookup"><span data-stu-id="4517f-281">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="4517f-282">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-282">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-283">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-283">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-284">Wątek, który jest przerywana jest aktualnie wstrzymana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-284">The thread that is being aborted is currently suspended.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-285">Aby uzyskać zaawansowane operacje w wątkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-285">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="4517f-286">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-286">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">
          <span data-ttu-id="4517f-287">Obiekt, który zawiera informacje specyficzne dla aplikacji, takie jak stan, które mogą być używane przez przerywany wątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-287">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-288">Zgłasza <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces zakończenia wątku, jednocześnie zapewniając wyjątek informacji o zakończenie wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-288">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span>
          </span>
          <span data-ttu-id="4517f-289">Wywołanie tej metody zwykle kończy wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-289">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-290">Gdy ta metoda jest wywoływana w wątku, system generuje <xref:System.Threading.ThreadAbortException> w wątku, aby przerwać go.</span><span class="sxs-lookup"><span data-stu-id="4517f-290">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="4517f-291">`ThreadAbortException` specjalne wyjątek, który może być przechwycony przez kod aplikacji, ale jest zgłoszony ponownie na końcu `catch` zablokować, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-291">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="4517f-292">`ResetAbort` anuluje żądanie do przerwania, a także zapobiega `ThreadAbortException` z przerywanie wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-292">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="4517f-293">Cofnąć `finally` bloki są wykonywane przed wątek został przerwany.</span><span class="sxs-lookup"><span data-stu-id="4517f-293">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-294">Gdy wywołuje wątku `Abort` na siebie, efekt jest podobny do generowania wyjątku; <xref:System.Threading.ThreadAbortException> się stanie, a wynik jest atrybutem wartości prognozowanych.</span><span class="sxs-lookup"><span data-stu-id="4517f-294">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="4517f-295">Jednak jeśli wywołuje jeden wątek `Abort` w innym wątku, przerwanie przerwań działa niezależnie od kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-295">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="4517f-296">Istnieje ryzyko, że może spowodować przerwanie Konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="4517f-296">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="4517f-297">W rzadkich przypadkach to może uniemożliwić wystąpienia tej klasy w tej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-297">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="4517f-298">W wersji systemu .NET Framework 1.0 i 1.1, istnieje ryzyko, można przerwać wątek podczas `finally` bloku jest uruchomiona, w którym to przypadku `finally` bloku zostało przerwane.</span><span class="sxs-lookup"><span data-stu-id="4517f-298">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="4517f-299">Wątek nie jest gwarantowana przerwania natychmiast lub w ogóle.</span><span class="sxs-lookup"><span data-stu-id="4517f-299">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="4517f-300">Taka sytuacja może wystąpić, jeśli wątek nie niezwiązana ilość obliczeń w `finally` bloków, które są wywoływane w ramach procedury przerwania, w tym samym nieograniczony czas opóźnienia przerwanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-300">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="4517f-301">Poczekać, aż wątek został przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> metody w wątku po wywołaniu <xref:System.Threading.Thread.Abort%2A> metody, ale nie ma żadnej gwarancji, który zakończy się czas oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="4517f-301">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-302">Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> może zablokować, jeśli wątek, który jest przerywana znajduje się w regionie chronionym kodu, takie jak `catch` bloku `finally` bloku lub region ograniczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="4517f-302">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="4517f-303">Jeśli wątku wywołującym <xref:System.Threading.Thread.Abort%2A> utrzymuje blokadę przez wątek zostało przerwane, może wystąpić zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="4517f-303">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="4517f-304">Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek przerwie, kiedy <xref:System.Threading.Thread.Start%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-304">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="4517f-305">Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest w stanie uśpienia, wątek przerwane i następnie przerwane.</span><span class="sxs-lookup"><span data-stu-id="4517f-305">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="4517f-306">Jeśli `Abort` jest wywoływana w wątku, który zostało zawieszone, <xref:System.Threading.ThreadStateException> jest zgłaszany w wątku, który wywołuje <xref:System.Threading.Thread.Abort%2A>, i <xref:System.Threading.ThreadState.AbortRequested> jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości przerywany wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-306">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="4517f-307">A <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w wątku zawieszonym do <xref:System.Threading.Thread.Resume%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-307">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="4517f-308">Jeśli `Abort` jest wywoływana w wątku zarządzanego podczas wykonywania kodu niezarządzanego `ThreadAbortException` nie jest generowany, dopóki wątek powróci do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="4517f-308">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="4517f-309">Jeśli dwa wywołań `Abort` występować w tym samym czasie, istnieje możliwość jedno wywołanie ustawić informacje o stanie i inne wywołania w celu wykonania `Abort`.</span><span class="sxs-lookup"><span data-stu-id="4517f-309">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="4517f-310">Jednak aplikacja nie wykrywa on tę sytuację.</span><span class="sxs-lookup"><span data-stu-id="4517f-310">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="4517f-311">Po `Abort` jest wywoływane w wątku, zawiera stan wątku <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="4517f-311">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="4517f-312">Po zakończeniu wątku wyniku pomyślnym nawiązaniu połączenia z `Abort`, stan wątku jest zmieniany na <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="4517f-312">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="4517f-313">Z wystarczającymi uprawnieniami, wątek to obiekt docelowy `Abort` można anulować przy użyciu przerwania `ResetAbort` metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-313">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="4517f-314">Na przykład, który demonstruje wywołania `ResetAbort` metody, zobacz `ThreadAbortException` klasy.</span><span class="sxs-lookup"><span data-stu-id="4517f-314">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-315">Poniższy przykład kodu pokazuje sposób przekazywania informacji do wątku, który jest przerywana.</span><span class="sxs-lookup"><span data-stu-id="4517f-315">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="4517f-316">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-316">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-317">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-317">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-318">Wątek, który jest przerywana jest aktualnie wstrzymana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-318">The thread that is being aborted is currently suspended.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-319">Aby uzyskać zaawansowane operacje w wątkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-319">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="4517f-320">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-320">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-321">Przydziela gniazda danych bez nazwy na wszystkie wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-321">Allocates an unnamed data slot on all the threads.</span>
          </span>
          <span data-ttu-id="4517f-322">W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-322">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-323">Przydzielony o nazwie gniazda danych na wszystkie wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-323">The allocated named data slot on all threads.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-324">Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-324">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4517f-325">Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-325">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4517f-326">Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-326">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4517f-327">Miejsce jest przydzielane w wszystkie wątki.</span><span class="sxs-lookup"><span data-stu-id="4517f-327">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="4517f-328">Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-328">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4517f-329">Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-329">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4517f-330">Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-330">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4517f-331">Gniazda danych różnią się na wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-331">Data slots are unique per thread.</span></span> <span data-ttu-id="4517f-332">Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-332">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-333">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-333">This section contains two code examples.</span></span> <span data-ttu-id="4517f-334">Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-334">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4517f-335">Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.</span><span class="sxs-lookup"><span data-stu-id="4517f-335">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4517f-336">**Pierwszym przykładzie**</span><span class="sxs-lookup"><span data-stu-id="4517f-336">**First Example**</span></span>  
  
 <span data-ttu-id="4517f-337">Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-337">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4517f-338">Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4517f-338">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4517f-339">**Drugi przykład**</span><span class="sxs-lookup"><span data-stu-id="4517f-339">**Second Example**</span></span>  
  
 <span data-ttu-id="4517f-340">Poniższy przykład kodu pokazuje, jak używać gniazda danych do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-340">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4517f-341">Nazwa miejsca danych do przydzielenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-341">The name of the data slot to be allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-342">Przydziela gniazda danych o podanej nazwie w wszystkie wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-342">Allocates a named data slot on all threads.</span>
          </span>
          <span data-ttu-id="4517f-343">W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-343">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-344">Przydzielony o nazwie gniazda danych na wszystkie wątki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-344">The allocated named data slot on all threads.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-345">Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-345">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4517f-346">Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-346">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4517f-347">Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-347">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4517f-348">Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-348">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4517f-349">Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-349">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4517f-350">Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-350">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4517f-351">Gniazda danych różnią się na wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-351">Data slots are unique per thread.</span></span> <span data-ttu-id="4517f-352">Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-352">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="4517f-353">Nie jest konieczne użycie <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metodę, aby przydzielić miejsce danych o podanej nazwie, ponieważ <xref:System.Threading.Thread.GetNamedDataSlot%2A> — metoda przydziela miejsce, jeśli nie został jeszcze przydzielony.</span><span class="sxs-lookup"><span data-stu-id="4517f-353">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-354">Jeśli <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metoda jest używana, należy nadać mu w głównym wątku w momencie uruchamiania programu, ponieważ zgłasza wyjątek, jeśli w miejscu o określonej nazwie została już przydzielona.</span><span class="sxs-lookup"><span data-stu-id="4517f-354">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="4517f-355">Nie istnieje sposób sprawdzić, czy gnieździe została już przydzielona.</span><span class="sxs-lookup"><span data-stu-id="4517f-355">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="4517f-356">Gniazda przydzielonych za pomocą tej metody należy oddzielić z <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-356">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-357">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-357">This section contains two code examples.</span></span> <span data-ttu-id="4517f-358">Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-358">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4517f-359">Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.</span><span class="sxs-lookup"><span data-stu-id="4517f-359">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4517f-360">**Pierwszym przykładzie**</span><span class="sxs-lookup"><span data-stu-id="4517f-360">**First Example**</span></span>  
  
 <span data-ttu-id="4517f-361">Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-361">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4517f-362">Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4517f-362">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4517f-363">**Drugi przykład**</span><span class="sxs-lookup"><span data-stu-id="4517f-363">**Second Example**</span></span>  
  
 <span data-ttu-id="4517f-364">W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-364">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-365">Przykład kodu nie używa <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metody, ponieważ <xref:System.Threading.Thread.GetNamedDataSlot%2A> — metoda przydziela miejsce, jeśli nie został jeszcze przydzielony.</span><span class="sxs-lookup"><span data-stu-id="4517f-365">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="4517f-366">Jeśli <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metoda jest używana, powinna być wywoływana w głównym wątku w momencie uruchamiania programu.</span><span class="sxs-lookup"><span data-stu-id="4517f-366">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4517f-367">Gniazdo danych o podanej nazwie, o określonej nazwie już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-367">A named data slot with the specified name already exists.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-368">Pobiera lub ustawia stan apartamentu tego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-368">Gets or sets the apartment state of this thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-369">Jeden z <see cref="T:System.Threading.ApartmentState" /> wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-369">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span>
          </span>
          <span data-ttu-id="4517f-370">Jest to wartość początkowa <see langword="Unknown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-370">The initial value is <see langword="Unknown" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-371">**<xref:System.Threading.Thread.ApartmentState%2A> Właściwość jest przestarzała.**</span><span class="sxs-lookup"><span data-stu-id="4517f-371">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="4517f-372">Nieprzestarzała alternatyw <xref:System.Threading.Thread.GetApartmentState%2A> metoda pobierania stanu apartamentu i <xref:System.Threading.Thread.SetApartmentState%2A> metody do ustawiania stanu apartamentu.</span><span class="sxs-lookup"><span data-stu-id="4517f-372">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="4517f-373">W wersji systemu .NET Framework 1.0 i 1.1 `ApartmentState` właściwości oznacza wątek, aby wskazać, że będą wykonywane w pojedynczym wątku lub wielowątkowe typu apartment.</span><span class="sxs-lookup"><span data-stu-id="4517f-373">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="4517f-374">Tej właściwości można ustawić, gdy wątek znajduje się w `Unstarted` lub `Running` wątku stanu; jednak można ją ustawić tylko raz dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-374">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="4517f-375">Jeśli nie ustawiono właściwości, zwraca `Unknown`.</span><span class="sxs-lookup"><span data-stu-id="4517f-375">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="4517f-376">Próba użycia <xref:System.Threading.Thread.ApartmentState%2A> właściwość do ustawiania stanu apartamentu wątku, w których stanu apartamentu została już ustawiona jest ignorowana.</span><span class="sxs-lookup"><span data-stu-id="4517f-376">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="4517f-377">Jednak <xref:System.Threading.Thread.SetApartmentState%2A> metoda zgłasza <xref:System.InvalidOperationException> w takim przypadku.</span><span class="sxs-lookup"><span data-stu-id="4517f-377">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-378">W programie .NET Framework w wersji 2.0, nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stanu apartamentu nie została ustawiona, zanim zostaną uruchomione.</span><span class="sxs-lookup"><span data-stu-id="4517f-378">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="4517f-379">Zainicjowano wątku głównego aplikacji do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie.</span><span class="sxs-lookup"><span data-stu-id="4517f-379">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="4517f-380">Nie można ustawić wątku głównego aplikacji <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> przez ustawienie <xref:System.Threading.ApartmentState?displayProperty=nameWithType> właściwości w pierwszym wierszu kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-380">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="4517f-381">Użyj <xref:System.STAThreadAttribute> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="4517f-381">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="4517f-382">W programie .NET Framework w wersji 2.0, można określić wątków aplikacji C++ za pomocą modelu COM. [/CLRTHREADATTRIBUTE (Ustaw CLR wątku atrybut)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) — opcja konsolidatora.</span><span class="sxs-lookup"><span data-stu-id="4517f-382">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-383">Poniższy przykład kodu pokazuje, jak można ustawić stanu apartamentu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-383">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4517f-384">Aby ustawić tę właściwość na stanie, który nie jest stanu apartamentu prawidłowy podejmowana jest próba (stanie innym niż jednowątkowego apartamentu (<see langword="STA" />) lub wielowątkowe apartamentu (<see langword="MTA" />)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-384">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-385">Powiadamia hosta wykonywania o zbliżającym się podanie kodu, w którym wątek przerwania lub nieobsługiwany wyjątek może zagrozić inne zadania w domenie aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-385">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-386">Hosty środowisko uruchomieniowe języka wspólnego (CLR), takich jak Microsoft SQL Server 2005, można ustanowić różne zasady dla niepowodzenia w regionach krytyczne i niekrytyczne kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-386">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="4517f-387">Krytyczne region jest jednym w którym przerwania wątku lub nieobsługiwany wyjątek nie mogą być ograniczone do bieżącego zadania.</span><span class="sxs-lookup"><span data-stu-id="4517f-387">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="4517f-388">Z kolei przerwania lub niepowodzenia w regionie niekrytyczne kodu dotyczy tylko zadania, w którym występuje błąd.</span><span class="sxs-lookup"><span data-stu-id="4517f-388">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="4517f-389">Rozważmy na przykład zadanie, które próbuje przydzielić pamięci podczas utrzymywania blokady.</span><span class="sxs-lookup"><span data-stu-id="4517f-389">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="4517f-390">W przypadku niepowodzenia alokacji pamięci przerywanie bieżącego zadania nie jest wystarczająca do zapewnienia stabilności <xref:System.AppDomain>, ponieważ może być inne zadania w domenie oczekiwanie na tym samym blokady.</span><span class="sxs-lookup"><span data-stu-id="4517f-390">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="4517f-391">Jeśli bieżące zadanie jest zakończone, można zakleszczone innych zadań.</span><span class="sxs-lookup"><span data-stu-id="4517f-391">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="4517f-392">Gdy wystąpi awaria w regionie krytycznych, host zdecydować się na zwolnienie całą <xref:System.AppDomain> zamiast zaryzykować i kontynuowanie wykonywania w potencjalnie niestabilnym stanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-392">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="4517f-393">Aby poinformować hosta, że kod jest wprowadzane krytyczne regionu, należy wywołać <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-393">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="4517f-394">Wywołanie <xref:System.Threading.Thread.EndCriticalRegion%2A> podczas wykonywania zwraca niekrytyczne regionu kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-394">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="4517f-395">W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.</span><span class="sxs-lookup"><span data-stu-id="4517f-395">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-396">W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> metody do dzielenia bloku kodu na krytyczne i niekrytyczne regionów.</span><span class="sxs-lookup"><span data-stu-id="4517f-396">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-397">Powiadamia ma wykonać instrukcje, które są zależne od tożsamości bieżącego wątku fizycznego systemu operacyjnego hosta, który kodu zarządzanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-397">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-398">Niektóre hosty środowiska CLR, takich jak Microsoft SQL Server 2005, podać własne zarządzania wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-398">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="4517f-399">Hosta, który dostarcza kierownictwo wątku można przenieść wykonywanie zadania z jednego wątku fizycznego systemu operacyjnego w dowolnym momencie.</span><span class="sxs-lookup"><span data-stu-id="4517f-399">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="4517f-400">Większość zadań nie dotyczy to przełączanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-400">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="4517f-401">Jednak niektóre zadania mają koligacji wątku - oznacza to, że są one zależne od tożsamości wątku fizycznego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-401">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="4517f-402">Te zadania, należy poinformować hosta podczas ich wykonywania kodu, który nie powinien być przełączane.</span><span class="sxs-lookup"><span data-stu-id="4517f-402">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="4517f-403">Na przykład, jeśli zablokować wywołania aplikacji interfejsu API systemu uzyskać systemu operacyjnego, który ma koligacji wątków, takich jak Win32 CRITICAL_SECTION, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskiwanie blokady, i <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="4517f-403">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="4517f-404">W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.</span><span class="sxs-lookup"><span data-stu-id="4517f-404">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-405">W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> i <xref:System.Threading.Thread.EndThreadAffinity%2A> metody powiadomiono hosta, który blok kodu jest zależna od tożsamości wątku fizycznego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-405">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-406">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-406">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4517f-407">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-407">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4517f-408">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-408">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-409">Pobiera bieżący kontekst, w którym jest wykonywany wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-409">Gets the current context in which the thread is executing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-410">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> reprezentujący bieżący kontekst wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-410">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-411">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-411">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4517f-412">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-412">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4517f-413">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-413">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-414">Pobiera lub ustawia kulturę bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-414">Gets or sets the culture for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-415">Obiekt, który reprezentuje kultura bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-415">An object that represents the culture for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-416"><xref:System.Globalization.CultureInfo> Obiekt, który jest zwracany przez tę właściwość, wraz z powiązane obiekty, określić domyślnego formatu daty, godziny, liczb, wartości waluty, sortowanie kolejność tekstu, wielkość liter konwencje i porównywania ciągów.</span><span class="sxs-lookup"><span data-stu-id="4517f-416">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="4517f-417">Zobacz <xref:System.Globalization.CultureInfo> klasy informacje na temat nazwy kultury i identyfikatory, różnice między niezmiennej neutralne i określonej kultury, a informacje o ustawieniach kulturowych sposób wpływa na wątków i domen aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-417">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="4517f-418">Zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości, aby dowiedzieć się, jak jest określany przez wątek domyślną kulturę i konfiguracji informacji o kulturze na komputerach użytkowników.</span><span class="sxs-lookup"><span data-stu-id="4517f-418">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  
  
 <span data-ttu-id="4517f-419">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], można ustawić <xref:System.Threading.Thread.CurrentCulture%2A> kultury neutralnej dla właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-419">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="4517f-420">Jest to spowodowane zachowanie <xref:System.Globalization.CultureInfo> klasa uległa zmianie: gdy reprezentuje kultury neutralnej jej wartości właściwości (w szczególności <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, i <xref:System.Globalization.CultureInfo.TextInfo%2A> właściwości) teraz odzwierciedlają określoną kulturę, która jest skojarzona z kultury neutralnej.</span><span class="sxs-lookup"><span data-stu-id="4517f-420">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="4517f-421">We wcześniejszych wersjach programu .NET Framework <xref:System.Threading.Thread.CurrentCulture%2A> zwrócił właściwość <xref:System.NotSupportedException> wyjątku, gdy kultury neutralnej została przypisana.</span><span class="sxs-lookup"><span data-stu-id="4517f-421">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-422">Poniższy przykład kodu pokazuje wątkowości instrukcji, która umożliwia interfejsu użytkownika formularzy systemu Windows, aby wyświetlić kultura, która jest ustawiona w Panelu sterowania.</span><span class="sxs-lookup"><span data-stu-id="4517f-422">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="4517f-423">Wymagany jest dodatkowy kod.</span><span class="sxs-lookup"><span data-stu-id="4517f-423">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4517f-424">Właściwość jest ustawiona na <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-424">The property is set to <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-425">dla ustawienia właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-425">for setting the property.</span>
          </span>
          <span data-ttu-id="4517f-426">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-427">Pobiera lub ustawia bieżący podmiot zabezpieczeń wątku (dla opartej na rolach zabezpieczeń).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-427">Gets or sets the thread's current principal (for role-based security).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-428">
            <see cref="T:System.Security.Principal.IPrincipal" /> Wartość reprezentującą kontekst zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-428">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4517f-429">W poniższym przykładzie kodu przedstawiono sposób ustawiania i pobierania podmiot zabezpieczeń wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-429">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-430">Obiekt wywołujący nie ma uprawnień wymaganych, aby ustawić podmiot zabezpieczeń.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-430">The caller does not have the permission required to set the principal.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-431">do manipulowania obiekt główny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-431">to manipulate the principal object.</span>
          </span>
          <span data-ttu-id="4517f-432">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-432">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-433">Pobiera obecnie uruchomiony wątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-433">Gets the currently running thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-434">A <see cref="T:System.Threading.Thread" /> czyli reprezentację aktualnie uruchomiony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-434">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4517f-435">Poniższy przykład tworzy zadanie, które z kolei tworzy 20 zadania podrzędne.</span><span class="sxs-lookup"><span data-stu-id="4517f-435">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="4517f-436">Aplikacja, jak również każdego zadania wywołuje `ShowThreadInformation` metodę, która używa <xref:System.Threading.Thread.CurrentThread%2A> właściwości, aby wyświetlić informacje o wątku, w którym jest uruchomiona.</span><span class="sxs-lookup"><span data-stu-id="4517f-436">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="4517f-437">Każde zadanie podrzędne generuje 1 milion liczb losowych od 1 do 1 milion i zwraca ich średniej.</span><span class="sxs-lookup"><span data-stu-id="4517f-437">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="4517f-438">Wywołania zadanie nadrzędne <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody, aby upewnić się, że zadania podrzędne zostały ukończone przed wyświetleniem średniej zwrócony przez każdego zadania i obliczenia średniej środków.</span><span class="sxs-lookup"><span data-stu-id="4517f-438">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="4517f-439">Należy pamiętać, że aplikacja działa na pierwszym planie wątku, każde zadanie uruchamia się w wątku puli wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-439">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-440">Pobiera lub ustawia bieżącą kulturę używaną przez Menedżera zasobów do wyszukiwania zasobów określonej kultury w czasie wykonywania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-440">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-441">Obiekt, który reprezentuje bieżącej kultury.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-441">An object that represents the current culture.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-442">Kultura interfejsu użytkownika określa zasoby, aplikacja musi obsługiwać użytkowników w danych wejściowych i wyjściowych i domyślnie jest taka sama jak kultury systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-442">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="4517f-443">Zobacz <xref:System.Globalization.CultureInfo> klasy informacje na temat nazwy kultury i identyfikatory, różnice między niezmiennej neutralne i określonej kultury, a informacje o ustawieniach kulturowych sposób wpływa na wątków i domen aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-443">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="4517f-444">Zobacz <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości, aby dowiedzieć się, jak jest określany przez wątek domyślną kulturę interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="4517f-444">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  
  
 <span data-ttu-id="4517f-445"><xref:System.Globalization.CultureInfo> Zwracane przez tę właściwość można kultury neutralnej.</span><span class="sxs-lookup"><span data-stu-id="4517f-445">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="4517f-446">Neutralne kultury nie powinien być używany z metod formatowania, takich jak <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, i <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-446">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-447">Użyj <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> metodę, aby uzyskać określoną kulturę, lub użyj <xref:System.Threading.Thread.CurrentCulture%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-447">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-448"><xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Metoda zgłasza <xref:System.ArgumentException> neutralne kultury "zh-Hant" ("zh-CHT") i "zh-Hans" ("zh-CHS").</span><span class="sxs-lookup"><span data-stu-id="4517f-448">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-449">Poniższy przykład określa, czy język kultury interfejsu użytkownika bieżącego wątku jest francuski.</span><span class="sxs-lookup"><span data-stu-id="4517f-449">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="4517f-450">Jeśli nie jest, ustawia kulturę interfejsu użytkownika bieżącego wątku język angielski (Stany Zjednoczone).</span><span class="sxs-lookup"><span data-stu-id="4517f-450">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="4517f-451">Poniższy przykład kodu pokazuje wątkowości instrukcji, która umożliwia interfejsu użytkownika formularzy systemu Windows, aby wyświetlić kultura, która jest ustawiona w Panelu sterowania.</span><span class="sxs-lookup"><span data-stu-id="4517f-451">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="4517f-452">Wymagany jest dodatkowy kod.</span><span class="sxs-lookup"><span data-stu-id="4517f-452">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4517f-453">Właściwość jest ustawiona na <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-453">The property is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4517f-454">Właściwość jest ustawiona na nazwę kultury, której nie można użyć do zlokalizowania pliku zasobu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-454">The property is set to a culture name that cannot be used to locate a resource file.</span>
          </span>
          <span data-ttu-id="4517f-455">W nazwach plików zasobów musi zawierać tylko litery, cyfry, łączniki i znaki podkreślenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-455">Resource filenames must include only letters, numbers, hyphens or underscores.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-456">Powoduje wyłączenie automatycznego oczyszczania wywoływane otoki środowiska uruchomieniowego (otoki RCW) dla bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-456">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-457">Domyślnie środowisko uruchomieniowe języka wspólnego (CLR) Czyści wywoływane otoki środowiska uruchomieniowego automatycznie.</span><span class="sxs-lookup"><span data-stu-id="4517f-457">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="4517f-458">Komunikaty pomp CLR podczas oczyszczania, co może spowodować problemy wielobieżność kilka aplikacji, które spełniają następujące kryteria nietypowe:</span><span class="sxs-lookup"><span data-stu-id="4517f-458">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="4517f-459">Aplikacja ma własny przekazywania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="4517f-459">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="4517f-460">Aplikacja musi kontrolować dokładnie podczas przekazywania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="4517f-460">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="4517f-461">Takie aplikacje mogą używać <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> metodę, aby zapobiec czynności wywoływane otoki automatyczne odzyskiwanie danych środowiska uruchomieniowego CLR.</span><span class="sxs-lookup"><span data-stu-id="4517f-461">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="4517f-462">Gdy ta metoda została wywołana dla wątku, automatycznego oczyszczania nie może być ponownie włączone dla tego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-462">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="4517f-463">Gdy aplikacja jest gotowa wyczyścić wywoływane otoki środowiska uruchomieniowego, użyj <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> metody w celu poinstruowania środowiska wykonawczego, aby wyczyścić wszystkie wywoływane otoki środowiska uruchomieniowego w bieżącym kontekście.</span><span class="sxs-lookup"><span data-stu-id="4517f-463">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="4517f-464">Przekazywanie komunikatów wystąpi podczas wykonywania metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-464">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4517f-465">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-465">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4517f-466">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-466">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-467">Powiadamia hosta wykonywania o zbliżającym się podanie kodu, w którym są ograniczone do bieżącego zadania przerwania wątku lub nieobsługiwany wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-467">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-468">Hosty środowisko uruchomieniowe języka wspólnego (CLR), takich jak Microsoft SQL Server 2005, można ustanowić różne zasady dla niepowodzenia w regionach krytyczne i niekrytyczne kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-468">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="4517f-469">Krytyczne region jest jednym w którym przerwania wątku lub nieobsługiwany wyjątek nie mogą być ograniczone do bieżącego zadania.</span><span class="sxs-lookup"><span data-stu-id="4517f-469">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="4517f-470">Z kolei przerwania lub niepowodzenia w regionie niekrytyczne kodu dotyczy tylko zadania, w którym występuje błąd.</span><span class="sxs-lookup"><span data-stu-id="4517f-470">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="4517f-471">Rozważmy na przykład zadanie, które próbuje przydzielić pamięci podczas utrzymywania blokady.</span><span class="sxs-lookup"><span data-stu-id="4517f-471">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="4517f-472">W przypadku niepowodzenia alokacji pamięci przerywanie bieżącego zadania nie jest wystarczająca do zapewnienia stabilności <xref:System.AppDomain>, ponieważ może być inne zadania w domenie oczekiwanie na tym samym blokady.</span><span class="sxs-lookup"><span data-stu-id="4517f-472">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="4517f-473">Jeśli bieżące zadanie jest zakończone, można zakleszczone innych zadań.</span><span class="sxs-lookup"><span data-stu-id="4517f-473">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="4517f-474">Gdy wystąpi awaria w regionie krytycznych, host zdecydować się na zwolnienie całą <xref:System.AppDomain> zamiast zaryzykować i kontynuowanie wykonywania w potencjalnie niestabilnym stanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-474">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="4517f-475">Aby poinformować hosta, że kod jest wprowadzane krytyczne regionu, należy wywołać <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-475">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="4517f-476">Wywołanie <xref:System.Threading.Thread.EndCriticalRegion%2A> podczas wykonywania zwraca niekrytyczne regionu kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-476">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="4517f-477">W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.</span><span class="sxs-lookup"><span data-stu-id="4517f-477">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-478">W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> metody do dzielenia bloku kodu na krytyczne i niekrytyczne regionów.</span><span class="sxs-lookup"><span data-stu-id="4517f-478">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-479">Powiadamia host, na którym kodu zarządzanego zakończył wykonywania instrukcji, które są zależne od tożsamości bieżącego wątku fizycznego systemu operacyjnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-479">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-480">Niektóre hosty środowiska CLR, takich jak Microsoft SQL Server 2005, podać własne zarządzania wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-480">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="4517f-481">Hosta, który dostarcza kierownictwo wątku można przenieść wykonywanie zadania z jednego wątku fizycznego systemu operacyjnego w dowolnym momencie.</span><span class="sxs-lookup"><span data-stu-id="4517f-481">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="4517f-482">Większość zadań nie dotyczy to przełączanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-482">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="4517f-483">Jednak niektóre zadania mają koligacji wątku - oznacza to, że są one zależne od tożsamości wątku fizycznego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-483">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="4517f-484">Te zadania, należy poinformować hosta podczas ich wykonywania kodu, który nie powinien być przełączane.</span><span class="sxs-lookup"><span data-stu-id="4517f-484">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="4517f-485">Na przykład, jeśli zablokować wywołania aplikacji interfejsu API systemu uzyskać systemu operacyjnego, który ma koligacji wątków, takich jak Win32 CRITICAL_SECTION, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskiwanie blokady, i <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnienie blokady.</span><span class="sxs-lookup"><span data-stu-id="4517f-485">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="4517f-486">W kodzie działającą w programie SQL Server 2005 za pomocą tej metody wymaga kodu do uruchomienia na najwyższym poziomie ochrony hosta.</span><span class="sxs-lookup"><span data-stu-id="4517f-486">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-487">W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> i <xref:System.Threading.Thread.EndThreadAffinity%2A> metody powiadomiono hosta, który blok kodu jest zależna od tożsamości wątku fizycznego systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="4517f-487">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-488">Obiekt wywołujący nie posiada wymaganych uprawnień.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-488">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4517f-489">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-489">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4517f-490">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-490">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-491">Pobiera <see cref="T:System.Threading.ExecutionContext" /> obiektu, który zawiera informacje o różnych kontekstach bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-491">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-492">
            <see cref="T:System.Threading.ExecutionContext" /> Obiektu, który konsoliduje informacje o kontekście bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-492">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-493"><xref:System.Threading.ExecutionContext> Klasa udostępnia jeden kontener dla wszystkich informacji dotyczących logicznego wątku wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4517f-493">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="4517f-494">W tym kontekstu zabezpieczeń, kontekst wywołania kontekst synchronizacji, lokalizacja kontekstu i kontekst transakcji.</span><span class="sxs-lookup"><span data-stu-id="4517f-494">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-495">Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <see cref="T:System.Threading.Thread" /> obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-495">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-496">Wywołania modułu zbierającego elementy bezużyteczne <xref:System.Threading.Thread.Finalize%2A> Jeśli bieżący obiekt jest gotowy do przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="4517f-496">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4517f-497">Nazwa miejsca danych ma zostać zwolniony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-497">The name of the data slot to be freed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-498">Eliminuje skojarzenia między nazwą gniazdo, wszystkie wątki tego procesu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-498">Eliminates the association between a name and a slot, for all threads in the process.</span>
          </span>
          <span data-ttu-id="4517f-499">W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-499">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-500">Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-500">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4517f-501">Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-501">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4517f-502">Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-502">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4517f-503">Po żadnego wątku wywołania `FreeNamedDataSlot`, innego wątku, który wywołuje <xref:System.Threading.Thread.GetNamedDataSlot%2A> o takiej samej nazwie przyzna nowe miejsce skojarzone z nazwą.</span><span class="sxs-lookup"><span data-stu-id="4517f-503">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="4517f-504">Kolejne wywołania `GetNamedDataSlot` przez wszystkie wątki zwróci nowego miejsca.</span><span class="sxs-lookup"><span data-stu-id="4517f-504">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="4517f-505">Jednak którymkolwiek wątku nadal mający <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> zwrócony przez wywołanie wcześniejszych `GetNamedDataSlot` można nadal używać starego miejsca.</span><span class="sxs-lookup"><span data-stu-id="4517f-505">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="4517f-506">Zwolnienia miejsca, który został skojarzony z nazwą tylko wtedy, gdy co `LocalDataStoreSlot` uzyskany przed wywołaniem do `FreeNamedDataSlot` został zwolniony i zbierane pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-506">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="4517f-507">Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-507">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4517f-508">Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-508">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4517f-509">Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-509">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4517f-510">Gniazda danych różnią się na wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-510">Data slots are unique per thread.</span></span> <span data-ttu-id="4517f-511">Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-511">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-512">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-512">This section contains two code examples.</span></span> <span data-ttu-id="4517f-513">Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-513">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4517f-514">Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.</span><span class="sxs-lookup"><span data-stu-id="4517f-514">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4517f-515">**Pierwszym przykładzie**</span><span class="sxs-lookup"><span data-stu-id="4517f-515">**First Example**</span></span>  
  
 <span data-ttu-id="4517f-516">Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-516">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4517f-517">Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4517f-517">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4517f-518">**Drugi przykład**</span><span class="sxs-lookup"><span data-stu-id="4517f-518">**Second Example**</span></span>  
  
 <span data-ttu-id="4517f-519">W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-519">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-520">Zwraca <see cref="T:System.Threading.ApartmentState" /> wartość wskazującą stanu apartamentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-520">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-521">Jeden z <see cref="T:System.Threading.ApartmentState" /> wartości, wskazując stanu apartamentu wątku zarządzanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-521">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span>
          </span>
          <span data-ttu-id="4517f-522">Wartość domyślna to <see cref="F:System.Threading.ApartmentState.Unknown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-522">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-523">Ta metoda wraz z <xref:System.Threading.Thread.SetApartmentState%2A> — metoda i <xref:System.Threading.Thread.TrySetApartmentState%2A> zastępuje metodę, <xref:System.Threading.Thread.ApartmentState%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-523">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-524">Poniższy przykład kodu pokazuje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-524">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="4517f-525">Przykład kodu tworzy wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-525">The code example creates a thread.</span></span> <span data-ttu-id="4517f-526">Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-526">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-527"><xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stanu apartamentu jest już ustawiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-527">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="4517f-528">Jeśli tę samą operację miał usiłowano <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> czy zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="4517f-528">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="4517f-529">Po uruchomieniu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> ponownie używana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="4517f-529">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="4517f-530">Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek został już uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-530">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-531">Zwraca <see cref="T:System.Threading.CompressedStack" /> obiektu, który może służyć do przechwytywania stosu dla bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-531">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-532">Brak.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-532">None.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-533">Ta metoda nie jest już obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="4517f-533">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4517f-534">We wszystkich przypadkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-534">In all cases.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4517f-535">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-535">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4517f-536">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-536">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">
          <span data-ttu-id="4517f-537">
            <see cref="T:System.LocalDataStoreSlot" /> z którego ma zostać pobrana wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-537">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-538">Pobiera wartość z określonym miejscu w bieżącym wątku w bieżącej domenie bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-538">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span>
          </span>
          <span data-ttu-id="4517f-539">W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-539">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-540">Pobrana wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-540">The retrieved value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-541">Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-541">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4517f-542">Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-542">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4517f-543">Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-543">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4517f-544">Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-544">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4517f-545">Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-545">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4517f-546">Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-546">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4517f-547">Gniazda danych różnią się na wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-547">Data slots are unique per thread.</span></span> <span data-ttu-id="4517f-548">Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-548">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-549"><xref:System.Threading.Thread.GetData%2A> jest `Shared` metodę, która zawsze ma zastosowanie do aktualnie realizowanej wątku, nawet wtedy, gdy wywołanie za pomocą zmiennej, która odwołuje się do innego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-549"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="4517f-550">Aby uniknąć pomyłek, należy użyć nazwy klasy podczas wywoływania metody `Shared` metody: `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="4517f-550">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-551">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-551">This section contains two code examples.</span></span> <span data-ttu-id="4517f-552">Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-552">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4517f-553">Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.</span><span class="sxs-lookup"><span data-stu-id="4517f-553">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4517f-554">**Pierwszym przykładzie**</span><span class="sxs-lookup"><span data-stu-id="4517f-554">**First Example**</span></span>  
  
 <span data-ttu-id="4517f-555">Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-555">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4517f-556">Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4517f-556">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4517f-557">**Drugi przykład**</span><span class="sxs-lookup"><span data-stu-id="4517f-557">**Second Example**</span></span>  
  
 <span data-ttu-id="4517f-558">W poniższym przykładzie pokazano sposób użycia gniazda danych do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-558">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-559">Zwraca bieżącej domenie, w której bieżący wątek jest uruchomiony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-559">Returns the current domain in which the current thread is running.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-560">
            <see cref="T:System.AppDomain" /> Reprezentujący bieżącej domeny aplikacji uruchomionej wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-560">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4517f-561">W poniższym przykładzie pokazano, jak można pobrać nazwy i Identyfikatora `AppDomain` , w którym wątek jest uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-561">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-562">Zwraca identyfikator domeny aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-562">Returns a unique application domain identifier.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-563">32-bitowe całkowita unikatowo identyfikujący domeny aplikacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-563">A 32-bit signed integer uniquely identifying the application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4517f-564">W poniższym przykładzie pokazano, jak można pobrać nazwy i Identyfikatora `AppDomain` , w którym wątek jest uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-564">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-565">Zwraca wartość skrótu dla bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-565">Returns a hash code for the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-566">Wartość całkowita skrótu kodu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-566">An integer hash code value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-567">Wartość skrótu jest nie musi być unikatowy.</span><span class="sxs-lookup"><span data-stu-id="4517f-567">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="4517f-568">Użyj <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości, jeśli potrzebujesz Unikatowy identyfikator zarządzanego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-568">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4517f-569">Nazwa miejsca danych lokalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-569">The name of the local data slot.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-570">Wyszukuje miejsca danych o podanej nazwie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-570">Looks up a named data slot.</span>
          </span>
          <span data-ttu-id="4517f-571">W celu poprawy wydajności użyj pola, które są oznaczone ikoną z <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-571">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-572">A <see cref="T:System.LocalDataStoreSlot" /> przydzielone dla tego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-572">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-573">Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-573">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4517f-574">Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-574">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4517f-575">Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-575">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4517f-576">Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-576">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4517f-577">Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-577">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4517f-578">Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia, po wygaśnięciu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-578">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="4517f-579">Gniazda danych różnią się na wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-579">Data slots are unique per thread.</span></span> <span data-ttu-id="4517f-580">Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-580">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="4517f-581">Jeśli miejsca o nazwie nie istnieje, nowe miejsce jest przydzielane.</span><span class="sxs-lookup"><span data-stu-id="4517f-581">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="4517f-582">Gniazda danych o nazwie są publiczne i może manipulować dla wszystkich użytkowników.</span><span class="sxs-lookup"><span data-stu-id="4517f-582">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-583">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-583">This section contains two code examples.</span></span> <span data-ttu-id="4517f-584">Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-584">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4517f-585">Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.</span><span class="sxs-lookup"><span data-stu-id="4517f-585">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4517f-586">**Pierwszym przykładzie**</span><span class="sxs-lookup"><span data-stu-id="4517f-586">**First Example**</span></span>  
  
 <span data-ttu-id="4517f-587">Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-587">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4517f-588">Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4517f-588">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4517f-589">**Drugi przykład**</span><span class="sxs-lookup"><span data-stu-id="4517f-589">**Second Example**</span></span>  
  
 <span data-ttu-id="4517f-590">W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-590">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-591">Przerywa wątku, który znajduje się w <see langword="WaitSleepJoin" /> stan wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-591">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-592">Jeśli ten wątek nie jest obecnie zablokowany oczekiwania, stan sprzężenia lub uśpienia, zostanie przerwana, gdy dalej rozpocznie się do blokowania.</span><span class="sxs-lookup"><span data-stu-id="4517f-592">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="4517f-593"><xref:System.Threading.ThreadInterruptedException> jest generowany w przerwanego wątku, ale nie do bloków wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-593"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="4517f-594">Wątek nigdy nie blokuje, nigdy nie wyjątku i w związku z tym wątek może zostać ukończone bez kiedykolwiek przerwane.</span><span class="sxs-lookup"><span data-stu-id="4517f-594">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-595">Poniższy przykład kodu pokazuje zachowanie uruchomiony wątek, gdy zostało przerwane, a następnie zostanie zablokowane.</span><span class="sxs-lookup"><span data-stu-id="4517f-595">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-596">Obiekt wywołujący nie ma odpowiedniej <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-596">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-597">Aby uzyskać zaawansowane operacje w wątkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-597">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="4517f-598">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-598">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-599">Pobiera wartość wskazującą, stan wykonania bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-599">Gets a value indicating the execution status of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-600">
            <see langword="true" /> Jeśli ten wątek został uruchomiony i nie ma zwykle zakończone lub przerwane; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-600">
              <see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-601">Pobiera lub ustawia wartość wskazującą, czy wątek jest wątku w tle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-601">Gets or sets a value indicating whether or not a thread is a background thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-602">
            <see langword="true" /> Jeśli ten wątek jest lub będzie wątku w tle; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-602">
              <see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-603">Wątek jest wątku w tle lub wątku pierwszego planu.</span><span class="sxs-lookup"><span data-stu-id="4517f-603">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="4517f-604">Wątki w tle są identyczne wątki pierwszego planu, z wyjątkiem tego, że wątki w tle uniemożliwia zakończenie procesu.</span><span class="sxs-lookup"><span data-stu-id="4517f-604">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="4517f-605">Po zakończeniu wszystkie wątki pierwszoplanowe należących do procesu, środowisko uruchomieniowe języka wspólnego kończy proces.</span><span class="sxs-lookup"><span data-stu-id="4517f-605">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="4517f-606">Wszystkie pozostałe wątki w tle są zatrzymane i nie zostanie wypełnione.</span><span class="sxs-lookup"><span data-stu-id="4517f-606">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="4517f-607">Domyślnie następujące wątków wykonania na pierwszym planie (to znaczy ich <xref:System.Threading.Thread.IsBackground%2A> zwraca `false`):</span><span class="sxs-lookup"><span data-stu-id="4517f-607">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="4517f-608">Podstawowy wątku (lub wątku głównego aplikacji).</span><span class="sxs-lookup"><span data-stu-id="4517f-608">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="4517f-609">Wszystkie wątki utworzona przez wywołanie metody <xref:System.Threading.Thread> konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="4517f-609">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="4517f-610">Domyślnie następujące wątków wykonywania w tle (to znaczy ich <xref:System.Threading.Thread.IsBackground%2A> zwraca `true`):</span><span class="sxs-lookup"><span data-stu-id="4517f-610">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="4517f-611">Wątków z puli wątków, które są puli wątków roboczych obsługiwane przez środowisko uruchomieniowe.</span><span class="sxs-lookup"><span data-stu-id="4517f-611">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="4517f-612">Wątek puli i harmonogram pracy można skonfigurować na wątków z puli wątków, przy użyciu <xref:System.Threading.ThreadPool> klasy.</span><span class="sxs-lookup"><span data-stu-id="4517f-612">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4517f-613">Oparty na zadaniach asynchronicznej operacji automatycznie wykonywane na wątków z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-613">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="4517f-614">Wszystkie wątki, które wprowadź zarządzanego środowiska wykonawczego z kodem niezarządzanym.</span><span class="sxs-lookup"><span data-stu-id="4517f-614">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-615">Poniższy przykład różni się znacząco zachowanie wątki pierwszego planu i tła.</span><span class="sxs-lookup"><span data-stu-id="4517f-615">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="4517f-616">Tworzy wątku pierwszego planu i wątku w tle.</span><span class="sxs-lookup"><span data-stu-id="4517f-616">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="4517f-617">Wątek pierwszego planu śledzi proces uruchomiony, dopóki nie ukończy jego `for` pętli i kończy.</span><span class="sxs-lookup"><span data-stu-id="4517f-617">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="4517f-618">Jednakże jak dane wyjściowe w przykładzie pokazano, ponieważ wątek pierwszego planu zakończył wykonanie, proces jest zakończony przed wątku w tle zakończy działanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-618">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-619">Wątek jest martwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-619">The thread is dead.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-620">Pobiera wartość wskazującą, czy wątek należy do puli wątków zarządzanych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-620">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-621">
            <see langword="true" /> Jeśli ten wątek należy do puli wątków zarządzanych; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-621">
              <see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-622">Aby uzyskać więcej informacji, zobacz [wątku Pula zarządzana](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-622">For more information see [The Managed Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-623">Poniższy przykład kodu pokazuje sposób określania, czy wątek jest z puli wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-623">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-624">Wątek wywołujący blokuje, aż do zakończenia wątku reprezentowanym przez to wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-624">Blocks the calling thread until the thread represented by this instance terminates.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-625">Wątek wywołujący blokuje, aż do zakończenia wątku reprezentowanym przez to wystąpienie, pozostawiając do wykonywania standardowych COM i <see langword="SendMessage" /> przekazywania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-625">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-626"><xref:System.Threading.Thread.Join%2A> jest to metoda synchronizacji, która blokuje wątku wywołującym (to znaczy wątku, który wywołuje metodę), aż do wątku którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została ukończona.</span><span class="sxs-lookup"><span data-stu-id="4517f-626"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="4517f-627">Użyj tej metody, aby upewnić się, że wątek został zakończony.</span><span class="sxs-lookup"><span data-stu-id="4517f-627">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="4517f-628">Wątek nie zakończy wywołującego zablokują przez nieograniczony czas.</span><span class="sxs-lookup"><span data-stu-id="4517f-628">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="4517f-629">W poniższym przykładzie `Thread1` wątku wywołania <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` blok do `Thread2` zostało ukończone.</span><span class="sxs-lookup"><span data-stu-id="4517f-629">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="4517f-630">Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="4517f-630">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="4517f-631">Nigdy nie powinien wywoływać <xref:System.Threading.Thread.Join%2A> metody <xref:System.Threading.Thread> obiekt, który reprezentuje bieżący wątek z bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-631">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="4517f-632">Powoduje to, że aplikacja zawieszenie, ponieważ bieżący wątek oczekuje od samego siebie</span><span class="sxs-lookup"><span data-stu-id="4517f-632">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="4517f-633">Ta metoda zmieni stan wątku uwzględnienie <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-633">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-634">Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.</span><span class="sxs-lookup"><span data-stu-id="4517f-634">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-635">Obiekt wywołujący próbował przyłączyć wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-635">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="4517f-636">Wątek jest przerwane podczas oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-636">The thread is interrupted while waiting.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="4517f-637">Wyrażony w milisekundach czas oczekiwania na zakończenie wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-637">The number of milliseconds to wait for the thread to terminate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-638">Wątek wywołujący aż do zakończenia wątku reprezentowanym przez to wystąpienie lub określonego czasu upłynie, pozostawiając do wykonywania standardowych COM i SendMessage przekazywanie bloków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-638">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-639">
            <see langword="true" /> Jeśli wątek został zakończony; <see langword="false" /> Jeśli wątek nie został zakończony po upływie czasu określonego przez <paramref name="millisecondsTimeout" /> parametru upłynął.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-639">
              <see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-640"><xref:System.Threading.Thread.Join%28System.Int32%29> to metoda synchronizacji, która blokuje wątku wywołującym (to znaczy wątku, który wywołuje metodę) do wątku albo którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została ukończona lub upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="4517f-640"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="4517f-641">W poniższym przykładzie `Thread1` wątku wywołania <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` blokowanie bądź do `Thread2` została ukończona lub upłynęły 2 sekundy.</span><span class="sxs-lookup"><span data-stu-id="4517f-641">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="4517f-642">Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> określono `millisecondsTimeout` parametru, ta metoda działa identycznie do <xref:System.Threading.Thread.Join> przeciążenie metody, z wyjątkiem wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="4517f-642">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="4517f-643">Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="4517f-643">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="4517f-644">Ta metoda zmieni stan wątku uwzględnienie <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-644">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-645">Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.</span><span class="sxs-lookup"><span data-stu-id="4517f-645">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4517f-646">Wartość <paramref name="millisecondsTimeout" /> jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> w milisekundach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-646">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-647">Wątek nie został uruchomiony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-647">The thread has not been started.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="4517f-648">A <see cref="T:System.TimeSpan" /> ustawioną ilość czasu oczekiwania na zakończenie wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-648">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-649">Wątek wywołujący aż do zakończenia wątku reprezentowanym przez to wystąpienie lub określonego czasu upłynie, pozostawiając do wykonywania standardowych COM i SendMessage przekazywanie bloków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-649">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-650">
            <see langword="true" /> Jeśli wątek zakończony; <see langword="false" /> Jeśli wątek nie został zakończony po upływie czasu określonego przez <paramref name="timeout" /> parametru upłynął.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-650">
              <see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-651"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> to metoda synchronizacji, która blokuje wątku wywołującym (to znaczy wątku, który wywołuje metodę) do wątku albo którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została ukończona lub upłynął limit czasu.</span><span class="sxs-lookup"><span data-stu-id="4517f-651"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="4517f-652">W poniższym przykładzie `Thread1` wątku wywołania <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` blokowanie bądź do `Thread2` została ukończona lub upłynęły 2 sekundy.</span><span class="sxs-lookup"><span data-stu-id="4517f-652">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="4517f-653">Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> określono `timeout`, ta metoda zachowuje się tak samo <xref:System.Threading.Thread.Join> przeciążenie metody, z wyjątkiem wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="4517f-653">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="4517f-654">Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="4517f-654">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="4517f-655">Ta metoda zmieni stan bieżący wątek, aby uwzględnić <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="4517f-655">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="4517f-656">Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.</span><span class="sxs-lookup"><span data-stu-id="4517f-656">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-657">Poniższy przykład kodu pokazuje sposób użycia `TimeSpan` wartości z `Join` metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-657">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4517f-658">Wartość <paramref name="timeout" /> jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (w milisekundach), albo jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-658">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-659">Obiekt wywołujący próbował przyłączyć wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-659">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-660">Pobiera unikatowy identyfikator bieżącego wątku zarządzanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-660">Gets a unique identifier for the current managed thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-661">Liczba całkowita, która reprezentuje unikatowy identyfikator dla tego wątku zarządzanego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-661">An integer that represents a unique identifier for this managed thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-662">Wątek <xref:System.Threading.Thread.ManagedThreadId%2A> wartość właściwości służy do jednoznacznej identyfikacji tego wątku w procesie.</span><span class="sxs-lookup"><span data-stu-id="4517f-662">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="4517f-663">Wartość <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości nie zmienia się wraz z upływem czasu, nawet jeśli kodu niezarządzanego, który obsługuje środowisko uruchomieniowe języka wspólnego implementuje wątku, co włókien.</span><span class="sxs-lookup"><span data-stu-id="4517f-663">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-664">Synchronizuje dostęp do pamięci w następujący sposób: procesor wykonywania bieżącego wątku nie można zmienić kolejności instrukcje w taki sposób, że pamięć uzyskuje dostęp do przed wywołaniem do <see cref="M:System.Threading.Thread.MemoryBarrier" /> wykonanie uzyskuje dostęp do pamięci, które należy wykonać wywołanie <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-664">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-665"><xref:System.Threading.Thread.MemoryBarrier%2A> jest wymagany tylko w systemach wieloprocesorowych słabe pamięci porządkowanie (na przykład system, w których zastosowano wiele procesorów Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="4517f-665"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="4517f-666">W większości przypadków, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji lub <xref:System.Threading.Monitor> klasy umożliwiają łatwiejsze do synchronizacji danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-666">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-667">Pobiera lub ustawia nazwę wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-667">Gets or sets the name of the thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-668">Ciąg zawierający nazwę wątku, lub <see langword="null" /> , jeśli nie została podana nazwa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-668">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-669">Ta właściwość jest zapisu — po.</span><span class="sxs-lookup"><span data-stu-id="4517f-669">This property is write-once.</span></span> <span data-ttu-id="4517f-670">Ponieważ wartość domyślną dla wątku <xref:System.Threading.Thread.Name%2A> właściwość jest `null`, można określić, czy nazwa już jawnie przypisany do wątku porównując go z `null`.</span><span class="sxs-lookup"><span data-stu-id="4517f-670">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="4517f-671">Ciąg znaków przypisany do <xref:System.Threading.Thread.Name%2A> właściwości może zawierać znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="4517f-671">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-672">Poniższy przykład przedstawia nazwę wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-672">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4517f-673">Zażądano operacji set, ale <see langword="Name" /> właściwość została już ustawiona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-673">A set operation was requested, but the <see langword="Name" /> property has already been set.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-674">Pobiera lub ustawia wartość określającą priorytet wątku w harmonogramie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-674">Gets or sets a value indicating the scheduling priority of a thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-675">Jeden z <see cref="T:System.Threading.ThreadPriority" /> wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-675">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span>
          </span>
          <span data-ttu-id="4517f-676">Wartość domyślna to <see cref="F:System.Threading.ThreadPriority.Normal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-676">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-677">Wątek można przypisać jeden z następujących priorytet <xref:System.Threading.ThreadPriority> wartości:</span><span class="sxs-lookup"><span data-stu-id="4517f-677">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="4517f-678">Systemy operacyjne nie muszą przestrzegać priorytetu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-678">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-679">Poniższy przykład przedstawia wynik zmiana priorytetu wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-679">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="4517f-680">Trzy wątki są tworzone, ma ustawioną wartość priorytetu jeden wątek <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, i ma ustawioną wartość priorytetu sekundy <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-680">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-681">Każdy wątek zwiększa zmiennej w `while` pętli i działa na określony czas.</span><span class="sxs-lookup"><span data-stu-id="4517f-681">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-682">Wątek osiągnął stanu końcowego, takie jak <see cref="F:System.Threading.ThreadState.Aborted" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-682">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4517f-683">Wartość określona dla operacji set nie jest prawidłową <see cref="T:System.Threading.ThreadPriority" /> wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-683">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-684">Anuluje <see cref="M:System.Threading.Thread.Abort(System.Object)" /> żądanie dla bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-684">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-685">Tę metodę można wywołać tylko przez kod z odpowiednimi uprawnieniami.</span><span class="sxs-lookup"><span data-stu-id="4517f-685">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="4517f-686">Gdy połączenie jest nawiązywane w przypadku `Abort` zakończenie wątku, system generuje <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="4517f-686">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="4517f-687">`ThreadAbortException` specjalne wyjątek, który może być przechwycony przez kod aplikacji, ale zgłoszony na końcu bloku catch, chyba że jest `ResetAbort` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="4517f-687">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="4517f-688">`ResetAbort` anuluje żądanie do przerwania, a także zapobiega `ThreadAbortException` z przerywanie wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-688">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="4517f-689">Zobacz <xref:System.Threading.ThreadAbortException> przykład przedstawiający wywołania `ResetAbort` metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-689">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="4517f-690">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-690">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-691">
            <see langword="Abort" /> nie została wywołana w bieżącym wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-691">
              <see langword="Abort" /> was not invoked on the current thread.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-692">Obiekt wywołujący nie ma wymaganych uprawnień zabezpieczeń dla bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-692">The caller does not have the required security permission for the current thread.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-693">Aby uzyskać zaawansowane operacje w wątkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-693">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="4517f-694">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-694">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-695">Wznawia wątku, który został wstrzymany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-695">Resumes a thread that has been suspended.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="4517f-696">Nie używaj <xref:System.Threading.Thread.Suspend%2A> i <xref:System.Threading.Thread.Resume%2A> metodami synchronizacji działania wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-696">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="4517f-697">Nie ma możliwości wiedzy, jaki kod w wątku jest wykonywany po jego wstrzymaniu.</span><span class="sxs-lookup"><span data-stu-id="4517f-697">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="4517f-698">Jeśli zawieszenia wątku, gdy posiada blokady podczas sprawdzania uprawnień zabezpieczeń, inne wątki we <xref:System.AppDomain> może zostać zablokowany.</span><span class="sxs-lookup"><span data-stu-id="4517f-698">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="4517f-699">Jeśli podczas wykonywania konstruktora klasy zawieszenia się wątku, inne wątki we <xref:System.AppDomain> który próba użycia, że klasa są blokowane.</span><span class="sxs-lookup"><span data-stu-id="4517f-699">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="4517f-700">Zakleszczenie może występować bardzo łatwe.</span><span class="sxs-lookup"><span data-stu-id="4517f-700">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="4517f-701">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-701">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-702">Wątek nie został uruchomiony, jest martwy lub nie jest w stanie wstrzymania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-702">The thread has not been started, is dead, or is not in the suspended state.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-703">Obiekt wywołujący nie ma odpowiedniej <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-703">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-704">Aby uzyskać zaawansowane operacje w wątkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-704">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="4517f-705">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-705">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="4517f-706">Nowy stan apartamentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-706">The new apartment state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-707">Ustawia stan apartamentu wątku przed jej uruchomieniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-707">Sets the apartment state of a thread before it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-708">Nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stanu apartamentu nie została ustawiona, zanim zostaną uruchomione.</span><span class="sxs-lookup"><span data-stu-id="4517f-708">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="4517f-709">Stanem apartamentu musi być ustawiona przed uruchomieniem wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-709">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-710">Zainicjowano wątku głównego aplikacji do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie.</span><span class="sxs-lookup"><span data-stu-id="4517f-710">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="4517f-711">Jedynym sposobem stanu apartamentu wątku głównego aplikacji, aby <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> stosuje się <xref:System.STAThreadAttribute> atrybutu metoda punktu wejścia.</span><span class="sxs-lookup"><span data-stu-id="4517f-711">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="4517f-712"><xref:System.Threading.Thread.SetApartmentState%2A> Metody, wraz z <xref:System.Threading.Thread.GetApartmentState%2A> — metoda i <xref:System.Threading.Thread.TrySetApartmentState%2A> zastępuje metodę, <xref:System.Threading.Thread.ApartmentState%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-712">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-713">Poniższy przykład kodu pokazuje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-713">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="4517f-714">Przykład kodu tworzy wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-714">The code example creates a thread.</span></span> <span data-ttu-id="4517f-715">Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-715">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-716"><xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stanu apartamentu jest już ustawiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-716">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="4517f-717">Jeśli tę samą operację miał usiłowano <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> czy zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="4517f-717">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="4517f-718">Po uruchomieniu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> ponownie używana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="4517f-718">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="4517f-719">Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek został już uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-719">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="4517f-720">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwana w macOS i platformy Linux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-720">.NET Core only: This member is not supported on the macOS and Linux platforms.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4517f-721">
            <paramref name="state" /> nie jest stanu apartamentu prawidłowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-721">
              <paramref name="state" /> is not a valid apartment state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-722">Wątek została już uruchomiona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-722">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4517f-723">Stanem apartamentu został już zainicjowany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-723">The apartment state has already been initialized.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">
          <span data-ttu-id="4517f-724">
            <see cref="T:System.Threading.CompressedStack" /> Obiekt ma zostać zastosowany do bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-724">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-725">Stosuje przechwyconych <see cref="T:System.Threading.CompressedStack" /> do bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-725">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-726">Ta metoda nie jest już obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="4517f-726">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4517f-727">We wszystkich przypadkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-727">In all cases.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4517f-728">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-728">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4517f-729">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-729">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">
          <span data-ttu-id="4517f-730">
            <see cref="T:System.LocalDataStoreSlot" /> w którym można ustawić wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-730">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="4517f-731">Wartość do ustawienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-731">The value to be set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-732">Ustawia dane w określonym miejscu na aktualnie uruchomionych wątków, dla tego wątku bieżącej domeny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-732">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span>
          </span>
          <span data-ttu-id="4517f-733">W celu poprawy wydajności użyj pola oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-733">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-734">Platforma .NET Framework zapewnia dwa mechanizmy przy użyciu lokalny magazyn wątków (TLS): powiązane z wątkiem pola statyczne (to znaczy pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute> atrybut) i gniazda danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-734">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="4517f-735">Względne wątkom pola statyczne znacznie poprawi wydajność gniazda danych, a następnie Włącz sprawdzanie typów w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-735">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="4517f-736">Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [magazynu lokalnego wątku: powiązane z wątkiem pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-736">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="4517f-737">Wątki korzysta z mechanizmu pamięci lokalnego magazynu do przechowywania danych właściwych dla wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-737">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="4517f-738">Środowisko uruchomieniowe języka wspólnego przydziela tablicą magazynu danych z wieloma do każdego procesu podczas jego tworzenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-738">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="4517f-739">Wątek można przydzielić miejsca danych w magazynie danych, magazynu i pobierania danych wartość w miejscu, a wolne miejsce do ponownego użycia od zakończenia procedury wątku i <xref:System.Threading.Thread> obiekt ma zostać odzyskana przez wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="4517f-739">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="4517f-740">Gniazda danych różnią się na wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-740">Data slots are unique per thread.</span></span> <span data-ttu-id="4517f-741">Nie inne wątku (nawet wątku podrzędnego) można uzyskać danych.</span><span class="sxs-lookup"><span data-stu-id="4517f-741">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-742"><xref:System.Threading.Thread.SetData%2A> jest `Shared` metodę, która zawsze ma zastosowanie do aktualnie realizowanej wątku, nawet wtedy, gdy wywołanie za pomocą zmiennej, która odwołuje się do innego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-742"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="4517f-743">Aby uniknąć pomyłek, należy użyć nazwy klasy podczas wywoływania metody `Shared` metody: `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="4517f-743">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-744">Ten rozdział zawiera dwa przykłady kodu.</span><span class="sxs-lookup"><span data-stu-id="4517f-744">This section contains two code examples.</span></span> <span data-ttu-id="4517f-745">Pierwszym przykładzie przedstawiono sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> atrybut do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-745">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="4517f-746">Drugi przykład przedstawia użycie gniazda danych, aby zrobić to samo.</span><span class="sxs-lookup"><span data-stu-id="4517f-746">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="4517f-747">**Pierwszym przykładzie**</span><span class="sxs-lookup"><span data-stu-id="4517f-747">**First Example**</span></span>  
  
 <span data-ttu-id="4517f-748">Poniższy przykład przedstawia sposób użycia pola oznaczone <xref:System.ThreadStaticAttribute> do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-748">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="4517f-749">Ta metoda zapewnia lepszą wydajność niż technika, który jest wyświetlany w drugim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4517f-749">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="4517f-750">**Drugi przykład**</span><span class="sxs-lookup"><span data-stu-id="4517f-750">**Second Example**</span></span>  
  
 <span data-ttu-id="4517f-751">W poniższym przykładzie pokazano sposób użycia miejsca o nazwie danych do przechowywania informacji na temat określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-751">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-752">Wstrzymuje bieżącego wątku dla określonego przedziału czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-752">Suspends the current thread for the specified amount of time.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="4517f-753">Liczba milisekund, dla których wątek jest zawieszony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-753">The number of milliseconds for which the thread is suspended.</span>
          </span>
          <span data-ttu-id="4517f-754">Jeśli wartość <c>millisecondsTimeout</c> argumentów wynosi zero, wątek zwalnia pozostałej części jej przedział czasu do dowolnego wątku taki sam priorytet, który jest gotowy do uruchomienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-754">If the value of the <c>millisecondsTimeout</c> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span>
          </span>
          <span data-ttu-id="4517f-755">Jeśli nie ma nie ma innych wątków o priorytecie, które są gotowe do uruchomienia, wykonanie bieżący wątek nie został wstrzymany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-755">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-756">Wstrzymuje bieżącego wątku dla określoną liczbę milisekund.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-756">Suspends the current thread for the specified number of milliseconds.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-757">Wątek nie będzie można zaplanowane do uruchomienia przez system operacyjny przez czas określony.</span><span class="sxs-lookup"><span data-stu-id="4517f-757">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="4517f-758">Ta metoda zmieni stan wątku w celu uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="4517f-758">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="4517f-759">Można określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> dla `millisecondsTimeout` parametru nieograniczony czas wstrzymania wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-759">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="4517f-760">Jednak zalecane jest użycie innych <xref:System.Threading?displayProperty=nameWithType> klas takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, lub <xref:System.Threading.Semaphore> zamiast wątków sychronize lub zarządzania zasobami.</span><span class="sxs-lookup"><span data-stu-id="4517f-760">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="4517f-761">Takty zegara systemu z określoną szybkością nazywany rozpoznawaniem zegara.</span><span class="sxs-lookup"><span data-stu-id="4517f-761">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="4517f-762">Limit czasu rzeczywistego może nie być dokładnie określony limit czasu, ponieważ określony limit czasu zostanie dostosowana do pokrywa się z Takty zegara.</span><span class="sxs-lookup"><span data-stu-id="4517f-762">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="4517f-763">Aby uzyskać więcej informacji na rozdzielczość zegara i czas oczekiwania, zobacz [uśpienia funkcja](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tematu.</span><span class="sxs-lookup"><span data-stu-id="4517f-763">For more information on clock resolution and the waiting time, see the [Sleep function](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="4517f-764">Ta metoda wywołuje [uśpienia funkcja](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) z interfejsów API systemu Windows.</span><span class="sxs-lookup"><span data-stu-id="4517f-764">This method calls the [Sleep function](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="4517f-765">Ta metoda nie przeprowadza standardowe COM i SendMessage przekazywania.</span><span class="sxs-lookup"><span data-stu-id="4517f-765">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-766">Jeśli musisz uśpienia w wątku, który ma <xref:System.STAThreadAttribute>, ale chcesz wykonać standard COM i SendMessage przekazywania, należy wziąć pod uwagę przy użyciu jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metodę, która określa wartość limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="4517f-766">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-767">W poniższym przykładzie użyto <xref:System.Threading.Thread.Sleep%2A> metodę, aby zablokować wątku głównego aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-767">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4517f-768">Wartość limitu czasu ma ujemną wartość i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-768">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="4517f-769">Ilość czasu, dla którego wątek jest zawieszony.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-769">The amount of time for which the thread is suspended.</span>
          </span>
          <span data-ttu-id="4517f-770">Jeśli wartość <c>millisecondsTimeout</c> argument jest <see cref="F:System.TimeSpan.Zero" />, wątek zwalnia pozostałej części jej przedział czasu do dowolnego wątku taki sam priorytet, który jest gotowy do uruchomienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-770">If the value of the <c>millisecondsTimeout</c> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span>
          </span>
          <span data-ttu-id="4517f-771">Jeśli nie ma nie ma innych wątków o priorytecie, które są gotowe do uruchomienia, wykonanie bieżący wątek nie został wstrzymany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-771">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-772">Wstrzymuje bieżącego wątku dla określonego przedziału czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-772">Suspends the current thread for the specified amount of time.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-773">Wątek nie będzie można zaplanowane do uruchomienia przez system operacyjny przez czas określony.</span><span class="sxs-lookup"><span data-stu-id="4517f-773">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="4517f-774">Ta metoda zmieni stan wątku w celu uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="4517f-774">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="4517f-775">Można określić <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> dla `timeout` parametru nieograniczony czas wstrzymania wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-775">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="4517f-776">Jednak zalecane jest użycie innych <xref:System.Threading?displayProperty=nameWithType> klas takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, lub <xref:System.Threading.Semaphore> zamiast wątków sychronize lub zarządzania zasobami.</span><span class="sxs-lookup"><span data-stu-id="4517f-776">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="4517f-777">To przeciążenie metody <xref:System.Threading.Thread.Sleep%2A> użyje całkowitej liczby pełnych milisekund w `timeout`.</span><span class="sxs-lookup"><span data-stu-id="4517f-777">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="4517f-778">Ułamkowych milisekund zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="4517f-778">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="4517f-779">Ta metoda nie przeprowadza standardowe COM i SendMessage przekazywania.</span><span class="sxs-lookup"><span data-stu-id="4517f-779">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-780">Jeśli musisz uśpienia w wątku, który ma <xref:System.STAThreadAttribute>, ale chcesz wykonać standard COM i SendMessage przekazywania, należy wziąć pod uwagę przy użyciu jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metodę, która określa wartość limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="4517f-780">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-781">W poniższym przykładzie użyto <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> przeciążenie metody, aby zablokować wątku głównego aplikacji pięć razy dla dwóch sekund.</span><span class="sxs-lookup"><span data-stu-id="4517f-781">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4517f-782">Wartość <paramref name="timeout" /> jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (w milisekundach), albo jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-782">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">
          <span data-ttu-id="4517f-783">32-bitowe całkowita definiująca, ile wątek jest oczekiwania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-783">A 32-bit signed integer that defines how long a thread is to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-784">Powoduje, że wątek oczekuje liczba zdefiniowanych przez <paramref name="iterations" /> parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-784">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-785"><xref:System.Threading.Thread.SpinWait%2A> Metoda jest przydatna do implementacji blokad.</span><span class="sxs-lookup"><span data-stu-id="4517f-785">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="4517f-786">Klas w programie .NET Framework, takich jak <xref:System.Threading.Monitor> i <xref:System.Threading.ReaderWriterLock>, korzystanie z tej metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-786">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="4517f-787"><xref:System.Threading.Thread.SpinWait%2A> zasadniczo umieszcza procesor z licznikiem pętli określony przez pętlę bardzo ścisłej `iterations` parametru.</span><span class="sxs-lookup"><span data-stu-id="4517f-787"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="4517f-788">Czas trwania czas oczekiwania w związku z tym zależy od szybkości procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-788">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="4517f-789">Natomiast to z <xref:System.Threading.Thread.Sleep%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-789">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="4517f-790">Wątek, który wywołuje <xref:System.Threading.Thread.Sleep%2A> daje z resztą jego bieżący fragment czasu procesora, nawet jeśli w określonym przedziale czasu wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="4517f-790">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="4517f-791">Określanie niezerowy interwał <xref:System.Threading.Thread.Sleep%2A> usuwa wątek brany pod uwagę przez wątek harmonogram przedział czasu przed upływem.</span><span class="sxs-lookup"><span data-stu-id="4517f-791">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="4517f-792"><xref:System.Threading.Thread.SpinWait%2A> nie jest zazwyczaj przydatne w przypadku zwykłej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-792"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="4517f-793">W większości przypadków należy używać klas synchronizacji podał .NET Framework; na przykład wywołać <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> lub instrukcję, która opakowuje <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` w języku C# lub `SyncLock` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4517f-793">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4517f-794">W rzadkich przypadkach, w których jest korzystne w celu uniknięcia przełączenie kontekstu, np. gdy wiesz, czy zmiany stanu jest bliska, wywoływania <xref:System.Threading.Thread.SpinWait%2A> metody w Twojej pętli.</span><span class="sxs-lookup"><span data-stu-id="4517f-794">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="4517f-795">Kod <xref:System.Threading.Thread.SpinWait%2A> wykonuje pozwala uniknąć problemów, które mogą wystąpić na komputerach z wieloma procesorami.</span><span class="sxs-lookup"><span data-stu-id="4517f-795">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="4517f-796">Na przykład na komputerach z wielu procesorów Intel wykorzystujące technologię Hyper-Threading <xref:System.Threading.Thread.SpinWait%2A> uniemożliwia zablokowania procesora w pewnych sytuacjach.</span><span class="sxs-lookup"><span data-stu-id="4517f-796">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-797">Powoduje, że zaplanowane wykonanie wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-797">Causes a thread to be scheduled for execution.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-798">Powoduje, że system operacyjny zmiany stanu do bieżącego wystąpienia <see cref="F:System.Threading.ThreadState.Running" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-798">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-799">Gdy wątek jest w <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stan systemu operacyjnego można zaplanować na wykonanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-799">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="4517f-800">Wątek rozpoczyna wykonywanie na pierwszy wiersz metodę reprezentowaną przez <xref:System.Threading.ThreadStart> lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-800">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="4517f-801">Należy pamiętać, że wywołanie <xref:System.Threading.Thread.Start%2A> wątek wywołujący nie są blokowane.</span><span class="sxs-lookup"><span data-stu-id="4517f-801">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-802">Jeśli to przeciążenie jest używany z wątkiem utworzone za pomocą <xref:System.Threading.ParameterizedThreadStart> delegować, `null` jest przekazywany do metody wykonywane przez wątek.</span><span class="sxs-lookup"><span data-stu-id="4517f-802">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="4517f-803">Gdy zakończenie wątku, go nie można uruchomić ponownie z innym wywołaniu `Start`.</span><span class="sxs-lookup"><span data-stu-id="4517f-803">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-804">Poniższy przykład utworzenie i uruchomienie wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-804">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-805">Wątek została już uruchomiona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-805">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="4517f-806">Nie ma wystarczającej ilości pamięci do uruchomienia tego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-806">There is not enough memory available to start this thread.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="4517f-807">Obiekt zawierający dane, które mają być używane przez metodę wykonuje wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-807">An object that contains data to be used by the method the thread executes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-808">Powoduje, że system operacyjny zmiany stanu do bieżącego wystąpienia <see cref="F:System.Threading.ThreadState.Running" />i opcjonalnie dostarcza obiekt zawierający dane mają być używane przez metodę wykonuje wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-808">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-809">Gdy wątek jest w <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stan systemu operacyjnego można zaplanować na wykonanie.</span><span class="sxs-lookup"><span data-stu-id="4517f-809">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="4517f-810">Wątek rozpoczyna wykonywanie na pierwszy wiersz metodę reprezentowaną przez <xref:System.Threading.ThreadStart> lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-810">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="4517f-811">Należy pamiętać, że wywołanie <xref:System.Threading.Thread.Start%2A> wątek wywołujący nie są blokowane.</span><span class="sxs-lookup"><span data-stu-id="4517f-811">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="4517f-812">Gdy zakończenie wątku, go nie można uruchomić ponownie z innym wywołaniu `Start`.</span><span class="sxs-lookup"><span data-stu-id="4517f-812">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="4517f-813">To przeciążenie i <xref:System.Threading.ParameterizedThreadStart> delegata ułatwiają przekazywanie danych do procedury wątku, ale technika nie jest typem bezpieczne, ponieważ każdy obiekt mogą zostać przekazane do tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-813">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="4517f-814">Bardziej niezawodna sposobem przekazywania danych do procedury wątku jest poddane zarówno procedury wątku i pola danych z obiektu procesu roboczego.</span><span class="sxs-lookup"><span data-stu-id="4517f-814">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="4517f-815">Aby uzyskać więcej informacji, zobacz [Tworzenie wątków i przekazywanie danych w chwili uruchomienia](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="4517f-815">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-816">Poniższy przykład tworzy <xref:System.Threading.ParameterizedThreadStart> delegata z metody statycznej i metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4517f-816">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-817">Wątek została już uruchomiona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-817">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="4517f-818">Nie ma wystarczającej ilości pamięci do uruchomienia tego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-818">There is not enough memory available to start this thread.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4517f-819">Ten wątek został utworzony przy użyciu <see cref="T:System.Threading.ThreadStart" /> delegować zamiast <see cref="T:System.Threading.ParameterizedThreadStart" /> delegowanie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-819">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-820">Wstrzymuje wątek albo jeśli wątek jest już wstrzymana, nie ma znaczenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-820">Either suspends the thread, or if the thread is already suspended, has no effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-821">Jeśli wątek jest już wstrzymana, ta metoda nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="4517f-821">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4517f-822">Nie używaj <xref:System.Threading.Thread.Suspend%2A> i <xref:System.Threading.Thread.Resume%2A> metodami synchronizacji działania wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-822">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="4517f-823">Nie ma możliwości wiedzy, jaki kod w wątku jest wykonywany po jego wstrzymaniu.</span><span class="sxs-lookup"><span data-stu-id="4517f-823">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="4517f-824">Jeśli zawieszenia wątku, gdy posiada blokady podczas sprawdzania uprawnień zabezpieczeń, inne wątki we <xref:System.AppDomain> może zostać zablokowany.</span><span class="sxs-lookup"><span data-stu-id="4517f-824">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="4517f-825">Jeśli podczas wykonywania konstruktora klasy zawieszenia się wątku, inne wątki we <xref:System.AppDomain> który próba użycia, że klasa są blokowane.</span><span class="sxs-lookup"><span data-stu-id="4517f-825">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="4517f-826">Zakleszczenie może występować bardzo łatwe.</span><span class="sxs-lookup"><span data-stu-id="4517f-826">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="4517f-827">Oprogramowanie .NET core: ten element członkowski nie jest obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-827">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-828">Wątek nie został uruchomiony lub jest martwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-828">The thread has not been started or is dead.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="4517f-829">Obiekt wywołujący nie ma odpowiedniej <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-829">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4517f-830">Aby uzyskać zaawansowane operacje w wątkach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-830">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="4517f-831">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-831">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="4517f-832">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-832">Reserved for future use.</span>
          </span>
          <span data-ttu-id="4517f-833">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-833">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="4517f-834">Przekazana tablica nazw ma być mapowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-834">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="4517f-835">Liczba nazw, które mają być mapowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-835">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="4517f-836">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-836">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="4517f-837">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-837">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-838">Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-838">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-839">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="4517f-839">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4517f-840">Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="4517f-840">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4517f-841">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-841">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="4517f-842">Informacje o typie, który będzie zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-842">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="4517f-843">Identyfikator regionalny dla informacji o typie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-843">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="4517f-844">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-844">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-845">Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-845">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-846">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="4517f-846">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4517f-847">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="4517f-847">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4517f-848">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-848">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="4517f-849">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-849">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-850">Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-850">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-851">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="4517f-851">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4517f-852">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="4517f-852">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4517f-853">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-853">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="4517f-854">Określa element członkowski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-854">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="4517f-855">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-855">Reserved for future use.</span>
          </span>
          <span data-ttu-id="4517f-856">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-856">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="4517f-857">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-857">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="4517f-858">Flagi opisujące kontekst wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-858">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="4517f-859">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-859">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="4517f-860">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-860">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="4517f-861">Wskaźnik do struktury, która zawiera informacje o wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-861">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="4517f-862">Indeks pierwszego argumentu, który zawiera błąd.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-862">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-863">Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-863">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-864">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="4517f-864">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4517f-865">Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="4517f-865">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4517f-866">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-866">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-867">Pobiera wartość zawierającą stanów bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-867">Gets a value containing the states of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4517f-868">Jeden z <see cref="T:System.Threading.ThreadState" /> wartości wskazujący stan bieżącego wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-868">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span>
          </span>
          <span data-ttu-id="4517f-869">Jest to wartość początkowa <see langword="Unstarted" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-869">The initial value is <see langword="Unstarted" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-870"><xref:System.Threading.Thread.ThreadState%2A> Właściwość zapewnia bardziej szczegółowych informacji niż <xref:System.Threading.Thread.IsAlive%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-870">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4517f-871">Stan wątku jest tylko w scenariuszach debugowania.</span><span class="sxs-lookup"><span data-stu-id="4517f-871">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="4517f-872">Kod nigdy nie należy używać stan wątku do synchronizowania działania wątków.</span><span class="sxs-lookup"><span data-stu-id="4517f-872">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-873">Poniższy przykład kodu pokazuje, uzyskiwanie dostępu do `ThreadState` wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-873">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="4517f-874">Nowy stan apartamentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-874">The new apartment state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-875">Ustawia stan apartamentu wątku przed jej uruchomieniem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-875">Sets the apartment state of a thread before it is started.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-876">
            <see langword="true" /> Jeśli ustawiono stan apartamentu; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-876">
              <see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-877">Nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stanu apartamentu nie została ustawiona, zanim zostaną uruchomione.</span><span class="sxs-lookup"><span data-stu-id="4517f-877">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="4517f-878">Stanem apartamentu musi być ustawiona przed uruchomieniem wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-878">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-879">Zainicjowano wątku głównego aplikacji do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie.</span><span class="sxs-lookup"><span data-stu-id="4517f-879">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="4517f-880">Jedynym sposobem stanu apartamentu wątku głównego aplikacji, aby <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> stosuje się <xref:System.STAThreadAttribute> atrybutu metoda punktu wejścia.</span><span class="sxs-lookup"><span data-stu-id="4517f-880">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="4517f-881"><xref:System.Threading.Thread.TrySetApartmentState%2A> Metody, wraz z <xref:System.Threading.Thread.GetApartmentState%2A> — metoda i <xref:System.Threading.Thread.SetApartmentState%2A> zastępuje metodę, <xref:System.Threading.Thread.ApartmentState%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="4517f-881">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4517f-882">Poniższy przykład kodu pokazuje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="4517f-882">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="4517f-883">Przykład kodu tworzy wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-883">The code example creates a thread.</span></span> <span data-ttu-id="4517f-884">Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4517f-884">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4517f-885"><xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stanu apartamentu jest już ustawiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-885">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="4517f-886">Jeśli tę samą operację miał usiłowano <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> czy zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="4517f-886">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="4517f-887">Po uruchomieniu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> ponownie używana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="4517f-887">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="4517f-888">Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek został już uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="4517f-888">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4517f-889">
            <paramref name="state" /> nie jest stanu apartamentu prawidłowe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-889">
              <paramref name="state" /> is not a valid apartment state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="4517f-890">Wątek została już uruchomiona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-890">The thread has already been started.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-891">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-891">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-892">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-892">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-893">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-893">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-894">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-894">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-895">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-895">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-896">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-896">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-897"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-897"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-898">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-898">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-899">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-899">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-900">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-900">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-901">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-901">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-902">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-902">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-903">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-903">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-904">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-904">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-905">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-905">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-906">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-906">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-907">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-907">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-908">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-908">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-909">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-909">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-910"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-910"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-911">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-911">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-912">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-912">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-913">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-913">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-914">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-914">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-915">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-915">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-916">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-916">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-917">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-917">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-918">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-918">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-919">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-919">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-920">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-920">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-921">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-921">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-922">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-922">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-923"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-923"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-924">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-924">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-925">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-925">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-926">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-926">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-927">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-927">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-928">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-928">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-929">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-929">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-930">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-930">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-931">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-931">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-932">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-932">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-933">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-933">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-934">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-934">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-935">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-935">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-936"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-936"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-937">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-937">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-938">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-938">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-939">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-939">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-940">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-940">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-941">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-941">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-942">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-942">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-943">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-943">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-944">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-944">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-945">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-945">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-946">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-946">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-947">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-947">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-948">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-948">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-949"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-949"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-950">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-950">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-951">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-951">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-952">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-952">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-953">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-953">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-954">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-954">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-955">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-955">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-956">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-956">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-957">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-957">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-958">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-958">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-959">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-959">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-960">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-960">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-961">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-961">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-962"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-962"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-963">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-963">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-964">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-964">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-965">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-965">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-966">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-966">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-967">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-967">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-968">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-968">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-969">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-969">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-970">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-970">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-971">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-971">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-972">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-972">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-973">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-973">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-974">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-974">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-975"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-975"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-976">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-976">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-977">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-977">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-978">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-978">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-979">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-979">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-980">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-980">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-981">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-981">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-982">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-982">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-983">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-983">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-984">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-984">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-985">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-985">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-986">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-986">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-987">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-987">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-988"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-988"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-989">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-989">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-990">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-990">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-991">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-991">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-992">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-992">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-993">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-993">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-994">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-994">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-995">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-995">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-996">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-996">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-997">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-997">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-998">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-998">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-999">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-999">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-1000">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1000">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1001"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1001"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1002">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1002">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1003">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-1003">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-1004">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1004">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1005">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1005">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1006">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1006">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1007">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1007">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1008">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1008">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1009">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1009">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1010">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1010">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1011">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1011">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-1012">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1012">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-1013">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1013">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1014"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1014"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1015">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1015">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1016">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-1016">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-1017">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1017">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1018">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1018">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1019">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1019">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1020">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1020">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1021">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1021">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1022">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1022">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1023">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1023">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1024">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1024">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-1025">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1025">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-1026">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1026">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1027"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1027"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1028">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1028">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1029">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-1029">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-1030">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1030">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1031">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1031">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1032">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1032">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1033">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1033">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1034">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1034">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1035">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1035">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1036">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1036">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1037">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1037">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-1038">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1038">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-1039">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1039">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1040"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1040"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1041">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1041">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1042">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-1042">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-1043">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1043">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1044">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1044">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1045">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1045">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1046">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1046">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1047">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1047">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1048">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1048">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1049">Pole do odczytu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1049">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1050">Odczytuje wartość pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1050">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="4517f-1051">Wartość jest najnowsza wersja napisane przez dowolnego procesora w komputerze, niezależnie od tego, czy liczba procesorów lub stan płyty pamięci podręcznej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1051">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-1052">Ostatnia wartość zapisana w polu przez dowolnego procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1052">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1053"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1053"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1054">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1054">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1055">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisany w lokalizacji pamięci przez dowolnego procesora.</span><span class="sxs-lookup"><span data-stu-id="4517f-1055">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="4517f-1056">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1056">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1057">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1057">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1058">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1058">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1059">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1059">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1060">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1060">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1061">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1061">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4517f-1062">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1062">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1063">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1063">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1064">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1064">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1065">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1065">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1066"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1066"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1067">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1067">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1068">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1068">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1069">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1069">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1070">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1070">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1071">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1071">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1072">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1072">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1073">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1073">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1074">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1074">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1075">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1075">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1076">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1076">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1077">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1077">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1078"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1078"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1079">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1079">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1080">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1080">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1081">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1081">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1082">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1082">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1083">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1083">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1084">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1084">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1085">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1085">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1086">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1086">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1087">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1087">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1088">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1088">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1089">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1089">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1090"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1090"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1091">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1091">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1092">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1092">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1093">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1093">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1094">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1094">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1095">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1095">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1096">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1096">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1097">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1097">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1098">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1098">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1099">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1099">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1100">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1100">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1101">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1101">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1102"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1102"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1103">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1103">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1104">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1104">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1105">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1105">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1106">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1106">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1107">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1107">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1108">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1108">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1109">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1109">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1110">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1110">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1111">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1111">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1112">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1112">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1113">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1113">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1114"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1114"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1115">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1115">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1116">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1116">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1117">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1117">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1118">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1118">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1119">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1119">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1120">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1120">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1121">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1121">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1122">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1122">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1123">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1123">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1124">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1124">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1125">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1125">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1126"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1126"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1127">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1127">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1128">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1128">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1129">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1129">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1130">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1130">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1131">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1131">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1132">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1132">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1133">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1133">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1134">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1134">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1135">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1135">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1136">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1136">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1137">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1137">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1138"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1138"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1139">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1139">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1140">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1140">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1141">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1141">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1142">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1142">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1143">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1143">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1144">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1144">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1145">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1145">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1146">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1146">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1147">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1147">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1148">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1148">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1149">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1149">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1150"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1150"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1151">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1151">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1152">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1152">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1153">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1153">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1154">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1154">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1155">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1155">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1156">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1156">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1157">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1157">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1158">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1158">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1159">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1159">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1160">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1160">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1161">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1161">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1162"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1162"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1163">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1163">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1164">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1164">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1165">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1165">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1166">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1166">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1167">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1167">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1168">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1168">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1169">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1169">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1170">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1170">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1171">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1171">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1172">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1172">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1173">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1173">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1174"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1174"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1175">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1175">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1176">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1176">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1177">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1177">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1178">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1178">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1179">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1179">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1180">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1180">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1181">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1181">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1182">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1182">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1183">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1183">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1184">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1184">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1185">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1185">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1186"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1186"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1187">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1187">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1188">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1188">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1189">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1189">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1190">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1190">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1191">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1191">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1192">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1192">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1193">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1193">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1194">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1194">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1195">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1195">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1196">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1196">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1197">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1197">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1198"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1198"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1199">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1199">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1200">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1200">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1201">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1201">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1202">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1202">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1203">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1203">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1204">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1204">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1205">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1205">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1206">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1206">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="4517f-1207">Pole, do którego ma zostać zapisany wartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1207">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4517f-1208">Wartość do zapisania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1208">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4517f-1209">Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczny dla wszystkich procesorów w komputerze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1209">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1210"><xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> są dla przypadków specjalnych synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1210"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="4517f-1211">W normalnych okolicznościach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy alternatywę łatwiejsze.</span><span class="sxs-lookup"><span data-stu-id="4517f-1211">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="4517f-1212">W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> zapewnia, że wartość zapisany w lokalizacji pamięci jest natychmiast widoczne dla wszystkich procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1212">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="4517f-1213">Może to wymagać opróżniania pamięci podręcznych procesorów.</span><span class="sxs-lookup"><span data-stu-id="4517f-1213">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="4517f-1214">Nawet w systemie jednoprocesorowy <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest do odczytu lub zapisywane w pamięci i nie w pamięci podręcznej (na przykład w rejestrze procesora).</span><span class="sxs-lookup"><span data-stu-id="4517f-1214">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="4517f-1215">W związku z tym można je zsynchronizować dostęp do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.</span><span class="sxs-lookup"><span data-stu-id="4517f-1215">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="4517f-1216">Wywołanie tej metody ma wpływ tylko dostęp do jednej pamięci.</span><span class="sxs-lookup"><span data-stu-id="4517f-1216">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="4517f-1217">Aby zapewnić skuteczne synchronizacji dla pola, dostęp do pola musi używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1217">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4517f-1218">W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="4517f-1218">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4517f-1219">Powoduje, że wątek wywołujący umożliwiające uzyskanie wykonywania do innego wątku, który jest gotowy do uruchomienia na bieżącym procesora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1219">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span>
          </span>
          <span data-ttu-id="4517f-1220">System operacyjny wybierze na uzyskanie do wątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1220">The operating system selects the thread to yield to.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4517f-1221">
            <see langword="true" /> Jeśli system operacyjny przełączono wykonywania na inny wątek; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4517f-1221">
              <see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4517f-1222">Jeśli ta metoda zakończy się powodzeniem, jest uzyskane z resztą przedział czasu bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="4517f-1222">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="4517f-1223">System operacyjny planuje wątek wywołujący dla innego przedział czasu, zależnie od jego priorytetu i stanu innych wątków, które są dostępne do uruchomienia.</span><span class="sxs-lookup"><span data-stu-id="4517f-1223">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="4517f-1224">Reaguje jest ograniczona do procesora, który jest wykonywany wątek wywołujący.</span><span class="sxs-lookup"><span data-stu-id="4517f-1224">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="4517f-1225">System operacyjny nie przechodzi wykonywania do innego procesora, nawet wtedy, gdy ten procesor jest bezczynny lub jest uruchomiony wątek o niższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="4517f-1225">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="4517f-1226">Jeśli nie ma nie ma innych wątków gotowych do wykonania na bieżącym procesora, system operacyjny nie przekazuje wykonywania i ta metoda zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="4517f-1226">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="4517f-1227">Ta metoda jest odpowiednikiem przy użyciu platformy wywołania do wywołań natywnych Win32 `SwitchToThread` funkcji.</span><span class="sxs-lookup"><span data-stu-id="4517f-1227">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="4517f-1228">Należy wywołać <xref:System.Threading.Thread.Yield%2A> wywołania metody zamiast platformy, ponieważ pomija wszelkie niestandardowe zachowanie wątkowości hosta zażądał wywołanie platformy.</span><span class="sxs-lookup"><span data-stu-id="4517f-1228">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
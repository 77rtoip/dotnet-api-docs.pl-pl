<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2ca5d7f1a1fc6d62777bb21d9e21635ceb6a37ef" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58562397" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Tworzy i kontroluje wątku, ustawia jego priorytet i pobiera jego stan.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu procesu środowiska uruchomieniowego języka wspólnego automatycznie tworzy wątku na pierwszym planie jednego, aby wykonać kod aplikacji. Wraz z tego wątku na pierwszym planie głównym proces, można utworzyć jeden lub więcej wątków do wykonania fragmentu kodu programu skojarzonego z procesem. Te wątki, można wykonać na pierwszym planie lub w tle. Ponadto można użyć <xref:System.Threading.ThreadPool> klasy do wykonywania kodu na wątków roboczych, które są zarządzane przez środowisko uruchomieniowe języka wspólnego.  
  
 W tej sekcji  
  
 [Uruchamianie wątku](#Starting)   
 [Pobieranie obiektów wątku](#Retrieving)   
 [Wątki pierwszego planu i tła](#Foreground)   
 [Kultura i wątki](#Culture)   
 [Pobieranie informacji o i sterowanie wątkami](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Uruchamianie wątku  
 Można uruchomić wątku poprzez dostarczenie delegata, który reprezentuje metodę, którą wątek znajduje się w jej konstruktora klasy. Następnie wywołaj <xref:System.Threading.Thread.Start%2A> metodę, aby rozpocząć wykonywanie ciągu.  
  
 <xref:System.Threading.Thread> Konstruktory można wykonać jedną z typami delegatów dwóch, w zależności od tego, czy można przekazać argument do metody w celu wykonania:  
  
-   Jeśli metoda nie ma argumentów, przekazać <xref:System.Threading.ThreadStart> delegować do konstruktora. Ma podpis:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Poniższy przykład tworzy i rozpoczyna się wątek, który jest wykonywany `ExecuteInForeground` metody. Metoda Wyświetla informacje o niektórych właściwości wątku, a następnie wykonuje pętlę, w którym zatrzymuje się na pół sekundy i wyświetla liczbę sekund, który upłynął. Jeśli wątek zostało wykonane przez co najmniej pięć sekund, zakończenia pętli i Wątek kończy wykonywanie.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Jeśli metoda wymaga argumentu, Przekaż <xref:System.Threading.ParameterizedThreadStart> delegować do konstruktora. Ma podpis:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Metoda wykonywane przez delegata można rzutować (w języku C#) lub przekonwertować (w języku Visual Basic) parametr odpowiedniego typu.  
  
     Poniższy przykład jest taka sama jak poprzedni, z tą różnicą, że wywoływanych przez nią <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora. Ta wersja `ExecuteInForeground` metoda ma jeden parametr reprezentujący przybliżoną liczbę milisekund pętli ma wykonać.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Nie jest konieczne zachować odwołanie do <xref:System.Threading.Thread> obiektu po rozpoczęciu wątku. Wątek kontynuuje wykonywanie aż do zakończenia procedury wątku.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Pobieranie obiektów wątku  
 Można użyć statycznej (`Shared` w języku Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> właściwość, aby pobrać odwołanie do aktualnie wykonywany wątek z kodu, który jest wykonywany wątek. W poniższym przykładzie użyto <xref:System.Threading.Thread.CurrentThread%2A> właściwości, aby wyświetlić informacje o wątku głównego aplikacji, innego wątku na pierwszym planie, wątku w tle i wątku z puli wątków.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Wątki pierwszego planu i tła  
 Wystąpienia elementu <xref:System.Threading.Thread> klasy reprezentują wątki pierwszego planu lub wątków w tle. Wątków w tle są takie same, wątki pierwszoplanowe z jednym wyjątkiem: wątku w tle nie przechowuje proces uruchomiony, jeśli wszystkie wątki pierwszoplanowe zostać zakończony. Po zatrzymaniu wszystkie wątki pierwszoplanowe środowiska uruchomieniowego zatrzymuje wszystkich wątków w tle i zamyka.  
  
 Domyślnie następujące wątki są wykonywane na pierwszym planie:  
  
-   Wątku głównego aplikacji.  
  
-   Wszystkie wątki, utworzonych przez wywoływanie <xref:System.Threading.Thread> konstruktora klasy.  
  
 Następujące wątków wykonania w tle domyślnie:  
  
-   Wątek puli wątków, które puli wątków roboczych utrzymywane przez środowisko uruchomieniowe.  Wątek puli i harmonogram pracy można skonfigurować na wątków z puli wątków, przy użyciu <xref:System.Threading.ThreadPool> klasy.  
  
    > [!NOTE]
    >  Oparta na zadaniach asynchronicznej operacji automatycznie wykonać na wątków z puli wątków. Użyj opartego na zadaniach asynchronicznej operacji <xref:System.Threading.Tasks.Task> i <xref:System.Threading.Tasks.Task%601> klasy do zaimplementowania [wzorca asynchronicznego opartego na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Wszystkie wątki, które wprowadzać środowiska wykonawczego zarządzanych z niezarządzanego kodu.  
  
 Możesz zmienić wątków do wykonania w tle, ustawiając <xref:System.Threading.Thread.IsBackground%2A> właściwość w dowolnym momencie.  Wątków w tle są przydatne w przypadku każdej operacji, która powinno być kontynuowane, dopóki aplikacja jest uruchomiona, ale nie powinny uniemożliwiają aplikacji przerywa, takich jak monitorowanie zmian systemu plików lub przychodzące połączenia gniazda.  
  
 Poniższy przykład ilustruje różnicę między wątki pierwszego planu i tła. Jest on podobny do pierwszego przykładu w [uruchamianie wątku](#Starting) sekcji, z tą różnicą, że ustawia wątków do wykonania w tle przed jego rozpoczęciem. Dane wyjściowe pokazują, pętla zostanie przerwana, przed rozpoczęciem wykonywania przez pięć sekund.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Kultura i wątki  
 Każdy wątek ma kultury, reprezentowane przez <xref:System.Threading.Thread.CurrentCulture%2A> właściwości i kultury UI, reprezentowane przez <xref:System.Threading.Thread.CurrentUICulture%2A> właściwości.  Bieżącej kultury obsługuje takie operacje zależne od kultury jako analizowania i formatowania, porównywania ciągów i sortowania, a także kontroluje, system pisma i kalendarz używany przez wątek. Bieżąca kultura interfejsu użytkownika umożliwia pobranie wrażliwość na ustawienia kulturowe zasoby w plikach zasobów.  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture> i <xref:System.Threading.Thread.CurrentUICulture> właściwości nie działają niezawodnie, gdy jest używane z żadnym z wątków niż bieżący wątek. W programie .NET Framework odczytywanie tych właściwości jest niezawodne, mimo że ustawienie tych właściwości dla wątku niż bieżący wątek nie jest. Na platformie .NET Core <xref:System.InvalidOperationException> jest generowany, jeśli wątek próbował odczytać lub zapisać tych właściwości w innym wątku.
> Firma Microsoft zaleca użycie <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> właściwości, aby pobierać i ustawiać bieżącej kultury.

 Podczas tworzenia wystąpienia nowego wątku jego kultury i kultury UI zdefiniowano Bieżąca kultura systemu i kultura interfejsu użytkownika, a nie przez kultury i kultury UI, wątku, z którego jest tworzony nowy wątek. Oznacza to, na przykład, że bieżąca kultura systemu jest angielski (Stany Zjednoczone) i bieżącej kultury wątku aplikacji głównej jest francuski (Francja), kultura nowy wątek, utworzonych przez wywoływanie <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora z wątku głównego jest angielski (Stany Zjednoczone), francuski (Francja). Aby uzyskać więcej informacji, zobacz sekcję "Kultura i wątki" <xref:System.Globalization.CultureInfo> temat poświęcony klasie.  
  
> [!IMPORTANT]
>  Nie jest to prawdą wątków, które są wykonywane asynchroniczne operacje dla aplikacji, których platformą docelową [!INCLUDE[net_v46](~/includes/net-v46-md.md)] i nowsze wersje, w tym przypadku, kultury i kultury UI jest częścią asynchronicznego kontekst operacji; wątku, na którym operacji asynchronicznej wykonuje przez domyślne dziedziczy kultury i kultury UI, wątku, z którego uruchomiono operację asynchroniczną. Aby uzyskać więcej informacji, zobacz sekcję "Kultury i opartego na zadaniach asynchronicznej operacji" <xref:System.Globalization.CultureInfo> temat poświęcony klasie.  
  
 Można wykonać jedną z następujących czynności, aby upewnić się, że wszystkie wątki wykonywane w aplikacji współużytkują tę samą kulturę i kultura interfejsu użytkownika:  
  
-   Możesz przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tę kulturę do <xref:System.Threading.ParameterizedThreadStart> delegować lub <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> metody.  
  
-   Dla aplikacji działających w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i nowsze wersje, można zdefiniować kultury i kultury UI, który ma być przypisana do wszystkich wątków, utworzone w domenie aplikacji, ustawiając wartość <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> i <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> właściwości. Należy pamiętać, że to ustawienie domeny na aplikację.  

 Aby uzyskać więcej informacji i przykładów, zobacz sekcję "Kultura i wątki" <xref:System.Globalization.CultureInfo> temat poświęcony klasie.

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Pobieranie informacji o i sterowanie wątkami  
 Możesz pobrać wiele wartości właściwości, które zawierają informacje o wątku. W niektórych przypadkach można również ustawić te wartości właściwości do sterowania działaniem wątku. Te właściwości wątku zawierać:  
  
-   Nazwa. <xref:System.Threading.Thread.Name%2A> jest zapis — raz te właściwości, która służy do identyfikowania wątku.  Jego wartość domyślna to `null`.  
  
-   Wartość skrótu, który można pobrać przez wywołanie metody <xref:System.Threading.Thread.GetHashCode%2A> metody. Kod skrótu może być używany do jednoznacznego identyfikowania wątek okres istnienia wątek jego kod skrótu nie będą kolidować z wartości z innego wątku, niezależnie od tego, w domenie aplikacji, z którego można uzyskać wartość.  
  
-   Identyfikator wątku. Wartość tylko do odczytu <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości jest przypisywany przez środowisko uruchomieniowe i unikatowo identyfikuje wątku w swoim procesie.  
  
    > [!NOTE]
    >  System operacyjny [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) nie ma stałej relacji wątków zarządzanych, ponieważ niezarządzany host może kontrolować relacji między wątkami zarządzanych i niezarządzanych. W szczególności można użyć zaawansowanych hosta [interfejs API hostingu środowiska CLR](https://msdn.microsoft.com/library/ms404385.aspx) zaplanować wiele wątków zarządzanych względem tego samego wątku systemu operacyjnego lub wątek być przenoszone między wątkami różnych systemów operacyjnych.  
  
-   Bieżący stan wątku. Czas trwania początku swojego istnienia wątku jest zawsze co najmniej jeden stanów z definicją <xref:System.Threading.ThreadState> właściwości.  
  
-   Poziom priorytetu planowania, która jest zdefiniowana przez <xref:System.Threading.ThreadPriority> właściwości. Mimo że można ustawić tę wartość, aby zażądać priorytet wątku, nie jest gwarantowana aby były używane przez system operacyjny.  
  
-   Tylko do odczytu <xref:System.Threading.Thread.IsThreadPoolThread%2A> właściwość, która wskazuje, czy wątek jest wątku z puli wątków.  
  
-   <xref:System.Threading.Thread.IsBackground%2A> Właściwości. Aby uzyskać więcej informacji, zobacz [wątki pierwszego planu i tła](#Foreground) sekcji.  
  
## Examples  
 W poniższym przykładzie pokazano proste funkcje wątków.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Ten kod tworzy dane wyjściowe podobne do następujących:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Używanie wątków i wątkowości</related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">Źródło odwołania dla klasy wątku</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">Delegat, który reprezentuje metody do wywołania, gdy ten wątek rozpoczyna wykonywanie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając delegat, który umożliwia obiektu mają być przekazywane do wątku, gdy wątek jest uruchomiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie rozpoczyna się wykonywanie po jego utworzeniu. Aby zaplanować wątków do wykonania, należy wywołać <xref:System.Threading.Thread.Start%2A> metody. Aby przekazać obiekt danych do wątku, należy użyć <xref:System.Threading.Thread.Start%28System.Object%29> przeciążenie metody.  
  
> [!NOTE]
>  Użytkowników programu Visual Basic można pominąć <xref:System.Threading.ThreadStart> Konstruktor podczas tworzenia wątku. Użyj `AddressOf` operator przy przekazywaniu metodę, na przykład `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano Składnia służąca do tworzenia i używania <xref:System.Threading.ParameterizedThreadStart> delegowanego z metody statycznej i metodą wystąpienia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ThreadStart" /> delegata, który reprezentuje metody do wywołania, gdy ten wątek rozpoczyna wykonywanie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie rozpoczyna się wykonywanie po jego utworzeniu. Aby zaplanować wątków do wykonania, należy wywołać <xref:System.Threading.Thread.Start%2A> metody.  
  
> [!NOTE]
>  Użytkowników programu Visual Basic można pominąć <xref:System.Threading.ThreadStart> Konstruktor podczas tworzenia wątku. Użyj `AddressOf` operator przy przekazywaniu metodę na przykład `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wątku, który wykonuje metodę statyczną.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje sposób tworzenia wątku, który wykonuje metodę wystąpienia.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> Parametr <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegata, który reprezentuje metody do wywołania, gdy ten wątek rozpoczyna wykonywanie.</param>
        <param name="maxStackSize">Rozmiar maksymalny stosu w bajtach, do użycia przez wątku lub 0, rozmiar maksymalny stosu domyślnego określony w nagłówku pliku wykonywalnego.  
  
Ważne dla częściowo zaufanego kodu, <paramref name="maxStackSize" /> jest ignorowana, jeśli jest on większy niż rozmiar stosu domyślnego. Jest zgłaszany żaden wyjątek.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając delegat, który umożliwia obiektu mają być przekazywane do wątku, gdy wątek jest uruchomiony i określając maksymalny rozmiar stosu dla wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy unikać używania tego przeciążenia konstruktora. Domyślny rozmiar stosu używana przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> przeciążenia konstruktora jest rozmiar stosu zalecane dla wątków. Jeśli wątek ma problemy z pamięcią, najbardziej prawdopodobną przyczyną jest programowania błędu, takie jak nieskończoną rekursję.  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]należy korzystać tylko z w pełni zaufany kod można ustawić `maxStackSize` wartość, która jest większa niż rozmiar stosu domyślnego (1 megabajt). Jeśli określono większą wartość dla `maxStackSize` gdy kod jest wykonywany z częściowym zaufaniem `maxStackSize` jest ignorowany i jest używany domyślny rozmiar stosu. Jest zgłaszany żaden wyjątek. Można ustawić kodu na dowolnym poziomie zaufania `maxStackSize` wartość, która jest mniejsza niż domyślny rozmiar stosu.  
  
> [!NOTE]
>  Jeśli tworzysz bibliotekę pełni zaufany, który będzie używany przez częściowo zaufany kod, a wówczas musisz uruchomić wątek wymagającym dużej stosu, pełne zaufanie musi potwierdzenia przed utworzeniem wątku lub będzie używany domyślny rozmiar stosu. Nie należy tego robić, chyba że w pełni kontrolować kod, który jest uruchamiany na wątku.  
  
 Jeśli `maxStackSize` jest mniejszy niż rozmiar minimalny stos jest używany rozmiar minimalny stosu. Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony jest zaokrąglana do większych kolejną wielokrotnością rozmiaru strony. Na przykład jeśli używasz platformy .NET Framework w wersji 2.0 w systemie Windows Vista, 256KB (262 144 bajty) to rozmiar minimalny stos, a rozmiar strony wynosi 64KB (65 536 bajtów).  
  
> [!NOTE]
>  W wersjach systemu Microsoft Windows przed Windows XP i Windows Server 2003 `maxStackSize` jest ignorowany i jest używany rozmiar stosu, określony w nagłówku pliku wykonywalnego.  
  
 Możesz określić rozmiar bardzo mały stos, może być konieczne wyłączenie sondowanie przepełnienia stosu. Stos poważnie jest ograniczony, sondowanie może sam spowodować przepełnienie stosu. Aby wyłączyć, sondowanie przepełnienie stosu, Dodaj następujący element do pliku konfiguracji aplikacji.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">A <see cref="T:System.Threading.ThreadStart" /> delegata, który reprezentuje metody do wywołania, gdy ten wątek rozpoczyna wykonywanie.</param>
        <param name="maxStackSize">Rozmiar maksymalny stosu w bajtach, do użycia przez wątku lub 0, rozmiar maksymalny stosu domyślnego określony w nagłówku pliku wykonywalnego.  
  
Ważne dla częściowo zaufanego kodu, <paramref name="maxStackSize" /> jest ignorowana, jeśli jest on większy niż rozmiar stosu domyślnego. Jest zgłaszany żaden wyjątek.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy, określając maksymalny rozmiar stosu dla wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy unikać używania tego przeciążenia konstruktora. Domyślny rozmiar stosu używana przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> przeciążenia konstruktora jest rozmiar stosu zalecane dla wątków. Jeśli wątek ma problemy z pamięcią, najbardziej prawdopodobną przyczyną jest programowania błędu, takie jak nieskończoną rekursję.  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]należy korzystać tylko z w pełni zaufany kod można ustawić `maxStackSize` wartość, która jest większa niż rozmiar stosu domyślnego (1 megabajt). Jeśli określono większą wartość dla `maxStackSize` gdy kod jest wykonywany z częściowym zaufaniem `maxStackSize` jest ignorowany i jest używany domyślny rozmiar stosu. Jest zgłaszany żaden wyjątek. Można ustawić kodu na dowolnym poziomie zaufania `maxStackSize` wartość, która jest mniejsza niż domyślny rozmiar stosu.  
  
> [!NOTE]
>  Jeśli tworzysz bibliotekę pełni zaufany, który będzie używany przez częściowo zaufany kod, a wówczas musisz uruchomić wątek wymagającym dużej stosu, pełne zaufanie musi potwierdzenia przed utworzeniem wątku lub będzie używany domyślny rozmiar stosu. Nie należy tego robić, chyba że w pełni kontrolować kod, który jest uruchamiany na wątku.  
  
 Jeśli `maxStackSize` jest mniejszy niż rozmiar minimalny stos jest używany rozmiar minimalny stosu. Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony jest zaokrąglana do większych kolejną wielokrotnością rozmiaru strony. Na przykład jeśli używasz platformy .NET Framework w wersji 2.0 w systemie Windows Vista, 256KB (262 144 bajty) to rozmiar minimalny stos, a rozmiar strony wynosi 64KB (65 536 bajtów).  
  
> [!NOTE]
>  W wersjach systemu Microsoft Windows przed Windows XP i Windows Server 2003 `maxStackSize` jest ignorowany i jest używany rozmiar stosu, określony w nagłówku pliku wykonywalnego.  
  
 Możesz określić rozmiar bardzo mały stos, może być konieczne wyłączenie sondowanie przepełnienia stosu. Stos poważnie jest ograniczony, sondowanie może sam spowodować przepełnienie stosu. Aby wyłączyć, sondowanie przepełnienie stosu, Dodaj następujący element do pliku konfiguracji aplikacji.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces zakończenie wątku. Zazwyczaj wywołanie tej metody powoduje zakończenie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> `Thread.Abort` Metoda powinna być używana z rozwagą. Szczególnie w przypadku, gdy wywołujesz ją przerwanie wątku niż bieżący wątek nie wiesz, jaki kod jest wykonywane lub nie można wykonać, gdy <xref:System.Threading.ThreadAbortException> jest generowany, ani nie może być niektórych stanu aplikacji lub ich stan aplikacji i użytkownika, który jest odpowiada za zachowania. Na przykład, wywołanie `Thread.Abort` może uniemożliwić wykonanie konstruktorów statycznych lub uniemożliwić zwalniania niezarządzanych zasobów. 
>
> Należy pamiętać, że `Thread.Abort` metoda nie jest obsługiwana na platformie .NET Core.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces zakończenie wątku. Zazwyczaj wywołanie tej metody powoduje zakończenie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana w wątku, system zgłasza <xref:System.Threading.ThreadAbortException> w wątku, aby je przerwać. `ThreadAbortException` specjalne wyjątek, który może zostać przechwycony przez kod aplikacji, ale jest ponownie zgłoszony na końcu `catch` blokowania, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana. `ResetAbort` anuluje żądanie do przerwania i zapobiega `ThreadAbortException` z zakończenie wątku. Cofnąć `finally` bloki są wykonywane przed wątek został przerwany.  
  
> [!NOTE]
>  Kiedy wątek wywołuje `Abort` na siebie, efekt jest podobny do zgłaszania wyjątku; <xref:System.Threading.ThreadAbortException> się stanie, natychmiast, a wynik jest przewidywalne. Jednak jeśli jeden wątek wywołuje `Abort` w innym wątku przerwanie przerywa działanie niezależnie od kod jest uruchomiony. Istnieje również ryzyko, statyczny Konstruktor może przerwane. W rzadkich przypadkach to może uniemożliwić wystąpień tej klasy są tworzone w tej domenie aplikacji. W .NET Framework w wersji 1.0 i 1.1, istnieje ryzyko, wątek może przerwać podczas `finally` bloku jest uruchomiona, w którym to przypadku `finally` bloku zostało przerwane.  
  
 Wątek nie jest gwarantowane do przerwania bezpośrednio lub w ogóle. Taka sytuacja może wystąpić, jeśli wątek ma niezwiązana ilość obliczeń w `finally` bloki, które są wywoływane w ramach procedury przerwania, w tym samym przez nieokreślony czas opóźnienia przerwanie. Poczekać, aż wątek został przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> wątku po wywołaniu metody <xref:System.Threading.Thread.Abort%2A> metody, ale nie ma żadnej gwarancji, zakończy się czas oczekiwania.  
  
> [!NOTE]
>  Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> może spowodować zablokowanie, jeśli wątek, który Trwa przerywanie znajduje się w regionie chronionym kodu, takich jak `catch` bloku `finally` bloku lub region ograniczonego wykonania. Jeśli wątku wywołującym <xref:System.Threading.Thread.Abort%2A> posiada blokadę, wymagająca przerwanie wątku zakleszczenia mogą wystąpić.  
  
 Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek zostanie przerwany, gdy <xref:System.Threading.Thread.Start%2A> jest wywoływana. Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest w stanie uśpienia, wątek jest przerwane i następnie zostało przerwane.  
  
 Jeśli `Abort` jest wywoływana w wątku, który zostało zawieszone, <xref:System.Threading.ThreadStateException> jest zgłaszany w wątku, który wywołał <xref:System.Threading.Thread.Abort%2A>, i <xref:System.Threading.ThreadState.AbortRequested> jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości wątku przerwanie. A <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w wstrzymania wątków, aż <xref:System.Threading.Thread.Resume%2A> jest wywoływana.  
  
 Jeśli `Abort` jest wywoływana w wątków zarządzanych, podczas wykonywania kodu niezarządzanego `ThreadAbortException` nie jest generowany, aż wątek wraca z kodem zarządzanym.  
  
 Jeśli dwa wywołania `Abort` występować w tym samym czasie, jest jedno wywołanie ustawić informacje o stanie i inne wywołanie, aby wykonać `Abort`. Jednak aplikacja nie może wykryć tę sytuację.  
  
 Po `Abort` zostanie wywołana w wątku, obejmuje stan wątku <xref:System.Threading.ThreadState.AbortRequested>. Po zakończeniu wątku wyniku pomyślnego `Abort`, stan wątku jest zmieniany na <xref:System.Threading.ThreadState.Stopped>. Z wystarczającymi uprawnieniami, wątek to obiekt docelowy `Abort` można anulować przy użyciu przerwania `ResetAbort` metody. Aby uzyskać przykład, który demonstruje wywołanie `ResetAbort` metody, zobacz `ThreadAbortException` klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek, który Trwa przerywanie jest aktualnie wstrzymana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Używanie wątków i wątkowości</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Niszczenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Obiekt, który zawiera informacje specyficzne dla aplikacji, takie jak stan, który może służyć przez wątek przerwanie.</param>
        <summary>Wywołuje <see cref="T:System.Threading.ThreadAbortException" /> w wątku, na którym jest wywoływana, aby rozpocząć proces zakończenie wątku, a jednocześnie zapewniając wyjątku o zakończenie wątku. Zazwyczaj wywołanie tej metody powoduje zakończenie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana w wątku, system zgłasza <xref:System.Threading.ThreadAbortException> w wątku, aby je przerwać. `ThreadAbortException` specjalne wyjątek, który może zostać przechwycony przez kod aplikacji, ale jest ponownie zgłoszony na końcu `catch` blokowania, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana. `ResetAbort` anuluje żądanie do przerwania i zapobiega `ThreadAbortException` z zakończenie wątku. Cofnąć `finally` bloki są wykonywane przed wątek został przerwany.  
  
> [!NOTE]
>  Kiedy wątek wywołuje `Abort` na siebie, efekt jest podobny do zgłaszania wyjątku; <xref:System.Threading.ThreadAbortException> się stanie, natychmiast, a wynik jest przewidywalne. Jednak jeśli jeden wątek wywołuje `Abort` w innym wątku przerwanie przerywa działanie niezależnie od kod jest uruchomiony. Istnieje ryzyko, statyczny Konstruktor może przerwane. W rzadkich przypadkach to może uniemożliwić wystąpień tej klasy są tworzone w tej domenie aplikacji. W .NET Framework w wersji 1.0 i 1.1, istnieje ryzyko, wątek może przerwać podczas `finally` bloku jest uruchomiona, w którym to przypadku `finally` bloku zostało przerwane.  
  
 Wątek nie jest gwarantowane do przerwania bezpośrednio lub w ogóle. Taka sytuacja może wystąpić, jeśli wątek ma niezwiązana ilość obliczeń w `finally` bloki, które są wywoływane w ramach procedury przerwania, w tym samym przez nieokreślony czas opóźnienia przerwanie. Należy poczekać, aż wątek został przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> wątku po wywołaniu metody <xref:System.Threading.Thread.Abort%2A> metody, ale nie ma żadnej gwarancji, która zakończy się czas oczekiwania.  
  
> [!NOTE]
>  Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> może spowodować zablokowanie, jeśli wątek, który Trwa przerywanie znajduje się w regionie chronionym kodu, takich jak `catch` bloku `finally` bloku lub region ograniczonego wykonania. Jeśli wątku wywołującym <xref:System.Threading.Thread.Abort%2A> posiada blokadę, wymagająca przerwanie wątku zakleszczenia mogą wystąpić.  
  
 Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek zostanie przerwany, gdy <xref:System.Threading.Thread.Start%2A> jest wywoływana. Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest w stanie uśpienia, wątek jest przerwane i następnie zostało przerwane.  
  
 Jeśli `Abort` jest wywoływana w wątku, który zostało zawieszone, <xref:System.Threading.ThreadStateException> jest zgłaszany w wątku, który wywołał <xref:System.Threading.Thread.Abort%2A>, i <xref:System.Threading.ThreadState.AbortRequested> jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości wątku przerwanie. A <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w wstrzymania wątków, aż <xref:System.Threading.Thread.Resume%2A> jest wywoływana.  
  
 Jeśli `Abort` jest wywoływana w wątków zarządzanych, podczas wykonywania kodu niezarządzanego `ThreadAbortException` nie jest generowany, aż wątek wraca z kodem zarządzanym.  
  
 Jeśli dwa wywołania `Abort` występować w tym samym czasie, jest jedno wywołanie ustawić informacje o stanie i inne wywołanie, aby wykonać `Abort`. Jednak aplikacja nie może wykryć tę sytuację.  
  
 Po `Abort` zostanie wywołana w wątku, obejmuje stan wątku <xref:System.Threading.ThreadState.AbortRequested>. Po zakończeniu wątku wyniku pomyślnego `Abort`, stan wątku jest zmieniany na <xref:System.Threading.ThreadState.Stopped>. Z wystarczającymi uprawnieniami, wątek to obiekt docelowy `Abort` można anulować przy użyciu przerwania `ResetAbort` metody. Aby uzyskać przykład, który demonstruje wywołanie `ResetAbort` metody, zobacz `ThreadAbortException` klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób przekazywania informacji do wątku, który jest przerywana.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek, który Trwa przerywanie jest aktualnie wstrzymana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Używanie wątków i wątkowości</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Niszczenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przydziela miejsce nienazwane danych we wszystkich wątkach. Lepszą wydajność, należy użyć pola, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>Przydzielony o nazwie gniazda danych we wszystkich wątkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Program .NET Framework zawiera dwa mechanizmy przy użyciu pamięci lokalnej wątku (TLS): względne wątkom pola statyczne (czyli tych pól, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu) i gniazda danych. Względne wątkom pola statyczne zapewnia znacznie lepszą wydajność niż gniazda danych i Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [wątku lokalnego magazynu: Względne wątkom pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Gniazdo jest przydzielany we wszystkich wątkach.  
  
 Wątki używany był mechanizm pamięci magazynu lokalnego do przechowywania danych specyficznych wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicy magazynu danych wielu miejsce, do każdego procesu, podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywania i pobierania danych wartość w gnieździe, a wolne miejsce do ponownego wykorzystania, po wygaśnięciu wątku. Gniazda danych są unikatowe dla wątku. Nie innego wątku (nawet wątek podrzędnych) można przekazać dane.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> atrybutu do przechowywania informacji specyficznych dla wątku. Drugi przykład pokazuje, jak zrobić to samo za pomocą gniazda danych.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> do przechowywania informacji specyficznych dla wątku. Ta metoda zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład kodu pokazuje, jak używać gniazda danych do przechowywania informacji specyficznych dla wątku.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokalny magazyn wątków: Względne wątkom pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych do przydzielenia.</param>
        <summary>Przydziela miejsce danych o podanej nazwie, we wszystkich wątkach. Lepszą wydajność, należy użyć pola, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>Przydzielony o nazwie gniazda danych we wszystkich wątkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Program .NET Framework zawiera dwa mechanizmy przy użyciu pamięci lokalnej wątku (TLS): względne wątkom pola statyczne (czyli tych pól, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu) i gniazda danych. Względne wątkom pola statyczne zapewnia znacznie lepszą wydajność niż gniazda danych i Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [wątku lokalnego magazynu: Względne wątkom pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki używany był mechanizm pamięci magazynu lokalnego do przechowywania danych specyficznych wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicy magazynu danych wielu miejsce, do każdego procesu, podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywania i pobierania danych wartość w gnieździe, a wolne miejsce do ponownego wykorzystania, po wygaśnięciu wątku. Gniazda danych są unikatowe dla wątku. Nie innego wątku (nawet wątek podrzędnych) można przekazać dane.  
  
 Nie jest konieczne użycie <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metodę, aby przydzielić miejsce danych o podanej nazwie, ponieważ <xref:System.Threading.Thread.GetNamedDataSlot%2A> — metoda przydziela miejsce, jeśli nie została już przydzielona.  
  
> [!NOTE]
>  Jeśli <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metoda jest używana, powinna zostać wywołana w wątku głównym, w momencie uruchamiania programu, ponieważ zgłasza wyjątek, jeśli w miejscu o określonej nazwie został już przydzielony. Nie istnieje żaden sposób, aby sprawdzić, czy miejsce została już przydzielona.  
  
 Gniazd przydzielonych przy użyciu tej metody musi być zwolniona przez <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> atrybutu do przechowywania informacji specyficznych dla wątku. Drugi przykład pokazuje, jak zrobić to samo za pomocą gniazda danych.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> do przechowywania informacji specyficznych dla wątku. Ta metoda zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład pokazuje, jak używać miejsca danych o podanej nazwie do przechowywania informacji specyficznych dla wątku.  
  
> [!NOTE]
>  Przykładowy kod nie używać <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metody, ponieważ <xref:System.Threading.Thread.GetNamedDataSlot%2A> — metoda przydziela miejsce, jeśli nie została już przydzielona. Jeśli <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metoda jest używana, powinien zostać wywołany w wątku głównym, w momencie uruchamiania programu.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Gniazdo danych o podanej nazwie, o określonej nazwie już istnieje.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokalny magazyn wątków: Względne wątkom pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia stan apartamentu tego wątku.</summary>
        <value>Jedną z <see cref="T:System.Threading.ApartmentState" /> wartości. Wartość początkowa to <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A> Właściwość jest przestarzała.**  Nieprzestarzała alternatywami są <xref:System.Threading.Thread.GetApartmentState%2A> metodę, aby pobrać stan apartamentu i <xref:System.Threading.Thread.SetApartmentState%2A> metodę, aby ustawić stan apartamentu.  
  
 W .NET Framework w wersji 1.0 i 1.1 `ApartmentState` właściwość oznacza wątku w celu wskazania, że wykona w apartamentu jednowątkowe lub wielowątkowych. Tę właściwość można ustawić, gdy wątek jest w `Unstarted` lub `Running` wątek stanie; jednak może zostać ustawiony tylko raz dla wątku. Jeśli właściwość nie została ustawiona, zwraca `Unknown`.  
  
 Próba użycia <xref:System.Threading.Thread.ApartmentState%2A> właściwość można ustawić stan apartamentu wątku, w których stan apartamentu został już ustawiony jest ignorowana. Jednak <xref:System.Threading.Thread.SetApartmentState%2A> metoda zgłasza wyjątek <xref:System.InvalidOperationException> w tym przypadku.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 2.0, nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stan apartamentu nie została ustawiona, zanim zostaną uruchomione. Głównego wątku aplikacji jest inicjowany do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie. Nie można ustawić wątku głównego aplikacji na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> , ustawiając <xref:System.Threading.ApartmentState?displayProperty=nameWithType> właściwość w pierwszym wierszu kodu. Użyj <xref:System.STAThreadAttribute> zamiast tego.  
  
 W .NET Framework w wersji 2.0, można określić model wątkowości COM dla aplikacji C++ za pomocą [/CLRTHREADATTRIBUTE (Ustaw wątku atrybut CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) — opcja konsolidatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można ustawić stan apartamentu wątku.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Zostanie podjęta próba, aby ustawić tę właściwość do stanu, który nie jest to stan apartamentu nieprawidłowy (stan innych niż jednowątkowym apartamentem (<see langword="STA" />) lub wielowątkowe apartamentu (<see langword="MTA" />)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, że wykonanie zostanie regionu kodu, w którym przerwanie wątku lub nieobsługiwany wyjątek mogłyby zagrozić innych zadań w domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosty środowisko uruchomieniowe języka wspólnego (CLR), takich jak Microsoft SQL Server 2005, można ustanowić różnych zasad pod kątem błędów krytyczne i niekrytyczne regiony kodu. Krytyczne region jest jeden w którym skutków przerwanie wątku lub nieobsługiwany wyjątek nie może być ograniczona do bieżącego zadania. Z drugiej strony przerwania lub niepowodzenia w regionie niekrytyczne kodu ma wpływ na zadania, w której występuje błąd.  
  
 Rozważmy na przykład zadanie, które próbuje przydzielić pamięci podczas utrzymywania blokady. Jeśli alokacja pamięci nie powiedzie się, przerywanie bieżącego zadania nie jest wystarczająca, aby zapewnić trwałość <xref:System.AppDomain>, ponieważ w domenie, oczekujący na blokadę tego samego mogą być inne zadania. Jeśli bieżące zadanie jest zakończone, można zakleszczone innych zadań.  
  
 Gdy wystąpi awaria w regionie krytycznych, host może podjąć decyzję o zwolnić całej <xref:System.AppDomain> zamiast zaryzykować i kontynuowanie wykonywania w potencjalnie niestabilnym stanie. Aby informuje hosta, że Twój kod wchodzi krytyczne regionu, należy wywołać <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Wywołaj <xref:System.Threading.Thread.EndCriticalRegion%2A> gdy wykonywanie powraca do zastosowania niekrytyczne obszar kodu.  
  
 Za pomocą tej metody w kodzie, który jest uruchamiany w ramach programu SQL Server 2005 wymaga kodu do uruchomienia na najwyższy poziom ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> metody dzielenia bloku kodu na krytyczne i niekrytyczne regionów.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informuje, że ma wykonać instrukcje, które są zależne od tożsamość bieżącego wątku systemu operacyjnego fizycznego hosta, który kodu zarządzanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre hosty środowisko uruchomieniowe języka wspólnego, takich jak Microsoft SQL Server 2005, podaj własne zarządzanie wątkami. Hosta, który udostępnia swoje własne zarządzanie wątkami można przenieść wykonywanie zadań z jednego wątku systemu operacyjnego fizycznego w dowolnym momencie. Większość zadań nie dotyczy to przełączanie. Jednak niektóre zadania pozostają w koligacji wątku — oznacza to, że są one zależne od tożsamość wątku fizycznego systemu operacyjnego. Te zadania, musi powiadomić hosta podczas ich wykonywania kodu, który nie powinien być przełączane.  
  
 Jeśli na przykład blokowanie wywołania aplikacji interfejsu API systemu można uzyskać systemu operacyjnego mającego koligacji wątku, takich jak Win32 CRITICAL_SECTION, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskiwania blokady, a <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnienie blokady.  
  
 Za pomocą tej metody w kodzie, który jest uruchamiany w ramach programu SQL Server 2005 wymaga kodu do uruchomienia na najwyższy poziom ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> i <xref:System.Threading.Thread.EndThreadAffinity%2A> metody w celu powiadomienia hosta, który bloku kodu zależy od tożsamość wątku fizycznego systemu operacyjnego.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący kontekst, w którym wykonywany jest wątek.</summary>
        <value>A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> reprezentujący bieżący kontekst wątku.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kulturę bieżącego wątku.</summary>
        <value>Obiekt, który reprezentuje kulturę bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Obiektu, który jest zwracany przez tę właściwość, wraz z jego skojarzone obiekty określenia domyślnego formatu daty, godziny, numery, wartości waluty, sortowanie kolejność tekstu, wielkość liter konwencje i porównywania ciągów. Zobacz <xref:System.Globalization.CultureInfo> klasy, aby dowiedzieć się więcej o nazwy i identyfikatory i różnice między niezmienne, neutralne i nacechowane kultury i informacji o kulturze sposób wpływa na wątki i domen aplikacji. Zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości, aby dowiedzieć się sposób ustalania kultury domyślnej dla wątku i jak użytkownicy ustawić informacje o ustawieniach kulturowych na swoich komputerach.  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture> Właściwości nie działa niezawodnie, gdy jest używane z żadnym z wątków niż bieżący wątek. W programie .NET Framework odczytu właściwości jest wiarygodna, mimo że ustawienie dla wątku niż bieżący wątek nie jest. Na platformie .NET Core <xref:System.InvalidOperationException> jest generowany, jeśli wątek podejmuje próbę odczytu lub zapisu <xref:System.Threading.Thread.CurrentCulture> właściwości w innym wątku.
> Firma Microsoft zaleca użycie <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> właściwości, aby pobrać i ustawić bieżącej kultury.

 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], można ustawić <xref:System.Threading.Thread.CurrentCulture%2A> właściwości kultury neutralnej. Jest to spowodowane zachowanie <xref:System.Globalization.CultureInfo> zmienił klasy: Gdy reprezentuje kultury neutralnej wartości właściwości (w szczególności <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, i <xref:System.Globalization.CultureInfo.TextInfo%2A> właściwości) uwzględniają określonej kultury, który jest skojarzony z wykorzystaniem kultury neutralnej. We wcześniejszych wersjach programu .NET Framework <xref:System.Threading.Thread.CurrentCulture%2A> zgłosił właściwość <xref:System.NotSupportedException> wyjątek, jeśli przypisano kultury neutralnej.  
  
## Examples  
 Poniższy przykład pokazuje wątkowości instrukcji, która zezwala na interfejsie użytkownika aplikacji Windows Forms do wyświetlenia w kulturze, który jest ustawiony w Panelu sterowania. Dodatkowy kod jest wymagany.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Tylko .NET core: Odczyt lub zapis kultury wątku z innego wątku nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do ustawiania właściwości. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący podmiot zabezpieczeń dla wątku (w przypadku opartej na rolach zabezpieczeń).</summary>
        <value><see cref="T:System.Security.Principal.IPrincipal" /> Reprezentującą kontekst zabezpieczeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób ustawiania i pobierania jednostki wątku.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień, aby ustawić podmiot zabezpieczeń.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby manipulować głównym przedmiotem. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktualnie uruchomionemu wątkowi.</summary>
        <value>A <see cref="T:System.Threading.Thread" /> oznacza to reprezentacja aktualnie uruchomionemu wątkowi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy zadanie, które z kolei tworzy 20 zadań podrzędnych. Aplikacja, jak również każdego zadania wywołuje `ShowThreadInformation` metodę, która używa <xref:System.Threading.Thread.CurrentThread%2A> właściwość do wyświetlenia informacji na temat wątku, na którym jest uruchomiony.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Każde zadanie podrzędne generuje 1 milion losowych liczb od 1 do 1 mln i zwraca ich wartości średniej. Wywołuje zadanie nadrzędne <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodę, aby upewnić się, że zadania podrzędne zostały ukończone przed wyświetleniem średniej zwracany przez każde zadanie podrzędne i obliczania średniej oznacza, że.  
  
 Należy pamiętać, że gdy aplikacja zostanie uruchomiona w wątku na pierwszym planie, każde zadanie podrzędne uruchamia się na wątku z puli wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą kulturę używaną przez Menedżera zasobów do wyszukiwania w czasie wykonywania zasoby specyficzne dla kultury.</summary>
        <value>Obiekt, który reprezentuje bieżącą kulturę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kultura interfejsu użytkownika określa zasoby, aplikacja musi obsługiwać dane wejściowe użytkownika i danych wyjściowych i domyślnie jest taka sama jak kultury systemu operacyjnego. Zobacz <xref:System.Globalization.CultureInfo> klasy, aby dowiedzieć się więcej o nazwy i identyfikatory i różnice między niezmienne, neutralne i nacechowane kultury i informacji o kulturze sposób wpływa na wątki i domen aplikacji. Zobacz <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości, aby dowiedzieć się, jak kultura interfejsu użytkownika domyślnego dla wątku jest określana.  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentUICulture> Właściwości nie działa niezawodnie, gdy jest używane z żadnym z wątków niż bieżący wątek. W programie .NET Framework odczytu właściwości jest wiarygodna, mimo że ustawienie dla wątku niż bieżący wątek nie jest. Na platformie .NET Core <xref:System.InvalidOperationException> jest generowany, jeśli wątek podejmuje próbę odczytu lub zapisu <xref:System.Threading.Thread.CurrentUICulture> właściwości w innym wątku.
> Firma Microsoft zaleca użycie <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> właściwości, aby pobrać i ustawić bieżącej kultury.

 <xref:System.Globalization.CultureInfo> Zwracane przez tę właściwość można kultury neutralnej. Nie należy używać kultury neutralnej za pomocą metod formatowania, takich jak <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, i <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Użyj <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> metodę, aby pobrać określoną kulturę, lub użyj <xref:System.Threading.Thread.CurrentCulture%2A> właściwości.  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Metoda zgłasza wyjątek <xref:System.ArgumentException> dla kultury neutralnej "zh-Hant" ("zh-CHT") i "zh-Hans" ("zh-CHS").  
  
   
  
## Examples  
 Poniższy przykład określa, czy język bieżący wątek kultury interfejsu użytkownika jest francuski. Jeśli nie jest, ustawia kulturę bieżącego wątku interfejsu użytkownika do języka angielskiego (Stany Zjednoczone).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Poniższy przykład kodu pokazuje wątkowości instrukcji, która umożliwia interfejsu użytkownika formularzy Windows w celu wyświetlenia w kulturze, który jest ustawiony w Panelu sterowania. Dodatkowy kod jest wymagany.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nazwa kultury, która nie może być używana do lokalizowania plików zasobów jest właściwością. W nazwach plików zasobów mogą zawierać wyłącznie litery, cyfry, łączniki i podkreślenia.</exception>
        <exception cref="T:System.InvalidOperationException">Tylko .NET core: Odczyt lub zapis kultury wątku z innego wątku nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje wyłączenie automatycznego czyszczenia wywoływanych otok środowiska uruchomieniowego (RCW) dla bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie środowisko uruchomieniowe języka wspólnego (CLR), które utraciły wywoływanych otok środowiska uruchomieniowego automatycznie. Komunikaty pomp CLR podczas oczyszczania, co może prowadzić do problemów współużytkowania wątkowości kilka aplikacji, które spełniają następujące kryteria nietypowe:  
  
-   Aplikacja wykonuje swoje własne przekazywanie komunikatów.  
  
-   Aplikacja musi kontrolować dokładnie sytuacji przekazywanie komunikatów.  
  
 Takie aplikacje mogą używać <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> metodę, aby uniemożliwić wykonywanie automatyczne odzyskiwanie plików wykonywalnych wywoływanych otok przez środowisko CLR.  
  
 Gdy ta metoda została wywołana w wątku, automatycznego oczyszczania nie może być ponownie włączone dla tego wątku. Jeśli aplikacja jest gotowa do oczyszczenia wywoływanych otok środowiska uruchomieniowego, użyj <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> metodę, aby nakazać środowiska uruchomieniowego, aby wyczyścić wszystkie wywoływanych otok środowiska uruchomieniowego w bieżącym kontekście. Przekazywanie komunikatów występuje, gdy metoda jest wykonywana.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, że wykonanie zostanie regionu kodu, w którym są ograniczone do bieżącego zadania przerwanie wątku lub nieobsługiwany wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosty środowisko uruchomieniowe języka wspólnego (CLR), takich jak Microsoft SQL Server 2005, można ustanowić różnych zasad pod kątem błędów krytyczne i niekrytyczne regiony kodu. Krytyczne region jest jeden w którym skutków przerwanie wątku lub nieobsługiwany wyjątek nie może być ograniczona do bieżącego zadania. Z drugiej strony przerwania lub niepowodzenia w regionie niekrytyczne kodu ma wpływ na zadania, w której występuje błąd.  
  
 Rozważmy na przykład zadanie, które próbuje przydzielić pamięci podczas utrzymywania blokady. Jeśli alokacja pamięci nie powiedzie się, przerywanie bieżącego zadania nie jest wystarczająca, aby zapewnić trwałość <xref:System.AppDomain>, ponieważ w domenie, oczekujący na blokadę tego samego mogą być inne zadania. Jeśli bieżące zadanie jest zakończone, można zakleszczone innych zadań.  
  
 Gdy wystąpi awaria w regionie krytycznych, host może podjąć decyzję o zwolnić całej <xref:System.AppDomain> zamiast zaryzykować i kontynuowanie wykonywania w potencjalnie niestabilnym stanie. Aby informuje hosta, że Twój kod wchodzi krytyczne regionu, należy wywołać <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Wywołaj <xref:System.Threading.Thread.EndCriticalRegion%2A> gdy wykonywanie powraca do zastosowania niekrytyczne obszar kodu.  
  
 Za pomocą tej metody w kodzie, który jest uruchamiany w ramach programu SQL Server 2005 wymaga kodu do uruchomienia na najwyższy poziom ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> metody dzielenia bloku kodu na krytyczne i niekrytyczne regionów.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, który zarządzanego kodu zostało zakończone, wykonywania instrukcji, które są zależne od tożsamość bieżącego wątku fizycznego systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre hosty środowisko uruchomieniowe języka wspólnego, takich jak Microsoft SQL Server 2005, podaj własne zarządzanie wątkami. Hosta, który udostępnia swoje własne zarządzanie wątkami można przenieść wykonywanie zadań z jednego wątku systemu operacyjnego fizycznego w dowolnym momencie. Większość zadań nie dotyczy to przełączanie. Jednak niektóre zadania pozostają w koligacji wątku — oznacza to, że są one zależne od tożsamość wątku fizycznego systemu operacyjnego. Te zadania, musi powiadomić hosta podczas ich wykonywania kodu, który nie powinien być przełączane.  
  
 Jeśli na przykład blokowanie wywołania aplikacji interfejsu API systemu można uzyskać systemu operacyjnego mającego koligacji wątku, takich jak Win32 CRITICAL_SECTION, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskiwania blokady, a <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnienie blokady.  
  
 Za pomocą tej metody w kodzie, który jest uruchamiany w ramach programu SQL Server 2005 wymaga kodu do uruchomienia na najwyższy poziom ochrony hosta.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> i <xref:System.Threading.Thread.EndThreadAffinity%2A> metody w celu powiadomienia hosta, który bloku kodu zależy od tożsamość wątku fizycznego systemu operacyjnego.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.ExecutionContext" /> obiekt, który zawiera informacje na temat różnych kontekstach bieżącego wątku.</summary>
        <value><see cref="T:System.Threading.ExecutionContext" /> Obiekt, który konsoliduje informacje o kontekście dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext> Klasa udostępnia jeden kontener dla wszystkich informacji dotyczących logiczne wątek wykonywania. Obejmuje to kontekst zabezpieczeń, kontekst wywołania, kontekst synchronizacji, lokalizacja kontekstu i kontekst transakcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że zasoby są zwalniane, a inne operacje oczyszczania są wykonywane, gdy moduł odśmiecania pamięci odzyskuje <see cref="T:System.Threading.Thread" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł odśmiecania pamięci wywołuje <xref:System.Threading.Thread.Finalize%2A> kiedy bieżący obiekt jest gotowy do można sfinalizować.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych ma zostać zwolniony.</param>
        <summary>Eliminuje skojarzenie między nazwę i miejsce, aby uzyskać wszystkie wątki w procesie. Lepszą wydajność, należy użyć pola, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Program .NET Framework zawiera dwa mechanizmy przy użyciu pamięci lokalnej wątku (TLS): względne wątkom pola statyczne (czyli tych pól, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu) i gniazda danych. Względne wątkom pola statyczne zapewnia znacznie lepszą wydajność niż gniazda danych i Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [wątku lokalnego magazynu: Względne wątkom pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Po dowolny wątek jest wywołany `FreeNamedDataSlot`, wątek, który wywołuje <xref:System.Threading.Thread.GetNamedDataSlot%2A> o takiej samej nazwie spowoduje przydzielenie nowe gniazdo skojarzone z nazwą. Kolejne wywołania `GetNamedDataSlot` w żadnym z wątków zwróci nowe miejsce. Jednak żadnym z wątków, środki, nieopłacone <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> zwrócony przez podczas wcześniejszego wywołania `GetNamedDataSlot` nadal używać starego miejsca.  
  
 Miejsca, które zostało skojarzone z nazwą jest zwalniany tylko wtedy, gdy każdy `LocalDataStoreSlot` uzyskany przed wywołaniem do `FreeNamedDataSlot` został zwolniony i zebranych elementów bezużytecznych.  
  
 Wątki używany był mechanizm pamięci magazynu lokalnego do przechowywania danych specyficznych wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicy magazynu danych wielu miejsce, do każdego procesu, podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywania i pobierania danych wartość w gnieździe, a wolne miejsce do ponownego wykorzystania, po wygaśnięciu wątku. Gniazda danych są unikatowe dla wątku. Nie innego wątku (nawet wątek podrzędnych) można przekazać dane.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> atrybutu do przechowywania informacji specyficznych dla wątku. Drugi przykład pokazuje, jak zrobić to samo za pomocą gniazda danych.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> do przechowywania informacji specyficznych dla wątku. Ta metoda zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład pokazuje, jak używać miejsca danych o podanej nazwie do przechowywania informacji specyficznych dla wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokalny magazyn wątków: Względne wątkom pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Threading.ApartmentState" /> wartość wskazującą stan apartamentu.</summary>
        <returns>Jedną z <see cref="T:System.Threading.ApartmentState" /> wartości, wskazującą stan apartamentu wątków zarządzanych. Wartość domyślna to <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody wraz z <xref:System.Threading.Thread.SetApartmentState%2A> metody i <xref:System.Threading.Thread.TrySetApartmentState%2A> zastępuje metodę <xref:System.Threading.Thread.ApartmentState%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody. Przykład kodu tworzy wątek. Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stan apartamentu została już ustawiona. Jeśli w tej samej operacji miał zostanie podjęta określona za pomocą <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> będzie zgłaszany.  
  
 Po rozpoczęciu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> metoda jest używana ponownie. Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek jest już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Threading.CompressedStack" /> obiektu, który może służyć do przechwytywania stosu dla bieżącego wątku.</summary>
        <returns>Brak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest już obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="slot"><see cref="T:System.LocalDataStoreSlot" /> z którego można pobrać wartości.</param>
        <summary>Pobiera wartość z określonego miejsca w bieżącym wątku, w bieżącej domenie bieżącego wątku. Lepszą wydajność, należy użyć pola, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>Pobrana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Program .NET Framework zawiera dwa mechanizmy przy użyciu pamięci lokalnej wątku (TLS): względne wątkom pola statyczne (czyli tych pól, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu) i gniazda danych. Względne wątkom pola statyczne zapewnia znacznie lepszą wydajność niż gniazda danych i Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [wątku lokalnego magazynu: Względne wątkom pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki używany był mechanizm pamięci magazynu lokalnego do przechowywania danych specyficznych wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicy magazynu danych wielu miejsce, do każdego procesu, podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywania i pobierania danych wartość w gnieździe, a wolne miejsce do ponownego wykorzystania, po wygaśnięciu wątku. Gniazda danych są unikatowe dla wątku. Nie innego wątku (nawet wątek podrzędnych) można przekazać dane.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> jest `Shared` metodę, która zawsze ma zastosowanie do aktualnie wykonywany wątek, nawet jeśli wywołasz ją za pomocą zmiennej, która odwołuje się do innego wątku. Aby uniknąć nieporozumień, użyj nazwy klasy podczas wywoływania `Shared` metody: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> atrybutu do przechowywania informacji specyficznych dla wątku. Drugi przykład pokazuje, jak zrobić to samo za pomocą gniazda danych.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> do przechowywania informacji specyficznych dla wątku. Ta metoda zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład pokazuje, jak używać gniazda danych do przechowywania informacji specyficznych dla wątku.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokalny magazyn wątków: Względne wątkom pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca bieżąca domena, w której bieżący wątek jest uruchomiony.</summary>
        <returns><see cref="T:System.AppDomain" /> Reprezentujący bieżącej domeny aplikacji uruchomionemu wątkowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać nazwy i Identyfikatora `AppDomain` , w którym jest uruchomiona w wątku.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca unikatowy identyfikator domeny.</summary>
        <returns>32-bitowych całkowita unikatowo identyfikujący domeny aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać nazwy i Identyfikatora `AppDomain` , w którym jest uruchomiona w wątku.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wątku.</summary>
        <returns>Wartość całkowita kod skrótu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość skrótu nie musi być unikatowa. Użyj <xref:System.Threading.Thread.ManagedThreadId%2A> właściwość, jeśli potrzebujesz Unikatowy identyfikator dla wątków zarządzanych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych lokalnych.</param>
        <summary>Wyszukuje gniazdo danych o podanej nazwie. Lepszą wydajność, należy użyć pola, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <returns>A <see cref="T:System.LocalDataStoreSlot" /> przydzielone dla tego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Program .NET Framework zawiera dwa mechanizmy przy użyciu pamięci lokalnej wątku (TLS): względne wątkom pola statyczne (czyli tych pól, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu) i gniazda danych. Względne wątkom pola statyczne zapewnia znacznie lepszą wydajność niż gniazda danych i Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [wątku lokalnego magazynu: Względne wątkom pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki używany był mechanizm pamięci magazynu lokalnego do przechowywania danych specyficznych wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicy magazynu danych wielu miejsce, do każdego procesu, podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywania i pobierania danych wartość w gnieździe, a wolne miejsce do ponownego wykorzystania, po wygaśnięciu wątku. Gniazda danych są unikatowe dla wątku. Nie innego wątku (nawet wątek podrzędnych) można przekazać dane.  
  
 Jeśli miejsce o nazwie nie istnieje, jest przydzielany nowe miejsce. Gniazda danych o nazwie były publiczne i mogą być zmieniane przez dowolną osobę.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> atrybutu do przechowywania informacji specyficznych dla wątku. Drugi przykład pokazuje, jak zrobić to samo za pomocą gniazda danych.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> do przechowywania informacji specyficznych dla wątku. Ta metoda zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład pokazuje, jak używać miejsca danych o podanej nazwie do przechowywania informacji specyficznych dla wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokalny magazyn wątków: Względne wątkom pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przerywa działanie wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> stan wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten wątek nie jest obecnie zablokowany w oczekiwania, uśpiony lub stanu dołączania do, zostanie przerwane, gdy następnie rozpoczyna się do blokowania.  
  
 <xref:System.Threading.ThreadInterruptedException> jest zgłaszany w przerwanego wątku, ale nie do bloków wątku. Jeśli wątek nigdy nie blokuje, nigdy nie jest zgłaszany wyjątek, i dlatego wątek może wykonać bez kiedykolwiek przerwane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie uruchomionego wątku, gdy zostało przerwane, a następnie zostanie zablokowane.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniego <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Wstrzymywanie i przerywanie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą stan wykonania bieżącego wątku.</summary>
        <value><see langword="true" /> Jeśli ten wątek został uruchomiony, a nie zostało zakończone normalnie lub zostało przerwane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wątek jest wątku w tle.</summary>
        <value><see langword="true" /> Jeśli tego wątku lub wątku w tle; staje się w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek jest wątku w tle lub wątku na pierwszym planie. Wątków w tle są identyczne z wątki pierwszoplanowe, z tą różnicą, że wątków w tle uniemożliwia zakończenie procesu. Gdy wszystkie wątki pierwszoplanowe należących do procesu zostały zakończone, środowisko uruchomieniowe języka wspólnego kończy proces. Wszystkie pozostałe wątków w tle zostaną zatrzymane, a nie zakończą się.  
  
 Domyślnie następujące wątki są wykonywane na pierwszym planie (oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> właściwość zwraca `false`):  
  
-   Wątek główny (lub wątku głównego aplikacji).  
  
-   Wszystkie wątki, utworzonych przez wywoływanie <xref:System.Threading.Thread> konstruktora klasy.  
  
 Domyślnie następujące wątki są wykonywane w tle (oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> właściwość zwraca `true`):  
  
-   Wątek puli wątków, które puli wątków roboczych utrzymywane przez środowisko uruchomieniowe. Wątek puli i harmonogram pracy można skonfigurować na wątków z puli wątków, przy użyciu <xref:System.Threading.ThreadPool> klasy.  
  
    > [!NOTE]
    >  Oparta na zadaniach asynchronicznej operacji automatycznie wykonać na wątków z puli wątków.  
  
-   Wszystkie wątki, które wprowadzać środowiska wykonawczego zarządzanych z niezarządzanego kodu.  
  
   
  
## Examples  
 Poniższy przykład różni się znacząco zachowanie wątki pierwszego planu i tła. Tworzy on wątku na pierwszym planie i wątku w tle. Wątku na pierwszym planie utrzymuje proces uruchomiony, dopóki nie ukończy jego `for` pętli i kończy. Jednak dane wyjściowe z przykładu pokazują, ponieważ wątku na pierwszym planie zakończył wykonanie, proces zostanie zakończony przed wątku w tle zakończyła wykonanie.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek jest nieaktywny.</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">Wątki pierwszego planu i tła</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wątek należy do puli wątków zarządzanych.</summary>
        <value><see langword="true" /> Jeśli ten wątek należy do puli wątków zarządzanych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [zarządzana Pula wątków](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustalić, czy wątek jest z puli wątków.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje wątek wywołujący, aż do zakończenia wątku, reprezentowane przez to wystąpienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje wątek wywołujący, aż do zakończenia wątku, reprezentowane przez to wystąpienie, przy jednoczesnym dalszym wykonać standardowe COM i <see langword="SendMessage" /> przekazywanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> jest to metoda synchronizacji, która blokuje wątek wywołujący (oznacza to, że wątek, który wywołuje metodę), aż wątek którego <xref:System.Threading.Thread.Join%2A> wywoływana jest metoda została zakończona. Użyj tej metody, aby upewnić się, że wątek został zakończony. Obiekt wywołujący zablokuje przez czas nieokreślony, jeśli wątek nie skończył się. W poniższym przykładzie `Thread1` wątek jest wywołany <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` do bloku, dopóki nie `Thread2` zostało zakończone.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.  
  
> [!WARNING]
>  Nigdy nie powinien wywoływać <xref:System.Threading.Thread.Join%2A> metody <xref:System.Threading.Thread> obiekt, który reprezentuje bieżący wątek z bieżącego wątku. Powoduje to, że aplikacja zawieszenie, ponieważ bieżący wątek czeka sam przez czas nieokreślony,  
  
 Ta metoda zmienia stan wątku wywołującego do uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Obiekt wywołujący próbował Dołącz do wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanu.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek jest przerwany podczas oczekiwania.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania na zakończenie wątku.</param>
        <summary>Blokuje wątek wywołujący, aż do zakończenia wątku, reprezentowane przez to wystąpienie lub określonego czasu upływa przerywając do wykonywania standardowych COM i SendMessage przekazywanie.</summary>
        <returns><see langword="true" /> Jeśli wątek został zakończony; <see langword="false" /> Jeśli wątek nie został zakończony po upływie czasu określonego przez <paramref name="millisecondsTimeout" /> upłynął parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> jest to metoda synchronizacji, która blokuje wątek wywołujący (oznacza to, że wątek, który wywołuje metodę), aż wątek albo którego <xref:System.Threading.Thread.Join%2A> metoda jest wywoływana zostało ukończone lub upłynął limit czasu. W poniższym przykładzie `Thread1` wątek jest wywołany <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` bądź do blokowania `Thread2` zostało ukończone lub upłynie 2 sekundy.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jest określona dla `millisecondsTimeout` parametr, Metoda ta działa identycznie do <xref:System.Threading.Thread.Join> przeciążenia metody, z wyjątkiem wartość zwracaną.  
  
 Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.  
  
 Ta metoda zmienia stan wątku wywołującego do uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> w milisekundach.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> równa ilość czasu oczekiwania na zakończenie wątku.</param>
        <summary>Blokuje wątek wywołujący, aż do zakończenia wątku, reprezentowane przez to wystąpienie lub określonego czasu upływa przerywając do wykonywania standardowych COM i SendMessage przekazywanie.</summary>
        <returns><see langword="true" /> Jeśli wątek się zakończył; <see langword="false" /> Jeśli wątek nie został zakończony po upływie czasu określonego przez <paramref name="timeout" /> upłynął parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> jest to metoda synchronizacji, która blokuje wątek wywołujący (oznacza to, że wątek, który wywołuje metodę), aż wątek albo którego <xref:System.Threading.Thread.Join%2A> metoda jest wywoływana zostało ukończone lub upłynął limit czasu. W poniższym przykładzie `Thread1` wątek jest wywołany <xref:System.Threading.Thread.Join> metody `Thread2`, co powoduje, że `Thread1` bądź do blokowania `Thread2` zostało ukończone lub upłynie 2 sekundy.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jest określona dla `timeout`, Metoda ta działa identycznie do <xref:System.Threading.Thread.Join> przeciążenia metody, z wyjątkiem wartość zwracaną.  
  
 Jeśli wątek został już zakończony podczas <xref:System.Threading.Thread.Join%2A> jest wywoływana metoda zwraca natychmiast.  
  
 Ta metoda zmienia stan bieżący wątek, aby uwzględnić <xref:System.Threading.ThreadState.WaitSleepJoin>. Nie można wywołać `Join` w wątku, który znajduje się w <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> stanu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania `TimeSpan` wartością `Join` metody.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (w milisekundach), lub jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Obiekt wywołujący próbował Dołącz do wątku, który znajduje się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanu.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla bieżącego wątku zarządzanych.</summary>
        <value>Liczba całkowita, która reprezentuje unikatowy identyfikator dla tego wątku zarządzanych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek <xref:System.Threading.Thread.ManagedThreadId%2A> wartość właściwości służy do jednoznacznego identyfikowania wątek w ramach procesu.  
  
 Wartość <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości nie różnią się wraz z upływem czasu, nawet wtedy, gdy kod niezarządzany, który hostuje środowisko uruchomieniowe języka wspólnego implementuje wątek jako włókien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronizuje dostęp do pamięci w następujący sposób: Procesor wykonywanie bieżącego wątku nie można zmienić kolejności instrukcje w taki sposób, że pamięć uzyskuje dostęp do przed wywołaniem do <see cref="M:System.Threading.Thread.MemoryBarrier" /> wykonaj po dostępy do pamięci, które należy wykonać wywołanie <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> jest wymagany tylko w systemach wieloprocesorowych pamięci słabe porządkowanie (na przykład system, w których zastosowano wiele procesorów Intel Itanium).  
  
 W większości przypadków języka C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji lub <xref:System.Threading.Monitor> klasy umożliwiają łatwiejsze do synchronizacji danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wątku.</summary>
        <value>Ciąg zawierający nazwę wątku, lub <see langword="null" /> Jeśli nazwa nie została ustawiona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zapisu — po. Ponieważ wartość domyślną dla wątku <xref:System.Threading.Thread.Name%2A> właściwość `null`, można określić, czy nazwy został już jawnie przypisany do wątku, porównując ją za pomocą `null`.  
  
 Ciąg znaków, przypisany do <xref:System.Threading.Thread.Name%2A> właściwość może zawierać żadnych znaków Unicode.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak nazwę wątku.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zażądano operacji zestawu, ale <see langword="Name" /> właściwość została już ustawiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą planowania priorytet wątku.</summary>
        <value>Jedną z <see cref="T:System.Threading.ThreadPriority" /> wartości. Wartość domyślna to <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek można przypisać dowolny z następujących — priorytet <xref:System.Threading.ThreadPriority> wartości:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Systemy operacyjne nie muszą przestrzegać priorytet wątku.  
  
   
  
## Examples  
 Poniższy przykład pokazuje wynik zmiana priorytetu wątku. Trzy wątki nie są tworzone, priorytet jeden wątek jest ustawiona na <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, i ustawiono priorytet sekundy <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Każdy wątek zwiększa wartość zmiennej w `while` pętli i uruchamia na określony czas.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek osiągnęło stan końcowy, takich jak <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla operacji zestawu nie jest prawidłowym <see cref="T:System.Threading.ThreadPriority" /> wartość.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">Harmonogram wątków</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje <see cref="M:System.Threading.Thread.Abort(System.Object)" /> żądane dla bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywołana tylko przez kod z odpowiednimi uprawnieniami.  
  
 Gdy połączenie jest nawiązywane w przypadku `Abort` , aby zakończyć wątek, system generuje <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` specjalne wyjątek, który może zostać przechwycony przez kod aplikacji, ale jest zgłaszany ponownie na końcu bloku catch, chyba że `ResetAbort` jest wywoływana. `ResetAbort` anuluje żądanie do przerwania i zapobiega `ThreadAbortException` z zakończenie wątku.  
  
 Zobacz <xref:System.Threading.ThreadAbortException> dla przykładu, który demonstruje wywołanie `ResetAbort` metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Threading.ThreadStateException"><see langword="Abort" /> nie została wywołana w bieżącym wątku.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień zabezpieczeń dla bieżącego wątku.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Niszczenie wątków</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia działanie wątku, która została zawieszona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Nie używaj <xref:System.Threading.Thread.Suspend%2A> i <xref:System.Threading.Thread.Resume%2A> metody, aby zsynchronizować działania wątków. Nie ma możliwości określenia, jaki kod w wątku jest wykonywany, gdy zostanie zawieszone. Jeśli wątek zostanie zawieszone, gdy posiada blokady podczas oceny uprawnień zabezpieczeń, inne wątki w <xref:System.AppDomain> może zostać zablokowany. Jeśli podczas wykonywania konstruktora klasy zawieszenie wątku, inne wątki w <xref:System.AppDomain> , podejmują próbę użycia, że klasy są blokowane. Zakleszczenia mogą wystąpić w bardzo prosty sposób.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony, jest nieaktywny lub nie znajduje się w stanie wstrzymania.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniego <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje na wątkach. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Wstrzymywanie i przerywanie wątków</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="state">Nowy stan apartamentu.</param>
        <summary>Ustawia stan apartamentu wątku, przed jej ponownym uruchomieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stan apartamentu nie została ustawiona, zanim zostaną uruchomione. Stan apartamentu musi być ustawiona przed uruchomieniem wątku.  
  
> [!NOTE]
>  Głównego wątku aplikacji jest inicjowany do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie. Jedynym sposobem, aby ustawić stan apartamentu wątku głównego aplikacji, aby <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> polega na zastosowaniu <xref:System.STAThreadAttribute> atrybutu do metody punktu wejścia.  
  
 <xref:System.Threading.Thread.SetApartmentState%2A> Metody, wraz z <xref:System.Threading.Thread.GetApartmentState%2A> metody i <xref:System.Threading.Thread.TrySetApartmentState%2A> zastępuje metodę <xref:System.Threading.Thread.ApartmentState%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody. Przykład kodu tworzy wątek. Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stan apartamentu została już ustawiona. Jeśli w tej samej operacji miał zostanie podjęta określona za pomocą <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> będzie zgłaszany.  
  
 Po rozpoczęciu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> metoda jest używana ponownie. Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek jest już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Ten element członkowski nie jest obsługiwana w systemach macOS i platformy Linux.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> nie jest stan apartamentu prawidłowe.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek już został uruchomiony.</exception>
        <exception cref="T:System.InvalidOperationException">Stan apartamentu został już zainicjowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stack"><see cref="T:System.Threading.CompressedStack" /> Obiektów, które mają być stosowane do bieżącego wątku.</param>
        <summary>Stosuje przechwyconych <see cref="T:System.Threading.CompressedStack" /> w bieżącym wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest już obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="slot"><see cref="T:System.LocalDataStoreSlot" /> w którym można ustawić wartości.</param>
        <param name="data">Wartość do ustawienia.</param>
        <summary>Ustawia dane w miejscu określonym na aktualnie uruchomionemu wątkowi, dla bieżącej domeny dla wątku. Lepszą wydajność, należy użyć pola oznaczone <see cref="T:System.ThreadStaticAttribute" /> zamiast tego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Program .NET Framework zawiera dwa mechanizmy przy użyciu pamięci lokalnej wątku (TLS): względne wątkom pola statyczne (czyli tych pól, które są oznaczone <xref:System.ThreadStaticAttribute> atrybutu) i gniazda danych. Względne wątkom pola statyczne zapewnia znacznie lepszą wydajność niż gniazda danych i Włącz sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z protokołu TLS, zobacz [wątku lokalnego magazynu: Względne wątkom pola statyczne i gniazda danych](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Wątki używany był mechanizm pamięci magazynu lokalnego do przechowywania danych specyficznych wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicy magazynu danych wielu miejsce, do każdego procesu, podczas jego tworzenia. Wątku można przydzielić miejsce danych w magazynie danych, przechowywania i pobierania danych wartość w gnieździe, a wolne miejsce do ponownego wykorzystania po zakończeniu procedury wątku i <xref:System.Threading.Thread> obiekt został odzyskany przez wyrzucanie elementów bezużytecznych. Gniazda danych są unikatowe dla wątku. Nie innego wątku (nawet wątek podrzędnych) można przekazać dane.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> jest `Shared` metodę, która zawsze ma zastosowanie do aktualnie wykonywany wątek, nawet jeśli wywołasz ją za pomocą zmiennej, która odwołuje się do innego wątku. Aby uniknąć nieporozumień, użyj nazwy klasy podczas wywoływania `Shared` metody: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> atrybutu do przechowywania informacji specyficznych dla wątku. Drugi przykład pokazuje, jak zrobić to samo za pomocą gniazda danych.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak użyć pola, które jest oznaczona za pomocą <xref:System.ThreadStaticAttribute> do przechowywania informacji specyficznych dla wątku. Ta metoda zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład pokazuje, jak używać miejsca danych o podanej nazwie do przechowywania informacji specyficznych dla wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Lokalny magazyn wątków: Względne wątkom pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstrzymuje działanie bieżącego wątku dla określonego przedziału czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, dla których wątek jest zawieszony. Jeśli wartość <paramref name="millisecondsTimeout" /> argument ma wartość zero, wątek zwalnia pozostałą część jego przedziału czasu na żadnym z wątków taki sam priorytet, który jest gotowy do uruchomienia. Jeśli nie ma innych wątków programu taki sam priorytet, które są gotowe do uruchomienia, wykonywanie bieżącego wątku nie jest wstrzymana.</param>
        <summary>Wstrzymuje działanie bieżącego wątku dla określoną liczbę milisekund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie zostanie zostaną zaplanowane do wykonania przez system operacyjny przez czas określony. Ta metoda zmienia stan wątku zawierać <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Można określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> dla `millisecondsTimeout` parametr wstrzymania wątku na czas nieokreślony. Jednak firma Microsoft zaleca użycie innych <xref:System.Threading?displayProperty=nameWithType> klasy, takie jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, lub <xref:System.Threading.Semaphore> zamiast tego do synchronizacji wątków lub zarządzania zasobami.  
  
 Taktów zegara systemu z określoną szybkością nazywany rozpoznawaniem zegara. Limit czasu rzeczywistego może nie być dokładnie określony limit czasu, ponieważ określony limit czasu zostanie dostosowana postoju taktów zegara. Aby uzyskać więcej informacji na temat rozdzielczość zegara i czas oczekiwania, zobacz [uśpienia funkcja](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tematu. Ta metoda wywołuje [uśpienia funkcja](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) z interfejsów API systemu Windows.  
  
 Ta metoda nie wykonuje standardowego modelu COM i SendMessage przekazywanie.  
  
> [!NOTE]
>  Jeśli musisz uśpienia w wątku, który ma <xref:System.STAThreadAttribute>, ale użytkownik chce wykonać standardowego modelu COM i SendMessage przekazywanie, należy wziąć pod uwagę przy użyciu jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metody, która określa interwał limitu czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Thread.Sleep%2A> metody do blokowania wątku głównego aplikacji.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość limitu czasu jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ilość czasu, dla którego wątek jest zawieszony. Jeśli wartość <paramref name="millisecondsTimeout" /> argument jest <see cref="F:System.TimeSpan.Zero" />, wątek zwalnia pozostałą część jego przedziału czasu na żadnym z wątków taki sam priorytet, który jest gotowy do uruchomienia. Jeśli nie ma innych wątków programu taki sam priorytet, które są gotowe do uruchomienia, wykonywanie bieżącego wątku nie jest wstrzymana.</param>
        <summary>Wstrzymuje działanie bieżącego wątku dla określonego przedziału czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie zostanie zostaną zaplanowane do wykonania przez system operacyjny przez czas określony. Ta metoda zmienia stan wątku zawierać <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Można określić <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> dla `timeout` parametr wstrzymania wątku na czas nieokreślony. Jednak firma Microsoft zaleca użycie innych <xref:System.Threading?displayProperty=nameWithType> klasy, takie jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, lub <xref:System.Threading.Semaphore> zamiast tego do synchronizacji wątków lub zarządzania zasobami.  
  
 To przeciążenie <xref:System.Threading.Thread.Sleep%2A> używa całkowita liczba milisekund całego `timeout`. Ułamkowe milisekund są odrzucane.  
  
 Ta metoda nie wykonuje standardowego modelu COM i SendMessage przekazywanie.  
  
> [!NOTE]
>  Jeśli musisz uśpienia w wątku, który ma <xref:System.STAThreadAttribute>, ale użytkownik chce wykonać standardowego modelu COM i SendMessage przekazywanie, należy wziąć pod uwagę przy użyciu jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metody, która określa interwał limitu czasu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> przeciążenia metody, aby zablokować wątku głównego aplikacji pięć razy na dwóch sekund.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna, a nie jest równa <see cref="F:System.Threading.Timeout.Infinite" /> (w milisekundach), lub jest większa niż <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iterations">32-bitowa liczba całkowita ze znakiem definiuje, jak długo trwa wątku oczekiwania.</param>
        <summary>Powoduje, że wątek oczekiwania liczba zdefiniowanych przez <paramref name="iterations" /> parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A> Metoda jest przydatna do implementowania blokad. Klasy w .NET Framework, takich jak <xref:System.Threading.Monitor> i <xref:System.Threading.ReaderWriterLock>, korzystanie z tej metody. <xref:System.Threading.Thread.SpinWait%2A> zasadniczo umieszcza procesor w bardzo pętli, liczba pętli, określony przez `iterations` parametru. Czas trwania oczekiwania zależy od w związku z tym od szybkości procesora.  
  
 Natomiast to za pomocą <xref:System.Threading.Thread.Sleep%2A> metody. Wątek, który wywołuje <xref:System.Threading.Thread.Sleep%2A> daje pozostałą część jej bieżącego wycinka czasu procesora, nawet jeśli w określonym przedziale czasu wynosi zero. Określanie niezerowy interwał <xref:System.Threading.Thread.Sleep%2A> usuwa wątku pod uwagę przez harmonogram wątku, dopóki upłynie interwał czasu.  
  
 <xref:System.Threading.Thread.SpinWait%2A> nie jest zazwyczaj przydatne w przypadku zwykłych aplikacji. W większości przypadków należy używać klas synchronizacji dostarczonych przez program .NET Framework; na przykład wywołać <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> lub instrukcję, która otacza <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` w języku C# lub `SyncLock` w języku Visual Basic).  
  
> [!CAUTION]
>  W rzadkich przypadkach, w których jest korzystne, aby uniknąć przełączenie kontekstu, na przykład jeśli wiadomo, że zmiany stanu jest bliska, wywoływania <xref:System.Threading.Thread.SpinWait%2A> metody w swojej pętli. Kod <xref:System.Threading.Thread.SpinWait%2A> wykonuje zaprojektowano, aby uniknąć problemów, które mogą wystąpić na komputerach z wieloma procesorami. Na przykład, na komputerach z wielu procesorów Intel wykorzystujące technologię hiperwątkowości <xref:System.Threading.Thread.SpinWait%2A> zapobiega zablokowania procesora w niektórych sytuacjach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że wątek być zaplanowane do wykonania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że system operacyjny, można zmienić stanu bieżącego wystąpienia do <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stanu systemu operacyjnego można zaplanować jego wykonywania. Wątek, który rozpoczyna się wykonywanie w pierwszym wierszu metody reprezentowanej przez <xref:System.Threading.ThreadStart> lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku. Należy pamiętać, że wywołanie <xref:System.Threading.Thread.Start%2A> nie blokuje wątek wywołujący.  
  
> [!NOTE]
>  Jeśli to przeciążenie jest używany z wątkiem utworzone za pomocą <xref:System.Threading.ParameterizedThreadStart> delegować, `null` jest przekazywany do metody, wykonywane przez wątek.  
  
 Gdy wątek się kończy, go nie można uruchomić ponownie z innym wywołaniu `Start`.  
  
   
  
## Examples  
 Poniższy przykład tworzy i uruchamia wątku.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek już został uruchomiony.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie jest za mało pamięci uruchomić ten wątek.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków i przekazywanie danych w czasie rozpoczęcia</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter">Obiekt zawierający dane do użycia przez metodę wątek wykonuje.</param>
        <summary>Powoduje, że system operacyjny, można zmienić stanu bieżącego wystąpienia do <see cref="F:System.Threading.ThreadState.Running" />i opcjonalnie dostarcza obiekt zawierający dane do użycia przez metodę wątek wykonuje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stanu systemu operacyjnego można zaplanować jego wykonywania. Wątek, który rozpoczyna się wykonywanie w pierwszym wierszu metody reprezentowanej przez <xref:System.Threading.ThreadStart> lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku. Należy pamiętać, że wywołanie <xref:System.Threading.Thread.Start%2A> nie blokuje wątek wywołujący.  
  
 Gdy wątek się kończy, go nie można uruchomić ponownie z innym wywołaniu `Start`.  
  
 To przeciążenie i <xref:System.Threading.ParameterizedThreadStart> delegata ułatwiają przekazywanie danych do procedury wątku, ale techniki nie jest bezpiecznym typem, ponieważ każdy obiekt może być przekazywany do tego przeciążenia. Bardziej niezawodny sposób przekazywania danych do procedury wątku jest umieszczenie procedury wątku i pola danych do obiektu procesu roboczego. Aby uzyskać więcej informacji, zobacz [Tworzenie wątków i przekazywanie danych na czas rozpoczęcia](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Threading.ParameterizedThreadStart> delegowanego z metody statycznej i metodą wystąpienia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek już został uruchomiony.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie jest za mało pamięci uruchomić ten wątek.</exception>
        <exception cref="T:System.InvalidOperationException">Ten wątek został utworzony przy użyciu <see cref="T:System.Threading.ThreadStart" /> delegować zamiast <see cref="T:System.Threading.ParameterizedThreadStart" /> delegować.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje działanie wątku albo jeśli wątek jest już zawieszony, nie ma znaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek jest już zawieszony, ta metoda nie ma znaczenia.  
  
> [!CAUTION]
>  Nie używaj <xref:System.Threading.Thread.Suspend%2A> i <xref:System.Threading.Thread.Resume%2A> metody, aby zsynchronizować działania wątków. Nie ma możliwości określenia, jaki kod w wątku jest wykonywany, gdy zostanie zawieszone. Jeśli wątek zostanie zawieszone, gdy posiada blokady podczas oceny uprawnień zabezpieczeń, inne wątki w <xref:System.AppDomain> może zostać zablokowany. Jeśli podczas wykonywania konstruktora klasy zawieszenie wątku, inne wątki w <xref:System.AppDomain> , podejmują próbę użycia, że klasy są blokowane. Zakleszczenia mogą wystąpić w bardzo prosty sposób.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET core: Ten element członkowski nie jest obsługiwane.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie została uruchomiona lub jest nieaktywny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniego <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać zaawansowane operacje na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Wstrzymywanie i przerywanie wątków</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość zawierającą stany bieżącego wątku.</summary>
        <value>Jedną z <see cref="T:System.Threading.ThreadState" /> wartości, wskazującą stan bieżącego wątku. Wartość początkowa to <see cref="F:System.Threading.ThreadState.Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A> Właściwość zapewnia bardziej szczegółowe informacje, niż <xref:System.Threading.Thread.IsAlive%2A> właściwości.  
  
> [!IMPORTANT]
>  Stan wątku jest tylko w scenariuszach debugowania. Kod powinien nigdy nie używaj stan wątku do synchronizowania działania wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, uzyskiwanie dostępu do `ThreadState` wątku.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="state">Nowy stan apartamentu.</param>
        <summary>Ustawia stan apartamentu wątku, przed jej ponownym uruchomieniu.</summary>
        <returns><see langword="true" /> Jeśli ustawiono stan apartamentu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wątki są inicjowane jako <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> jeśli ich stan apartamentu nie została ustawiona, zanim zostaną uruchomione. Stan apartamentu musi być ustawiona przed uruchomieniem wątku.  
  
> [!NOTE]
>  Głównego wątku aplikacji jest inicjowany do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> domyślnie. Jedynym sposobem, aby ustawić stan apartamentu wątku głównego aplikacji, aby <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> polega na zastosowaniu <xref:System.STAThreadAttribute> atrybutu do metody punktu wejścia.  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A> Metody, wraz z <xref:System.Threading.Thread.GetApartmentState%2A> metody i <xref:System.Threading.Thread.SetApartmentState%2A> zastępuje metodę <xref:System.Threading.Thread.ApartmentState%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> metody. Przykład kodu tworzy wątek. Przed rozpoczęciem wątku <xref:System.Threading.Thread.GetApartmentState%2A> Wyświetla początkowej <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stanu i <xref:System.Threading.Thread.SetApartmentState%2A> zmienia stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. <xref:System.Threading.Thread.TrySetApartmentState%2A> Następnie metoda zwraca `false` podczas próby zmiany stanu do <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> ponieważ stan apartamentu została już ustawiona. Jeśli w tej samej operacji miał zostanie podjęta określona za pomocą <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> będzie zgłaszany.  
  
 Po rozpoczęciu wątku <xref:System.Threading.Thread.TrySetApartmentState%2A> metoda jest używana ponownie. Tym razem zgłasza <xref:System.Threading.ThreadStateException> ponieważ wątek jest już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> nie jest stan apartamentu prawidłowe.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek już został uruchomiony.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole do odczytu.</param>
        <summary>Odczytuje wartość pola. Wartość jest najnowsza wersja napisane przez każdy procesor w komputerze, niezależnie od tego, czy liczba procesorów lub stan pamięci podręcznej.</summary>
        <returns>Ostatnia wartość zapisywane do tego pola przez każdy procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje wartość najnowszych zapisanych przez każdy procesor lokalizacji w pamięci. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do której ma być zapisywane wartości.</param>
        <param name="value">Wartość do zapisania.</param>
        <summary>Zapisuje wartość do pola natychmiast, tak aby wartość jest widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> dla szczególnych przypadkach synchronizacji. W normalnych warunkach, C# `lock` instrukcji, Visual Basic `SyncLock` instrukcji i <xref:System.Threading.Monitor> klasy dostarczają alternatywy łatwiejsze.  
  
 W systemie wieloprocesorowym <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartości zapisane w lokalizacji pamięci jest natychmiast widoczny dla wszystkich procesorów. Może to wymagać opróżnianie procesora, pamięci podręcznych.  
  
 Nawet na komputerze jednoprocesorowym <xref:System.Threading.Thread.VolatileRead%2A> i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytać lub zapisywane w pamięci, a nie pamięci podręcznej (na przykład w rejestrze procesora). W związku z tym można ich użyć do synchronizowania dostępu do pola, które mogą być aktualizowane przez inny wątek lub sprzętu.  
  
 Wywołanie tej metody wpływa na tylko dostęp do jednej pamięci. Aby zapewnić skuteczne synchronizacji dla pola, należy użyć wszelki dostęp do pola <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W języku C# za pomocą `volatile` modyfikator pola gwarantuje, że wszelki dostęp do tego pola używa <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wątek wywołujący, umożliwiające uzyskanie wykonywania do innego wątku, który jest gotowy do uruchomienia na bieżącym procesora. System operacyjny wybiera wątku do podania.</summary>
        <returns><see langword="true" /> Jeśli system operacyjny przełączenie wykonywania do innego wątku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zakończy się powodzeniem, jest uzyskane pozostałej części bieżącego przedziału czasu dla wątku. System operacyjny planuje wątku wywołującego do innego przedziału czasu, zgodnie z jego priorytet i stan innych wątków, które są dostępne do uruchomienia.  
  
 Reaguje jest ograniczona do procesora, który jest wykonywany wątek wywołujący. System operacyjny nie przełączy wykonywania do innego procesora, nawet jeśli ten procesor jest w stanie bezczynności lub jest uruchomiona w wątku o niższym priorytecie. Jeśli istnieją nie ma innych wątków, które są gotowe do wykonania na procesorze bieżącego systemu operacyjnego nie przekazuje wykonywanie i ta metoda zwraca `false`.  
  
 Ta metoda jest odpowiednikiem przy użyciu platformy wywołana w celu wywołania natywny Win32 `SwitchToThread` funkcji. Należy wywołać <xref:System.Threading.Thread.Yield%2A> wywołać metody zamiast przy użyciu platformy, ponieważ wywołanie platformy pomija wszelkie niestandardowe zachowanie wątkowości host zgłosił żądanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
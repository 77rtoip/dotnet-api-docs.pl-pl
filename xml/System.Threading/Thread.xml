<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b191f27764f5c1ddc44910f2efc96055d50d4945" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69143879" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Tworzy i kontroluje wątek, ustawia jego priorytet i pobiera jego stan.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po rozpoczęciu procesu środowisko uruchomieniowe języka wspólnego automatycznie tworzy jeden wątek pierwszego planu, aby wykonać kod aplikacji. Wraz z tym głównym wątkiem pierwszego planu proces może utworzyć jeden lub więcej wątków, aby wykonać część kodu programu skojarzonego z procesem. Te wątki można wykonać na pierwszym planie lub w tle. Ponadto można użyć <xref:System.Threading.ThreadPool> klasy do wykonywania kodu w wątkach roboczych, które są zarządzane przez środowisko uruchomieniowe języka wspólnego.  
  
 W tej sekcji  
  
 [Uruchamianie wątku](#Starting)   
 [Pobieranie obiektów wątków](#Retrieving)   
 [Wątki pierwszego planu i tła](#Foreground)   
 [Kultura i wątki](#Culture)   
 [Pobieranie informacji o wątkach i sterowanie nimi](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Uruchamianie wątku  
 Wątek można uruchomić, dostarczając delegata, który reprezentuje metodę, którą wątek ma wykonać w konstruktorze klasy. Następnie należy wywołać metodę <xref:System.Threading.Thread.Start%2A> , aby rozpocząć wykonywanie.  
  
 <xref:System.Threading.Thread> Konstruktory mogą przyjmować jeden z dwóch typów delegatów, w zależności od tego, czy można przekazać argument do metody do wykonania:  
  
-   Jeśli metoda nie ma argumentów, przekazuje <xref:System.Threading.ThreadStart> delegata do konstruktora. Ma podpis:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Poniższy przykład tworzy i uruchamia wątek, który wykonuje `ExecuteInForeground` metodę. Metoda Wyświetla informacje o niektórych właściwościach wątku, a następnie wykonuje pętlę, w której wstrzymuje się w ciągu pół sekundy i wyświetla upłynęło liczbę sekund. Gdy wątek jest wykonywany przez co najmniej pięć sekund, pętla kończy się i wątek kończy wykonywanie.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Jeśli metoda ma argument, przekazuje <xref:System.Threading.ParameterizedThreadStart> delegata do konstruktora. Ma podpis:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Metoda wykonywana przez delegata może następnie rzutować (w C#) lub skonwertować (w Visual Basic) parametr do odpowiedniego typu.  
  
     Poniższy przykład jest identyczny z poprzednim, z tą różnicą, że wywołuje <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora. Ta wersja `ExecuteInForeground` metody ma jeden parametr, który reprezentuje przybliżoną liczbę milisekund, jaką ma wykonać pętla.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Nie jest konieczne zachowywanie odwołania do <xref:System.Threading.Thread> obiektu po rozpoczęciu wątku. Wątek będzie nadal wykonywany do momentu zakończenia procedury wątku.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Pobieranie obiektów wątków  
 Można użyć właściwości static (`Shared` in Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> , aby pobrać odwołanie do aktualnie wykonywanego wątku z kodu, który wykonuje wątek. Poniższy przykład używa <xref:System.Threading.Thread.CurrentThread%2A> właściwości, aby wyświetlić informacje o wątku głównej aplikacji, drugi wątek pierwszego planu, wątek w tle i wątek puli wątków.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Wątki pierwszego planu i tła  
 <xref:System.Threading.Thread> Wystąpienia klasy reprezentują wątki pierwszego planu lub wątki w tle. Wątki w tle są takie same jak wątki pierwszego planu z jednym wyjątkiem: wątek w tle nie utrzymuje procesu uruchomionego, jeśli wszystkie wątki pierwszego planu zostały zakończone. Po zatrzymaniu wszystkich wątków pierwszego planu środowisko uruchomieniowe zatrzymuje wszystkie wątki w tle i zamknie.  
  
 Domyślnie następujące wątki są wykonywane na pierwszym planie:  
  
-   Główny wątek aplikacji.  
  
-   Wszystkie wątki utworzone przez wywołanie <xref:System.Threading.Thread> konstruktora klasy.  
  
 Następujące wątki są domyślnie wykonywane w tle:  
  
-   Wątki puli wątków, które są pulą wątków roboczych obsługiwanych przez środowisko uruchomieniowe.  Można skonfigurować pulę wątków i zaplanować prace w wątkach puli wątków przy użyciu <xref:System.Threading.ThreadPool> klasy.  
  
    > [!NOTE]
    >  Asynchroniczne operacje oparte na zadaniach są automatycznie wykonywane w wątkach puli wątków. Asynchroniczne operacje oparte na zadaniach używają <xref:System.Threading.Tasks.Task> klas <xref:System.Threading.Tasks.Task%601> i, aby zaimplementować [wzorzec asynchroniczny oparty na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Wszystkie wątki, które wprowadzają zarządzane środowisko wykonawcze z kodu niezarządzanego.  
  
 Można zmienić wątek do wykonania w tle, ustawiając <xref:System.Threading.Thread.IsBackground%2A> właściwość w dowolnym momencie.  Wątki w tle są przydatne w przypadku każdej operacji, która powinna być kontynuowana, gdy aplikacja jest uruchomiona, ale nie powinna uniemożliwiać przerwania działania aplikacji, na przykład monitorowania zmian systemu plików lub połączeń gniazd przychodzących.  
  
 Poniższy przykład ilustruje różnicę między wątkiem na pierwszym planie i w tle. Jest on podobny do pierwszego przykładu w sekcji [Uruchamianie wątku](#Starting) , z tą różnicą, że ustawia wątek do wykonania w tle przed jego uruchomieniem. Jak widać, pętla zostanie przerwana przed wykonaniem przez pięć sekund.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Kultura i wątki  
 Każdy wątek ma kulturę, reprezentowane przez <xref:System.Threading.Thread.CurrentCulture%2A> Właściwość i kulturę interfejsu użytkownika reprezentowanej <xref:System.Threading.Thread.CurrentUICulture%2A> przez właściwość.  Bieżąca kultura obsługuje takie operacje, które są zależne od kultury, jak analizowanie i formatowanie, Porównywanie ciągów i sortowanie, a także kontroluje system pisania i kalendarz używany przez wątek. Bieżąca kultura interfejsu użytkownika umożliwia pobieranie zasobów z uwzględnieniem kultury w plikach zasobów.  

> [!IMPORTANT]
> Właściwości <xref:System.Threading.Thread.CurrentCulture> i<xref:System.Threading.Thread.CurrentUICulture> nie działają prawidłowo, gdy są używane z jakimkolwiek wątkiem innym niż bieżący wątek. W .NET Framework odczytywanie tych właściwości jest niezawodne, chociaż ustawienie tych właściwości dla wątku innego niż bieżący wątek nie jest. W przypadku platformy .NET Core <xref:System.InvalidOperationException> jest zgłaszany, jeśli wątek próbuje odczytać lub zapisać te właściwości w innym wątku.
> Zalecamy używanie <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> właściwości i <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> do pobierania i ustawiania bieżącej kultury.

 Podczas tworzenia wystąpienia nowego wątku jego kultura i kultura interfejsu użytkownika są definiowane przez bieżącą kulturę systemu i kulturę interfejsu użytkownika, a nie przez kulturę i kultury interfejsu użytkownika wątku, z którego tworzony jest nowy wątek. Oznacza to, na przykład, że jeśli bieżącą kulturą systemu jest angielski (Stany Zjednoczone), a bieżąca kultura wątku aplikacji głównej jest francuski (Francja), kultura nowego wątku utworzonego przez wywołanie <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> konstruktora z wątku podstawowego jest angielski (Stany Zjednoczone), a nie francuski (Francja). Aby uzyskać więcej informacji, zobacz sekcję <xref:System.Globalization.CultureInfo> "Kultura i wątki" tematu klasy.  
  
> [!IMPORTANT]
>  Nie jest to prawdziwe w przypadku wątków, które wykonują operacje asynchroniczne dla aplikacji [!INCLUDE[net_v46](~/includes/net-v46-md.md)] przeznaczonych dla i nowszych wersji, w tym przypadku kultura i kultury interfejsu użytkownika są częścią operacji asynchronicznych "context"; wątek, w którym operacja asynchroniczna wykonywane domyślnie dziedziczy kultury i kulturę interfejsu użytkownika wątku, z którego została uruchomiona operacja asynchroniczna. Aby uzyskać więcej informacji, zapoznaj się z sekcją "kultury i operacje asynchroniczne oparte na <xref:System.Globalization.CultureInfo> zadaniach" w temacie dotyczącym klas.  
  
 Możesz wykonać jedną z następujących czynności, aby upewnić się, że wszystkie wątki wykonywane w aplikacji mają tę samą kulturę i kulturę interfejsu użytkownika:  
  
-   Można przekazać <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tę kulturę, <xref:System.Threading.ParameterizedThreadStart> do delegata lub <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> metody.  
  
-   W przypadku aplikacji uruchamianych [!INCLUDE[net_v45](~/includes/net-v45-md.md)] w systemie i nowszych wersjach można zdefiniować kulturę i kulturę interfejsu użytkownika, która ma być przypisana do wszystkich wątków utworzonych w domenie aplikacji przez ustawienie wartości <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> właściwości i <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> . Należy zauważyć, że jest to ustawienie domeny dla poszczególnych aplikacji.  

 Aby uzyskać więcej informacji i przykładów, zobacz sekcję <xref:System.Globalization.CultureInfo> "Kultura i wątki" tematu klasy.

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Pobieranie informacji o wątkach i sterowanie nimi  
 Można pobrać wiele wartości właściwości, które dostarczają informacje o wątku. W niektórych przypadkach można również ustawić te wartości właściwości w celu kontrolowania operacji wątku. Te właściwości wątku obejmują:  
  
-   Nazwa. <xref:System.Threading.Thread.Name%2A>to właściwość jednokrotnego zapisu, która służy do identyfikowania wątku.  Wartość domyślna to `null`.  
  
-   Kod skrótu, który można pobrać, wywołując <xref:System.Threading.Thread.GetHashCode%2A> metodę. Kod skrótu może służyć do unikatowego identyfikowania wątku; w przypadku okresu istnienia wątku jego kod skrótu nie koliduje z wartością z dowolnego innego wątku, niezależnie od domeny aplikacji, z której ma zostać uzyskana wartość.  
  
-   Identyfikator wątku. Wartość właściwości tylko <xref:System.Threading.Thread.ManagedThreadId%2A> do odczytu jest przypisana przez środowisko uruchomieniowe i jednoznacznie identyfikuje wątek w ramach procesu.  
  
    > [!NOTE]
    >  [ThreadID](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) systemu operacyjnego nie ma stałej relacji z zarządzanym wątkiem, ponieważ niezarządzany host może kontrolować relacje między wątki zarządzane i niezarządzane. W przypadku zaawansowanego hosta można użyć [interfejsu API hostingu środowiska CLR](https://msdn.microsoft.com/library/ms404385.aspx) do zaplanowania wielu zarządzanych wątków w tym samym wątku systemu operacyjnego lub przenoszenia zarządzanego wątku między różnymi wątkami systemu operacyjnego.  
  
-   Bieżący stan wątku. Na czas istnienia wątek jest zawsze w co najmniej jednym ze Stanów zdefiniowanych przez <xref:System.Threading.ThreadState> właściwość.  
  
-   Poziom priorytetu planowania zdefiniowany przez <xref:System.Threading.ThreadPriority> właściwość. Mimo że można ustawić tę wartość, aby zażądać priorytetu wątku, nie ma gwarancji, że jest on uznawany przez system operacyjny.  
  
-   Właściwość tylko <xref:System.Threading.Thread.IsThreadPoolThread%2A> do odczytu, która wskazuje, czy wątek jest wątkiem puli wątków.  
  
-   <xref:System.Threading.Thread.IsBackground%2A> Właściwość. Aby uzyskać więcej informacji, zobacz sekcję dotyczącą [wątków pierwszego planu i tła](#Foreground) .  
  
## Examples  
 Poniższy przykład ilustruje prostą funkcję wątkowości.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Ten kod generuje dane wyjściowe podobne do następujących:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Używanie wątków i wątkowości</related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">Źródło odwołania dla klasy wątku</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">Delegat reprezentujący metody, które mają być wywoływane po rozpoczęciu wykonywania tego wątku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Thread" /> klasy, określając delegat, który umożliwia przekazanie obiektu do wątku, gdy wątek zostanie uruchomiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie rozpoczyna wykonywania, gdy zostanie utworzony. Aby zaplanować wykonywanie wątku, wywołaj <xref:System.Threading.Thread.Start%2A> metodę. Aby przekazać obiekt danych do wątku, użyj <xref:System.Threading.Thread.Start%28System.Object%29> przeciążenia metody.  
  
> [!NOTE]
>  Visual Basic użytkownicy mogą pominąć <xref:System.Threading.ThreadStart> konstruktora podczas tworzenia wątku. Użyj operatora podczas przekazywania metody, na przykład `Dim t As New Thread(AddressOf ThreadProc)`. `AddressOf` Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnię tworzenia i używania <xref:System.Threading.ParameterizedThreadStart> delegata z metodą statyczną i metodą wystąpienia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><see cref="T:System.Threading.ThreadStart" /> Delegat reprezentujący metody, które mają być wywoływane po rozpoczęciu wykonywania tego wątku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.Thread" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie rozpoczyna wykonywania, gdy zostanie utworzony. Aby zaplanować wykonywanie wątku, wywołaj <xref:System.Threading.Thread.Start%2A> metodę.  
  
> [!NOTE]
>  Visual Basic użytkownicy mogą pominąć <xref:System.Threading.ThreadStart> konstruktora podczas tworzenia wątku. Użyj operatora podczas przekazywania metody na przykład `Dim t As New Thread(AddressOf ThreadProc)`. `AddressOf` Visual Basic automatycznie wywołuje <xref:System.Threading.ThreadStart> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wątek, który wykonuje metodę statyczną.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak utworzyć wątek, który wykonuje metodę wystąpienia.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="start" /></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start"><see cref="T:System.Threading.ParameterizedThreadStart" /> Delegat reprezentujący metody, które mają być wywoływane po rozpoczęciu wykonywania tego wątku.</param>
        <param name="maxStackSize">Maksymalny rozmiar stosu w bajtach, który ma być używany przez wątek, lub 0, aby użyć domyślnego maksymalnego rozmiaru stosu określonego w nagłówku pliku wykonywalnego.  
  
Ważne dla częściowo zaufanego kodu <paramref name="maxStackSize" /> , jest ignorowany, jeśli jest większy niż domyślny rozmiar stosu. Nie zgłoszono żadnego wyjątku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Thread" /> klasy, określając delegat, który umożliwia przekazanie obiektu do wątku podczas uruchamiania wątku i określanie maksymalnego rozmiaru stosu dla wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unikaj korzystania z tego przeciążenia konstruktora. Domyślny rozmiar stosu używany przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> przeciążenie konstruktora to zalecany rozmiar stosu dla wątków. Jeśli wątek ma problemy z pamięcią, najbardziej prawdopodobną przyczyną jest błąd programistyczny, taki jak nieskończona rekursja.  
  
> [!IMPORTANT]
>  Począwszy od `maxStackSize` , tylko w pełni zaufany kod można ustawić na wartość, która jest większa niż domyślny rozmiar stosu (1 megabajt). [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Jeśli jest określona `maxStackSize` większa wartość, gdy kod jest uruchomiony z częściowym zaufaniem `maxStackSize` , jest ignorowany i używany jest domyślny rozmiar stosu. Nie zgłoszono żadnego wyjątku. Kod na dowolnym poziomie zaufania można ustawić `maxStackSize` na wartość, która jest mniejsza niż domyślny rozmiar stosu.  
  
> [!NOTE]
>  W przypadku tworzenia w pełni zaufanej biblioteki, która będzie używana przez częściowo zaufany kod i należy uruchomić wątek, który wymaga dużego stosu, należy poświadczyć pełne zaufanie przed utworzeniem wątku lub użyć domyślnego rozmiaru stosu. Nie wykonuj tej czynności, chyba że w pełni kontrolujesz kod, który jest uruchamiany w wątku.  
  
 Jeśli `maxStackSize` jest mniejsza niż minimalny rozmiar stosu, używany jest minimalny rozmiar stosu. Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony, jest zaokrąglana do następnej większej wielokrotności rozmiaru strony. Jeśli na przykład używasz .NET Framework w wersji 2,0 w systemie Windows Vista, 256 KB (262 144 bajtów) to minimalny rozmiar stosu, a rozmiar strony to 64 KB (65 536 bajtów).  
  
> [!NOTE]
>  W wersjach systemu Microsoft Windows starszych niż Windows XP i Windows Server 2003 `maxStackSize` program jest ignorowany i jest używany rozmiar stosu określony w nagłówku pliku wykonywalnego.  
  
 W przypadku określenia bardzo małego rozmiaru stosu może być konieczne wyłączenie sondowania przepełnienia stosu. Gdy stos jest poważnie ograniczony, sondowanie może sam spowodować przepełnienie stosu. Aby wyłączyć sondowanie przeciążenia stosu, Dodaj następujący plik do pliku konfiguracji aplikacji.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start"><see cref="T:System.Threading.ThreadStart" /> Delegat reprezentujący metody, które mają być wywoływane po rozpoczęciu wykonywania tego wątku.</param>
        <param name="maxStackSize">Maksymalny rozmiar stosu w bajtach, który ma być używany przez wątek, lub 0, aby użyć domyślnego maksymalnego rozmiaru stosu określonego w nagłówku pliku wykonywalnego.  
  
Ważne dla częściowo zaufanego kodu <paramref name="maxStackSize" /> , jest ignorowany, jeśli jest większy niż domyślny rozmiar stosu. Nie zgłoszono żadnego wyjątku.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Thread" /> klasy, określając maksymalny rozmiar stosu dla wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unikaj korzystania z tego przeciążenia konstruktora. Domyślny rozmiar stosu używany przez <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> przeciążenie konstruktora to zalecany rozmiar stosu dla wątków. Jeśli wątek ma problemy z pamięcią, najbardziej prawdopodobną przyczyną jest błąd programistyczny, taki jak nieskończona rekursja.  
  
> [!IMPORTANT]
>  Począwszy od `maxStackSize` , tylko w pełni zaufany kod można ustawić na wartość, która jest większa niż domyślny rozmiar stosu (1 megabajt). [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Jeśli jest określona `maxStackSize` większa wartość, gdy kod jest uruchomiony z częściowym zaufaniem `maxStackSize` , jest ignorowany i używany jest domyślny rozmiar stosu. Nie zgłoszono żadnego wyjątku. Kod na dowolnym poziomie zaufania można ustawić `maxStackSize` na wartość, która jest mniejsza niż domyślny rozmiar stosu.  
  
> [!NOTE]
>  W przypadku tworzenia w pełni zaufanej biblioteki, która będzie używana przez częściowo zaufany kod i należy uruchomić wątek, który wymaga dużego stosu, należy poświadczyć pełne zaufanie przed utworzeniem wątku lub użyć domyślnego rozmiaru stosu. Nie wykonuj tej czynności, chyba że w pełni kontrolujesz kod, który jest uruchamiany w wątku.  
  
 Jeśli `maxStackSize` jest mniejsza niż minimalny rozmiar stosu, używany jest minimalny rozmiar stosu. Jeśli `maxStackSize` nie jest wielokrotnością rozmiaru strony, jest zaokrąglana do następnej większej wielokrotności rozmiaru strony. Jeśli na przykład używasz .NET Framework w wersji 2,0 w systemie Windows Vista, 256 KB (262 144 bajtów) to minimalny rozmiar stosu, a rozmiar strony to 64 KB (65 536 bajtów).  
  
> [!NOTE]
>  W wersjach systemu Microsoft Windows starszych niż Windows XP i Windows Server 2003 `maxStackSize` program jest ignorowany i jest używany rozmiar stosu określony w nagłówku pliku wykonywalnego.  
  
 W przypadku określenia bardzo małego rozmiaru stosu może być konieczne wyłączenie sondowania przepełnienia stosu. Gdy stos jest poważnie ograniczony, sondowanie może sam spowodować przepełnienie stosu. Aby wyłączyć sondowanie przeciążenia stosu, Dodaj następujący plik do pliku konfiguracji aplikacji.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.ThreadAbortException" /> Podnosi do wątku, w którym jest wywoływana, aby rozpocząć proces kończenia wątku. Wywołanie tej metody zwykle kończy działanie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> `Thread.Abort` Metoda powinna być stosowana z zachowaniem ostrożności. Szczególnie w przypadku wywołania go w celu przerwania wątku innego niż bieżący wątek nie wiadomo, jaki kod został wykonany lub nie można wykonać, gdy <xref:System.Threading.ThreadAbortException> zostanie zgłoszony, ani nie może być określony stan aplikacji lub aplikacji i stanu użytkownika. odpowiedzialny za zachowanie. Na przykład, wywołanie `Thread.Abort` może uniemożliwić wykonywanie przez konstruktory statyczne lub uniemożliwić wydawanie niezarządzanych zasobów. 
>
> Należy zauważyć, `Thread.Abort` że metoda nie jest obsługiwana w programie .NET Core.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.ThreadAbortException" /> Podnosi do wątku, w którym jest wywoływana, aby rozpocząć proces kończenia wątku. Wywołanie tej metody zwykle kończy działanie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana w wątku, system zgłasza <xref:System.Threading.ThreadAbortException> w wątku, aby go przerwać. `ThreadAbortException`to specjalny wyjątek, który może zostać przechwycony przez kod aplikacji, ale jest ponownie zgłaszany na końcu `catch` bloku, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana. `ResetAbort`anuluje żądanie przerwania i uniemożliwia `ThreadAbortException` zakończenie wątku. Niewykonane `finally` bloki są wykonywane przed przerwaniem wątku.  
  
> [!NOTE]
>  Gdy wątek wywołuje `Abort` sam siebie, efekt jest podobny do zgłaszania wyjątku <xref:System.Threading.ThreadAbortException> ; dzieje się natychmiast, a wynik jest przewidywalny. Jeśli jednak jeden wątek wywołuje `Abort` inny wątek, przerwanie przerywa działanie dowolnego kodu. Istnieje również możliwość przerwania działania konstruktora statycznego. W rzadkich przypadkach może to spowodować, że wystąpienia tej klasy zostaną utworzone w tej domenie aplikacji. W .NET Framework wersje 1,0 i 1,1 istnieje szansa, że wątek może zostać przerwany w trakcie `finally` działania bloku, w którym to `finally` przypadku blok został przerwany.  
  
 Wątek nie jest gwarantowany do natychmiastowego przerwania lub wcale. Taka sytuacja może wystąpić, jeśli wątek wykonuje niepowiązaną ilość obliczeń w `finally` blokach, które są wywoływane w ramach procedury Abort, przez co nieoczekiwanie opóźnia to przerwanie. Aby poczekać, aż wątek zostanie przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> metodę w wątku po <xref:System.Threading.Thread.Abort%2A> wywołaniu metody, ale nie ma żadnej gwarancji, że oczekiwanie zakończy się.  
  
> [!NOTE]
>  Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> wywołania, może blokować, jeśli wątek, który jest przerywany, znajduje się w chronionym regionie kodu, `catch` takim jak `finally` blok, blok lub region ograniczonego wykonania. Jeśli wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> , ma blokadę wymaganą przez przerwany wątek, może wystąpić zakleszczenie.  
  
 Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek zostanie przerwany, gdy <xref:System.Threading.Thread.Start%2A> zostanie wywołana. Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest uśpiony, wątek zostanie przerwany, a następnie przerwany.  
  
 Jeśli `Abort` jest wywoływana w wątku, który został zawieszony <xref:System.Threading.ThreadStateException> , jest zgłaszany w wątku, który został wywołany <xref:System.Threading.Thread.Abort%2A>, <xref:System.Threading.ThreadState.AbortRequested> i jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości przerwanego wątku. Element <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w zawieszonym wątku <xref:System.Threading.Thread.Resume%2A> do momentu wywołania metody.  
  
 Jeśli `Abort` jest wywoływana w wątku zarządzanym podczas wykonywania kodu niezarządzanego `ThreadAbortException` , nie jest generowane, dopóki wątek nie powróci do kodu zarządzanego.  
  
 Jeśli dwa wywołania `Abort` są w tym samym czasie, możliwe jest jedno wywołanie, aby ustawić informacje o stanie i inne wywołanie do `Abort`wykonania. Jednak aplikacja nie może wykryć takiej sytuacji.  
  
 Po `Abort` wywołaniu w wątku, stan wątku zawiera <xref:System.Threading.ThreadState.AbortRequested>. Po zakończeniu wątku w wyniku pomyślnego wywołania do `Abort`, stan wątku jest zmieniany na. <xref:System.Threading.ThreadState.Stopped> Mając wystarczające uprawnienia, wątek, który jest elementem docelowym `Abort` , może anulować przerwanie `ResetAbort` przy użyciu metody. Aby zapoznać się z przykładem, `ResetAbort` który demonstruje wywołanie metody `ThreadAbortException` , zobacz Klasa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Przerwany wątek jest aktualnie zawieszony.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zaawansowanych operacji na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Używanie wątków i wątkowości</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Niszczenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Obiekt, który zawiera informacje specyficzne dla aplikacji, takie jak stan, który może być używany przez przerywany wątek.</param>
        <summary><see cref="T:System.Threading.ThreadAbortException" /> Podnosi do wątku, w którym jest wywoływana, aby rozpocząć proces kończenia wątku, a także dostarcza informacje o wyjątku dotyczące zakończenia wątku. Wywołanie tej metody zwykle kończy działanie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana w wątku, system zgłasza <xref:System.Threading.ThreadAbortException> w wątku, aby go przerwać. `ThreadAbortException`to specjalny wyjątek, który może zostać przechwycony przez kod aplikacji, ale jest ponownie zgłaszany na końcu `catch` bloku, chyba że <xref:System.Threading.Thread.ResetAbort%2A> jest wywoływana. `ResetAbort`anuluje żądanie przerwania i uniemożliwia `ThreadAbortException` zakończenie wątku. Niewykonane `finally` bloki są wykonywane przed przerwaniem wątku.  
  
> [!NOTE]
>  Gdy wątek wywołuje `Abort` sam siebie, efekt jest podobny do zgłaszania wyjątku <xref:System.Threading.ThreadAbortException> ; dzieje się natychmiast, a wynik jest przewidywalny. Jeśli jednak jeden wątek wywołuje `Abort` inny wątek, przerwanie przerywa działanie dowolnego kodu. Istnieje prawdopodobieństwo, że można przerwać Konstruktor statyczny. W rzadkich przypadkach może to spowodować, że wystąpienia tej klasy zostaną utworzone w tej domenie aplikacji. W .NET Framework wersje 1,0 i 1,1 istnieje szansa, że wątek może zostać przerwany w trakcie `finally` działania bloku, w którym to `finally` przypadku blok został przerwany.  
  
 Wątek nie jest gwarantowany do natychmiastowego przerwania lub wcale. Taka sytuacja może wystąpić, jeśli wątek wykonuje niepowiązaną ilość obliczeń w `finally` blokach, które są wywoływane w ramach procedury Abort, przez co nieoczekiwanie opóźnia to przerwanie. Aby poczekać, aż wątek zostanie przerwany, można wywołać <xref:System.Threading.Thread.Join%2A> metodę w wątku po <xref:System.Threading.Thread.Abort%2A> wywołaniu metody, ale nie ma żadnej gwarancji, że oczekiwanie zakończy się.  
  
> [!NOTE]
>  Wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> wywołania, może blokować, jeśli wątek, który jest przerywany, znajduje się w chronionym regionie kodu, `catch` takim jak `finally` blok, blok lub region ograniczonego wykonania. Jeśli wątek, który wywołuje <xref:System.Threading.Thread.Abort%2A> , ma blokadę wymaganą przez przerwany wątek, może wystąpić zakleszczenie.  
  
 Jeśli `Abort` jest wywoływana w wątku, który nie został uruchomiony, wątek zostanie przerwany, gdy <xref:System.Threading.Thread.Start%2A> zostanie wywołana. Jeśli `Abort` jest wywoływana w wątku, który jest zablokowany lub jest uśpiony, wątek zostanie przerwany, a następnie przerwany.  
  
 Jeśli `Abort` jest wywoływana w wątku, który został zawieszony <xref:System.Threading.ThreadStateException> , jest zgłaszany w wątku, który został wywołany <xref:System.Threading.Thread.Abort%2A>, <xref:System.Threading.ThreadState.AbortRequested> i jest dodawany do <xref:System.Threading.Thread.ThreadState%2A> właściwości przerwanego wątku. Element <xref:System.Threading.ThreadAbortException> nie jest zgłaszany w zawieszonym wątku <xref:System.Threading.Thread.Resume%2A> do momentu wywołania metody.  
  
 Jeśli `Abort` jest wywoływana w wątku zarządzanym podczas wykonywania kodu niezarządzanego `ThreadAbortException` , nie jest generowane, dopóki wątek nie powróci do kodu zarządzanego.  
  
 Jeśli dwa wywołania `Abort` są w tym samym czasie, możliwe jest jedno wywołanie, aby ustawić informacje o stanie i inne wywołanie do `Abort`wykonania. Jednak aplikacja nie może wykryć takiej sytuacji.  
  
 Po `Abort` wywołaniu w wątku, stan wątku zawiera <xref:System.Threading.ThreadState.AbortRequested>. Po zakończeniu wątku w wyniku pomyślnego wywołania do `Abort`, stan wątku jest zmieniany na. <xref:System.Threading.ThreadState.Stopped> Mając wystarczające uprawnienia, wątek, który jest elementem docelowym `Abort` , może anulować przerwanie `ResetAbort` przy użyciu metody. Aby zapoznać się z przykładem, `ResetAbort` który demonstruje wywołanie metody `ThreadAbortException` , zobacz Klasa.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak przekazać informacje do wątku, który jest przerywany.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Przerwany wątek jest aktualnie zawieszony.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zaawansowanych operacji na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Używanie wątków i wątkowości</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Niszczenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przydziela nienazwane gniazdo danych we wszystkich wątkach. W celu uzyskania lepszej wydajności Użyj pól, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> atrybutem.</summary>
        <returns>Przydzielono nazwane gniazdo danych we wszystkich wątkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework zapewnia dwa mechanizmy używania lokalnego magazynu wątków (TLS): pola statyczne powiązane z <xref:System.ThreadStaticAttribute> wątkiem (czyli pola oznaczone atrybutem) i gniazda danych. Pola statyczne względne dla wątków zapewniają znacznie lepszą wydajność niż gniazda danych i umożliwiają sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z [protokołu TLS, zobacz temat lokalny magazyn wątków: Pola statyczne powiązane z wątkiem i gniazda](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)danych.  
  
 Gniazdo jest przydzielono we wszystkich wątkach.  
  
 Wątki używają mechanizmu pamięci magazynu lokalnego do przechowywania danych specyficznych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicę magazynów danych z obsługą wielu gniazd do każdego procesu podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywać i pobierać wartość danych w gnieździe i zwolnić miejsce do ponownego użycia po wygaśnięciu wątku. Gniazda danych są unikatowe dla każdego wątku. Żaden inny wątek (nawet wątek podrzędny) nie może uzyskać tych danych.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak używać pola, które jest oznaczone <xref:System.ThreadStaticAttribute> atrybutem, aby przechowywać informacje specyficzne dla wątku. Drugi przykład pokazuje, jak używać miejsca danych do wykonania tego samego działania.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak używać pola oznaczonego przez <xref:System.ThreadStaticAttribute> , aby przechowywać informacje specyficzne dla wątku. Ta technika zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład kodu demonstruje, jak używać miejsca danych do przechowywania informacji dotyczących wątku.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Pamięć lokalna wątku: Powiązane z wątkiem pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych do przydzielenia.</param>
        <summary>Przydziela nazwane gniazdo danych we wszystkich wątkach. W celu uzyskania lepszej wydajności Użyj pól, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> atrybutem.</summary>
        <returns>Przydzielono nazwane gniazdo danych we wszystkich wątkach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework zapewnia dwa mechanizmy używania lokalnego magazynu wątków (TLS): pola statyczne powiązane z <xref:System.ThreadStaticAttribute> wątkiem (czyli pola oznaczone atrybutem) i gniazda danych. Pola statyczne względne dla wątków zapewniają znacznie lepszą wydajność niż gniazda danych i umożliwiają sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z [protokołu TLS, zobacz temat lokalny magazyn wątków: Pola statyczne powiązane z wątkiem i gniazda](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)danych.  
  
 Wątki używają mechanizmu pamięci magazynu lokalnego do przechowywania danych specyficznych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicę magazynów danych z obsługą wielu gniazd do każdego procesu podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywać i pobierać wartość danych w gnieździe i zwolnić miejsce do ponownego użycia po wygaśnięciu wątku. Gniazda danych są unikatowe dla każdego wątku. Żaden inny wątek (nawet wątek podrzędny) nie może uzyskać tych danych.  
  
 Nie jest konieczne użycie <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metody do przydzielenia nazwanego gniazda danych, <xref:System.Threading.Thread.GetNamedDataSlot%2A> ponieważ metoda przydziela miejsce, jeśli nie zostało jeszcze przydzielone.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Jeśli metoda jest używana, powinna być wywoływana w wątku głównym przy uruchamianiu programu, ponieważ zgłasza wyjątek, jeśli gniazdo o określonej nazwie zostało już przydzielono. Nie ma możliwości sprawdzenia, czy gniazdo zostało już przydzieloną.  
  
 Gniazda przydzieloną za pomocą tej metody muszą być zwolnione z <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak używać pola, które jest oznaczone <xref:System.ThreadStaticAttribute> atrybutem, aby przechowywać informacje specyficzne dla wątku. Drugi przykład pokazuje, jak używać miejsca danych do wykonania tego samego działania.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak używać pola oznaczonego przez <xref:System.ThreadStaticAttribute> , aby przechowywać informacje specyficzne dla wątku. Ta technika zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład ilustruje sposób użycia nazwanego gniazda danych do przechowywania informacji dotyczących wątku.  
  
> [!NOTE]
>  Przykładowy kod nie używa <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metody, <xref:System.Threading.Thread.GetNamedDataSlot%2A> ponieważ metoda przydziela miejsce, jeśli nie zostało jeszcze przydzielone. <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Jeśli metoda jest używana, powinna być wywoływana w wątku głównym przy uruchamianiu programu.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwane gniazdo danych o podanej nazwie już istnieje.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Pamięć lokalna wątku: Powiązane z wątkiem pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia stan apartamentu tego wątku.</summary>
        <value>Jedna z <see cref="T:System.Threading.ApartmentState" /> wartości. Wartość początkowa to <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A> Właściwość jest przestarzała.**  Nieprzestarzałe alternatywy to <xref:System.Threading.Thread.GetApartmentState%2A> Metoda pobrania stanu apartamentu <xref:System.Threading.Thread.SetApartmentState%2A> i metody w celu ustawienia stanu apartamentu.  
  
 W .NET Framework wersje 1,0 i 1,1 `ApartmentState` Właściwość oznacza wątek, aby wskazać, że będzie wykonywany w jednowątkowym lub wielowątkowym apartamentie. Tę właściwość można ustawić, gdy wątek jest w `Unstarted` stanie wątku lub `Running` , ale można ją ustawić tylko raz dla wątku. Jeśli właściwość nie została ustawiona, zwraca `Unknown`.  
  
 Próba użycia <xref:System.Threading.Thread.ApartmentState%2A> właściwości w celu ustawienia stanu apartamentu wątku, którego stan apartamentu został już ustawiony, jest ignorowana. <xref:System.Threading.Thread.SetApartmentState%2A> Jednak Metoda<xref:System.InvalidOperationException> zgłasza w tym przypadku.  
  
> [!IMPORTANT]
>  W .NET Framework w wersji 2,0 nowe wątki są inicjowane tak <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , jakby ich stan apartamentu nie został ustawiony przed rozpoczęciem. Główny wątek aplikacji jest domyślnie zainicjowany <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> . Nie można już ustawić głównego wątku <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> aplikacji, <xref:System.Threading.ApartmentState?displayProperty=nameWithType> ustawiając właściwość w pierwszym wierszu kodu. <xref:System.STAThreadAttribute> Użyj zamiast tego.  
  
 W .NET Framework w wersji 2,0 można określić model wątkowości COM dla C++ aplikacji przy użyciu [/CLRTHREADATTRIBUTE (ustaw atrybut wątku CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) opcji konsolidatora.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób ustawiania stanu apartamentu wątku.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podjęto próbę ustawienia dla tej właściwości stanu, który nie jest prawidłowym stanem apartamentu (stanem innym niż Single-Threading Apartment<see langword="STA" />() lub apartamentem wielowątkowym<see langword="MTA" />()).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, że wykonanie polega na wprowadzeniu regionu kodu, w którym efekty przerwania wątku lub nieobsłużonego wyjątku mogą zagrozić innym zadaniom w domenie aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosty środowiska uruchomieniowego języka wspólnego (CLR), takie jak Microsoft SQL Server 2005, mogą nawiązywać różne zasady dla błędów w regionach krytycznych i niekrytycznych. Region krytyczny to jeden, w którym skutki przerwania wątku lub nieobsłużonego wyjątku mogą nie być ograniczone do bieżącego zadania. Z kolei, przerwanie lub błąd w niekrytycznym regionie kodu ma wpływ tylko na zadanie, w którym występuje błąd.  
  
 Rozważmy na przykład zadanie, które próbuje przydzielić pamięć podczas utrzymywania blokady. Jeśli alokacja pamięci nie powiedzie się, przerywanie bieżącego zadania nie jest wystarczające, aby zapewnić <xref:System.AppDomain>stabilność, ponieważ w domenie mogą znajdować się inne zadania oczekujące na tę samą blokadę. Jeśli bieżące zadanie zostało zakończone, inne zadania mogą być zakleszczony.  
  
 Gdy wystąpi awaria w regionie krytycznym, host może podjąć decyzję o rozłączeniu <xref:System.AppDomain> całości, a nie z ryzykiem ciągłego wykonywania w stanie potencjalnie niestabilnym. Aby poinformować hosta, że Twój kod przechodzi do regionu krytycznego, wywołaj <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Wywołanie <xref:System.Threading.Thread.EndCriticalRegion%2A> , gdy wykonanie powraca do niekrytycznego regionu kodu.  
  
 Użycie tej metody w kodzie, który jest uruchamiany w SQL Server 2005 wymaga, aby kod był uruchamiany na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> metod i <xref:System.Threading.Thread.EndCriticalRegion%2A> do dzielenia bloku kodu na regiony krytyczne i niekrytyczne.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, że kod zarządzany ma wykonać instrukcje, które są zależne od tożsamości bieżącego fizycznego wątku systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre hosty środowiska uruchomieniowego języka wspólnego, takie jak Microsoft SQL Server 2005, zapewniają własne zarządzanie wątkami. Host, który zapewnia własne zarządzanie wątkami, może przenieść wykonywanie zadania z jednego fizycznego wątku systemu operacyjnego do innego w dowolnym momencie. Tego przełączania nie ma wpływ na większość zadań. Jednak niektóre zadania mają koligację wątku — to oznacza, że zależą od tożsamości fizycznego wątku systemu operacyjnego. Te zadania muszą poinformować hosta, gdy wykonują kod, który nie powinien być przełączany.  
  
 Na przykład jeśli aplikacja wywołuje systemowy interfejs API w celu uzyskania blokady systemu operacyjnego, która ma koligację wątku, taką jak critical_section Win32, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskaniem blokady i <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnieniu blokady.  
  
 Użycie tej metody w kodzie, który jest uruchamiany w SQL Server 2005 wymaga, aby kod był uruchamiany na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> metod i <xref:System.Threading.Thread.EndThreadAffinity%2A> w celu powiadomienia hosta, że blok kodu zależy od tożsamości fizycznego wątku systemu operacyjnego.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący kontekst, w którym wykonywany jest wątek.</summary>
        <value><see cref="T:System.Runtime.Remoting.Contexts.Context" /> Reprezentujący bieżący kontekst wątku.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kulturę dla bieżącego wątku.</summary>
        <value>Obiekt, który reprezentuje kulturę dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> Obiekt, który jest zwracany przez tę właściwość wraz ze skojarzonymi z nim obiektami, określa domyślny format dat, godzin, liczb, wartości walutowych, kolejności sortowania tekstu, Konwencji wielkości liter i porównań ciągów. Zapoznaj się z klasą, aby dowiedzieć się więcej o nazwach i identyfikatorach kultur, różnicach między niezmiennymi, neutralnymi i szczególnymi kulturami oraz sposobem, w jaki informacje kultury wpływają na wątki i domeny aplikacji. <xref:System.Globalization.CultureInfo> Zapoznaj się z właściwością, aby dowiedzieć się, jak jest określana kultura domyślna wątku oraz jak użytkownicy ustawiają informacje o kulturze dla swoich komputerów. <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>  

> [!IMPORTANT]
> Właściwość <xref:System.Threading.Thread.CurrentCulture> nie działa w sposób niezawodny, gdy jest używany z jakimkolwiek wątkiem innym niż bieżący wątek. W .NET Framework odczytywanie właściwości jest niezawodne, chociaż ustawienie jej dla wątku innego niż bieżący wątek nie jest. W przypadku platformy .NET Core <xref:System.InvalidOperationException> jest zgłaszany, jeśli wątek próbuje odczytać lub <xref:System.Threading.Thread.CurrentCulture> zapisać właściwość w innym wątku.
> Zalecamy użycie <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> właściwości, aby pobrać i ustawić bieżącą kulturę.

 Począwszy od <xref:System.Threading.Thread.CurrentCulture%2A> , można ustawić właściwość na neutralną kulturę. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Wynika to z faktu, że <xref:System.Globalization.CultureInfo> zachowanie klasy zostało zmienione: Gdy reprezentuje kulturę neutralną, jej wartości właściwości (w <xref:System.Globalization.CultureInfo.Calendar%2A>szczególności <xref:System.Globalization.CultureInfo.CompareInfo%2A> <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> <xref:System.Globalization.CultureInfo.NumberFormat%2A>właściwości,,, i <xref:System.Globalization.CultureInfo.TextInfo%2A> ) odzwierciedlają teraz określoną kulturę, która jest skojarzona z kulturą neutralną. We wcześniejszych wersjach .NET Framework <xref:System.Threading.Thread.CurrentCulture%2A> Właściwość <xref:System.NotSupportedException> zgłosiła wyjątek, gdy zostanie przypisana kultura neutralna.  
  
## Examples  
 Poniższy przykład przedstawia instrukcję Threading, która umożliwia interfejsowi użytkownika aplikacji Windows Forms wyświetlanie w kulturze, która jest ustawiona w panelu sterowania. Wymagany jest dodatkowy kod.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Tylko .NET Core: Odczytywanie lub zapisywanie kultury wątku z innego wątku nie jest obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do ustawiania właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący podmiot zabezpieczeń wątku (dla zabezpieczeń opartych na rolach).</summary>
        <value><see cref="T:System.Security.Principal.IPrincipal" /> Wartość reprezentująca kontekst zabezpieczeń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawić i pobrać podmiot zabezpieczeń wątku.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnienia wymaganego do ustawienia podmiotu zabezpieczeń.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do manipulowania obiektem głównym. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktualnie uruchomiony wątek.</summary>
        <value><see cref="T:System.Threading.Thread" /> Jest to reprezentacja aktualnie działającego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy zadanie, które z kolei tworzy 20 zadań podrzędnych. Sama aplikacja, a także każde zadanie, wywołuje `ShowThreadInformation` metodę, która <xref:System.Threading.Thread.CurrentThread%2A> używa właściwości, aby wyświetlić informacje o wątku, w którym jest uruchomiony.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Każde zadanie podrzędne generuje liczbę losową 1 000 000 z zakresu od 1 do 1 000 000 i zwraca ich średnią wartość. Zadanie nadrzędne wywołuje <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodę, aby upewnić się, że zadania podrzędne zostały ukończone przed wyświetleniem średniej zwróconej przez każde zadanie i obliczenia średniego środka.  
  
 Należy pamiętać, że podczas gdy aplikacja jest uruchamiana w wątku pierwszego planu, każde zadanie jest uruchamiane w wątku puli wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą kulturę używaną przez Menedżer zasobów do wyszukiwania zasobów specyficznych dla kultury w czasie wykonywania.</summary>
        <value>Obiekt, który reprezentuje bieżącą kulturę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kultura interfejsu użytkownika określa zasoby, których aplikacja musi obsługiwać dane wejściowe i wyjściowe użytkownika, a domyślnie jest taka sama jak kultura systemu operacyjnego. Zapoznaj się z klasą, aby dowiedzieć się więcej o nazwach i identyfikatorach kultur, różnicach między niezmiennymi, neutralnymi i szczególnymi kulturami oraz sposobem, w jaki informacje kultury wpływają na wątki i domeny aplikacji. <xref:System.Globalization.CultureInfo> Zobacz Właściwość <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> , aby dowiedzieć się, jak jest określana domyślna kultura interfejsu użytkownika wątku.  

> [!IMPORTANT]
> Właściwość <xref:System.Threading.Thread.CurrentUICulture> nie działa w sposób niezawodny, gdy jest używany z jakimkolwiek wątkiem innym niż bieżący wątek. W .NET Framework odczytywanie właściwości jest niezawodne, chociaż ustawienie jej dla wątku innego niż bieżący wątek nie jest. W przypadku platformy .NET Core <xref:System.InvalidOperationException> jest zgłaszany, jeśli wątek próbuje odczytać lub <xref:System.Threading.Thread.CurrentUICulture> zapisać właściwość w innym wątku.
> Zalecamy użycie <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> właściwości, aby pobrać i ustawić bieżącą kulturę.

 <xref:System.Globalization.CultureInfo> Zwracana przez tę właściwość może być kulturą neutralną. Nie należy używać kultur neutralnych z metodami formatowania, <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>takimi jak <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, i. Użyj metody, aby uzyskać określoną kulturę, lub <xref:System.Threading.Thread.CurrentCulture%2A> Użyj właściwości. <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Metoda zgłasza<xref:System.ArgumentException> dla nieneutralnych kultur "zh-Hant" ("zh-CHT") i "zh-Hans" ("zh-CHS").  
  
   
  
## Examples  
 Poniższy przykład określa, czy język kultury interfejsu bieżącego wątku jest francuski. Jeśli tak nie jest, ustawia kulturę interfejsu użytkownika bieżącego wątku na angielski (Stany Zjednoczone).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Poniższy przykład kodu przedstawia instrukcję Threading, która umożliwia interfejsowi użytkownika Windows Forms wyświetlanie w kulturze, która jest ustawiona w panelu sterowania. Wymagany jest dodatkowy kod.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Właściwość jest ustawiona na <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na nazwę kultury, której nie można użyć do zlokalizowania pliku zasobów. Nazwy plików zasobów muszą zawierać tylko litery, cyfry, łączniki i podkreślenia.</exception>
        <exception cref="T:System.InvalidOperationException">Tylko .NET Core: Odczytywanie lub zapisywanie kultury wątku z innego wątku nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza automatyczne czyszczenie wywoływanych otok (RCW) środowiska uruchomieniowego dla bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie środowisko uruchomieniowe języka wspólnego (CLR) czyści automatycznie wywoływane otoki środowiska uruchomieniowego. Komunikaty środowiska CLR podczas czyszczenia, co może powodować problemy z współużytkowania wątkowością dla kilku aplikacji, które spełniają następujące nietypowe kryteria:  
  
-   Aplikacja wykonuje własną pompę komunikatów.  
  
-   Aplikacja musi dokładnie kontrolować, kiedy odbywa się pompa komunikatów.  
  
 Takie aplikacje mogą korzystać <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> z metody, aby uniemożliwić środowisku CLR automatyczne odzyskiwanie wywoływanych otok środowiska uruchomieniowego.  
  
 Po wywołaniu tej metody w wątku automatyczne czyszczenie nie może zostać włączone dla tego wątku. Gdy aplikacja jest gotowa do czyszczenia wywoływanych otok środowiska uruchomieniowego, użyj <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> metody, aby nakazać środowisko uruchomieniowe oczyszczania wszystkich wywoływanych otok środowiska uruchomieniowego w bieżącym kontekście. Podczas wykonywania metody jest wykonywana pompa komunikatów.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, że wykonanie polega na wprowadzeniu regionu kodu, w którym efekty przerwania wątku lub nieobsłużonego wyjątku są ograniczone do bieżącego zadania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosty środowiska uruchomieniowego języka wspólnego (CLR), takie jak Microsoft SQL Server 2005, mogą nawiązywać różne zasady dla błędów w regionach krytycznych i niekrytycznych. Region krytyczny to jeden, w którym skutki przerwania wątku lub nieobsłużonego wyjątku mogą nie być ograniczone do bieżącego zadania. Z kolei, przerwanie lub błąd w niekrytycznym regionie kodu ma wpływ tylko na zadanie, w którym występuje błąd.  
  
 Rozważmy na przykład zadanie, które próbuje przydzielić pamięć podczas utrzymywania blokady. Jeśli alokacja pamięci nie powiedzie się, przerywanie bieżącego zadania nie jest wystarczające, aby zapewnić <xref:System.AppDomain>stabilność, ponieważ w domenie mogą znajdować się inne zadania oczekujące na tę samą blokadę. Jeśli bieżące zadanie zostało zakończone, inne zadania mogą być zakleszczony.  
  
 Gdy wystąpi awaria w regionie krytycznym, host może podjąć decyzję o rozłączeniu <xref:System.AppDomain> całości, a nie z ryzykiem ciągłego wykonywania w stanie potencjalnie niestabilnym. Aby poinformować hosta, że Twój kod przechodzi do regionu krytycznego, wywołaj <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Wywołanie <xref:System.Threading.Thread.EndCriticalRegion%2A> , gdy wykonanie powraca do niekrytycznego regionu kodu.  
  
 Użycie tej metody w kodzie, który jest uruchamiany w SQL Server 2005 wymaga, aby kod był uruchamiany na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Threading.Thread.BeginCriticalRegion%2A> metod i <xref:System.Threading.Thread.EndCriticalRegion%2A> do dzielenia bloku kodu na regiony krytyczne i niekrytyczne.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia hosta, że kod zarządzany zakończył wykonywanie instrukcji, które są zależne od tożsamości bieżącego fizycznego wątku systemu operacyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre hosty środowiska uruchomieniowego języka wspólnego, takie jak Microsoft SQL Server 2005, zapewniają własne zarządzanie wątkami. Host, który zapewnia własne zarządzanie wątkami, może przenieść wykonywanie zadania z jednego fizycznego wątku systemu operacyjnego do innego w dowolnym momencie. Tego przełączania nie ma wpływ na większość zadań. Jednak niektóre zadania mają koligację wątku — to oznacza, że zależą od tożsamości fizycznego wątku systemu operacyjnego. Te zadania muszą poinformować hosta, gdy wykonują kod, który nie powinien być przełączany.  
  
 Na przykład jeśli aplikacja wywołuje systemowy interfejs API w celu uzyskania blokady systemu operacyjnego, która ma koligację wątku, taką jak critical_section Win32, należy wywołać <xref:System.Threading.Thread.BeginThreadAffinity%2A> przed uzyskaniem blokady i <xref:System.Threading.Thread.EndThreadAffinity%2A> po zwolnieniu blokady.  
  
 Użycie tej metody w kodzie, który jest uruchamiany w SQL Server 2005 wymaga, aby kod był uruchamiany na najwyższym poziomie ochrony hosta.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Threading.Thread.BeginThreadAffinity%2A> metod i <xref:System.Threading.Thread.EndThreadAffinity%2A> w celu powiadomienia hosta, że blok kodu zależy od tożsamości fizycznego wątku systemu operacyjnego.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.ExecutionContext" /> Pobiera obiekt, który zawiera informacje o różnych kontekstach bieżącego wątku.</summary>
        <value><see cref="T:System.Threading.ExecutionContext" /> Obiekt, który konsoliduje informacje kontekstu dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext> Klasa zawiera pojedynczy kontener dla wszystkich informacji istotnych dla logicznego wątku wykonywania. Dotyczy to kontekstu zabezpieczeń, kontekstu wywołania, kontekstu synchronizacji, kontekstu lokalizacji i kontekstu transakcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że zasoby są zwolnione i inne operacje czyszczenia są wykonywane, gdy moduł zbierający <see cref="T:System.Threading.Thread" /> elementy bezużyteczne odzyskuje obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł zbierający elementy <xref:System.Threading.Thread.Finalize%2A> bezużyteczne wywołuje, kiedy bieżący obiekt jest gotowy do sfinalizowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa miejsca danych, które ma zostać zwolnione.</param>
        <summary>Eliminuje skojarzenie między nazwą i miejscem, dla wszystkich wątków w procesie. W celu uzyskania lepszej wydajności Użyj pól, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> atrybutem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework zapewnia dwa mechanizmy używania lokalnego magazynu wątków (TLS): pola statyczne powiązane z <xref:System.ThreadStaticAttribute> wątkiem (czyli pola oznaczone atrybutem) i gniazda danych. Pola statyczne względne dla wątków zapewniają znacznie lepszą wydajność niż gniazda danych i umożliwiają sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z [protokołu TLS, zobacz temat lokalny magazyn wątków: Pola statyczne powiązane z wątkiem i gniazda](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)danych.  
  
 Po dowolnych `FreeNamedDataSlot`wywołaniach wątku każdy inny wątek <xref:System.Threading.Thread.GetNamedDataSlot%2A> , który wywołuje o tej samej nazwie, przydzieli nowe miejsce skojarzone z nazwą. Kolejne wywołania do `GetNamedDataSlot` każdego wątku zwracają nowe miejsce. Jednak każdy wątek, który nadal jest <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> zwracany przez poprzednie wywołanie do `GetNamedDataSlot` , może nadal używać starego gniazda.  
  
 Gniazdo, które zostało skojarzone z nazwą, jest uwalniane tylko wtedy `LocalDataStoreSlot` , gdy jest ono uzyskiwane przed `FreeNamedDataSlot` zwolnieniem i zebraniem elementów bezużytecznych.  
  
 Wątki używają mechanizmu pamięci magazynu lokalnego do przechowywania danych specyficznych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicę magazynów danych z obsługą wielu gniazd do każdego procesu podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywać i pobierać wartość danych w gnieździe i zwolnić miejsce do ponownego użycia po wygaśnięciu wątku. Gniazda danych są unikatowe dla każdego wątku. Żaden inny wątek (nawet wątek podrzędny) nie może uzyskać tych danych.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak używać pola, które jest oznaczone <xref:System.ThreadStaticAttribute> atrybutem, aby przechowywać informacje specyficzne dla wątku. Drugi przykład pokazuje, jak używać miejsca danych do wykonania tego samego działania.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak używać pola oznaczonego przez <xref:System.ThreadStaticAttribute> , aby przechowywać informacje specyficzne dla wątku. Ta technika zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład ilustruje sposób użycia nazwanego gniazda danych do przechowywania informacji dotyczących wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Pamięć lokalna wątku: Powiązane z wątkiem pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.ApartmentState" /> Zwraca wartość wskazującą stan apartamentu.</summary>
        <returns>Jedna z <see cref="T:System.Threading.ApartmentState" /> wartości wskazujących stan apartamentu zarządzanego wątku. Wartość domyślna to <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda, wraz z <xref:System.Threading.Thread.SetApartmentState%2A> metodą <xref:System.Threading.Thread.TrySetApartmentState%2A> i metodą, zastępuje <xref:System.Threading.Thread.ApartmentState%2A> właściwość.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Threading.Thread.GetApartmentState%2A>metody, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> . Przykładowy kod tworzy wątek. Przed uruchomieniem wątku program <xref:System.Threading.Thread.GetApartmentState%2A> wyświetli stan początkowy <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> i <xref:System.Threading.Thread.SetApartmentState%2A> zmieni stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Następnie metoda zwraca `false` przy próbie zmiany stanu na <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , ponieważ stan apartamentu jest już ustawiony. <xref:System.Threading.Thread.TrySetApartmentState%2A> Jeśli podjęto próbę wykonania <xref:System.Threading.Thread.SetApartmentState%2A>tej samej operacji, <xref:System.InvalidOperationException> zostanie zgłoszony.  
  
 Gdy wątek zostanie uruchomiony, <xref:System.Threading.Thread.TrySetApartmentState%2A> Metoda zostanie użyta ponownie. Ten czas jest zgłaszany <xref:System.Threading.ThreadStateException> , ponieważ wątek został już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.CompressedStack" /> Zwraca obiekt, który może służyć do przechwytywania stosu dla bieżącego wątku.</summary>
        <returns>Brak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest już obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot">, <see cref="T:System.LocalDataStoreSlot" /> Z którego ma zostać pobrana wartość.</param>
        <summary>Pobiera wartość z określonego gniazda w bieżącym wątku w bieżącej domenie bieżącego wątku. W celu uzyskania lepszej wydajności Użyj pól, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> atrybutem.</summary>
        <returns>Pobrana wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework zapewnia dwa mechanizmy używania lokalnego magazynu wątków (TLS): pola statyczne powiązane z <xref:System.ThreadStaticAttribute> wątkiem (czyli pola oznaczone atrybutem) i gniazda danych. Pola statyczne względne dla wątków zapewniają znacznie lepszą wydajność niż gniazda danych i umożliwiają sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z [protokołu TLS, zobacz temat lokalny magazyn wątków: Pola statyczne powiązane z wątkiem i gniazda](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)danych.  
  
 Wątki używają mechanizmu pamięci magazynu lokalnego do przechowywania danych specyficznych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicę magazynów danych z obsługą wielu gniazd do każdego procesu podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywać i pobierać wartość danych w gnieździe i zwolnić miejsce do ponownego użycia po wygaśnięciu wątku. Gniazda danych są unikatowe dla każdego wątku. Żaden inny wątek (nawet wątek podrzędny) nie może uzyskać tych danych.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A>`Shared` to metoda, która zawsze ma zastosowanie do aktualnie wykonywanego wątku, nawet jeśli zostanie wywołana przy użyciu zmiennej, która odwołuje się do innego wątku. Aby uniknąć nieporozumień, użyj nazwy klasy podczas `Shared` wywoływania metod `Dim test As Object = Thread.GetData(testSlot)`:.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak używać pola, które jest oznaczone <xref:System.ThreadStaticAttribute> atrybutem, aby przechowywać informacje specyficzne dla wątku. Drugi przykład pokazuje, jak używać miejsca danych do wykonania tego samego działania.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak używać pola oznaczonego przez <xref:System.ThreadStaticAttribute> , aby przechowywać informacje specyficzne dla wątku. Ta technika zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład ilustruje sposób użycia miejsca danych do przechowywania informacji dotyczących wątku.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Pamięć lokalna wątku: Powiązane z wątkiem pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca bieżącą domenę, w której jest uruchomiony bieżący wątek.</summary>
        <returns><see cref="T:System.AppDomain" /> Reprezentująca bieżącą domenę aplikacji działającego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać nazwę i identyfikator, `AppDomain` w którym jest uruchomiony wątek.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca unikatowy identyfikator domeny aplikacji.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem, która jednoznacznie identyfikuje domenę aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać nazwę i identyfikator, `AppDomain` w którym jest uruchomiony wątek.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego wątku.</summary>
        <returns>Wartość kodu skrótu wartości całkowitej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod skrótu nie gwarantuje unikalności. Użyj właściwości <xref:System.Threading.Thread.ManagedThreadId%2A> , jeśli potrzebujesz unikatowego identyfikatora dla wątku zarządzanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa lokalnego miejsca danych.</param>
        <summary>Wyszukuje nazwane gniazdo danych. W celu uzyskania lepszej wydajności Użyj pól, które są oznaczone <see cref="T:System.ThreadStaticAttribute" /> atrybutem.</summary>
        <returns><see cref="T:System.LocalDataStoreSlot" /> Przydzielono dla tego wątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework zapewnia dwa mechanizmy używania lokalnego magazynu wątków (TLS): pola statyczne powiązane z <xref:System.ThreadStaticAttribute> wątkiem (czyli pola oznaczone atrybutem) i gniazda danych. Pola statyczne względne dla wątków zapewniają znacznie lepszą wydajność niż gniazda danych i umożliwiają sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z [protokołu TLS, zobacz temat lokalny magazyn wątków: Pola statyczne powiązane z wątkiem i gniazda](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)danych.  
  
 Wątki używają mechanizmu pamięci magazynu lokalnego do przechowywania danych specyficznych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicę magazynów danych z obsługą wielu gniazd do każdego procesu podczas jego tworzenia. Wątek może przydzielić miejsce danych w magazynie danych, przechowywać i pobierać wartość danych w gnieździe i zwolnić miejsce do ponownego użycia po wygaśnięciu wątku. Gniazda danych są unikatowe dla każdego wątku. Żaden inny wątek (nawet wątek podrzędny) nie może uzyskać tych danych.  
  
 Jeśli nazwane miejsce nie istnieje, przydzielono nowe miejsce. Nazwane gniazda danych są publiczne i mogą być przetwarzane przez każdego użytkownika.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak używać pola, które jest oznaczone <xref:System.ThreadStaticAttribute> atrybutem, aby przechowywać informacje specyficzne dla wątku. Drugi przykład pokazuje, jak używać miejsca danych do wykonania tego samego działania.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak używać pola oznaczonego przez <xref:System.ThreadStaticAttribute> , aby przechowywać informacje specyficzne dla wątku. Ta technika zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład ilustruje sposób użycia nazwanego gniazda danych do przechowywania informacji dotyczących wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Pamięć lokalna wątku: Powiązane z wątkiem pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przerywa wątek, który jest w <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> stanie wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten wątek nie jest obecnie blokowany w stanie oczekiwania, uśpienia lub przyłączania, zostanie przerwany po następnym rozpoczęciu bloku.  
  
 <xref:System.Threading.ThreadInterruptedException>jest zgłaszany w przerwanym wątku, ale nie do momentu blokowania wątków. Jeśli wątek nigdy nie jest blokowany, wyjątek nigdy nie zostanie zgłoszony i w ten sposób wątek może zakończyć się bez przerywania działania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zachowanie działającego wątku, gdy zostanie przerwany i następnie jest blokowany.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniego <see cref="T:System.Security.Permissions.SecurityPermission" />elementu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zaawansowanych operacji na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Wstrzymywanie i przerywanie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą stan wykonywania bieżącego wątku.</summary>
        <value><see langword="true" />Jeśli ten wątek został uruchomiony i nie został zakończony normalnie lub przerwany; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wątek jest wątkiem w tle.</summary>
        <value><see langword="true" />Jeśli ten wątek jest lub ma być wątkiem w tle; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek jest wątkiem w tle lub wątkiem pierwszego planu. Wątki w tle są takie same jak wątki pierwszego planu, z wyjątkiem tego, że wątki w tle nie uniemożliwiają zakończenia procesu. Gdy wszystkie wątki pierwszego planu należące do procesu zakończą działanie, środowisko uruchomieniowe języka wspólnego kończy proces. Wszystkie pozostałe wątki w tle są zatrzymane i nie są kompletne.  
  
 Domyślnie następujące wątki są wykonywane na pierwszym planie (oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> Właściwość zwraca `false`):  
  
-   Wątek podstawowy (lub główny wątek aplikacji).  
  
-   Wszystkie wątki utworzone przez wywołanie <xref:System.Threading.Thread> konstruktora klasy.  
  
 Domyślnie następujące wątki są wykonywane w tle (oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A> Właściwość zwraca `true`):  
  
-   Wątki puli wątków, które są pulą wątków roboczych obsługiwanych przez środowisko uruchomieniowe. Można skonfigurować pulę wątków i zaplanować prace w wątkach puli wątków przy użyciu <xref:System.Threading.ThreadPool> klasy.  
  
    > [!NOTE]
    >  Asynchroniczne operacje oparte na zadaniach są automatycznie wykonywane w wątkach puli wątków.  
  
-   Wszystkie wątki, które wprowadzają zarządzane środowisko wykonawcze z kodu niezarządzanego.  
  
   
  
## Examples  
 Poniższy przykład kontrastuje zachowanie wątków pierwszego planu i tła. Tworzy wątek pierwszego planu i wątek w tle. Wątek pierwszego planu utrzymuje proces uruchomiony do momentu ukończenia `for` jego pętli i zakończenia. Jednak jako dane wyjściowe z przykładu pokazują, że wątek pierwszego planu zakończył wykonywanie, proces zostanie przerwany przed ukończeniem wykonywania wątku w tle.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek jest martwy.</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">Wątki pierwszego planu i tła</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wątek należy do puli zarządzanych wątków.</summary>
        <value><see langword="true" />Jeśli ten wątek należy do puli wątków zarządzanych; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji [, zobacz Zarządzana pula wątków](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustalić, czy wątek pochodzi z puli wątków.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Zarządzana pula wątków</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje wątek wywołujący do momentu zakończenia wątku reprezentowanego przez to wystąpienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje wątek wywołujący do momentu przerwania wątku reprezentowanego przez to wystąpienie, przy jednoczesnym kontynuowaniu <see langword="SendMessage" /> wykonywania standardowych modeli com i pompowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A>jest metodą synchronizacji, która blokuje wątek wywołujący (czyli wątek wywołujący metodę) do momentu, gdy wątek, którego <xref:System.Threading.Thread.Join%2A> Metoda jest wywoływana, została ukończona. Użyj tej metody, aby upewnić się, że wątek został zakończony. Obiekt wywołujący będzie blokowany w nieskończoność, jeśli wątek nie zostanie zakończony. W `Thread1` poniższym przykładzie wątek `Thread2` <xref:System.Threading.Thread.Join> wywołuje metodę, która powoduje `Thread1` zablokowanie do momentu `Thread2` ukończenia.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Jeśli wątek został już zakończony, gdy <xref:System.Threading.Thread.Join%2A> jest wywoływana, metoda zwraca natychmiast.  
  
> [!WARNING]
>  Nigdy nie należy wywoływać <xref:System.Threading.Thread.Join%2A> metody <xref:System.Threading.Thread> obiektu, który reprezentuje bieżący wątek z bieżącego wątku. Powoduje to, że aplikacja przestanie odpowiadać, ponieważ bieżący wątek czeka na siebie,  
  
 Ta metoda zmienia stan wątku wywołującego do dołączenia <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Nie można wywołać `Join` w wątku, który jest <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> w stanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Obiekt wywołujący próbował dołączyć do wątku znajdującego się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanie.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek został przerwany podczas oczekiwania.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania na zakończenie wątku.</param>
        <summary>Blokuje wątek wywołujący do momentu przerwania wątku reprezentowanego przez to wystąpienie lub określonego czasu, przy jednoczesnym kontynuowaniu standardowej pompowania modelu COM i SendMessage.</summary>
        <returns><see langword="true" />Jeśli wątek został zakończony; Jeśli wątek nie został zakończony po upływie czasu określonego <paramref name="millisecondsTimeout" /> przez parametr. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29>jest metodą synchronizacji, która blokuje wątek wywołujący (czyli wątek wywołujący metodę) do momentu, gdy wątek, którego <xref:System.Threading.Thread.Join%2A> Metoda jest wywoływana, została zakończona lub upłynął limit czasu. W `Thread1` poniższym przykładzie wątek `Thread2` <xref:System.Threading.Thread.Join> wywołuje metodę, która powoduje `Thread1` zablokowanie do czasu `Thread2` zakończenia lub 2 sekundy.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jest określony `millisecondsTimeout` dla parametru, ta metoda zachowuje się identycznie z <xref:System.Threading.Thread.Join> przeciążeniem metody, z wyjątkiem wartości zwracanej.  
  
 Jeśli wątek został już zakończony, gdy <xref:System.Threading.Thread.Join%2A> jest wywoływana, metoda zwraca natychmiast.  
  
 Ta metoda zmienia stan wątku wywołującego do dołączenia <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Nie można wywołać `Join` w wątku, który jest <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> w stanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsTimeout" /> jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa wartości w milisekundach.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><paramref name="millisecondsTimeout" />jest mniejsza niż-1 (timeout. Infinite).</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wątek został przerwany podczas oczekiwania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Ustawiony na czas oczekiwania na zakończenie wątku.</param>
        <summary>Blokuje wątek wywołujący do momentu przerwania wątku reprezentowanego przez to wystąpienie lub określonego czasu, przy jednoczesnym kontynuowaniu standardowej pompowania modelu COM i SendMessage.</summary>
        <returns><see langword="true" />Jeśli wątek został przerwany; Jeśli wątek nie został zakończony po upływie czasu określonego <paramref name="timeout" /> przez parametr. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29>jest metodą synchronizacji, która blokuje wątek wywołujący (czyli wątek wywołujący metodę) do momentu, gdy wątek, którego <xref:System.Threading.Thread.Join%2A> Metoda jest wywoływana, została zakończona lub upłynął limit czasu. W `Thread1` poniższym przykładzie wątek `Thread2` <xref:System.Threading.Thread.Join> wywołuje metodę, która powoduje `Thread1` zablokowanie do czasu `Thread2` zakończenia lub 2 sekundy.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Jeśli <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jest określony dla `timeout`, ta metoda zachowuje się identycznie z <xref:System.Threading.Thread.Join> przeciążeniem metody, z wyjątkiem wartości zwracanej.  
  
 Jeśli wątek został już zakończony, gdy <xref:System.Threading.Thread.Join%2A> jest wywoływana, metoda zwraca natychmiast.  
  
 Ta metoda zmienia stan bieżącego wątku do dołączenia <xref:System.Threading.ThreadState.WaitSleepJoin>. Nie można wywołać `Join` w wątku, który jest <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> w stanie.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób używania `TimeSpan` wartości `Join` z metodą.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa wartości w milisekundach lub jest większa od <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Obiekt wywołujący próbował dołączyć do wątku znajdującego się w <see cref="F:System.Threading.ThreadState.Unstarted" /> stanie.</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator bieżącego wątku zarządzanego.</summary>
        <value>Liczba całkowita reprezentująca unikatowy identyfikator dla tego wątku zarządzanego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości wątku służy do jednoznacznego identyfikowania tego wątku w ramach procesu.  
  
 Wartość <xref:System.Threading.Thread.ManagedThreadId%2A> właściwości nie różni się w zależności od czasu, nawet jeśli kod niezarządzany, który obsługuje środowisko uruchomieniowe języka wspólnego, implementuje wątek jako włókna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronizuje dostęp do pamięci w następujący sposób: Procesor wykonujący bieżący wątek nie może zmienić kolejności instrukcji w taki sposób, że dostęp do pamięci przed wywołaniem <see cref="M:System.Threading.Thread.MemoryBarrier" /> zostanie wykonany po uzyskaniu dostępu do pamięci, który jest zgodny z <see cref="M:System.Threading.Thread.MemoryBarrier" />wywołaniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A>jest wymagana tylko w systemach wieloprocesorowych z słabą kolejnością pamięci (na przykład w systemie wykorzystującym wiele procesorów Intel Itanium).  
  
 W C# `lock` większości zastosowań instrukcja, instrukcja Visual Basic `SyncLock` lub <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze sposoby synchronizowania danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę wątku.</summary>
        <value>Ciąg zawierający nazwę wątku lub <see langword="null" /> Jeśli nie ustawiono żadnej nazwy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest jednokrotnie zapisu. Ponieważ wartością domyślną <xref:System.Threading.Thread.Name%2A> właściwości wątku jest `null`, można określić, czy nazwa została już jawnie przypisana do wątku, porównując ją z `null`.  
  
 Ciąg przypisany do <xref:System.Threading.Thread.Name%2A> właściwości może zawierać dowolny znak Unicode.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak nazwać wątek.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zażądano operacji zestawu, ale <see langword="Name" /> właściwość została już ustawiona.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą priorytet planowania wątku.</summary>
        <value>Jedna z <see cref="T:System.Threading.ThreadPriority" /> wartości. Wartość domyślna to <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do wątku można przypisać jedną z następujących wartości priorytetu <xref:System.Threading.ThreadPriority> :  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Systemy operacyjne nie są wymagane do przestrzegania priorytetu wątku.  
  
   
  
## Examples  
 Poniższy przykład pokazuje wynik zmiany priorytetu wątku. Trzy wątki są tworzone, priorytet jednego wątku jest ustawiony na <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, a priorytet sekundy jest ustawiony na. <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType> Każdy wątek zwiększa zmienną w `while` pętli i działa przez określony czas.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek osiągnął stan końcowy, na <see cref="F:System.Threading.ThreadState.Aborted" />przykład.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla operacji zestawu nie jest prawidłową <see cref="T:System.Threading.ThreadPriority" /> wartością.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">Harmonogram wątków</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje <see cref="M:System.Threading.Thread.Abort(System.Object)" /> żądanie dla bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać tylko przy użyciu kodu z odpowiednimi uprawnieniami.  
  
 Gdy wywołanie `Abort` w celu zakończenia wątku, system <xref:System.Threading.ThreadAbortException>zgłasza. `ThreadAbortException`to specjalny wyjątek, który może zostać przechwycony przez kod aplikacji, ale jest ponownie zgłaszany na końcu bloku catch, chyba że `ResetAbort` jest wywoływana. `ResetAbort`anuluje żądanie przerwania i uniemożliwia `ThreadAbortException` zakończenie wątku.  
  
 Zobacz <xref:System.Threading.ThreadAbortException> , aby zapoznać się z przykładem `ResetAbort` , który demonstruje wywoływanie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany.</exception>
        <exception cref="T:System.Threading.ThreadStateException"><see langword="Abort" />nie została wywołana w bieżącym wątku.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganego uprawnienia zabezpieczeń dla bieżącego wątku.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zaawansowanych operacji na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Niszczenie wątków</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia wątek, który został zawieszony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Nie należy używać <xref:System.Threading.Thread.Suspend%2A> metod i <xref:System.Threading.Thread.Resume%2A> do synchronizowania działań wątków. Nie ma możliwości znajomości kodu, który jest wykonywany przez wątek po jego wstrzymaniu. W przypadku wstrzymania wątku, gdy jest on blokowany podczas oceny uprawnień zabezpieczeń, inne wątki w programie <xref:System.AppDomain> mogą zostać zablokowane. Jeśli wątek zawiesza się podczas wykonywania konstruktora klasy, inne wątki w <xref:System.AppDomain> tej próbce użycia tej klasy są blokowane. Zakleszczenia mogą być bardzo proste.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony, jest martwy lub nie jest w stanie wstrzymania.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniego <see cref="T:System.Security.Permissions.SecurityPermission" />elementu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zaawansowanych operacji na wątkach. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Wstrzymywanie i przerywanie wątków</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state">Nowy stan apartamentu.</param>
        <summary>Ustawia stan apartamentu wątku przed jego uruchomieniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wątki są inicjowane <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> tak, jakby ich stan apartamentu nie został ustawiony przed rozpoczęciem. Przed uruchomieniem wątku należy ustawić stan apartamentu.  
  
> [!NOTE]
>  Główny wątek aplikacji jest domyślnie zainicjowany <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> . Jedynym sposobem ustawienia statusu apartamentu głównego wątku <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> aplikacji jest <xref:System.STAThreadAttribute> zastosowanie atrybutu do metody punktu wejścia.  
  
 Metoda, wraz <xref:System.Threading.Thread.GetApartmentState%2A> z metodą i <xref:System.Threading.Thread.TrySetApartmentState%2A> metodą, zastępuje <xref:System.Threading.Thread.ApartmentState%2A> właściwość. <xref:System.Threading.Thread.SetApartmentState%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Threading.Thread.GetApartmentState%2A>metody, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> . Przykładowy kod tworzy wątek. Przed uruchomieniem wątku program <xref:System.Threading.Thread.GetApartmentState%2A> wyświetli stan początkowy <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> i <xref:System.Threading.Thread.SetApartmentState%2A> zmieni stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Następnie metoda zwraca `false` przy próbie zmiany stanu na <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , ponieważ stan apartamentu jest już ustawiony. <xref:System.Threading.Thread.TrySetApartmentState%2A> Jeśli podjęto próbę wykonania <xref:System.Threading.Thread.SetApartmentState%2A>tej samej operacji, <xref:System.InvalidOperationException> zostanie zgłoszony.  
  
 Gdy wątek zostanie uruchomiony, <xref:System.Threading.Thread.TrySetApartmentState%2A> Metoda zostanie użyta ponownie. Ten czas jest zgłaszany <xref:System.Threading.ThreadStateException> , ponieważ wątek został już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany na platformach macOS i Linux.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" />nie jest prawidłowym stanem apartamentu.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek został już uruchomiony.</exception>
        <exception cref="T:System.InvalidOperationException">Stan apartamentu został już zainicjowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stack"><see cref="T:System.Threading.CompressedStack" /> Obiekt, który ma zostać zastosowany do bieżącego wątku.</param>
        <summary>Stosuje przechwyconą <see cref="T:System.Threading.CompressedStack" /> do bieżącego wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest już obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">We wszystkich przypadkach.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot">, <see cref="T:System.LocalDataStoreSlot" /> W którym ma zostać ustawiona wartość.</param>
        <param name="data">Wartość, która ma zostać ustawiona.</param>
        <summary>Ustawia dane w określonym gnieździe w aktualnie uruchomionym wątku dla bieżącej domeny tego wątku. Aby uzyskać lepszą wydajność, zamiast tego użyj pól <see cref="T:System.ThreadStaticAttribute" /> oznaczonych atrybutem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework zapewnia dwa mechanizmy używania lokalnego magazynu wątków (TLS): pola statyczne powiązane z <xref:System.ThreadStaticAttribute> wątkiem (czyli pola oznaczone atrybutem) i gniazda danych. Pola statyczne względne dla wątków zapewniają znacznie lepszą wydajność niż gniazda danych i umożliwiają sprawdzanie typów w czasie kompilacji. Aby uzyskać więcej informacji o korzystaniu z [protokołu TLS, zobacz temat lokalny magazyn wątków: Pola statyczne powiązane z wątkiem i gniazda](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)danych.  
  
 Wątki używają mechanizmu pamięci magazynu lokalnego do przechowywania danych specyficznych dla wątku. Środowisko uruchomieniowe języka wspólnego przydziela tablicę magazynów danych z obsługą wielu gniazd do każdego procesu podczas jego tworzenia. Wątek może przydzielić miejsce na danych w magazynie danych, przechowywać i pobierać wartość danych w gnieździe i zwalniać miejsce do ponownego użycia po zakończeniu procedury wątku i <xref:System.Threading.Thread> odzyskania obiektu przez wyrzucanie elementów bezużytecznych. Gniazda danych są unikatowe dla każdego wątku. Żaden inny wątek (nawet wątek podrzędny) nie może uzyskać tych danych.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A>`Shared` to metoda, która zawsze ma zastosowanie do aktualnie wykonywanego wątku, nawet jeśli zostanie wywołana przy użyciu zmiennej, która odwołuje się do innego wątku. Aby uniknąć nieporozumień, użyj nazwy klasy podczas `Shared` wywoływania metod `Thread.SetData(testSlot, "test data")`:.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak używać pola, które jest oznaczone <xref:System.ThreadStaticAttribute> atrybutem, aby przechowywać informacje specyficzne dla wątku. Drugi przykład pokazuje, jak używać miejsca danych do wykonania tego samego działania.  
  
 **Pierwszy przykład**  
  
 Poniższy przykład pokazuje, jak używać pola oznaczonego przez <xref:System.ThreadStaticAttribute> , aby przechowywać informacje specyficzne dla wątku. Ta technika zapewnia lepszą wydajność niż technika, która jest wyświetlana w drugim przykładzie.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Drugi przykład**  
  
 Poniższy przykład ilustruje sposób użycia nazwanego gniazda danych do przechowywania informacji dotyczących wątku.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Pamięć lokalna wątku: Powiązane z wątkiem pola statyczne i gniazda danych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstrzymuje bieżący wątek przez określony czas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, przez jaką wątek jest zawieszony. Jeśli wartość <paramref name="millisecondsTimeout" /> argumentu jest równa zero, wątek zwalnia resztę jego wycinka czasu do dowolnego wątku o równym priorytecie, który jest gotowy do uruchomienia. Jeśli nie ma innych wątków o równym priorytecie, które są gotowe do uruchomienia, wykonanie bieżącego wątku nie jest wstrzymane.</param>
        <summary>Wstrzymuje bieżący wątek przez określoną liczbę milisekund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie zostanie zaplanowany do wykonania przez system operacyjny przez określony czas. Ta metoda zmienia stan wątku do uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Możesz określić <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> `millisecondsTimeout` parametr, aby wstrzymać wątek w nieskończoność. Zaleca się jednak używanie innych <xref:System.Threading?displayProperty=nameWithType> klas, takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor> <xref:System.Threading.EventWaitHandle>,, lub <xref:System.Threading.Semaphore> zamiast synchronizować wątki lub zarządzać zasobami.  
  
 Zegar systemowy taktuje określoną stawkę nazywaną rozdzielczością zegara. Rzeczywisty limit czasu może nie być dokładnie określony w określonym limicie czasu, ponieważ określony limit czasu zostanie dostosowany tak, aby był zbieżny z taktami zegara. Aby uzyskać więcej informacji o rozdzielczości zegara i czasie oczekiwania, zobacz temat [Funkcja uśpienia](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) . Ta metoda wywołuje [funkcję uśpienia](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) z interfejsów API systemu Windows.  
  
 Ta metoda nie wykonuje standardowej pompowania modelu COM i SendMessage.  
  
> [!NOTE]
>  Jeśli zachodzi potrzeba uśpienia w wątku, który <xref:System.STAThreadAttribute>ma, ale chcesz wykonać standardowe pompowanie modelu COM i SendMessage, rozważ użycie jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metody, która określa interwał limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Threading.Thread.Sleep%2A> metody do blokowania głównego wątku aplikacji.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość limitu czasu jest ujemna i nie jest równa <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Czas wstrzymania wątku. Jeśli wartość <paramref name="millisecondsTimeout" /> argumentu to <see cref="F:System.TimeSpan.Zero" />, wątek zrzeka reszty jego wycinka czasu do dowolnego wątku o równym priorytecie, który jest gotowy do uruchomienia. Jeśli nie ma innych wątków o równym priorytecie, które są gotowe do uruchomienia, wykonanie bieżącego wątku nie jest wstrzymane.</param>
        <summary>Wstrzymuje bieżący wątek przez określony czas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wątek nie zostanie zaplanowany do wykonania przez system operacyjny przez określony czas. Ta metoda zmienia stan wątku do uwzględnienia <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Możesz określić <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> `timeout` parametr, aby wstrzymać wątek w nieskończoność. Zaleca się jednak używanie innych <xref:System.Threading?displayProperty=nameWithType> klas, takich jak <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor> <xref:System.Threading.EventWaitHandle>,, lub <xref:System.Threading.Semaphore> zamiast synchronizować wątki lub zarządzać zasobami.  
  
 To Przeciążenie <xref:System.Threading.Thread.Sleep%2A> używa łącznej liczby całych milisekund w `timeout`. Ułamki milisekundy są odrzucane.  
  
 Ta metoda nie wykonuje standardowej pompowania modelu COM i SendMessage.  
  
> [!NOTE]
>  Jeśli zachodzi potrzeba uśpienia w wątku, który <xref:System.STAThreadAttribute>ma, ale chcesz wykonać standardowe pompowanie modelu COM i SendMessage, rozważ użycie jednego z przeciążeń <xref:System.Threading.Thread.Join%2A> metody, która określa interwał limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> przeciążenia metody do zablokowania głównego wątku aplikacji pięć razy, przez dwa sekundy za każdym razem.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="timeout" /> jest ujemna i nie jest <see cref="F:System.Threading.Timeout.Infinite" /> równa wartości w milisekundach lub jest większa od <see cref="F:System.Int32.MaxValue" /> milisekund.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="iterations">32-bitowa liczba całkowita ze znakiem, która definiuje czas oczekiwania wątku.</param>
        <summary>Powoduje, że wątek oczekuje liczby razy zdefiniowanej przez <paramref name="iterations" /> parametr.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A> Metoda jest przydatna do implementowania blokad. Klasy w .NET Framework, takie jak <xref:System.Threading.Monitor> i <xref:System.Threading.ReaderWriterLock>, używają tej metody wewnętrznie. <xref:System.Threading.Thread.SpinWait%2A>zasadniczo umieszcza procesor w bardzo ścisłej pętli, z liczbą pętli określoną przez `iterations` parametr. W związku z tym czas oczekiwania zależy od szybkości procesora.  
  
 Z drugiej strony, <xref:System.Threading.Thread.Sleep%2A> za pomocą metody. Wątek, który wywołuje <xref:System.Threading.Thread.Sleep%2A> program, zwraca resztę bieżącego wycinka czasu procesora, nawet jeśli określony interwał wynosi zero. Określanie interwału niezerowego dla <xref:System.Threading.Thread.Sleep%2A> usuwa wątek z rozważenia przez harmonogram wątków do momentu, aż upłynie interwał czasu.  
  
 <xref:System.Threading.Thread.SpinWait%2A>nie jest zazwyczaj przydatne w przypadku zwykłych aplikacji. W większości przypadków należy używać klas synchronizacji dostarczonych przez .NET Framework; na przykład wywołanie <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> lub instrukcja, `SyncLock` która <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> zawija (`lock` w C# lub w Visual Basic).  
  
> [!CAUTION]
>  W rzadkich przypadkach, gdy jest korzystne, aby uniknąć przełączenia kontekstu, na przykład gdy wiadomo, że zmiana stanu jest bliska, należy wywołać <xref:System.Threading.Thread.SpinWait%2A> metodę w pętli. Ten kod <xref:System.Threading.Thread.SpinWait%2A> jest przeznaczony do zapobiegania problemom, które mogą wystąpić na komputerach z wieloma procesorami. Na przykład na komputerach z wieloma procesorami firmy Intel wykorzystujących technologię wielowątkowości w niektórych <xref:System.Threading.Thread.SpinWait%2A> sytuacjach program zapobiega zastępowaniu procesora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje zaplanowanie wykonywania wątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje zmianę stanu bieżącego wystąpienia systemu operacyjnego na <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek jest w <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stanie, system operacyjny może zaplanować jego wykonanie. Wątek rozpoczyna wykonywanie w pierwszym wierszu metody reprezentowanej przez <xref:System.Threading.ThreadStart> obiekt lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku. Należy zauważyć, że wywołanie <xref:System.Threading.Thread.Start%2A> nie blokuje wątku wywołującego.  
  
> [!NOTE]
>  Jeśli to przeciążenie jest używane z wątkiem utworzonym za <xref:System.Threading.ParameterizedThreadStart> pomocą delegata, `null` jest przenoszona do metody wykonywanej przez wątek.  
  
 Po zakończeniu wątku nie można go uruchomić ponownie przy użyciu innego wywołania metody `Start`.  
  
   
  
## Examples  
 Poniższy przykład tworzy i uruchamia wątek.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek został już uruchomiony.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci do uruchomienia tego wątku.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Wątki i wątkowość</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków i przekazywanie danych w czasie rozpoczęcia</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter">Obiekt, który zawiera dane, które mają być używane przez ten wątek.</param>
        <summary>Powoduje, że system operacyjny zmienia stan bieżącego wystąpienia na <see cref="F:System.Threading.ThreadState.Running" />i opcjonalnie dostarcza obiekt zawierający dane, które mają być używane przez ten wątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek jest w <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stanie, system operacyjny może zaplanować jego wykonanie. Wątek rozpoczyna wykonywanie w pierwszym wierszu metody reprezentowanej przez <xref:System.Threading.ThreadStart> obiekt lub <xref:System.Threading.ParameterizedThreadStart> delegata dostarczonego do konstruktora wątku. Należy zauważyć, że wywołanie <xref:System.Threading.Thread.Start%2A> nie blokuje wątku wywołującego.  
  
 Po zakończeniu wątku nie można go uruchomić ponownie przy użyciu innego wywołania metody `Start`.  
  
 Takie Przeciążenie i <xref:System.Threading.ParameterizedThreadStart> delegat ułatwiają przekazywanie danych do procedury wątku, ale technika nie jest bezpieczna, ponieważ każdy obiekt może zostać przekazany do tego przeciążenia. Bardziej niezawodny sposób przekazywania danych do procedury wątku polega na umieszczeniu procedury wątku i pól danych w obiekcie Worker. Aby uzyskać więcej informacji, zobacz [Tworzenie wątków i przekazywanie danych w czasie rozpoczęcia](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Threading.ParameterizedThreadStart> delegat z metodą statyczną i metodą wystąpienia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Wątek został już uruchomiony.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci do uruchomienia tego wątku.</exception>
        <exception cref="T:System.InvalidOperationException">Ten wątek został utworzony przy użyciu <see cref="T:System.Threading.ThreadStart" /> delegata, a <see cref="T:System.Threading.ParameterizedThreadStart" /> nie delegata.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Tworzenie wątków</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiesza wątek lub jeśli wątek jest już wstrzymany, nie ma żadnego wpływu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wątek jest już wstrzymany, ta metoda nie ma żadnego wpływu.  
  
> [!CAUTION]
> Nie należy używać <xref:System.Threading.Thread.Suspend%2A> metod i <xref:System.Threading.Thread.Resume%2A> do synchronizowania działań wątków. Nie ma możliwości znajomości kodu, który jest wykonywany przez wątek po jego wstrzymaniu. W przypadku wstrzymania wątku, gdy jest on blokowany podczas oceny uprawnień zabezpieczeń, inne wątki w programie <xref:System.AppDomain> mogą zostać zablokowane. Jeśli wątek zawiesza się podczas wykonywania konstruktora klasy, inne wątki w <xref:System.AppDomain> tej próbce użycia tej klasy są blokowane. Zakleszczenia mogą być bardzo proste.

Po wywołaniu `Suspend` metody w wątku, system odnotowuje, że zażądano zawieszenia wątku i zezwala na wykonanie wątku do momentu osiągnięcia bezpiecznego punktu przed faktycznym wstrzymaniem wątku. Bezpiecznym punktem dla wątku jest punkt w jego wykonaniu, w którym można wykonać odzyskiwanie pamięci. Po osiągnięciu bezpiecznego punktu środowiska uruchomieniowego gwarantuje, że wstrzymany wątek nie będzie podejmować dalszych postępów w kodzie zarządzanym. Wątek wykonujący się poza kodem zarządzanym jest zawsze bezpieczny do wyrzucania elementów bezużytecznych, a jego wykonywanie jest kontynuowane do momentu próby wznowienia wykonywania kodu zarządzanego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek nie został uruchomiony lub jest nieaktywny.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma odpowiedniego <see cref="T:System.Security.Permissions.SecurityPermission" />elementu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla zaawansowanych operacji na wątkach. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Wstrzymywanie i przerywanie wątków</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetIDsOfNames`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfo`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfoCount`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::Invoke`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość zawierającą Stany bieżącego wątku.</summary>
        <value>Jedna z <see cref="T:System.Threading.ThreadState" /> wartości wskazujących stan bieżącego wątku. Wartość początkowa to <see cref="F:System.Threading.ThreadState.Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zawiera bardziej szczegółowe informacje <xref:System.Threading.Thread.IsAlive%2A> niż właściwość. <xref:System.Threading.Thread.ThreadState%2A>  
  
> [!IMPORTANT]
>  Stan wątku jest interesujący tylko w scenariuszach debugowania. Kod nigdy nie powinien używać stanu wątku do synchronizowania działań wątków.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje dostęp `ThreadState` do wątku.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state">Nowy stan apartamentu.</param>
        <summary>Ustawia stan apartamentu wątku przed jego uruchomieniem.</summary>
        <returns><see langword="true" />Jeśli jest ustawiony stan apartamentu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowe wątki są inicjowane <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> tak, jakby ich stan apartamentu nie został ustawiony przed rozpoczęciem. Przed uruchomieniem wątku należy ustawić stan apartamentu.  
  
> [!NOTE]
>  Główny wątek aplikacji jest domyślnie zainicjowany <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> . Jedynym sposobem ustawienia statusu apartamentu głównego wątku <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> aplikacji jest <xref:System.STAThreadAttribute> zastosowanie atrybutu do metody punktu wejścia.  
  
 Metoda, wraz <xref:System.Threading.Thread.GetApartmentState%2A> z metodą i <xref:System.Threading.Thread.SetApartmentState%2A> metodą, zastępuje <xref:System.Threading.Thread.ApartmentState%2A> właściwość. <xref:System.Threading.Thread.TrySetApartmentState%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Threading.Thread.GetApartmentState%2A>metody, <xref:System.Threading.Thread.SetApartmentState%2A>, i <xref:System.Threading.Thread.TrySetApartmentState%2A> . Przykładowy kod tworzy wątek. Przed uruchomieniem wątku program <xref:System.Threading.Thread.GetApartmentState%2A> wyświetli stan początkowy <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> i <xref:System.Threading.Thread.SetApartmentState%2A> zmieni stan na <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Następnie metoda zwraca `false` przy próbie zmiany stanu na <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , ponieważ stan apartamentu jest już ustawiony. <xref:System.Threading.Thread.TrySetApartmentState%2A> Jeśli podjęto próbę wykonania <xref:System.Threading.Thread.SetApartmentState%2A>tej samej operacji, <xref:System.InvalidOperationException> zostanie zgłoszony.  
  
 Gdy wątek zostanie uruchomiony, <xref:System.Threading.Thread.TrySetApartmentState%2A> Metoda zostanie użyta ponownie. Ten czas jest zgłaszany <xref:System.Threading.ThreadStateException> , ponieważ wątek został już uruchomiony.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Tylko .NET Core: Ten element członkowski nie jest obsługiwany na platformach macOS i Linux.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" />nie jest prawidłowym stanem apartamentu.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Wątek został uruchomiony i zakończył się lub wywołanie nie jest wykonywane z kontekstu wątku, gdy działa wątek.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, które ma zostać odczytane.</param>
        <summary>Odczytuje wartość pola. Wartość to Najnowsza wersja zapisywana przez dowolny procesor w komputerze, niezależnie od liczby procesorów lub stanu pamięci podręcznej procesora.</summary>
        <returns>Najnowsza wartość zapisywana w polu przez dowolny procesor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileRead%2A> uzyskuje bardzo aktualną wartość zapisaną w lokalizacji pamięci przez dowolny procesor. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Pole, do którego ma zostać zapisywana wartość.</param>
        <param name="value">Wartość, która ma zostać zapisywana.</param>
        <summary>Natychmiast zapisuje wartość w polu, tak aby wartość była widoczna dla wszystkich procesorów w komputerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A>i <xref:System.Threading.Thread.VolatileWrite%2A> są przeznaczone dla specjalnych przypadków synchronizacji. W C# `lock` normalnych warunkach instrukcja, instrukcja Visual Basic `SyncLock` i <xref:System.Threading.Monitor> Klasa zapewniają łatwiejsze alternatywy.  
  
 W systemie wieloprocesorowym program <xref:System.Threading.Thread.VolatileWrite%2A> gwarantuje, że wartość zapisywana w lokalizacji w pamięci jest natychmiast widoczna dla wszystkich procesorów. Może to wymagać opróżniania pamięci podręcznych procesora.  
  
 Nawet w systemie <xref:System.Threading.Thread.VolatileRead%2A> jednoprocesorowym i <xref:System.Threading.Thread.VolatileWrite%2A> upewnij się, że wartość jest odczytywana lub zapisywana w pamięci, a nie w pamięci podręcznej (na przykład w rejestrze procesora). Z tego względu można użyć ich do synchronizowania dostępu do pola, które może być aktualizowane przez inny wątek lub przez sprzęt.  
  
 Wywołanie tej metody dotyczy tylko pojedynczego dostępu do pamięci. Aby zapewnić skuteczną synchronizację dla pola, wszystkie prawa dostępu do pola muszą używać <xref:System.Threading.Thread.VolatileRead%2A> lub <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  W C#programie użycie `volatile` modyfikatora w polu gwarantuje, że cały dostęp do tego pola korzysta <xref:System.Threading.Thread.VolatileRead%2A> z <xref:System.Threading.Thread.VolatileWrite%2A>lub.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wątek wywołujący przekazuje wykonywanie do innego wątku, który jest gotowy do uruchomienia na bieżącym procesorze. System operacyjny wybiera wątek do przeprowadzenia.</summary>
        <returns><see langword="true" />Jeśli system operacyjny przełączył wykonywanie do innego wątku; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zakończy się pomyślnie, zostanie nadana reszta bieżącego wycinka czasu wątku. System operacyjny planuje wątek wywołujący dla innego wycinka czasu, zgodnie z jego priorytetem i stanem innych wątków, które są dostępne do uruchomienia.  
  
 Trwa ograniczenie do procesora, który wykonuje wątek wywołujący. System operacyjny nie przełączy wykonania na inny procesor, nawet jeśli ten procesor jest w stanie bezczynności lub działa wątek o niższym priorytecie. Jeśli nie ma innych wątków gotowych do wykonania na bieżącym procesorze, system operacyjny nie jest w stanie wykonać operacji, a ta metoda zwraca wartość `false`.  
  
 Ta metoda jest równoważna użyciu wywołania platformy w celu wywołania natywnej `SwitchToThread` funkcji Win32. Należy wywołać <xref:System.Threading.Thread.Yield%2A> metodę zamiast używać wywołania platformy, ponieważ wywołanie platformy pomija wszelkie niestandardowe zachowanie wątku, którego żądał host.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

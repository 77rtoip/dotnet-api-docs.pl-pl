<Type Name="LazyInitializer" FullName="System.Threading.LazyInitializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b8f1237cfd6d85d48bb50e363e78511841ce1202" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68543700" /></Metadata><TypeSignature Language="C#" Value="public static class LazyInitializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LazyInitializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LazyInitializer" />
  <TypeSignature Language="VB.NET" Value="Public Class LazyInitializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class LazyInitializer abstract sealed" />
  <TypeSignature Language="F#" Value="type LazyInitializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="db8da-101">Dostarcza procedury inicjowania z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="db8da-101">Provides lazy initialization routines.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="db8da-102">Te procedury nie wymagają przydzielenia dedykowanego wystąpienia inicjalizacji z opóźnieniem, zamiast tego przy użyciu odwołań, aby upewnić się, że obiekty docelowe zostały zainicjowane w miarę uzyskiwania do nich dostępu.</span><span class="sxs-lookup"><span data-stu-id="db8da-102">These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using references to ensure targets have been initialized as they are accessed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="db8da-103">W poniższym przykładzie pokazano, jak używać EnsureInitialized do opóźnieniem zainicjować wartości przy użyciu wartości logicznej, aby sprawdzić, czy Inicjalizacja już się zakończyła, oraz obiekt, który ma być używany jako wzajemne blokady wykluczenia.</span><span class="sxs-lookup"><span data-stu-id="db8da-103">The following example demonstrates how to use EnsureInitialized to lazily initialize a value using a Boolean value to track whether initialization has already happened and an object to use as the mutual exclusion lock.</span></span>  
  
```vb  
Dim _data As ExpensiveData = Nothing  
Dim _dataInitialized As Boolean = False  
Dim _dataLock As Object = Nothing  
'    ...  
Dim name = LazyInitializer.EnsureInitialized(_data, _dataInitialized, _dataLock)  
```  
  
```csharp  
ExpensiveData _data = null;  
bool _dataInitialized = false;  
object _dataLock = new object();  

//  ...  
  
ExpensiveData dataToUse = LazyInitializer.EnsureInitialized(ref _data, ref _dataInitialized, ref _dataLock);  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="db8da-104">Metody <see cref="T:System.Threading.LazyInitializer" /> są bezpieczne dla wątków i mogą być wywoływane z wielu wątków jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="db8da-104">The methods of <see cref="T:System.Threading.LazyInitializer" /> are thread-safe and may be called from multiple threads concurrently.</span></span></threadsafe>
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="db8da-105">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="db8da-105">Lazy Initialization</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="EnsureInitialized&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="db8da-106">Inicjuje typ docelowy, jeśli nie został jeszcze zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-106">Initializes a target type if it hasn't already been initialized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="db8da-107">Typ odwołania, który ma zostać zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-107">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="db8da-108">Odwołanie do zainicjowania, jeśli nie zostało jeszcze zainicjowane.</span><span class="sxs-lookup"><span data-stu-id="db8da-108">A reference to initialize if it has not already been initialized.</span></span></param>
        <summary><span data-ttu-id="db8da-109">Inicjuje docelowy typ referencyjny z konstruktorem bez parametrów typu, jeśli nie został jeszcze zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-109">Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="db8da-110">Zainicjowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-110">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="db8da-111">Ta metoda może być używana tylko w przypadku typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="db8da-111">This method may only be used on reference types.</span></span> <span data-ttu-id="db8da-112">Aby zapewnić inicjalizację typów wartości, zobacz inne przeciążenia `EnsureInitialized`.</span><span class="sxs-lookup"><span data-stu-id="db8da-112">To ensure initialization of value types, see other overloads of `EnsureInitialized`.</span></span>  
  
 <span data-ttu-id="db8da-113">Ta metoda może być używana współbieżnie przez wiele wątków do zainicjowania `target`.</span><span class="sxs-lookup"><span data-stu-id="db8da-113">This method may be used concurrently by multiple threads to initialize `target`.</span></span>  
  
 <span data-ttu-id="db8da-114">W przypadku, gdy wiele wątków uzyskuje dostęp do tej metody współbieżnie, można `T` utworzyć wiele wystąpień, ale tylko jeden z nich będzie przechowywany `target`w.</span><span class="sxs-lookup"><span data-stu-id="db8da-114">In the event that multiple threads access this method concurrently, multiple instances of `T` may be created, but only one will be stored into `target`.</span></span> <span data-ttu-id="db8da-115">W takim przypadku ta metoda nie spowoduje usunięcia obiektów, które nie zostały zapisane.</span><span class="sxs-lookup"><span data-stu-id="db8da-115">In such an occurrence, this method will not dispose of the objects that were not stored.</span></span> <span data-ttu-id="db8da-116">Jeśli takie obiekty muszą zostać usunięte, jest do obiektu wywołującego, aby określić, czy obiekt nie był używany, a następnie odpowiednio usunąć obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-116">If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="db8da-117">Brak uprawnień dostępu do konstruktora typu <paramref name="T" /> .</span><span class="sxs-lookup"><span data-stu-id="db8da-117">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="db8da-118">Typ <paramref name="T" /> nie ma konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="db8da-118">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="db8da-119">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="db8da-119">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="db8da-120">Typ odwołania, który ma zostać zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-120">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="db8da-121">Odwołanie do zainicjowania, jeśli nie zostało jeszcze zainicjowane.</span><span class="sxs-lookup"><span data-stu-id="db8da-121">The reference to initialize if it hasn't already been initialized.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="db8da-122">Funkcja, która jest wywoływana w celu zainicjowania odwołania.</span><span class="sxs-lookup"><span data-stu-id="db8da-122">The function that is called to initialize the reference.</span></span></param>
        <summary><span data-ttu-id="db8da-123">Inicjuje docelowy typ referencyjny przy użyciu określonej funkcji, jeśli nie została jeszcze zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="db8da-123">Initializes a target reference type by using a specified function if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="db8da-124">Zainicjowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-124">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="db8da-125">Ta metoda może być używana tylko w typach referencyjnych i `valueFactory` nie może zwracać odwołania o wartości null (Nothing w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="db8da-125">This method may only be used on reference types, and `valueFactory` may not return a null reference (Nothing in Visual Basic).</span></span> <span data-ttu-id="db8da-126">Aby zapewnić inicjalizację typów wartości lub zezwolić na puste typy odwołań, zobacz inne przeciążenia EnsureInitialized.</span><span class="sxs-lookup"><span data-stu-id="db8da-126">To ensure initialization of value types or to allow null reference types, see other overloads of EnsureInitialized.</span></span>  
  
 <span data-ttu-id="db8da-127">Ta metoda może być używana współbieżnie przez wiele wątków do zainicjowania `target`.</span><span class="sxs-lookup"><span data-stu-id="db8da-127">This method may be used concurrently by multiple threads to initialize `target`.</span></span>  
  
 <span data-ttu-id="db8da-128">W przypadku, gdy wiele wątków uzyskuje dostęp do tej metody współbieżnie, można `T` utworzyć wiele wystąpień, ale tylko jeden z nich będzie przechowywany `target`w.</span><span class="sxs-lookup"><span data-stu-id="db8da-128">In the event that multiple threads access this method concurrently, multiple instances of `T` may be created, but only one will be stored into `target`.</span></span> <span data-ttu-id="db8da-129">W takim przypadku ta metoda nie spowoduje usunięcia obiektów, które nie zostały zapisane.</span><span class="sxs-lookup"><span data-stu-id="db8da-129">In such an occurrence, this method will not dispose of the objects that were not stored.</span></span> <span data-ttu-id="db8da-130">Jeśli takie obiekty muszą zostać usunięte, jest do obiektu wywołującego, aby określić, czy obiekt nie był używany, a następnie odpowiednio usunąć obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-130">If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="db8da-131">Typ <paramref name="T" /> nie ma konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="db8da-131">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="db8da-132"><paramref name="valueFactory" />zwrócono wartość null (Nothing w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="db8da-132"><paramref name="valueFactory" /> returned null (Nothing in Visual Basic).</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="db8da-133">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="db8da-133">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  *  *  -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="db8da-134">Typ odwołania, który ma zostać zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-134">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="db8da-135">Odwołanie lub wartość typu <c>T</c> do zainicjowania, jeśli nie została jeszcze zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="db8da-135">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="initialized"><span data-ttu-id="db8da-136">Odwołanie do wartości logicznej określającej, czy element docelowy został już zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-136">A reference to a Boolean value that determines whether the target has already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="db8da-137">Odwołanie do obiektu używanego jako wzajemnie wykluczające się blokady do inicjowania <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="db8da-137">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="db8da-138">Jeśli <paramref name="syncLock" /> ma<see langword="null" />wartość, zostanie utworzony nowy obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-138">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <summary><span data-ttu-id="db8da-139">Inicjuje odwołanie docelowe lub typ wartości z konstruktorem bez parametrów, jeśli nie został jeszcze zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-139">Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="db8da-140">Zainicjowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-140">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="db8da-141">Jeśli `initialized` wartość jest równa true, dalsze inicjowanie nie jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="db8da-141">If `initialized` is specified as true, then no further initialization occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="db8da-142">Brak uprawnień dostępu do konstruktora typu <paramref name="T" /> .</span><span class="sxs-lookup"><span data-stu-id="db8da-142">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="db8da-143">Typ <paramref name="T" /> nie ma konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="db8da-143">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="db8da-144">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="db8da-144">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref object syncLock, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  *  * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="db8da-145">Typ odwołania, który ma zostać zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-145">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="db8da-146">Odwołanie do zainicjowania, jeśli nie zostało jeszcze zainicjowane.</span><span class="sxs-lookup"><span data-stu-id="db8da-146">A reference to initialize if it has not already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="db8da-147">Odwołanie do obiektu używanego jako wzajemnie wykluczające się blokady do inicjowania <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="db8da-147">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="db8da-148">Jeśli <paramref name="syncLock" /> ma<see langword="null" />wartość, zostanie utworzony nowy obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-148">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="db8da-149">Metoda do wywołania do zainicjowania <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="db8da-149">The method to invoke to initialize <paramref name="target" />.</span></span></param>
        <summary><span data-ttu-id="db8da-150">Inicjuje docelowy typ referencyjny z określoną funkcją, jeśli nie została jeszcze zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="db8da-150">Initializes a target reference type with a specified function if it has not already been initialized.</span></span></summary>
        <returns><span data-ttu-id="db8da-151">Zainicjowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-151">The initialized object.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock, Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  *  *  * Func&lt;'T&gt; -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="db8da-152">Typ odwołania, który ma zostać zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-152">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="db8da-153">Odwołanie lub wartość typu <c>T</c> do zainicjowania, jeśli nie została jeszcze zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="db8da-153">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="initialized"><span data-ttu-id="db8da-154">Odwołanie do wartości logicznej określającej, czy element docelowy został już zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="db8da-154">A reference to a Boolean value that determines whether the target has already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="db8da-155">Odwołanie do obiektu używanego jako wzajemnie wykluczające się blokady do inicjowania <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="db8da-155">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="db8da-156">Jeśli <paramref name="syncLock" /> ma<see langword="null" />wartość, zostanie utworzony nowy obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-156">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="db8da-157">Funkcja, która jest wywoływana w celu zainicjowania odwołania lub wartości.</span><span class="sxs-lookup"><span data-stu-id="db8da-157">The function that is called to initialize the reference or value.</span></span></param>
        <summary><span data-ttu-id="db8da-158">Inicjuje odwołanie docelowe lub typ wartości przy użyciu określonej funkcji, jeśli nie została jeszcze zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="db8da-158">Initializes a target reference or value type by using a specified function if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="db8da-159">Zainicjowany obiekt.</span><span class="sxs-lookup"><span data-stu-id="db8da-159">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="db8da-160">Jeśli `initialized` wartość jest równa true, dalsze inicjowanie nie jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="db8da-160">If `initialized` is specified as true, then no further initialization occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="db8da-161">Brak uprawnień dostępu do konstruktora typu <paramref name="T" /> .</span><span class="sxs-lookup"><span data-stu-id="db8da-161">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="db8da-162">Typ <paramref name="T" /> nie ma konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="db8da-162">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="db8da-163">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="db8da-163">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
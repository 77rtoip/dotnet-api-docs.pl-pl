<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ed9a740eab700d16f5778c2b6c1ce675521e870e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36605893" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje blokadę obsługuje autorzy jednego i wielu czytników.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Ma dwa reader_writer_lock, <xref:System.Threading.ReaderWriterLockSlim> i <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> jest zalecana dla wszystkich nowych wdrożeń. <xref:System.Threading.ReaderWriterLockSlim> przypomina <xref:System.Threading.ReaderWriterLock>, ale jest prostszy zasady rekursji oraz uaktualniania i zmiany na starszą wersję stan blokady. <xref:System.Threading.ReaderWriterLockSlim> pozwala uniknąć wielu przypadkach potencjalnych zakleszczenia. Ponadto wydajność <xref:System.Threading.ReaderWriterLockSlim> jest znacznie lepszą niż <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock> Służy do synchronizowania dostęp do zasobu. W dowolnym momencie umożliwia równoczesne dostęp do odczytu dla wielu wątków lub dostęp do zapisu dla jednego wątku. W sytuacji, gdy zasób jest rzadko, zmieniane `ReaderWriterLock` zapewnia większą przepustowość niż proste blokady jednego w czasie, takie jak <xref:System.Threading.Monitor>.  
  
 `ReaderWriterLock` działa najlepiej, których uzyskuje dostęp do większości odczytów, gdy zapisy są rzadko i krótki czas trwania. Wielu czytników alternatywne z pojedynczego zapisywania, dzięki czemu czytników ani zapisywania są blokowane przez dłuższy czas.  
  
> [!NOTE]
>  Akcji blokad czytnika lub moduł zapisujący blokady przez dłuższy czas będzie blokować go, inne wątki. Aby uzyskać najlepszą wydajność należy wziąć pod uwagę restrukturyzacji aplikacji w taki sposób, aby zminimalizować czas trwania operacji zapisu.  
  
 Wątek może zawierać czytnik blokady lub blokadę zapisu, ale nie oba jednocześnie. Zamiast zwalnianie blokada czytnika. Aby uzyskać blokadę zapisu, można użyć <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> i <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  
  
 Żądania lock cykliczne Zwiększ liczbę blokad na blokadę.  
  
 Czytniki i zapisywania są umieszczane w kolejce oddzielnie. Gdy wątek zwalnia blokadę zapisu, wszystkich wątków oczekujących w kolejce czytnika w tej chwili otrzymują blokad czytnika; gdy wszystkie te blokady czytnika zostały zwolnione, dalej oczekiwania wątku w moduł zapisujący kolejki, jeśli istnieje, uzyskuje blokadę zapisu i tak dalej. Innymi słowy `ReaderWriterLock` przełącza między kolekcją czytelników i jednego składnika zapisywania.  
  
 Podczas wątku w kolejce modułu zapisującego oczekuje na zwolnienie blokad aktywny czytnik, żądanie nowego czytnika blokad wątków gromadzone w kolejce czytnika. Ich żądania nie są przyznawane, mimo że można mają współbieżny dostęp z istniejących posiadaczy blokada czytnika; Pozwala to chronić autorów przed nieograniczonego zablokowaniu przez czytelników.  
  
 Uzyskiwanie blokad na większości metod `ReaderWriterLock` zaakceptować wartości limitu czasu. Użyj limitów czasu, aby uniknąć zakleszczenie w aplikacji. Na przykład wątek może uzyskać blokadę zapisu na jeden zasób, a następnie żądają blokadę na drugi zasobów; Tymczasem inny wątek może uzyskać blokadę zapisu na drugi oraz blokadę pierwszego żądania. Jeśli używane są limity czasu, zakleszczenie wątków.  
  
 Jeśli interwał limitu czasu wygaśnie, a nie udzielono żądanie blokady, metoda zwraca kontroli w wątku wywołującym przez zgłaszanie <xref:System.ApplicationException>. Wątek można przechwycić tego wyjątku i ustalić, jakie działania należy podjąć.  
  
 Limity czasu są wyrażony w milisekundach. Jeśli używasz <xref:System.TimeSpan?displayProperty=nameWithType> Aby określić limit czasu, wartość używana jest całkowita liczba pełnych milisekund reprezentowany przez <xref:System.TimeSpan>. W poniższej tabeli przedstawiono wartości prawidłowy limit czasu w milisekundach.  
  
|Wartość|Opis|  
|-----------|-----------------|  
|-1|Wątek oczekuje, aż uzyskać blokady, niezależnie od tego, jak długo. Dla metod, które określić limity czasu liczba całkowita, stała <xref:System.Threading.Timeout.Infinite> mogą być używane.|  
|0|Wątek nie oczekuje na przejęcie blokady. Jeśli nie można uzyskać blokady natychmiast, metoda zwraca wartość.|  
|>0|Wyrażony w milisekundach czas oczekiwania.|  
  
 Z wyjątkiem -1 wartości limitu czasu ujemne są niedozwolone. Jeśli określisz ujemną liczbą całkowitą od-1, zamiast niego jest używana wartość limitu czasu o wartości zero. (To znaczy, metoda zwraca bez oczekiwania, jeśli nie można natychmiast uzyskać blokady.) Jeśli określisz <xref:System.TimeSpan> reprezentujący ujemnej liczby milisekund od-1, <xref:System.ArgumentOutOfRangeException> jest generowany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Threading.ReaderWriterLock> ochrony udostępnianego zasobu, wartość całkowitą o nazwie `resource`, która jest jednocześnie Odczyt i zapis wyłącznie przez wiele wątków. Należy pamiętać, że <xref:System.Threading.ReaderWriterLock> jest zadeklarowane na poziomie klasy, aby były one widoczne dla wszystkich wątków.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.ReaderWriterLock" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nowe wystąpienie klasy <xref:System.Threading.ReaderWriterLock> klasy.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje blokadę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Limit czasu w milisekundach.</param>
        <summary>Uzyskuje czytnik zablokować, przy użyciu <see cref="T:System.Int32" /> wartość limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blokuje, jeśli moduł zapisujący blokady ma inny wątek lub co najmniej jeden wątek oczekuje na blokadę zapisu.  
  
> [!NOTE]
>  Jeśli bieżący wątek już moduł zapisujący blokady, blokada nie czytnik jest uzyskiwana. Zamiast tego jest zwiększany liczbę blokad na blokadę zapisu. Zapobiega to blokowania na jego własnej blokadę wątku. Wynik jest dokładnie taka sama, co wywołanie <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>oraz dodatkowe wywołanie <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> jest wymagana podczas zwalniania blokady modułu zapisującego.  
  
 `AcquireReaderLock` obsługuje żądania blokada czytnika cyklicznego. Oznacza to wątku mogą wywoływać AcquireReaderLock wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> raz przy każdym wywołaniu `AcquireReaderLock`. Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Aby zmniejszyć liczbę blokad na zero, natychmiast.  
  
 Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce czytnika. Umożliwia cykliczne blokady z ostrożnością, unikania blokowania blokadę zapisu żądania przez dłuższy czas.  
  
 Dla limitu czasu prawidłowe wartości, zobacz <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać i zwolnić blokadę i sposób obsługi wyjątek, gdy upłynie limit czasu żądania.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> wygasa przed udzieleniem żądanie blokady.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see langword="TimeSpan" /> określający okres limitu czasu.</param>
        <summary>Uzyskuje czytnik zablokować, przy użyciu <see cref="T:System.TimeSpan" /> wartość limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blokuje, jeśli moduł zapisujący blokady ma inny wątek lub co najmniej jeden wątek oczekuje na blokadę zapisu.  
  
> [!NOTE]
>  Jeśli bieżący wątek już moduł zapisujący blokady, blokada nie czytnik jest uzyskiwana. Zamiast tego jest zwiększany liczbę blokad na blokadę zapisu. Zapobiega to blokowania na jego własnej blokadę wątku. Wynik jest dokładnie taka sama, co wywołanie <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>oraz dodatkowe wywołanie <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> jest wymagana podczas zwalniania blokady modułu zapisującego.  
  
 `AcquireReaderLock` obsługuje żądania blokada czytnika cyklicznego. Oznacza to wątku mogą wywoływać AcquireReaderLock wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> raz przy każdym wywołaniu `AcquireReaderLock`. Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Aby zmniejszyć liczbę blokad na zero, natychmiast.  
  
 Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce czytnika. Umożliwia cykliczne blokady z ostrożnością, unikania blokowania blokadę zapisu żądania przez dłuższy czas.  
  
 Dla limitu czasu prawidłowe wartości, zobacz <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> wygasa przed udzieleniem żądanie blokady.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Określa wartość ujemną, innego niż-1 milisekund.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje blokadę zapisu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Limit czasu w milisekundach.</param>
        <summary>Pobiera moduł zapisujący zablokować, przy użyciu <see cref="T:System.Int32" /> wartość limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda blokuje, jeśli ma inny wątek blokada czytnika lub moduł zapisujący blokady. Opis sposobu blokadę zapisu przełącza wyposażonych w kilka blokad czytnika jednoczesnych, zobacz <xref:System.Threading.ReaderWriterLock> klasy.  
  
 Wątek, który ma już blokadę może uzyskać blokadę zapisu w jeden z dwóch sposobów: przez zwolnienie blokady czytnika przed wywołaniem <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, lub przez wywołanie metody <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Jeśli wątek wywołuje `AcquireWriterLock` gdy nadal jest blokadę, blokuje na jego własnej blokada czytnika; Jeśli nieskończonego limitu czasu jest określony, będzie zakleszczenie wątku. Aby uniknąć takich zakleszczenia, użyj <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> ustalenie, czy bieżący wątek jest już blokadę.  
  
 `AcquireWriterLock` obsługuje żądania blokadę zapisu cyklicznego. Oznacza to, że wątek można wywołać `AcquireWriterLock` wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> raz przy każdym wywołaniu `AcquireWriterLock`. Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Aby zmniejszyć liczbę blokad na zero, natychmiast.  
  
 Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce modułu zapisującego.  
  
 Dla limitu czasu prawidłowe wartości, zobacz <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać i zwolnić blokadę i sposób obsługi wyjątek, gdy upłynie limit czasu żądania.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> wygasa przed udzieleniem żądanie blokady.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" /> Określający okres limitu czasu.</param>
        <summary>Pobiera moduł zapisujący zablokować, przy użyciu <see cref="T:System.TimeSpan" /> wartość limitu czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda blokuje, jeśli ma inny wątek blokada czytnika lub moduł zapisujący blokady. Opis sposobu blokadę zapisu przełącza wyposażonych w kilka blokad czytnika jednoczesnych, zobacz <xref:System.Threading.ReaderWriterLock> klasy.  
  
 Wątek, który ma już blokadę może uzyskać blokadę zapisu w jeden z dwóch sposobów: przez zwolnienie blokady czytnika przed wywołaniem <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, lub przez wywołanie metody <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Jeśli wątek wywołuje `AcquireWriterLock` gdy nadal jest blokadę, blokuje na jego własnej blokada czytnika; Jeśli nieskończonego limitu czasu jest określony, będzie zakleszczenie wątku. Aby uniknąć takich zakleszczenia, użyj <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> ustalenie, czy bieżący wątek jest już blokadę.  
  
 `AcquireWriterLock` obsługuje żądania blokadę zapisu cyklicznego. Oznacza to, że wątek można wywołać `AcquireWriterLock` wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> raz przy każdym wywołaniu `AcquireWriterLock`. Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Aby zmniejszyć liczbę blokad na zero, natychmiast.  
  
 Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce modułu zapisującego.  
  
 Dla limitu czasu prawidłowe wartości, zobacz <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> wygasa przed udzieleniem żądanie blokady.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Określa wartość ujemną, innego niż-1 milisekund.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">Numer sekwencji.</param>
        <summary>Wskazuje, czy moduł zapisujący blokady zostało przyznane którymkolwiek wątku ponieważ uzyskano numer sekwencji.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł zapisujący blokady zostało przyznane którymkolwiek wątku ponieważ uzyskano numer sekwencyjny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> i `AnyWritersSince` aby poprawić wydajność aplikacji. Na przykład wątku może buforować informacje, które uzyskuje podczas utrzymywania blokady czytnika. Po zwalniania i później reacquiring blokady, można użyć wątku `AnyWritersSince` ustalenie, czy inne wątki zostały zapisane do zasobu w międzyczasie; w przeciwnym razie można buforowanych informacji. Ta technika jest przydatna, gdy odczytu informacji o chronionych przez blokady jest kosztowne. na przykład uruchomienie kwerendy bazy danych.  
  
 Obiekt wywołujący musi zawierający blokadę lub blokadę zapisu w kolejności numeru sekwencji powinna być użyteczna.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> — metoda i <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> właściwości w celu określenia, czy inny wątek uzyskać blokadę zapisu na komputerze chronionym zasobów od bieżącego wątku ostatniego stanu blokadę zapisu.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock :  -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">A <see cref="T:System.Threading.LockCookie" /> zwrócony przez <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Przywraca stan blokady wątku sprzed <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> zwalnia blokadę zapisu, niezależnie od tego, liczbę blokad cykliczne i przywraca blokada czytnika, która obowiązywała przez wątek przed uaktualnieniem do wersji blokadę zapisu. Po przywróceniu liczbę blokad na blokada czytnika.  
  
> [!NOTE]
>  `DowngradeFromWriterLock` akceptuje <xref:System.Threading.LockCookie> można uzyskać przez wywołanie <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. Nie używaj `LockCookie` zwrócony przez <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  
  
 Wątek nie blokuje przy przechodzeniu z blokadę zapisu nawet w przypadku innych wątków oczekuje na blokadę zapisu, ponieważ wszystkie żądania blokada czytnika są przyznawane po zwolnieniu blokadę zapisu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak do żądania blokadę, Uaktualnij blokada czytnika do blokadę i obniżyć blokadę ponownie.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Wątek nie ma blokady modułu zapisującego.</exception>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="lockCookie" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <see cref="T:System.Threading.ReaderWriterLock" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania modułu zbierającego elementy bezużyteczne <xref:System.Threading.ReaderWriterLock.Finalize%2A> podczas bieżącej <xref:System.Threading.ReaderWriterLock> obiekt jest gotowy do przetwarzania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek utrzymuje blokadę.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek utrzymuje blokadę; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia `IsReaderLockHeld` w celu uniknięcia zakleszczenia.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący wątek utrzymuje blokadę zapisu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący wątek utrzymuje blokadę; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, że podczas próby uzyskania blokady czytnika w wątku, który ma blokadę zapisu `ReaderWriterLock` nie powoduje przyznania blokada czytnika, ale zamiast tego zwiększa liczbę blokad na blokadę zapisu.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia blokadę, niezależnie od tego, ile razy wątek uzyskać blokady.</summary>
        <returns>A <see cref="T:System.Threading.LockCookie" /> wartość reprezentującą zwolnione blokady.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> zwalnia blokada czytnika lub blokadę zapisu, niezależnie od tego, liczbę blokad cyklicznego. Aby przywrócić stan blokady, w tym liczbę blokad przekazać <xref:System.Threading.LockCookie> do <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> metodę, aby zwolnić blokady, niezależnie od tego, ile razy uzyskano przez wątek i przywracania stanu blokady później.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę blokad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> zmniejsza liczbę blokad. Jeśli licznik osiągnie wartość zero, blokada jest zwalniany.  
  
> [!NOTE]
>  Jeśli moduł zapisujący blokady wątku, podczas wywoływania `ReleaseReaderLock` ma ten sam efekt co wywołanie <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. Jeśli wątku nie ma blokad, wywoływania `ReleaseReaderLock` zgłasza <xref:System.ApplicationException>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać i zwolnić blokadę i sposób obsługi wyjątek, gdy upłynie limit czasu żądania.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Wątek nie ma żadnych blokad odczytywania lub zapisywania.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza liczbę blokad na blokadę zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> zmniejsza liczbę blokad modułu zapisującego. Jeśli licznik osiągnie wartość zero, moduł zapisujący blokady jest zwalniany.  
  
> [!NOTE]
>  Jeśli wątek blokadę lub nie blokad, wywoływania `ReleaseWriterLock` zgłasza <xref:System.ApplicationException>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać i zwolnić blokadę i sposób obsługi wyjątek, gdy upłynie limit czasu żądania.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Wątek nie ma blokady modułu zapisującego.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock :  -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">A <see cref="T:System.Threading.LockCookie" /> zwrócony przez <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Przywraca stan blokady wątku jest przed wywołaniem <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan przywrócone przez `RestoreLock` zawiera liczbę blokad cyklicznego.  
  
 Bloki wątku, jeśli próbuje przywrócić blokadę po inny wątek ustawił blokadę zapisu lub spróbuje przywrócić blokadę zapisu, po inny wątek ustawił blokada czytnika lub moduł zapisujący blokady. Ponieważ `RestoreLock` nie akceptuje limit czasu, można należy zwrócić uwagę, aby uniknąć możliwe zakleszczenie.  
  
> [!CAUTION]
>  Przed wywołaniem `RestoreLock`, upewnij się, że zostały wydane wszystkich blokad ustawionych od czasu wywołania <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. Na przykład wątku zakleszczenie jeśli uzyskuje blokadę, a następnie podejmie próbę przywrócenia starszej blokadę zapisu. Użyj <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> i <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> do wykrywania takich dodatkowych blokad.  
  
 Nie używaj <xref:System.Threading.LockCookie> zwrócony z <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> metodę, aby zwolnić blokady, niezależnie od tego, ile razy uzyskano przez wątek i przywracania stanu blokady później.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Adres <paramref name="lockCookie" /> jest wskaźnika o wartości null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uaktualnia blokadę do blokadę zapisu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Limit czasu w milisekundach.</param>
        <summary>Blokowanie blokadę w składniku zapisywania uaktualnień, przy użyciu <see langword="Int32" /> wartość limitu czasu.</summary>
        <returns>A <see cref="T:System.Threading.LockCookie" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołuje wątku `UpgradeToWriterLock` blokada czytnika został wydany, niezależnie od tego, liczbę blokad i wątku przechodzi do końca moduł zapisujący blokady do kolejki. W związku z tym inne wątki może zapisać zasobów przed wątku, który zażądał uaktualnienia uzyskuje blokadę zapisu.  
  
> [!IMPORTANT]
>  Limit czasu nie wyjątku do wątku, który wywołuje <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> metody można ponownie uzyskać blokady czytnika. Jeśli nie ma żadnych innych wątków oczekujących na blokadę zapisu, dzieje się natychmiast. Jednak jeśli inny wątek jest w kolejce na blokadę zapisu, wątek który wywołuje <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> metody nie można ponownie uzyskać blokady czytnika, aż wszystkie bieżące czytników zostały wydane ich blokad, a jeden wątek stały i wydane blokadę zapisu. Dotyczy to nawet wtedy, gdy wątek, żądany moduł zapisujący blokady zażądał go po wywołaniu metody bieżącego wątku <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> metody.  
  
 Aby przywrócić stan blokady, należy wywołać <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> przy użyciu <xref:System.Threading.LockCookie> zwrócony przez `UpgradeToWriterLock`. Nie używaj to `LockCookie` z <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Jeśli wątek nie blokada czytnika, nie używaj `UpgradeToWriterLock`. Zamiast nich należy używać słów kluczowych <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Dla limitu czasu prawidłowe wartości, zobacz <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak do żądania blokadę, Uaktualnij blokada czytnika do blokadę i obniżyć blokadę ponownie.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> wygasa przed udzieleniem żądanie blokady.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" /> Określający okres limitu czasu.</param>
        <summary>Blokowanie blokadę w składniku zapisywania uaktualnień, przy użyciu <see langword="TimeSpan" /> wartość limitu czasu.</summary>
        <returns>A <see cref="T:System.Threading.LockCookie" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołuje wątku `UpgradeToWriterLock` blokada czytnika został wydany, niezależnie od tego, liczbę blokad i wątku przechodzi do końca moduł zapisujący blokady do kolejki. W związku z tym inne wątki może zapisać zasobów przed wątku, który zażądał uaktualnienia uzyskuje blokadę zapisu.  
  
> [!IMPORTANT]
>  Limit czasu nie wyjątku do wątku, który wywołuje <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> metody można ponownie uzyskać blokady czytnika. Jeśli nie ma żadnych innych wątków oczekujących na blokadę zapisu, dzieje się natychmiast. Jednak jeśli inny wątek jest w kolejce na blokadę zapisu, wątek który wywołuje <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> metody nie można ponownie uzyskać blokady czytnika, aż wszystkie bieżące czytników zostały wydane ich blokad, a jeden wątek stały i wydane blokadę zapisu. Dotyczy to nawet wtedy, gdy wątek, żądany moduł zapisujący blokady zażądał go po wywołaniu metody bieżącego wątku <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> metody.  
  
 Aby przywrócić stan blokady, należy wywołać <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> przy użyciu <xref:System.Threading.LockCookie> zwrócony przez `UpgradeToWriterLock`. Nie używaj to `LockCookie` z <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Jeśli wątek nie blokada czytnika, nie używaj `UpgradeToWriterLock`. Zamiast nich należy używać słów kluczowych <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.  
  
 Dla limitu czasu prawidłowe wartości, zobacz <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> wygasa przed udzieleniem żądanie blokady.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> Określa wartość ujemną, innego niż-1 milisekund.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący numer sekwencji.</summary>
        <value>Bieżący numer sekwencji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sekwencja liczba zwiększa się zawsze, gdy wątek uzyskuje blokadę zapisu. Można zapisać numer sekwencji i przekaż go do <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> w późniejszym czasie, aby ustalić, czy inne wątki zostały nabyte blokadę zapisu w tym samym czasie.  
  
 Można użyć `WriterSeqNum` aby poprawić wydajność aplikacji. Na przykład wątku może buforować informacje, które uzyskuje podczas utrzymywania blokady czytnika. Po zwalniania i później reacquiring blokady, Wątek można określić, czy inne wątki zostały zapisane zasobu, wywołując `AnyWritersSince`; Jeśli nie, można użyć buforowanych informacji. Ta technika jest przydatna podczas odczytywania informacji o chronionych przez blokady jest kosztowne. na przykład uruchomienie kwerendy bazy danych.  
  
 Obiekt wywołujący musi zawierający blokadę lub blokadę zapisu w kolejności numeru sekwencji powinna być użyteczna.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> właściwości i <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> metodę, aby określić, czy inny wątek uzyskać blokadę zapisu na komputerze chronionym zasobów od bieżącego wątku ostatniego stanu blokadę zapisu.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Threading.ReaderWriterLock> klasy.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
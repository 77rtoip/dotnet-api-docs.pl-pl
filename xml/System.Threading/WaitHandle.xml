<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0b6e3dd3b2837ebe70209ea950a3414c4d7dd591" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407233" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje obiekty specyficzne dla systemu operacyjnego, które poczekaj, aż wyłącznego dostępu do zasobów udostępnionych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> Klasa hermetyzuje dojścia synchronizacji Win32 i jest używana do reprezentowania wszystkich obiektów synchronizacji w czasie wykonywania, które umożliwiają wielu operacji oczekiwania. Porównanie uchwyty oczekiwania z innymi obiektami synchronizacji, zobacz [podstawowych Omówienie synchronizacji](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 <xref:System.Threading.WaitHandle> Sama klasa jest abstrakcyjna. Klasy wyprowadzone z <xref:System.Threading.WaitHandle> zdefiniować mechanizm sygnalizowania biorąc lub zwalniania dostęp do udostępnionych zasobów, ale korzystają z dziedziczonego <xref:System.Threading.WaitHandle> metod, które mają być blokowane podczas oczekiwania na dostęp do zasobów udostępnionych. Klasy pochodne <xref:System.Threading.WaitHandle> obejmują:  
  
-   <xref:System.Threading.Mutex> Klasy. Zobacz [muteksy](~/docs/standard/threading/mutexes.md).  
  
-   <xref:System.Threading.EventWaitHandle> Klasy i jej klas pochodnych <xref:System.Threading.AutoResetEvent> i <xref:System.Threading.ManualResetEvent>. Zobacz [EventWaitHandle, autoresetevent —, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   <xref:System.Threading.Semaphore> Klasy. Zobacz [semafor i klasa SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Zablokować wątków w dojściu do poszczególnych oczekiwania przez wywołanie metody wystąpienia <xref:System.Threading.WaitHandle.WaitOne%2A>, który jest dziedziczone przez klasy pochodzące od <xref:System.Threading.WaitHandle>.  
  
 Klasy pochodne <xref:System.Threading.WaitHandle> różnią się w ich koligacji wątku. Uchwyty oczekiwania zdarzenia (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, i <xref:System.Threading.ManualResetEvent>) i semaforów nie mają koligacji wątku; którymkolwiek wątku można zasygnalizować dojście oczekiwania zdarzenia lub semafora. Z drugiej strony, muteksy, mają koligacji wątku; Wątek, który jest właścicielem obiektu mutex musi zwolnić go i jest zwracany wyjątek, jeśli wątek wywołuje <xref:System.Threading.Mutex.ReleaseMutex%2A> metody dla obiektu mutex, który nie jest właścicielem.  
  
 Ponieważ <xref:System.Threading.WaitHandle> pochodną klasy <xref:System.MarshalByRefObject>, te klasy mogą być używane do synchronizowania działania wątków poza granice domeny aplikacji.  
  
 Oprócz jej klas pochodnych <xref:System.Threading.WaitHandle> klasa ma kilka metod statycznych, które blokują wątku, dopóki jedna lub więcej obiektów synchronizacji odebrał sygnału. Należą do nich następujące elementy:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, dzięki czemu wątek sygnału jeden dojście oczekiwania i natychmiast czekać na innym.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, dzięki czemu wątek poczekać, aż wszystkie dojścia oczekiwania w tablicy odebrał sygnału.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, dzięki czemu wątek poczekać, aż któregokolwiek z określonego zestawu uchwyty oczekiwania został sygnalizowane.  
  
 Przeciążenia metody te zapewniają interwałów limitu czasu dla porzucanie czas oczekiwania oraz możliwość zakończyć kontekstu synchronizacji przed wprowadzeniem czas oczekiwania, dzięki czemu inne wątki używać kontekstu synchronizacji.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu tego typu lub typu pochodnego w bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.Threading.WaitHandle.Close%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 <xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca. Zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md). Jeśli pochodzi od <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości do przechowywania uchwyt macierzysty uchwyt systemu operacyjnego. Nie trzeba zastąpić chronionej <xref:System.Threading.WaitHandle.Dispose%2A> metody chyba że są używane dodatkowe zasoby niezarządzane.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład jak dwa wątki można wykonać zadania w tle podczas głównym wątku czeka na zakończenie przy użyciu statycznych zadań <xref:System.Threading.WaitHandle.WaitAny%2A> i <xref:System.Threading.WaitHandle.WaitAll%2A> metody <xref:System.Threading.WaitHandle> klasy.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby zajmowane przez bieżące <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest implementacją publicznego <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodę <xref:System.Threading.WaitHandle> klasy i jej klas pochodnych. Zapewnia standardowej implementacji, która wywołuje `Dispose(Boolean)` przeciążenia z `true` argument, a następnie wywołania <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody. Wywołanie tej metody, aby zwolnić wszystkie zasoby zajmowane przez wystąpienia `WaitHandle` lub klasy pochodnej.  
  
 Gdy ta metoda jest wywoływana, odwołania do bieżącego wystąpienia spowodować niezdefiniowane zachowanie.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.WaitHandle>. W przeciwnym razie zasoby, które używa nie zostanie zwolniona.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy zastąpić <see langword="Dispose(Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> — klasa</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.WaitHandle" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.Threading.WaitHandle.Close%2A> metody.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Threading.WaitHandle.Close%2A> lub <xref:System.Threading.WaitHandle.Dispose> przed zwolnieniem ostatniego odwołania do <xref:System.Threading.WaitHandle>. W przeciwnym razie zasoby, które używa nie zostanie zwolniona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zwalnia zasoby niezarządzane używane przez <see cref="T:System.Threading.WaitHandle" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez <xref:System.Threading.WaitHandle.Close%2A> i <xref:System.Threading.WaitHandle.Dispose> metod `explicitDisposing` ustawiono parametr `true`.  Gdy `explicitDisposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Threading.WaitHandle> obiektu odwołania.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Należy zastąpić <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodę, aby zwolnić zasoby przydzielone w klasach pochodnych.  <see cref="M:System.Threading.WaitHandle.Close" /> Lub <see cref="M:System.Threading.WaitHandle.Dispose" /> metodę można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania tej metody, należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" /> lub <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia uchwyt macierzysty system operacyjny.</summary>
        <value>
          <see langword="IntPtr" /> Reprezentujący uchwyt macierzysty system operacyjny. Wartość domyślna to wartość <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> pola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przypisywanie nową wartość do <xref:System.Threading.WaitHandle.Handle%2A> właściwości nie zamyka poprzedniej dojścia. Może to spowodować, że ujawnione dojścia.  
  
 Nie należy używać tej właściwości w programie .NET Framework w wersji 2.0 lub nowszy; Użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości zamiast tego. Ustawienie tej właściwości na prawidłowy uchwyt również zestawy <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości, ale ustawieniem dla niego <xref:System.Threading.WaitHandle.InvalidHandle> może spowodować uchwyt ujawnione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymagane jest pełne zaufanie do bezpośredniego obiektu wywołującego można ustawić wartości właściwości. Nie można ustawić tego elementu członkowskiego przez kod częściowo zaufany lub przezroczyste.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> można ustawić wartości właściwości.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje dojścia nieprawidłowy natywnego systemu operacyjnego. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używana wewnętrznie w celu zainicjowania <xref:System.Threading.WaitHandle.Handle%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Tej wartości można użyć, aby określić, czy <see cref="P:System.Threading.WaitHandle.Handle" /> właściwość zawiera dojście prawidłowego natywnego systemu operacyjnego.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia uchwyt macierzysty system operacyjny.</summary>
        <value>A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> reprezentujący uchwyt macierzysty system operacyjny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po przypisaniu nową wartość do <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwość poprzedniej dojście zostanie zamknięty kiedy poprzedniej <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> zbieranych obiektu. Nie ręcznie zamknąć uchwytu, ponieważ powoduje to <xref:System.ObjectDisposedException> podczas <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> próbuje zamknąć dojścia.  
  
 <xref:System.Threading.WaitHandle> implementuje <xref:System.IDisposable.Dispose%2A> wzorca. Zobacz [wzorzec Dispose](~/docs/standard/design-guidelines/dispose-pattern.md). Jeśli pochodzi od <xref:System.Threading.WaitHandle>, użyj <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> właściwości do przechowywania uchwyt macierzysty uchwyt systemu operacyjnego. Nie trzeba zastąpić chronionej <xref:System.Threading.WaitHandle.Dispose%2A> metody chyba że są używane dodatkowe zasoby niezarządzane.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Typy pochodne muszą mieć <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> do wywołania tego elementu członkowskiego.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</param>
        <summary>Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym.</summary>
        <returns>
          <see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania zakończy się pomyślnie; Jeśli czas oczekiwania nie zostanie ukończone, metoda zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie jest gwarantowana niepodzielnych. Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> przeciążenie metody, aby zezwolić na sygnał zablokowanych wątków, a następnie poczekaj zakończenie wątku zadania głównego wątku.  
  
 Przykład rozpoczyna pięć wątków, pozwala na blokowanie na <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flagi, a następnie jeden wątek wersjach czasu naciśnięciu klawisza ENTER. W przykładzie następnie kolejki innego pięć wątków i zwalnia wszystkie przy użyciu <xref:System.Threading.EventWaitHandle> utworzone za pomocą <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flagi.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> jest <see langword="null" />.  - lub - <paramref name="toWaitOn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> jest semafora i jest już pełna count.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba całkowita, która reprezentuje interwału oczekiwania. Jeśli wartość jest <see cref="F:System.Threading.Timeout.Infinite" />, -1, czas oczekiwania jest nieograniczony.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym określająca interwał limitu czasu, całkowita 32-bitowe i określanie, czy zamknąć domeny synchronizacji w kontekście przed wejściem czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania ukończone pomyślnie, lub <see langword="false" /> jeśli sygnał ukończone, ale czas oczekiwania upłynął limit czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie jest gwarantowana niepodzielnych. Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.  
  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza on stan `toWaitOn` i zwraca natychmiast.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> jest <see langword="null" />.  - lub - <paramref name="toWaitOn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda jest wywoływana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.WaitHandle" /> Nie może zostać zgłoszony, ponieważ zostałaby przekroczona maksymalna wartość licznika.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> Sygnalizują.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> Oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący interwał oczekiwania. Jeśli wartość wynosi -1, czas oczekiwania to nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Sygnały jedną <see cref="T:System.Threading.WaitHandle" /> i czeka na innym Określanie limitu czasu jako <see cref="T:System.TimeSpan" /> i określanie, czy należy zakończyć domeny synchronizacji w kontekście przed wejściem czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli zarówno sygnał, jak i czas oczekiwania ukończone pomyślnie, lub <see langword="false" /> jeśli sygnał ukończone, ale czas oczekiwania upłynął limit czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie jest gwarantowana niepodzielnych. Po bieżącym wątku sygnały `toSignal` , ale przed oczekuje `toWaitOn`, wątku, który działa na innego procesora może sygnalizować `toWaitOn` lub zaczekaj na nim.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza on stan `toWaitOn` i zwraca natychmiast.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.SignalAndWait%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.SignalAndWait%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.SignalAndWait%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.SignalAndWait%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> jest <see langword="null" />.  - lub - <paramref name="toWaitOn" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Metoda została wywołana w wątku, który ma <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> jest semafora i jest już pełna count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> daje w wyniku ujemną liczbę milisekund niż -1.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na wszystkie elementy w określonej tablicy na odebrał sygnału.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</param>
        <summary>Czeka na wszystkie elementy w określonej tablicy na odebrał sygnału.</summary>
        <returns>
          <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie metoda zwraca nigdy nie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy wszystkie dojścia są sygnalizowane. W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany. Jeśli tablica zawiera duplikaty, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików. Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów. Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />. - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  - lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.  </para>
          </block>
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.  - lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.Int32" /> wartość, aby określić interwał czasu.</summary>
        <returns>
          <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania zakończenie, co oznacza, że gdy są sygnalizowane wszystkie dojścia lub przekroczenia limitu czasu. W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany. Jeśli istnieją duplikaty w tablicy, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  - lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.  </para>
          </block>
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.  - lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund, będzie czekać w nieskończoność.</param>
        <summary>Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartość, aby określić interwał czasu.</summary>
        <returns>
          <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca kończy czas oczekiwania, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu. W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany. Jeśli tablica zawiera duplikaty, połączenie nie powiedzie się.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  - lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.ArgumentException" />, zamiast tego.  </para>
          </block>
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.  - lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu (duplikatów).</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.Int32" /> wartość, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca wartość, gdy czas oczekiwania zakończenie, co oznacza, że gdy są sygnalizowane wszystkie dojścia lub przekroczenia limitu czasu. W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany. Jeśli istnieją duplikaty w tablicy, połączenie kończy się niepowodzeniem z <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie jest pochodną <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atrybutu. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików. Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów. Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  - lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.  - lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia. Ta tablica nie może zawierać wiele odwołań do tego samego obiektu.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund, będzie czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka na wszystkie elementy w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> wartość, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Podczas każdego elementu w <paramref name="waitHandles" /> otrzymał sygnał; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda zwraca kończy czas oczekiwania, co oznacza, że są sygnalizowane albo wszystkie dojścia lub przekroczenia limitu czasu. W niektórych implementacjach więcej niż 64 uchwyty są przekazywane <xref:System.NotSupportedException> jest generowany. Jeśli tablica zawiera duplikaty, połączenie nie powiedzie się.  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> Metoda nie jest obsługiwana w wątkach, które mają <xref:System.STAThreadAttribute>.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAll%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie jest pochodną <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAll%2A> metody. Zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAll%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAll%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAll%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak za pomocą puli wątków asynchronicznie utworzyć i zapisać do grupy plików. Po zakończeniu każdej operacji zapisu jest w kolejce elementu roboczego i sygnałów. Główny wątek oczekuje dla wszystkich elementów, które sygnalizują i kończy pracę.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.  - lub - <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> Tablica zawiera elementy, które są duplikatami.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.  - lub - <see cref="T:System.STAThreadAttribute" /> atrybut jest stosowany do procedury wątku dla bieżącego wątku i <paramref name="waitHandles" /> zawiera więcej niż jeden element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na jeden z elementów w określonej tablicy na odebrał sygnału.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <summary>Czeka na jeden z elementów w określonej tablicy na odebrał sygnału.</summary>
        <returns>Indeks tablicy obiektu spełniającego oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.  
  
> [!NOTE]
>  W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.  
  
 Ta metoda zwraca, jeśli zostanie zasygnalizowane dowolny uchwyt. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.  
  
 Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 (lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) dla `millisecondsTimeout` i `true` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie <xref:System.Threading.WaitHandle.WaitAny%2A> metody.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Czeka na jeden z elementów w określonej tablicy na sygnał, za pomocą całkowita 32-bitowy, aby określić interwał czasu.</summary>
        <returns>Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="millisecondsTimeout" /> minął.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.  
  
 Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Czeka na jeden z elementów w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> Aby określić interwał czasu.</summary>
        <returns>Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="timeout" /> minął.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.  
  
 Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub przekroczenia limitu czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka na jeden z elementów w określonej tablicy na sygnał, za pomocą całkowita 32-bitowy, aby określić przedział czasu i określająca, czy zakończyć działanie synchronizacji domeny przed czas oczekiwania.</summary>
        <returns>Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="millisecondsTimeout" /> minął.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.  
  
> [!NOTE]
>  W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.  
  
 Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub zostanie przekroczony limit czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach. Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> tablicę zawierającą obiekty, dla których będzie czekać bieżącego wystąpienia.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Czeka na jeden z elementów w określonej tablicy na sygnał, przy użyciu <see cref="T:System.TimeSpan" /> określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>Indeks tablicy obiektu, który spełnia oczekiwania, lub <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> Jeśli żaden obiekt spełnione czas oczekiwania i przedział czasu odpowiednikiem <paramref name="timeout" /> minął.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan uchwyty oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwraca `true` wykona czas oczekiwania, ponieważ obiektu mutex zostanie zaniechana. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> Metoda zgłasza <xref:System.Threading.AbandonedMutexException> tylko, gdy czas oczekiwania kończy z powodu porzuconego elementu mutex. Jeśli `waitHandles` zawiera wydanych obiektu mutex niższy numer indeksu niż porzuconego elementu mutex <xref:System.Threading.WaitHandle.WaitAny%2A> metody kończy się normalnie i nie jest zgłaszany wyjątek.  
  
> [!NOTE]
>  W wersjach wcześniejszych niż wersja 2.0, jeśli wątek kończy działanie lub przerwanie bez jawnego zwolnienia programu .NET Framework <xref:System.Threading.Mutex>oraz że `Mutex` znajduje się pod indeksem 0 (zero) w `WaitAny` tablicy w innym wątku, indeks zwrócony przez `WaitAny` jest 128 zamiast 0.  
  
 Ta metoda zwraca wartość, gdy zakończenie czas oczekiwania, jeśli dowolny z uchwytów są sygnalizowane lub przekroczenia limitu czasu. Jeśli więcej niż jeden obiekt staje się zasygnalizowane podczas wywołania, zwracana wartość jest indeks tablicy sygnałowego obiektu mający najmniejszą wartość indeksu sygnałowego obiektów. W niektórych implementacjach, jeśli więcej dojść 64 są przekazywane <xref:System.NotSupportedException> jest generowany.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitAny%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitAny%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitAny%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitAny%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitAny%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach. Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> Parametr jest <see langword="null" />.  - lub - co najmniej jeden z obiektów w <paramref name="waitHandles" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Liczba obiektów w <paramref name="waitHandles" /> jest większa, niż pozwala na system.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 1.0 lub 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> jest tablicą o żadnych elementów i jest programu .NET Framework w wersji 2.0 lub nowszej.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> Tablica zawiera przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału. Jeśli bieżące wystąpienie nigdy nie zostanie zasygnalizowane, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nigdy nie zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Element wywołujący tego bloków metody do czasu bieżącego wystąpienia odbiera sygnał. Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Wywołanie metody przeciążenie tej metody jest odpowiednikiem wywołania <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody i określając -1 lub <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> jako pierwszy parametr i `false` dla drugiego parametru.  
  
 Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, aby określić interwał czasu w milisekundach przy użyciu całkowita 32-bitowych.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan dojście oczekiwania, a zwraca natychmiast.  
  
 Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie. Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Blokuje bieżący wątek, do momentu otrzymania przez bieżące wystąpienie sygnał, przy użyciu <see cref="T:System.TimeSpan" /> Aby określić interwał czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan dojście oczekiwania, a zwraca natychmiast.  
  
 Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie. Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> przeciążenia i określając `false` dla `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Blokuje bieżącego wątku do bieżącego <see cref="T:System.Threading.WaitHandle" /> odbiera sygnał, za pomocą całkowita 32-bitowy, aby określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `millisecondsTimeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan dojście oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie. Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono sposób <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> przeciążenie metody ma zachowywać się, gdy jest wywoływana w domenie synchronizacji. Po pierwsze, wątek oczekuje z `exitContext` ustawioną `false` i blokuje do chwili osiągnięcia limitu czasu oczekiwania. Drugi wątek wykonuje po pierwszym wątkiem kończy i czeka z `exitContext` ustawioną `true`. Wywołanie sygnału dojście oczekiwania dla tego drugiego wątku nie jest blokowane i zakończeniu przed upływem limitu czasu oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <param name="exitContext">
          <see langword="true" /> Aby zakończyć domeny synchronizacji dla kontekstu przed oczekiwaniem (Jeśli w kontekście zsynchronizowane), a potem; ponownie pozyskać w przeciwnym razie <see langword="false" />.</param>
        <summary>Blokuje bieżący wątek, do momentu otrzymania przez bieżące wystąpienie sygnał, przy użyciu <see cref="T:System.TimeSpan" /> określić przedział czasu i określanie, czy zamknąć domeny synchronizacji przed czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżące wystąpienie odebrał sygnału; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `timeout` wynosi zero, nie są blokowane przez metodę. Sprawdza stan dojście oczekiwania, a zwraca natychmiast.  
  
 <xref:System.Threading.AbandonedMutexException> jest nowa w programie .NET Framework w wersji 2.0. W poprzednich wersjach <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwraca `true` kiedy zostanie porzucony obiektu mutex. Porzuconego elementu mutex często oznacza to poważny błąd kodowania. W przypadku obiektu mutex całego systemu może oznaczać, że aplikacji zostało zakończone nagle (na przykład za pomocą Menedżera zadań systemu Windows). Wyjątek zawiera informacje przydatne podczas debugowania.  
  
 Występuje, wywołujący bloków tej metody do momentu otrzymania sygnału lub limit czasu oczekiwania przez bieżące wystąpienie. Ta metoda służy do blokowania do <xref:System.Threading.WaitHandle> odbiera sygnał z innego wątku, takich jak jest generowany po zakończeniu operacji asynchronicznej. Aby uzyskać więcej informacji, zobacz <xref:System.IAsyncResult> interfejsu.  
  
 Zastępuje tę metodę, aby dostosować zachowanie klas pochodnych.  
  
 Maksymalna wartość `timeout` jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Uwagi dotyczące zamykania kontekstu  
 `exitContext` Parametru nie obowiązuje, chyba że <xref:System.Threading.WaitHandle.WaitOne%2A> metoda jest wywoływana z wewnątrz w kontekście zarządzanych niestandardowy. Może się to zdarzyć, jeśli Twoje wątek znajduje się wewnątrz wywołania do wystąpienia klasy pochodzącej od <xref:System.ContextBoundObject>. Nawet wtedy, gdy metody są aktualnie wykonywanych na klasę, która nie pochodzi od <xref:System.ContextBoundObject>, takiej jak <xref:System.String>, może być w kontekście innych niż domyślne Jeśli <xref:System.ContextBoundObject> jest na stosie w bieżącej domenie aplikacji.  
  
 Gdy kod jest wykonywany w kontekście innych niż domyślne, określając `true` dla `exitContext` powoduje, że na zakończenie niestandardowy kontekst zarządzanego wątku (oznacza to, przejście do domyślnego kontekstu) przed wykonaniem <xref:System.Threading.WaitHandle.WaitOne%2A> metody. Wątek zwraca do oryginalnego kontekstu niestandardowy po wywołaniu <xref:System.Threading.WaitHandle.WaitOne%2A> ukończeniu metody.  
  
 Może to być przydatne, gdy zawiera klasy powiązane z kontekstem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. W takim przypadku wszystkie wywołania do elementów członkowskich klasy są synchronizowane automatycznie, a domena synchronizacji jest cały kod klasy. Jeśli kod w stosie wywołań elementu członkowskiego wywołuje <xref:System.Threading.WaitHandle.WaitOne%2A> — metoda i określa `true` dla `exitContext`, wątek opuszcza domeny synchronizacji, dzięki czemu wątek, który jest zablokowany na wywołanie członków obiektu, aby kontynuować. Gdy <xref:System.Threading.WaitHandle.WaitOne%2A> metoda zwróci wartość, oczekiwania wątku, który zgłosił wywołanie ponownie wprowadzić domeny synchronizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zapobiec proces przerywanie podczas oczekiwania na zakończenie wykonywania wątku w tle przy użyciu dojścia oczekiwania.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżące wystąpienie został już usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  - lub - <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">Oczekiwanie zakończone, ponieważ wątek został zakończony bez zwolnienia obiektu mutex. Ten wyjątek nie jest generowany na Windows 98 lub Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące wystąpienie jest przezroczystego obiektu pośredniczącego dla <see cref="T:System.Threading.WaitHandle" /> w innej domenie aplikacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Oznacza to, że <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> upłynął limit czasu operacji przed żadnego uchwyty oczekiwania były sygnalizowane. To pole jest stałe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest jedną z możliwych wartości zwracanych metody `WaitAny`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać puli wątków jednocześnie wyszukiwania plików na wielu dyskach. Zagadnienia miejsca przeszukiwane będą tylko w katalogu głównym każdego dysku.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>